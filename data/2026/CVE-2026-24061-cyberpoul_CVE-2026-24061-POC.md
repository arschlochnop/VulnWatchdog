## CVE-2026-24061 - GNU InetUtils telnetd 认证绕过 (Authentication Bypass)

**漏洞编号:** CVE-2026-24061

**漏洞类型:** 认证绕过 (Authentication Bypass)

**影响应用:** GNU InetUtils telnetd

**危害等级:** 严重 (Critical)

**CVSS评分:** 9.8

**影响版本:** GNU InetUtils 1.9.3 到 2.7 (含)

**利用条件:** 远程可利用，无需认证，需要网络访问目标Telnet服务 (通常为TCP 23端口)

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2026-24061是一个潜伏了11年的远程认证绕过漏洞，影响GNU InetUtils套件中的Telnetd服务。这个漏洞的核心在于Telnetd在处理客户端传入的 `USER` 环境变量时，未对其进行充分的验证和过滤，就直接将其作为参数传递给Linux系统的 `/usr/bin/login` 程序。`/usr/bin/login` 程序旨在处理用户登录请求，它支持一些特殊参数，例如 `-f username`，该参数在某些受信任的场景下允许绕过密码验证直接登录。攻击者正是利用了这一机制，通过Telnet协议的 `NEW_ENVIRON` 选项，将 `USER` 环境变量的值设置为 `"-f root"`。当Telnetd接收到这个恶意构造的环境变量后，它会将 `login -f root` 命令传递给底层的login程序执行。由于 `login` 程序在没有进一步验证的情况下执行了 `-f root`，这便导致了攻击者能够以root用户的身份在目标系统上获取一个未经授权的交互式Shell。

所提供的PoC代码 `cve-2026-24061-poc.py` 精确地复现了上述利用逻辑。该PoC用Python编写，其核心功能是实现了一个简化的Telnet客户端。它首先与目标Telnetd服务建立TCP连接，然后执行标准的Telnet协议协商过程，这包括处理DO/WILL/DONT/WONT等选项，确保通信协议的正确建立。更关键的是，PoC会特别协商并利用RFC 1572定义的 `Telnet Environment Option (NEW_ENVIRON)`。在协商成功后，PoC会构造一个包含 `VAR=USER` 和 `VALUE=-f root` 的 `SB (Subnegotiation Begin)` 数据包并发送给目标Telnetd服务。一旦Telnetd接收并错误地处理了这个数据包，它就会触发 `login -f root` 的执行，进而赋予攻击者root权限。PoC随后会尝试将攻击者本地的标准输入/输出重定向到与目标机器建立的Telnet连接上，从而提供一个完整的、交互式的root Shell。这种直接且高效的利用方式使得该PoC具有极高的有效性，能够成功演示和利用这一高危漏洞，将一个远程未授权的连接升级为完全的系统控制权。其功能完整性与预期攻击效果高度一致，证明了其作为完整利用工具的强大能力。

**利用步骤**
利用此PoC来复现CVE-2026-24061漏洞并获取目标系统root权限的步骤如下：

1.  **确认攻击环境**: 确保攻击机器上安装了Python解释器（建议使用Python 3）。PoC脚本是纯Python编写，无需额外依赖。
2.  **获取PoC代码**: 打开终端，使用Git命令克隆PoC的GitHub仓库到本地：
    ```bash
    git clone https://github.com/cyberpoul/CVE-2026-24061-POC
    ```
3.  **进入PoC目录**: 切换到刚刚克隆下来的PoC项目目录：
    ```bash
    cd CVE-2026-24061-POC
    ```
4.  **识别目标系统**: 明确受影响的目标机器的IP地址或主机名，以及其Telnetd服务监听的端口（通常为TCP/23端口）。
5.  **执行PoC脚本**: 运行Python脚本，并提供目标IP地址和端口作为参数。例如，如果目标IP是`192.168.1.100`，端口是`23`：
    ```bash
    python cve-2026-24061-poc.py 192.168.1.100 23
    ```
6.  **获取Root Shell**: 如果目标系统运行的是受影响的Telnetd版本（1.9.3到2.7），并且Telnet服务可从攻击机访问，PoC脚本将在成功利用后自动建立一个与目标系统的交互式Shell。此时，攻击者将在终端中看到一个以`root@target_hostname:~#`开头的提示符，表明已经成功获得目标系统的root权限，可以执行任何系统命令，从而实现完全控制。

**投毒风险分析**
对提供的 `cve-2026-24061-poc.py` 代码进行了全面细致的分析后，可以得出结论，该PoC的投毒风险极低，因此将其风险百分比设定为10%。这10%的风险并非源于代码中发现的任何明确恶意行为，而是考虑到任何第三方代码都可能存在的极小概率的非预期行为或未来潜在的修改风险。

首先，**代码的透明度**是评估投毒风险的关键因素。`cve-2026-24061-poc.py` 是一个纯Python脚本，代码结构清晰，逻辑一目了然，没有使用任何形式的代码混淆技术。所有的功能实现都直接呈现在代码中，使得安全研究人员和分析师可以轻松地进行审计和理解其工作原理。这种高度的透明性极大地降低了隐藏恶意代码的可能性。

其次，**依赖项分析**显示该PoC仅依赖于Python的**标准库**。它导入了 `socket` 用于建立网络连接，`sys` 用于系统级操作（如`sys.exit`），`threading` 用于处理多线程的I/O转发，`argparse` 用于命令行参数解析，以及 `os` 用于操作系统交互。这意味着该PoC不需要安装任何第三方包，从而完全规避了来自外部依赖库的**供应链投毒风险**。许多恶意PoC会通过引入看似无害的第三方库，在其中注入恶意代码，但此PoC没有此风险。

再次，**恶意行为分析**结果为阴性。脚本的核心功能完全专注于Telnet协议的协商和漏洞利用，旨在通过发送 `USER="-f root"` 环境变量来绕过认证并获取root权限。在代码中，我们没有发现任何可疑的行为，例如：尝试在运行PoC的**本地攻击机器**上安装后门、持久化机制或恶意软件；通过加密、编码或其他方式隐藏敏感或恶意功能；收集本地系统信息并将其传输到外部服务器；下载并执行来自远程源的额外脚本或二进制文件；利用 `eval()`、`exec()` 或 `subprocess.run()` 等函数执行非预期的任意代码。该PoC的唯一“恶意”意图是针对目标系统，以证明并利用Telnetd的漏洞，而不是感染执行PoC的攻击者自身系统。

最后，在**网络行为**方面，该PoC只会与用户指定的**目标IP地址和端口**（Telnet服务，默认为23）进行通信。它不会尝试连接到其他任何外部的命令与控制（C2）服务器、恶意更新源或其他可疑网络位置。这种单一且目的明确的网络连接模式进一步证实了其无投毒意图。

综上所述，该PoC代码在透明度、依赖性、恶意行为和网络通信方面均表现出高度的安全性。因此，10%的投毒风险评分代表了对其作为合法防御性安全研究工具的信任，仅保留了理论上最小的不确定性，并非发现任何实际的恶意代码。防御性安全团队可以相对放心地在受控环境中分析和测试此PoC。

**项目地址:** https://github.com/cyberpoul/CVE-2026-24061-POC

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2026-24061
