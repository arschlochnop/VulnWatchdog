## CVE-2018-10933 - libssh 身份验证绕过 (Authentication Bypass)

**漏洞编号:** CVE-2018-10933

**漏洞类型:** 身份验证绕过 (Authentication Bypass)

**影响应用:** libssh

**危害等级:** CRITICAL

**CVSS评分:** 9.1 (CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)

**影响版本:** libssh 0.6 及更高版本 (0.6.x, 0.7.x, 0.8.x)，在 0.8.4 和 0.7.6 中修复

**利用条件:** 目标服务器启用了 libssh 的服务器模式 (server mode) 且未更新补丁；攻击者能够通过网络访问 SSH 服务端口。

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 5%

## 详情

POC有效性分析：该漏洞的本质是 libssh 服务端代码的状态机逻辑错误。在正常的 SSH 认证流程中，客户端应发送 SSH2_MSG_USERAUTH_REQUEST。然而，由于服务端逻辑缺陷，如果客户端直接发送 SSH2_MSG_USERAUTH_SUCCESS 消息，libssh 服务端会误认为身份验证已经成功，从而绕过密码或密钥检查直接进入授权状态。提供的 Python POC 代码使用了 paramiko 库。分析其逻辑：代码通过底层 socket 连接到目标端口，手动构造了一个 paramiko Transport 对象。核心操作在于调用了 `message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)` 并通过 `_send_message` 方法强行向服务端注入了“认证成功”的消息。随后，代码尝试 `open_session` 并执行 `exec_command`。这种实现方式直接跳过了 paramiko 标准的 `connect(password=...)` 流程，准确地复现了 CVE-2018-10933 的利用原语。经评估，该 POC 逻辑清晰、路径直达，对于存在漏洞的 libssh 实例具有极高的攻击有效性。它不依赖复杂的堆溢出或内存布局，仅通过协议逻辑层面的消息违规即可实现 RCE（远程代码执行）。\n\n利用步骤：1. 准备 Python 3 环境并安装 paramiko 库。2. 获取目标主机的 IP 地址和运行 libssh 的端口（默认通常为 22）。3. 运行脚本：`python exploit.py <IP> <PORT> <COMMAND>`。4. 脚本将建立 TCP 连接并初始化 SSH 传输层。5. 脚本构造并发送标识认证成功的十六进制字节码。6. 成功绕过认证后，脚本打开会话通道并执行指定的 shell 命令。7. 结果通过 stdout/stderr 回显至控制台。\n\n投毒风险分析：对所提供的 `exploit.py` 进行静态代码审计。代码导入了标准的 `sys`, `paramiko`, `socket`, `logging` 模块，未发现任何混淆（如 base64 加密、动态执行 eval）或非官方外部库引用。代码逻辑完全透明，主要围绕 paramiko 的内部接口进行调用。在网络行为方面，脚本仅与用户指定的 `hostname` 和 `port` 进行通信，不存在向第三方服务器外传敏感信息（如私钥、环境变量或凭证）的逻辑。脚本中虽然使用了私有方法 `_send_message`，但这属于针对协议漏洞的非常规编程技巧，而非恶意后门。综上所述，该 POC 代码属于纯粹的防御性安全研究工具，不存在植入木马、反弹 shell 给第三方或窃取本地数据的风险，投毒风险评级为极低（5%）。建议安全团队在隔离的沙箱环境中验证，并监控异常的 SSH 协议状态包，以作为 IDS/IPS 的签名依据。

**项目地址:** [https://github.com/vulnwatchdog/libssh-server-cve-2018-10933](https://www.google.com/search?q=https://github.com/vulnwatchdog/libssh-server-cve-2018-10933)

**漏洞详情:** [https://nvd.nist.gov/vuln/detail/CVE-2018-10933](https://nvd.nist.gov/vuln/detail/CVE-2018-10933)
