# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

# CVE-2018-0114

> 📦 该CVE有 **12** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-0114-Eremiel_CVE-2018-0114.md](../2018/CVE-2018-0114-Eremiel_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致权限提升和身份伪造

**影响版本:** < 0.11.0

**利用条件:** 需要目标系统使用存在漏洞的 Node-jose 库来验证 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准规定，表示公钥的 JSON Web Key (JWK) 可以嵌入到 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用此漏洞。

**有效性分析：**

根据漏洞描述和搜索结果，该漏洞允许攻击者通过在 JWT 头部嵌入攻击者控制的公钥，并使用对应的私钥重新签名 JWT，从而绕过 JWT 签名验证。提供的 POC 代码 `cve-2018-0114.py` 实现了这一攻击过程，可以生成伪造的 JWT 令牌。因此，提供的 POC 代码有效。

**投毒风险分析：**

查看 `cve-2018-0114.py` 脚本，该脚本的主要功能是生成 RSA 密钥对，构造包含公钥的 JWT 头部，然后使用私钥对 JWT 进行签名。脚本的逻辑相对简单，没有发现任何可疑的代码，例如反弹 shell、恶意文件写入或网络请求等。虽然脚本使用了 `base64`、`urllib` 和 `rsa` 等库，但这些库的使用方式都是常规的，没有发现任何利用漏洞的迹象。
因此，可以认为此仓库中不存在作者隐藏的投毒代码的可能性为 0%。

**利用方式总结：**

1.  攻击者构造一个包含恶意 payload 的 JWT 结构。
2.  攻击者生成一对 RSA 密钥，并将公钥嵌入到 JWT 头部的 `jwk` 字段中。
3.  攻击者使用私钥对 JWT 进行签名，生成伪造的 JWT 令牌。
4.  攻击者将伪造的 JWT 令牌发送给目标系统。
5.  目标系统使用 `node-jose` 库验证 JWT 令牌时，会信任 JWT 头部中的公钥，并使用该公钥验证签名。由于签名是用攻击者控制的私钥生成的，因此验证会成功，从而使攻击者能够绕过身份验证或权限控制。

**项目地址:** [Eremiel/CVE-2018-0114](https://github.com/Eremiel/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #2

**来源**: [CVE-2018-0114-Logeirs_CVE-2018-0114.md](../2018/CVE-2018-0114-Logeirs_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在token中的密钥重新签名token，从而伪造JWT。

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的node-jose库，且JWT验证逻辑信任header中的jwk。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 允许攻击者通过在JWT的header中嵌入包含攻击者公钥的JWK (JSON Web Key)，然后使用与该公钥匹配的私钥对篡改后的JWT进行签名，从而绕过JWT的签名验证。

**有效性评估:**

提供的POC代码 `CVE-2018-0114.py` 的确实现了上述攻击过程。它生成RSA密钥对，将公钥嵌入到JWT的header中，然后使用私钥对token进行签名。如果目标应用使用存在漏洞的node-jose库并且信任header中的`jwk`字段，那么攻击者就可以利用这个POC生成有效的伪造JWT。

搜索结果也表明该漏洞确实存在，并且有公开的利用代码和练习。

**投毒风险评估:**

在提供的POC代码中，存在一定的投毒风险的可能性，但可能性较小。代码中与投毒相关的主要风险点在于:

*   **密钥生成:** 代码可以生成新的RSA密钥对，或者从本地文件读取现有密钥对。如果攻击者提供恶意的`pubkey.pem`或`privkey.pem`文件，就可能引入后门。但是如果使用新生成的密钥，则问题不大。
*   **依赖库:** 依赖 `rsa` 等库，如果这些库被篡改，可能存在投毒风险，但这不是此仓库本身的风险，而是外部依赖风险。
*   **`pack_bigint`函数:** 该函数将大整数打包成字节数组。虽然功能上没有直接问题，但如果被恶意修改，可能会导致生成的公钥不正确，从而使攻击无效或者引入其他安全问题。这个风险较低。

综合来看，代码本身没有明显的恶意行为。投毒风险主要存在于外部提供的密钥文件和潜在的第三方库篡改。 因此, 投毒风险评估为 10%.

**利用方式:**

1.  **准备攻击环境:** 准备好存在漏洞版本的node-jose库环境，以及Python环境。
2.  **生成RSA密钥对 (可选):**  如果`pubkey.pem`和`privkey.pem`不存在，POC脚本会自动生成一个新的RSA密钥对。
3.  **构造Payload:** 根据目标应用的需求，构造需要伪造的JWT payload，例如修改用户名或权限。
4.  **运行POC:** 运行POC脚本，将构造的payload作为参数传递给脚本。
5.  **获取伪造的JWT:** POC脚本会生成一个伪造的JWT，其中header包含攻击者的公钥，并且使用攻击者的私钥进行了签名。
6.  **利用伪造的JWT:** 将伪造的JWT发送给目标应用。如果目标应用信任header中的`jwk`，并且使用攻击者的公钥验证签名，那么攻击者就可以成功绕过身份验证。


**项目地址:** [Logeirs/CVE-2018-0114](https://github.com/Logeirs/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #3

**来源**: [CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md](../2018/CVE-2018-0114-Pandora-research_CVE-2018-0114-Exploit.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的 Node-jose 库进行 JWT 验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入恶意构造的 JSON Web Key (JWK)，然后使用与该 JWK 关联的私钥重新签名，从而伪造 JWT 令牌。漏洞利用方式如下：

1.  **获取原始 JWT 令牌：** 首先，攻击者需要获取一个由目标系统签发的 JWT 令牌。
2.  **构造恶意 JWK：** 攻击者生成一对新的公钥和私钥。然后，攻击者创建一个包含公钥信息的 JWK 对象，并将其添加到 JWT 头部。
3.  **移除原始签名并重新签名：** 攻击者移除原始 JWT 签名，使用攻击者生成的私钥对修改后的 JWT 头部和载荷进行签名。
4.  **发送伪造的 JWT 令牌：** 攻击者将伪造的 JWT 令牌发送到目标系统。

由于存在漏洞的 Node-jose 库信任 JWT 头部中提供的 JWK，因此它会使用攻击者的公钥验证伪造的签名，从而允许攻击者绕过身份验证。

根据提供的漏洞利用代码 `jwt-cisco-node-exploit.py`，该脚本实现了上述步骤，可以生成带有攻击者控制的签名的恶意 JWT 令牌。该代码没有发现明显的投毒风险，主要功能是生成密钥对，构造包含公钥信息的header，然后对header和payload进行签名，最终生成伪造的 JWT 令牌。

搜索引擎结果也确认了该漏洞的存在和利用方式，并提供了相关的 PoC 和练习。因此，提供的 POC 代码是有效的。


**项目地址:** [Pandora-research/CVE-2018-0114-Exploit](https://github.com/Pandora-research/CVE-2018-0114-Exploit)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #4

**来源**: [CVE-2018-0114-Starry-lord_CVE-2018-0114.md](../2018/CVE-2018-0114-Starry-lord_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者伪造 JWT 令牌

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞版本的Node-jose库，并且JWT验证逻辑信任内嵌的JWK。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Node-jose 0.11.0 之前的版本中。该漏洞允许攻击者通过在 JWT 头部嵌入一个包含攻击者公钥的 JWK (JSON Web Key) 并使用攻击者私钥重新签名 JWT 来伪造 JWT 令牌。由于 Node-jose 库在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证，从而冒充任何用户或获得未授权的访问权限。

**有效性评估：**

根据漏洞描述、搜索引擎结果以及提供的 POC 代码，该漏洞是有效的。POC 代码演示了如何生成 RSA 密钥对，构造包含攻击者公钥的 JWK，将 JWK 嵌入 JWT 头部，并使用攻击者私钥重新签名 JWT。

**投毒风险评估：**

提供的 POC 代码主要功能是生成密钥对，创建包含公钥信息的头部，构造payload，并使用私钥对JWT进行签名。代码中没有发现任何尝试连接外部服务器、执行恶意代码或篡改系统配置的行为。`README.md`文件只是对漏洞的简单描述，也没有包含任何恶意代码。

**利用方式：**

1.  **构造恶意 JWT 头部：**  攻击者生成一个 RSA 密钥对，并将公钥信息（模数 n 和指数 e）以 JWK 的形式添加到 JWT 头部。
2.  **修改 JWT 负载（Payload）：** 攻击者可以修改 JWT 的负载以包含攻击者想要伪造的信息，例如用户名或权限。
3.  **移除原始签名：** 移除 JWT 令牌中原始的签名信息。
4.  **重新签名：**  使用攻击者的私钥对修改后的 JWT 头部和负载进行签名。
5.  **发送恶意 JWT：**  将伪造的 JWT 令牌发送到目标应用程序。由于目标应用程序信任头部中的 JWK，因此会将攻击者伪造的签名视为有效，从而允许攻击者绕过身份验证并获得未授权的访问权限。

**项目地址:** [Starry-lord/CVE-2018-0114](https://github.com/Starry-lord/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #5

**来源**: [CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-adityathebe_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT密钥混淆

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT密钥混淆

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致身份伪造和权限提升。

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于node-jose库遵循JWS标准，允许在JWT头部嵌入JSON Web Key (JWK)。攻击者可以构造包含恶意公钥的JWT，并使用与之对应的私钥签名，从而绕过验证。 

**利用方式：**
1.  攻击者获取或构造一个合法的JWT。
2.  攻击者生成一个新的RSA密钥对（公钥和私钥）。
3.  攻击者修改JWT头部，将`alg`设置为`RS256`，并在头部添加一个`jwk`字段，其中包含攻击者生成的公钥（以JWK格式）。
4.  攻击者计算修改后的JWT头部和负载的SHA256哈希值。
5.  攻击者使用其私钥对哈希值进行RSA签名。
6.  攻击者将修改后的头部、原始负载和新生成的签名组合成一个新的JWT。
7.  当应用程序使用存在漏洞的node-jose库验证该JWT时，它会信任嵌入在头部中的恶意公钥，并使用该公钥验证攻击者提供的签名，从而认为该JWT是有效的。

**有效性：**
根据漏洞描述和提供的POC代码，此漏洞是有效的。POC代码展示了如何生成包含恶意公钥的JWT，并使用相应的私钥进行签名，从而实现令牌的伪造。

**投毒风险：**
分析POC代码，没有发现明显的投毒代码。代码的主要功能是生成RSA密钥对，构造包含公钥的JWT头部，并使用私钥对JWT进行签名。代码逻辑清晰，没有执行恶意操作或下载恶意资源的迹象。因此，投毒风险较低。

**项目地址:** [adityathebe/POC-CVE-2018-0114](https://github.com/adityathebe/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---



---

## POC #6

**来源**: [CVE-2018-0114-amr9k8_jwt-spoof-tool.md](../2018/CVE-2018-0114-amr9k8_jwt-spoof-tool.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 node-jose 库处理 JWT 令牌

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco 的 node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞，通过在 JWT 头部嵌入包含攻击者公钥的 JSON Web Key (JWK)，然后使用与该公钥关联的私钥重新签名令牌，从而绕过签名验证。服务器会信任 JWT 头部中嵌入的公钥，用于验证签名，这使得攻击者可以伪造有效的 JWT 令牌。

**有效性评估：**

提供的 POC 代码 `jwt_attacker_gen.py` 似乎有效。代码的主要逻辑是：

1.  生成新的 RSA 密钥对。
2.  解析原始 JWT 令牌，提取头部和载荷。
3.  从新生成的公钥中提取 `n` (模数) 和 `e` (指数)，并将其注入到 JWT 头部中的 `jwk` 对象中。
4.  修改 JWT 载荷中的目标字段。
5.  使用新生成的私钥对修改后的 JWT 重新签名。
6.  利用脚本生成的 payload 替换原始 payload，成功绕过身份验证。

**投毒风险评估：**

代码中存在轻微的投毒风险。虽然核心逻辑是利用 CVE-2018-0114 漏洞，但代码中可能存在以下潜在的投毒点：

*   **依赖项风险：** `jwt_attacker_gen.py` 依赖于多个第三方库，如 `cryptography`, `Crypto`, `jwcrypto`, `jwt`。这些库本身可能存在安全漏洞或被恶意篡改，从而引入安全风险。尽管这些库是常用的，但仍然存在潜在的供应链攻击风险。
*   **后门风险：**虽然代码结构清晰，功能明确，没有发现明显的恶意代码或后门，但作者可以在不影响主要功能的情况下，植入隐蔽的恶意代码，例如收集用户信息、执行任意代码等。

综合考虑，投毒风险评估为 10%。

**利用方式分析：**

1.  **获取目标 JWT 令牌：** 攻击者首先需要获取一个由目标应用程序生成的 JWT 令牌。
2.  **生成新的 RSA 密钥对：** 使用提供的脚本生成一个新的 RSA 密钥对。
3.  **修改 JWT 头部：** 将原始 JWT 头部中的 `jwk` 对象替换为包含攻击者公钥的 JWK 对象。或者，如果原始头部中已经存在 `jwk` 对象，则更新其 `n` 和 `e` 字段。
4.  **修改 JWT 载荷：** 根据需要修改 JWT 载荷中的声明。
5.  **重新签名 JWT：** 使用攻击者生成的私钥对修改后的 JWT 重新签名。
6.  **利用伪造的 JWT：** 将伪造的 JWT 令牌提交给目标应用程序。由于应用程序信任 JWT 头部中的公钥，因此会错误地验证伪造的签名，从而允许攻击者绕过身份验证。

**项目地址:** [amr9k8/jwt-spoof-tool](https://github.com/amr9k8/jwt-spoof-tool)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #7

**来源**: [CVE-2018-0114-j4k0m_CVE-2018-0114.md](../2018/CVE-2018-0114-j4k0m_CVE-2018-0114.md)

## CVE-2018-0114 Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份冒用和未授权访问

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞版本的Node-jose库来验证JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114漏洞存在于Cisco node-jose开源库0.11.0之前的版本中，允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。漏洞原因是node-jose遵循JSON Web Signature (JWS)标准来处理JSON Web Tokens (JWTs)。此标准指定JSON Web Key (JWK)，表示公钥可以嵌入在JWS的header中。该公钥随后被信任用于验证。攻击者可以通过以下步骤利用此漏洞：

1.  获取一个有效的JWT。
2.  移除原始签名。
3.  在header中添加一个新的JWK，包含攻击者控制的公钥。
4.  使用与header中公钥对应的私钥对该对象进行签名。
5.  将伪造的JWT提交给应用程序。由于应用程序信任header中的JWK，因此它将接受攻击者伪造的签名。

根据漏洞利用代码仓库中的README.md，该漏洞的利用方式如下：

1.  使用`openssl`创建RSA私钥。
2.  从私钥的公钥部分提取`n`和`e`。
3.  使用相同的私钥对payload进行签名。
4.  更改payload中的`n`和`e`值，以确保它们与正在使用的私钥匹配。
5.  创建正确的payload作为令牌的主体。
6.  确保算法`alg`是用于签名的算法。很可能需要将值更改为`RS256`。

仓库中的`jwk-node-jose.py`可能包含实现该漏洞利用的示例代码。

**有效性：** 根据漏洞库信息和搜索结果，该漏洞存在且POC代码可用。因此，可以判断POC代码是有效的。

**投毒风险：** 提供的代码仓库中只包含了README.md文件，其中描述了漏洞的利用方式，并提供了一个Python脚本的链接。该描述主要是漏洞利用的说明，没有发现任何潜在的后门或恶意代码。所以投毒风险为0%。

**利用方式：** 利用方式总结如下：

1.  **构造包含恶意JWK的JWT Header：** 攻击者创建一个新的JSON Web Key (JWK)，包含攻击者控制的公钥，并将其嵌入到JWT的header中。
2.  **移除原始签名：** 删除JWT中的原始签名。
3.  **使用攻击者的私钥重新签名：** 使用与JWK中的公钥对应的私钥对JWT重新签名。
4.  **欺骗验证逻辑：** 将修改后的JWT发送到服务器。如果服务器信任JWT header中的JWK用于验证，则会错误地接受攻击者伪造的签名，从而允许攻击者冒充其他用户或绕过身份验证。

**项目地址:** [j4k0m/CVE-2018-0114](https://github.com/j4k0m/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #8

**来源**: [CVE-2018-0114-mmeza-developer_CVE-2018-0114.md](../2018/CVE-2018-0114-mmeza-developer_CVE-2018-0114.md)

## CVE-2018-0114 - Node-jose Library JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者使用嵌入在 token 中的密钥重新签名 token，可能导致权限提升和数据篡改。

**影响版本:** < 0.11.0

**利用条件:** 应用程序使用存在漏洞的 Node-jose 库来处理 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs)，攻击者可以利用 JWT 规范中允许在 JWS 头部嵌入 JSON Web Key (JWK) 的特性，该 JWK 代表一个公钥，并被信任用于验证。利用方式如下：

1.  攻击者获取一个合法的 JWT。
2.  攻击者移除原始签名。
3.  攻击者在 JWT 头部添加一个新的 JWK，其中包含攻击者控制的公钥。
4.  攻击者使用与头部 JWK 中公钥对应的私钥对修改后的 JWT 进行签名。
5.  应用程序使用存在漏洞的 node-jose 库验证 JWT 时，会信任嵌入的 JWK，从而接受伪造的签名。

提供的 POC 代码旨在演示如何生成包含恶意 JWK 头的 JWT，并使用攻击者的私钥对其进行签名。代码包含生成 RSA 密钥对、构造 JWT 头部和 payload、以及使用私钥进行签名的功能。代码片段存在不完整的部分，例如jwtSign函数未完成，可能需要补充完整才能正常工作。投毒风险评估基于以下几点：

*   代码主要功能是生成和签名 JWT，没有明显的恶意行为。
*   代码依赖的第三方库（如 pycryptodome、PyJWT、PyOpenSSL）本身可能存在安全问题，但这不是代码作者直接引入的。
*   需要注意的是，代码中的密钥生成和使用需要谨慎处理，不安全的密钥管理可能导致安全风险。PATH_PUBLIC_KEY 和 PATH_PRIVATE_KEY 是硬编码路径，如果作者有恶意，可能在其他地方使用这些密钥。

因此，综合考虑，代码存在一定的投毒风险，但可能性较低，约为10%。主要的风险在于不安全的编码实践和对第三方库的依赖。

**项目地址:** [mmeza-developer/CVE-2018-0114](https://github.com/mmeza-developer/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #9

**来源**: [CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md](../2018/CVE-2018-0114-n0m-d_CVE-2018-0114-Go.md)

## CVE-2018-0114 - Node-jose JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的远程攻击者重新签名令牌，可能导致权限提升和身份验证绕过

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库，并接受包含嵌入式 JWK 的 JWT。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-0114 漏洞存在于 node-jose 0.11.0 之前的版本中。该漏洞源于 node-jose 库在处理 JWT 时，信任 JWT 头部中嵌入的 JSON Web Key (JWK) 用于签名验证。攻击者可以构造一个包含恶意 JWK 的 JWT，该 JWK 包含攻击者控制的公钥，然后使用与该公钥关联的私钥对 JWT 进行签名。由于 node-jose 信任头部中的 JWK，它会使用攻击者的公钥验证签名，从而成功伪造 JWT。 

**漏洞利用方式:**
1.  攻击者获取或构造一个 JWT。
2.  攻击者生成一个新的 RSA 密钥对（公钥和私钥）。
3.  攻击者修改 JWT 头部，添加一个 `jwk` 字段，该字段包含攻击者生成的公钥。
4.  攻击者使用其私钥对修改后的 JWT 进行签名。
5.  攻击者将伪造的 JWT 发送给目标应用程序。
6.  如果目标应用程序使用存在漏洞的 node-jose 库进行 JWT 验证，它将信任 JWT 头部中的 JWK，使用攻击者的公钥验证签名，并认为 JWT 是有效的。

**POC 代码分析:**
提供的 POC 代码是一个 Go 程序，用于生成包含指定声明（claim）的 JWT，并在 JWT 头部嵌入攻击者生成的公钥。 

*   `main.go`:  程序的入口点，负责解析命令行参数（`claim`），生成 RSA 密钥对，构造 JWT 头部，并输出生成的 JWT。
*   `keys.go`:  包含生成 RSA 密钥对和使用私钥对数据进行签名的函数。
*   `jwt.go`:  包含用于构造 JWT 头部和有效负载的结构体和函数。
*   `banner.go`: 用于在控制台中显示 CVE 信息。

**有效性评估:**
根据漏洞描述和 POC 代码，该 POC 代码是有效的。它能够生成包含恶意 JWK 的 JWT，可以用于利用 CVE-2018-0114 漏洞。

**投毒风险评估:**
代码本身逻辑是生成存在漏洞的JWT，不太容易植入后门.考虑到代码较为简单，依赖的外部库较少，且代码功能集中于 JWT 生成，投毒的概率较低，主要风险可能在于对外部库`github.com/mbndr/figlet4go`的供应链攻击。但总的来说，投毒的概率相对较低。


**项目地址:** [n0m-d/CVE-2018-0114-Go](https://github.com/n0m-d/CVE-2018-0114-Go)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #10

**来源**: [CVE-2018-0114-scumdestroy_CVE-2018-0114.md](../2018/CVE-2018-0114-scumdestroy_CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，允许未授权的攻击者伪造JWT令牌，可能导致身份冒充和权限提升

**影响版本:** < 0.11.0

**利用条件:** 目标系统使用存在漏洞的Node-jose库进行JWT验证

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准处理 JSON Web Tokens (JWTs) 引起的。此标准指定代表公钥的 JSON Web Key (JWK) 可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名来利用这一点。

**利用方式：**

1.  **获取目标JWT:** 攻击者首先需要获取一个有效的JWT令牌，该令牌由易受攻击的Node-jose库处理。
2.  **构造恶意JWK:** 攻击者生成自己的RSA密钥对，并将公钥部分构造为一个JWK，嵌入到JWT的header中。
3.  **修改JWT Header:**  将原始JWT header中的签名算法（`alg`）修改为`RS256`，并将构造好的JWK添加到header中。
4.  **重新签名:** 使用攻击者自己的私钥对修改后的JWT header和payload进行签名。
5.  **发送伪造的JWT:** 将伪造的JWT发送给目标系统。由于目标系统信任header中的JWK，因此会使用攻击者的公钥验证签名，从而成功绕过身份验证。

**代码分析:**

提供的Ruby脚本 `CVE-2018-0114.rb` 实现了上述的攻击流程：

*   生成或读取攻击者的RSA私钥和公钥。
*   构造包含攻击者公钥的JWK header。
*   从命令行或代码中获取目标用户名，并将其编码为JWT payload。
*   使用攻击者的私钥对修改后的header和payload进行签名。
*   输出最终的伪造JWT。

**投毒风险:**

分析了提供的代码仓库，该仓库的目的是为了重现CVE-2018-0114漏洞的利用。该仓库只包含了一个ruby脚本和一个README文件，ruby脚本实现了漏洞利用，没有发现隐藏的恶意代码或后门，因此投毒风险为0%。

**项目地址:** [scumdestroy/CVE-2018-0114](https://github.com/scumdestroy/CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #11

**来源**: [CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md](../2018/CVE-2018-0114-sealldeveloper_CVE-2018-0114-PoC.md)

## CVE-2018-0114-Node-jose-JWT 签名伪造

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名伪造

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份验证绕过和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要目标应用使用存在漏洞的 node-jose 库处理 JWT

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 0.11.0 之前的版本。该漏洞允许未经身份验证的远程攻击者使用嵌入在令牌中的密钥重新签名令牌。该漏洞是由于 node-jose 遵循 JSON Web Signature (JWS) 标准 for JSON Web Tokens (JWTs) 造成的。该标准指定 JSON Web Key (JWK)（表示公钥）可以嵌入在 JWS 的标头中。然后信任此公钥进行验证。攻击者可以通过以下方式利用此漏洞：删除原始签名，将新的公钥添加到标头，然后使用与嵌入在该 JWS 标头中的公钥关联的（攻击者拥有的）私钥对对象进行签名。

**利用方式：**

1.  获取一个合法的 JWT 令牌。
2.  修改 JWT 头部，添加 `jwk` 字段，该字段包含攻击者控制的公钥。
3.  移除原始签名。
4.  使用攻击者控制的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给服务器。由于服务器信任 `jwk` 中提供的公钥，因此会验证通过，从而绕过身份验证。

**投毒风险分析：**

提供的代码片段是 GNU GPL 许可协议，并非漏洞利用代码。根据搜索结果，github上存在此漏洞的POC代码，因此需要单独进行分析。当前提供的代码片段不包含任何可疑的恶意代码，因此，**投毒风险为 0%**。

**项目地址:** [sealldeveloper/CVE-2018-0114-PoC](https://github.com/sealldeveloper/CVE-2018-0114-PoC)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

## POC #12

**来源**: [CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md](../2018/CVE-2018-0114-zi0Black_POC-CVE-2018-0114.md)

## CVE-2018-0114-Node-jose-JWT 签名绕过

**漏洞编号:** CVE-2018-0114

**漏洞类型:** JWT 签名绕过

**影响应用:** Node-jose Library

**危害等级:** 高危，可能导致身份伪造和权限提升

**影响版本:** < 0.11.0

**利用条件:** 需要应用程序使用存在漏洞的 Node-jose 库处理 JWT。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-0114 漏洞存在于 Cisco node-jose 开源库 0.11.0 之前的版本中。攻击者可以利用该漏洞通过在 JWT 头部嵌入包含攻击者公钥的 JWK (JSON Web Key)，然后使用与该公钥关联的私钥对令牌进行重新签名来伪造 JWT。由于 node-jose 在验证 JWT 时信任头部中的 JWK，因此攻击者可以绕过签名验证机制。漏洞利用方式如下：

1.  获取原始 JWT。
2.  移除原始签名。
3.  在 JWT 头部添加包含攻击者公钥的 `jwk` 参数。
4.  使用攻击者的私钥对修改后的 JWT 进行签名。
5.  将伪造的 JWT 发送给目标应用程序。

由于提供的代码片段仅包含 Apache 许可证，没有发现可疑或恶意的代码，因此投毒风险较低。

**项目地址:** [zi0Black/POC-CVE-2018-0114](https://github.com/zi0Black/POC-CVE-2018-0114)

**漏洞详情:** [CVE-2018-0114](https://nvd.nist.gov/vuln/detail/CVE-2018-0114)

---

