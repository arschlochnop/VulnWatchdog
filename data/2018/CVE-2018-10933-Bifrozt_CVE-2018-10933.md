## CVE-2018-10933 - libssh 身份验证绕过 (Authentication Bypass)

**漏洞编号:** CVE-2018-10933

**漏洞类型:** 身份验证绕过 (Authentication Bypass)

**影响应用:** libssh

**危害等级:** CRITICAL

**CVSS评分:** 9.1 (CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)

**影响版本:** 0.6.0 及更高版本；在 0.7.6 和 0.8.4 版本之前

**利用条件:** 目标服务器必须运行受影响版本的 libssh 服务，攻击者需能够进行网络访问。

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

POC有效性分析：该POC代码针对libssh服务端的逻辑漏洞进行了高度有效的实现。漏洞根源在于libssh的服务端状态机处理逻辑存在缺陷，当客户端向服务端发送 SSH2_MSG_USERAUTH_SUCCESS 消息（本应由服务端发往客户端表示认证成功）时，服务端会错误地改变其内部状态，认为认证已经完成，从而允许客户端在未提供有效凭据的情况下开启会话通道。POC通过 paramiko 库直接构造并发送该特定字节码，避开常规的认证流程。代码逻辑清晰，包含了参数解析、底层 Socket 连接以及直接操纵传输层消息的步骤，能够成功在目标机器上执行任意命令（如默认的 uptime）。经过分析，该 POC 代码结构严谨，具备较高的实战化利用价值，只需目标环境满足版本条件即可复现，无需复杂的环境模拟或多阶段交互。\n\n利用步骤：1. 准备 Python 环境并安装依赖库 paramiko。2. 确认目标主机的 IP 地址及运行 libssh 服务的端口（通常为 22 或 2222）。3. 执行脚本，使用参数 -H 指定目标，-C 指定待执行的命令。4. 脚本建立 Socket 连接后，利用 paramiko 构建传输层对象，手动发送 SSH2_MSG_USERAUTH_SUCCESS 信号。5. 绕过认证后，脚本打开 session 通道并调用 exec_command 执行命令，最后读取并打印返回结果。\n\n投毒风险分析：该 POC 代码的投毒风险极低。首先，代码导入的均是标准的 Python 库（如 socket, argparse, sys）和广为人知的第三方安全库（paramiko），未引用任何不明来源的远程脚本或二进制组件。其次，代码逻辑透明，从参数处理到 Socket 通信流程均清晰可见，不存在混淆（Obfuscation）或加密后的 Shellcode。在关键的攻击逻辑中，它仅针对目标 IP 发起请求，没有发现扫描本地网络、上传敏感文件或开启本地监听后门的行为。代码中虽包含超时处理和结果循环读取，但均为合法的 I/O 操作，旨在增强利用的稳定性。尽管如此，防御者在使用此类脚本时仍需注意，在复杂的防御边界内运行未审计的利用脚本可能触发流量告警，但从代码层面看，此 POC 是纯粹的防御性研究工具，无恶意投毒痕迹。

**项目地址:** [https://github.com/vulnspy/CVE-2018-10933](https://www.google.com/search?q=https://github.com/vulnspy/CVE-2018-10933)

**漏洞详情:** [https://nvd.nist.gov/vuln/detail/CVE-2018-10933](https://nvd.nist.gov/vuln/detail/CVE-2018-10933)
