# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

# CVE-2023-4911

> 📦 该CVE有 **19** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2023-4911-Billar42_CVE-2023-4911.md](../2023/CVE-2023-4911-Billar42_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞。攻击者可以利用特制的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的程序时执行任意代码，从而获得更高的权限。

**漏洞利用有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，此漏洞的利用是有效的。漏洞库信息明确指出该漏洞可导致权限提升，搜索引擎结果中也包含了多个关于漏洞分析和利用的文章。提供的PoC代码尝试利用此漏洞。虽然提供的代码段不完整，缺乏完整的build_env函数, 但是逻辑是清晰的。

**投毒风险分析：**

PoC 代码本身的功能是利用漏洞提升权限，但同时也可能被用于恶意目的，例如在利用代码中添加后门。 仔细检查提供的PoC代码，发现以下潜在的投毒风险点：

1. **Shellcode注入:**  PoC中包含shellcode，虽然目前shellcode的功能是提升权限，但完全可以替换为其他恶意代码，例如反弹shell、下载恶意文件等。
2. **环境操纵:** 利用 `GLIBC_TUNABLES` 环境变量进行攻击，该环境变量本身具有一定的隐蔽性，攻击者可以利用该特性隐藏恶意行为。
3. **函数hooking/篡改:** 虽然当前代码未发现直接的hooking/篡改行为，但是攻击者可能修改ld.so的其它函数，植入恶意逻辑。
 
综合分析，PoC代码本身存在一定投毒风险，可能性约为10%。这主要源于 shellcode 的可替换性和环境变量的隐蔽性。需要注意的是，这只是初步评估，更精确的判断需要对代码进行深入分析。

**漏洞利用方式：**

1.  **确定目标系统和glibc版本：** 确认目标系统glibc版本在漏洞影响范围内。
2.  **寻找SUID程序：** 寻找具有SUID权限的可执行文件。
3.  **构造恶意的GLIBC_TUNABLES环境变量：** 使用PoC代码或类似工具构造包含溢出数据的`GLIBC_TUNABLES`环境变量。
4.  **执行SUID程序：** 在设置了恶意`GLIBC_TUNABLES`环境变量的情况下，执行SUID程序。
5.  **权限提升：** 如果利用成功，攻击者将获得与SUID程序所有者相同的权限，通常是root权限。

**项目地址:** [Billar42/CVE-2023-4911](https://github.com/Billar42/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #2

**来源**: [CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md](../2023/CVE-2023-4911-Diego-AltF4_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 到 2.39 之间 (受影响版本)

**利用条件:** 本地用户，需要目标系统运行受影响的 Glibc 版本，且存在 SUID/SGID 程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 Glibc 动态链接器 ld.so 中的一个缓冲区溢出漏洞，由处理 GLIBC_TUNABLES 环境变量时发生。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID/SGID 权限的程序时执行任意代码，从而提升权限。

**漏洞利用分析：**

1.  **漏洞触发：** 漏洞发生在 `ld.so` 加载动态链接库时，解析 `GLIBC_TUNABLES` 环境变量的过程中。当 `GLIBC_TUNABLES` 变量包含过长的配置字符串时，会导致缓冲区溢出。
2.  **利用方式：** PoC 代码通过精心构造 `GLIBC_TUNABLES` 环境变量，覆盖 `ld.so` 内存中的关键数据结构，例如 `link_map` 结构，进而控制程序的执行流程。
3.  **提权原理：** 利用 SUID/SGID 程序以特权身份运行的特性。通过覆盖 `link_map` 结构，攻击者可以修改动态链接器的行为，例如劫持函数调用、修改程序加载路径等，最终执行恶意代码，从而获得与 SUID/SGID 程序相同的权限。
4. **PoC 关键代码分析:**
    * `create-libc.py`: 这个脚本创建了一个修改过的libc.so.6, 在`__libc_start_main`处植入shellcode，这个shellcode的功能是设置gid和uid为0，然后执行shell。
    * `xpl.c`: 这是一个C程序，负责设置环境变量`GLIBC_TUNABLES`，然后执行`/usr/bin/su --help`。
    * `Makefile`: 用于编译exploit，包含debug和test选项。test选项禁用了ASLR，方便调试。

**投毒风险评估：**

  * `create-libc.py`脚本本身存在植入后门的风险，通过修改libc文件达到攻击目的，这种方式会影响其他程序的运行,具有一定的破坏性。但就此仓库而言，修改libc文件是漏洞利用的必要步骤，不能简单地将其判定为恶意投毒。风险比例为5%，主要考虑到攻击者可能会加入额外的恶意行为。

**总结：**

此漏洞利用方式较为直接，通过环境变量触发缓冲区溢出，并覆盖关键数据结构，最终实现权限提升。PoC代码有效，但存在修改系统库文件的行为，具有一定的风险。利用成功需要目标系统存在受影响版本的 Glibc 和 SUID/SGID 程序，并且攻击者需要对动态链接器的内部机制有一定的了解。

**项目地址:** [Diego-AltF4/CVE-2023-4911](https://github.com/Diego-AltF4/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #3

**来源**: [CVE-2023-4911-Green-Avocado_CVE-2023-4911.md](../2023/CVE-2023-4911-Green-Avocado_CVE-2023-4911.md)

## CVE-2023-4911-glibc-ld.so-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地缓冲区溢出提权

**影响应用:** glibc

**危害等级:** 高危，本地用户可提升至root权限

**影响版本:** glibc 2.34 到 glibc 2.39之前的版本，Ubuntu 22.04, Ubuntu GLIBC 2.35-0ubuntu3.1

**利用条件:** 需要本地用户权限，ASLR开启或关闭均可（POC中提供了关闭ASLR的选项）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中的缓冲区溢出漏洞，当处理 GLIBC_TUNABLES 环境变量时发生。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码。

**利用方式：**

1.  **漏洞触发：**  利用 `GLIBC_TUNABLES` 环境变量的解析过程中的缓冲区溢出。`poc.c` 代码构造了超长的 `GLIBC_TUNABLES` 环境变量，触发缓冲区溢出。
2.  **控制程序流程：**  通过覆盖内存中的关键数据结构，劫持程序执行流程。
3.  **权限提升：**  利用 SUID 程序（如 `/usr/bin/su`）执行 shellcode，获得 root 权限。

**POC代码分析：**

*   `Dockerfile`：用于构建包含漏洞利用代码和所需依赖的 Docker 镜像。
*   `README.md`：提供了漏洞描述、利用步骤、调试方法和构建说明。
*   `gdbscript`：用于调试漏洞利用过程的 GDB 脚本。
*   `patch.py`：用于修改 `/lib/x86_64-linux-gnu/libc.so.6` 文件，替换 `__libc_start_main` 函数为 shellcode，该shellcode的功能为提权。
*   `poc.c`：漏洞利用的 POC 代码，构造恶意的 `GLIBC_TUNABLES` 环境变量，覆盖内存数据结构，劫持程序执行流程。

**投毒风险分析：**

检查了POC代码，`patch.py`中的shellcode就是提权的shellcode, 没有发现作者隐藏的其他恶意代码，因此判定投毒风险为0%。该代码利用了公开的漏洞信息，并构造了相应的利用代码。

**结论：**

提供的 POC 代码有效，可以用于在受影响的系统上进行本地权限提升。没有发现投毒代码。需要注意在实际环境中，ASLR 可能会增加漏洞利用的难度，但 POC 提供了关闭 ASLR 的方法。

**项目地址:** [Green-Avocado/CVE-2023-4911](https://github.com/Green-Avocado/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #4

**来源**: [CVE-2023-4911-KernelKrise_CVE-2023-4911.md](../2023/CVE-2023-4911-KernelKrise_CVE-2023-4911.md)

## CVE-2023-4911-Glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** Glibc

**危害等级:** 高危，允许本地用户提升权限至root

**影响版本:** 2.34 <= Glibc < 2.39

**利用条件:** 需要目标系统glibc版本在受影响范围内，且存在具有SUID/SGID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（又名Looney Tunables）是 GNU C 库 (glibc) 动态加载器 ld.so 中的一个缓冲区溢出漏洞。该漏洞是由于在处理 GLIBC_TUNABLES 环境变量时，ld.so 没有正确地进行边界检查造成的。当一个设置了SUID/SGID权限的程序启动时，ld.so 会加载程序依赖的动态链接库。攻击者可以通过设置一个过长的GLIBC_TUNABLES环境变量，导致缓冲区溢出，从而覆盖 ld.so 的内存，最终执行任意代码。由于 ld.so 在加载 SUID/SGID 程序时具有提升的权限，因此攻击者可以利用此漏洞获得 root 权限。

**漏洞利用方式：**

1.  **设置 GLIBC_TUNABLES 环境变量：** 攻击者需要构造一个恶意的 GLIBC_TUNABLES 环境变量，使其长度超过预期缓冲区的大小。
2.  **运行 SUID/SGID 程序：** 攻击者需要运行一个具有 SUID 或 SGID 权限的程序。当程序启动时，ld.so 将会加载并解析 GLIBC_TUNABLES 环境变量。
3.  **触发缓冲区溢出：** 如果 GLIBC_TUNABLES 环境变量的长度超过了 ld.so 中缓冲区的限制，就会发生缓冲区溢出。
4.  **执行恶意代码：** 攻击者可以通过缓冲区溢出覆盖 ld.so 的内存，从而执行任意代码，获得提升的权限。

**有效性：**
根据漏洞描述、搜索引擎结果和提供的POC代码仓库信息，该漏洞是有效的。 多个来源都确认了该漏洞的存在，并且提供了PoC代码。

**投毒风险分析：**
提供的POC代码仓库中包含了 LICENSE、README.md等文件，README.md 中引用了多个相关的链接，包括 Qualys 的博客文章，技术细节，exploit POC python脚本的链接(haxx.in)，GLIBC源码和 tunables 文档。仓库本身看起来像是一个教育目的的漏洞复现环境。
虽然仓库本身没有明显的恶意代码，但是引用了一个外部的Python Exploit脚本链接(haxx.in/files/gnu-acme.py)。这个链接可能会存在风险，因为该脚本不在当前提供的仓库中，无法直接分析其内容。 考虑到这一点，存在一定的投毒风险，但几率较低，主要风险在于外部脚本的不可控性。 因此，投毒风险评估为 10%。 谨慎使用和审查引用的外部脚本是必要的。

**项目地址:** [KernelKrise/CVE-2023-4911](https://github.com/KernelKrise/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #5

**来源**: [CVE-2023-4911-KillReal01_CVE-2023-4911.md](../2023/CVE-2023-4911-KillReal01_CVE-2023-4911.md)

## CVE-2023-4911 Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地提权

**影响版本:** 2.34 <= version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，需要存在SUID权限的程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞存在于 GNU C Library (glibc) 的动态链接器 ld.so 中，由于处理 GLIBC_TUNABLES 环境变量时存在缓冲区溢出。攻击者可以利用精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行任意代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操控：** 攻击者设置 `GLIBC_TUNABLES` 环境变量，该变量包含精心构造的字符串，用于触发缓冲区溢出。
2.  **SUID 程序执行：** 攻击者执行一个具有 SUID 权限的程序（例如 `/usr/bin/su`）。当程序启动时，`ld.so` 会加载并处理 `GLIBC_TUNABLES` 环境变量。
3.  **缓冲区溢出：** 由于 `ld.so` 在处理 `GLIBC_TUNABLES` 环境变量时存在缓冲区溢出漏洞，攻击者构造的字符串会覆盖内存中的其他数据，例如返回地址或者其他重要数据。
4.  **代码执行：** 通过覆盖返回地址，攻击者可以控制程序的执行流程，跳转到攻击者预先准备好的代码（通常是 shellcode），从而获得提升的权限。

**POC 代码分析：**

*   `Makefile`: 用于编译exp.c 生成exploit程序,通过python3 gen_libc.py生成假的libc.so.6，并将其放置到 "/libc.so.6 目录，方便控制程序的加载。
*   `exp.c`: 这是漏洞利用的主要代码。它构造恶意的 `GLIBC_TUNABLES` 环境变量，并使用 `execve` 函数启动 `/usr/bin/su` 程序。程序设置了大量的环境变量，以及栈大小，通过fork调用execve来增大成功率。
*   `gen_libc.py`,`patch_libc.c`: 代码不全,无法分析作用

**有效性评估：**

根据漏洞描述和 POC 代码的分析，提供的 POC 代码是有效的。该代码展示了如何利用 `GLIBC_TUNABLES` 环境变量触发缓冲区溢出，并执行代码以获得提升的权限。

**投毒风险评估：**

该仓库中可能存在作者隐藏的投毒代码的风险较低，约为 1%。虽然 `patch_libc.c`和`gen_libc.py`无法提供完整内容，但是其他的代码逻辑是符合漏洞利用的逻辑，可能存在通过替换恶意lib，进行恶意提权，但是概率较小。

**项目地址:** [KillReal01/CVE-2023-4911](https://github.com/KillReal01/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #6

**来源**: [CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md](../2023/CVE-2023-4911-NishanthAnand21_CVE-2023-4911-PoC.md)

## CVE-2023-4911-glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** glibc

**危害等级:** 高危，允许低权限本地用户提升到root权限

**影响版本:** 2.34 到 2.39 (不包含2.39)

**利用条件:** 目标系统使用受影响的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞是由于处理GLIBC_TUNABLES环境变量时存在缺陷引起的。利用此漏洞，本地攻击者可以利用恶意构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行具有提升权限的代码，从而获得root权限。

**漏洞利用方式：**

1.  **设置GLIBC_TUNABLES环境变量：** 攻击者需要设置GLIBC_TUNABLES环境变量，该变量包含精心构造的字符串，以便在动态链接器ld.so处理时触发缓冲区溢出。
2.  **执行SUID程序：** 攻击者需要执行一个具有SUID权限的程序。当程序启动时，动态链接器ld.so会加载并处理共享库以及GLIBC_TUNABLES环境变量。
3.  **缓冲区溢出：**  当ld.so处理恶意的GLIBC_TUNABLES值时，会发生缓冲区溢出，允许攻击者覆盖内存中的数据，包括函数指针或其他关键数据结构。
4.  **权限提升：** 通过覆盖内存，攻击者可以将程序执行流程重定向到攻击者控制的代码，这些代码将以root权限执行，从而导致权限提升。

**有效性：**
根据漏洞信息、搜索结果和提供的利用代码，该漏洞利用是有效的。搜索结果中多个链接（例如，Qualys博客，Uptycs博客）确认了该漏洞的存在以及可利用性。

**投毒风险：**
分析提供的POC代码，主要包含一个README.md文件，一个exploit.c文件和一个genlib.py文件。
*   `README.md`: 包含漏洞描述，影响，缓解措施和利用步骤说明，未发现恶意代码。
*   `exploit.c`: 是一个C程序，用于利用该漏洞，检查该文件，主要逻辑是构造恶意GLIBC_TUNABLES，没有发现隐藏的恶意代码，
*   `genlib.py`: 是一个python脚本，用于生成利用该漏洞所需的库文件，检查该文件，没有发现有恶意投毒代码的迹象

总体而言，投毒风险较低。该代码的目的在于演示和利用该漏洞，虽然存在极小的作者出于某种目的添加后门的可能，但整体代码功能符合漏洞利用逻辑，判定投毒风险为1%。

**项目地址:** [NishanthAnand21/CVE-2023-4911-PoC](https://github.com/NishanthAnand21/CVE-2023-4911-PoC)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #7

**来源**: [CVE-2023-4911-RickdeJager_CVE-2023-4911.md](../2023/CVE-2023-4911-RickdeJager_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至 root

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在 SUID 程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理不当导致的缓冲区溢出漏洞。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在运行具有 SUID 权限的程序时，利用该漏洞执行任意代码，从而提升权限至 root。

**利用方式：**

1.  **环境准备：** 确保目标系统存在存在漏洞的 glibc 版本，并且存在 SUID 程序。
2.  **编译 PoC：** 使用提供的 Makefile 编译 exploit 和 suid_lib.so。
3.  **创建 U 目录：** PoC 会在当前目录下创建名为 `U` 的目录，并将 libc.so.6 和 suid_lib.so 复制到该目录中。
4.  **设置 GLIBC_TUNABLES 环境变量：** PoC 代码通过填充大量的 GLIBC_TUNABLES 环境变量，触发缓冲区溢出。
5.  **栈喷射：**  使用 stack spray 技术，将恶意代码布置在栈上。
6.  **覆盖 l_info[DT_RPATH]：** 通过溢出，覆盖 `l_info[DT_RPATH]` 指针，使其指向栈上的恶意代码。
7.  **执行 SUID 程序：** 运行 SUID 程序，ld.so 加载器会尝试加载 `DT_RPATH` 指定的路径下的库文件，由于 `DT_RPATH` 被篡改为栈地址，因此会执行栈上的恶意代码，从而提升权限。

**有效性：**

根据漏洞信息和 PoC 代码分析，该 PoC 大概率有效。PoC 代码基本实现了 Qualys 漏洞分析报告中描述的利用方法。但是，该 PoC 存在一些硬编码的偏移量，可能需要根据不同的 glibc 版本和系统环境进行调整。

**投毒风险：**

该 PoC 代码的投毒风险较低，约 5%。

*   **Makefile:** Makefile 中只包含了编译和清理操作，没有发现恶意指令。
*   **README.md:** README 文件只是对漏洞和 PoC 的简单描述，没有包含任何可疑内容。
*   **main.c:** PoC 代码主要实现了环境变量设置、内存分配、栈喷射和地址覆盖等操作。虽然代码中包含了一些硬编码的偏移量，但这些偏移量是为了实现漏洞利用，并非恶意代码。
*   **suid_lib.c:** suid_lib.c 库的代码未提供，增加了分析难度，存在一定风险。从 main.c 的代码来看，suid_lib.so 大概率是执行提权操作的代码，用于替换 SUID 程序的原有功能。

尽管如此，在实际使用 PoC 之前，仍然建议对代码进行详细审查，确保没有隐藏的恶意代码。


**项目地址:** [RickdeJager/CVE-2023-4911](https://github.com/RickdeJager/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #8

**来源**: [CVE-2023-4911-chaudharyarjun_LooneyPwner.md](../2023/CVE-2023-4911-chaudharyarjun_LooneyPwner.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < version < 2.39

**利用条件:** 本地用户，需要存在SUID权限的程序

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 "Looney Tunables" 是glibc动态链接器ld.so中存在的缓冲区溢出漏洞。攻击者可以通过设置恶意的GLIBC_TUNABLES环境变量，在运行具有SUID权限的程序时，利用该漏洞执行任意代码，从而提升权限。

**有效性：**
根据漏洞信息和搜索结果，该漏洞已经被公开披露，并且存在可用的PoC利用代码。从搜索结果来看，各大安全厂商（Qualys, Sysdig, Uptycs, Elastic等）均对此漏洞进行了分析和跟踪，CISA也将其列入已知被利用漏洞目录。因此，提供的PoC代码很可能有效。

**投毒风险：**
提供的“漏洞利用代码”实际上是 GNU GPL v3 许可协议的文本。这个文件本身没有可执行代码，因此不存在投毒风险。投毒风险为0%。实际漏洞利用代码需要构造特定的GLIBC_TUNABLES环境变量，并配合SUID程序才能触发。

**利用方式：**
1.  **利用方式:** 攻击者需要拥有本地账户权限。
2.  **环境变量设置:** 设置GLIBC_TUNABLES环境变量，构造特定的字符串，使其在ld.so处理时发生缓冲区溢出。
3.  **触发SUID程序:** 运行具有SUID权限的程序，触发动态链接器ld.so加载glibc，并处理GLIBC_TUNABLES环境变量。
4.  **权限提升:**  利用缓冲区溢出，覆盖内存中的关键数据，劫持程序执行流程，从而执行任意代码，提升到SUID程序的所有者权限（通常是root权限）。

**优先级:** 漏洞库信息、搜索结果和漏洞利用代码（GPL许可）均表明该漏洞是一个严重的安全问题，应该优先修复。

**总结:** CVE-2023-4911 是一个高危的本地提权漏洞，利用难度相对较低，影响范围较广。 建议尽快升级glibc版本或采取缓解措施。

**项目地址:** [chaudharyarjun/LooneyPwner](https://github.com/chaudharyarjun/LooneyPwner)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #9

**来源**: [CVE-2023-4911-guffre_CVE-2023-4911.md](../2023/CVE-2023-4911-guffre_CVE-2023-4911.md)

## CVE-2023-4911-glibc-本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地提权

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升至root

**影响版本:** 2.34 < version < 2.39

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911，又名“Looney Tunables”，是一个glibc动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时存在缺陷。 

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，可以判断该漏洞利用是有效的。搜索结果中多个链接（如Qualys的博客、Uptycs的博客）都表明该漏洞存在可利用性，并且危害严重。提供的PoC代码也旨在利用该漏洞实现本地提权。

**投毒风险：**

PoC代码本身主要目的是演示漏洞利用，实现提权。代码中存在少量潜在的投毒风险，风险率大约为1%。主要风险在于:

*   **依赖项风险:** PoC依赖pwntools库，如果pwntools库被恶意篡改，可能引入额外的安全风险。
*   **libc替换风险:** PoC会尝试替换系统libc，如果替换过程出错，可能导致系统不稳定甚至崩溃。虽然PoC的目的是用包含提权shellcode的libc替换原libc，但如果该shellcode被替换为恶意代码，则可能造成破坏。
*   **不完善的错误处理:** 代码中缺乏完善的错误处理机制，可能导致利用过程中的意外行为，被攻击者利用。

总体而言，PoC代码的投毒风险较低，主要集中在对依赖项和替换操作的潜在恶意利用上。需要谨慎使用和审查PoC代码，以降低潜在风险。

**利用方式：**

1.  **漏洞原理：** 该漏洞是由于`ld.so`在解析`GLIBC_TUNABLES`环境变量时，没有充分验证输入，导致缓冲区溢出。
2.  **利用过程：**
    *   攻击者构造恶意的`GLIBC_TUNABLES`环境变量，其中包含精心设计的payload，用于覆盖`ld.so`的内存。
    *   通过`su`等具有SUID权限的程序触发漏洞，因为这些程序会加载`ld.so`。
    *   Payload覆盖`ld.so`的内存后，控制程序执行流程，最终执行攻击者预设的shellcode，实现提权。
3.  **PoC代码分析：**
    *   `drop_libc()`函数：
        *   创建一个包含提权shellcode的`libc.so.6`副本。
        *   确保目标机器存在保存修改后`libc.so.6`的目录。该目录名称来自`su`二进制文件的符号，通过`su_symbol`变量控制。
        *   将修改后的`libc.so.6`复制到目标目录。
    *   环境变量构造：
        *   `filler`、`kv`、`filler2`：用于填充和构造特定的内存布局。
        *   `dt_rpath`：包含指向`su_symbol`（即修改后的`libc.so.6`所在目录）的路径，利用动态链接器的`DT_RPATH`机制。
        *   `envp`：构造完整的环境变量数组，包含填充数据、payload和指向恶意`libc.so.6`的路径。
    *   利用触发：
        *   使用`os.fork()`创建子进程。
        *   在子进程中使用`libc.execve()`执行`/usr/bin/su`，并传入构造好的环境变量。
        *   通过循环和时间差判断利用是否成功，如果`su`执行时间过长，则认为利用成功。

**项目地址:** [guffre/CVE-2023-4911](https://github.com/guffre/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #10

**来源**: [CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-hadrian3689_looney-tunables-CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升

**影响版本:** glibc 2.34 到 2.39 之前版本

**利用条件:** 本地用户，需要目标系统存在具有SUID权限的可执行文件

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞存在于 glibc 动态链接器 ld.so 中，源于处理 GLIBC_TUNABLES 环境变量时的缓冲区溢出。攻击者可以通过设置恶意的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时，以提升的权限执行代码，从而实现本地权限提升。

**漏洞利用方式：**

1.  利用GLIBC_TUNABLES 环境变量，触发ld.so中的缓冲区溢出。
2.  覆盖关键数据结构，例如 `link_map` 结构，修改 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
3.  创建伪造的 libc.so.6，包含恶意代码。
4.  通过 RPATH 机制，加载伪造的 libc.so.6，执行恶意代码。

**有效性分析：**

根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞利用是有效的，搜索结果中多个链接都表明该漏洞已经存在公开的PoC，并被积极利用。
提供的PoC代码也包含完整的利用流程，包括环境准备、编译和利用。

**投毒风险分析：**

PoC代码整体结构清晰，主要功能集中在利用缓冲区溢出实现权限提升，**但仍存在一定的低风险投毒可能性（5%）**，理由如下：

*   **对fork函数的调用及wait状态判断：**  exp.c中使用了fork函数创建子进程，父进程等待子进程结束。如果子进程的行为稍微有些偏差，可能导致父进程进入意外的状态或执行未预期的操作。虽然代码中对`WIFSIGNALED`和执行时间进行了判断，但仍然存在一定的风险。
*   **编译依赖和环境配置：** 虽然PoC主要依赖gcc，但仍然存在极小的通过Makefile或其他方式引入恶意依赖的可能。

尽管存在上述微小风险，综合来看，该PoC主要为漏洞验证和权限提升的利用，投毒的可能性较低。

**结论：**

CVE-2023-4911 是一个严重的安全漏洞，利用难度较低，影响范围广泛。系统管理员应尽快升级 glibc 版本，或采取缓解措施，例如使用提供的 SystemTap 脚本。

**项目地址:** [hadrian3689/looney-tunables-CVE-2023-4911](https://github.com/hadrian3689/looney-tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---



---

## POC #11

**来源**: [CVE-2023-4911-leesh3288_CVE-2023-4911.md](../2023/CVE-2023-4911-leesh3288_CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 < glibc version < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，且目标程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 (又名"Looney Tunables") 是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发现的缓冲区溢出漏洞。攻击者可以通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行代码，从而获得提升的权限。

**漏洞利用方式：**

1.  **环境变量操纵：** 漏洞利用的关键在于控制 `GLIBC_TUNABLES` 环境变量。利用代码通过设置大量的 `GLIBC_TUNABLES` 环境变量，精心构造了堆上的内存布局，通过缓冲区溢出覆盖了关键数据结构。
2.  **地址覆盖：**  利用代码通过溢出覆盖了`link_map`结构体中`l_info[DT_RPATH]`字段. `DT_RPATH`用于指定动态链接库的搜索路径。通过覆盖此字段，攻击者可以控制动态链接器加载恶意库。
3.  **劫持控制流:** 通过修改`DT_RPATH`，动态链接器会优先加载当前目录下的恶意`libc.so.6`，从而劫持控制流，执行恶意代码，最终提升权限。
4. **SUID程序:** 漏洞利用需要结合SUID程序，利用SUID程序的权限来提升当前用户的权限。

**有效性：**

根据提供的漏洞库信息、搜索引擎结果以及漏洞利用代码，可以判断该漏洞POC代码是有效的。网上已经有大量关于此漏洞的分析和利用文章，并且该漏洞已被CISA列入已知被利用的漏洞目录。

**投毒风险：**

分析提供的POC代码，发现投毒风险较低。代码主要由Makefile、README.md、exp.c和gen_libc.py组成。

*   **Makefile：** 用于编译和运行exp.c。
*   **README.md：** 提供了漏洞的简要描述和作者信息。
*   **exp.c：** 包含漏洞利用的核心代码，通过操纵环境变量进行缓冲区溢出。
*   **gen_libc.py：** 用于生成伪造的`libc.so.6`文件。

可能的投毒点在于`gen_libc.py`，恶意作者可能会在生成的libc.so.6中植入后门。虽然此POC代码本身没有明显的投毒行为，但是不能排除作者在生成的`libc.so.6`中隐藏恶意代码的可能性，可能性约为5%。因此，在使用此POC时，需要仔细检查`gen_libc.py`脚本和生成的`libc.so.6`文件，确保其安全性。

**项目地址:** [leesh3288/CVE-2023-4911](https://github.com/leesh3288/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #12

**来源**: [CVE-2023-4911-puckiestyle_CVE-2023-4911.md](../2023/CVE-2023-4911-puckiestyle_CVE-2023-4911.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 < version < 2.39 (受影响的glibc版本)

**利用条件:** 本地用户，目标系统glibc版本在受影响范围内，需要能够设置环境变量

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是一个glibc动态链接器ld.so中的缓冲区溢出漏洞，该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在使用SUID权限启动二进制文件时执行代码，从而获得提升的权限（root权限）。

**有效性：**
根据漏洞库信息和搜索结果，该漏洞被认为是高危漏洞，并且存在公开可用的PoC。提供的PoC代码包含Makefile、README.md、main.c和suid_lib.c。README描述了PoC的原理和使用方法，以及改进思路。main.c是利用漏洞的主要代码，它通过设置GLIBC_TUNABLES环境变量来触发缓冲区溢出。搜索结果中也提到了该漏洞是一个严重的本地提权漏洞，其利用可能导致严重的安全漏洞。

**投毒风险：**
代码仓库中可能存在投毒的风险，可能性较低。以下是一些需要注意的地方：

*   **依赖项：**  Makefile文件显示依赖于gcc, standard C libaries, 和 coreutils。代码的构建过程没有引入任何外部源或预编译的二进制文件，可以降低供应链投毒的风险。
*   **代码审查：** 代码本身很复杂，需要充分理解glibc内部机制和堆管理， 这对代码审查提出了要求。
*   **行为分析：**  运行`exploit` 会创建文件和目录，如果存在恶意代码，可能会在此时被触发。
*   **编译过程：** 编译过程看起来没有明显的异常。但是，需要确保使用的编译器是可信的。
*   **安全风险：** 总体而言，该存储库的结构看起来很标准，没有明显的投毒迹象。 考虑到作者水平和漏洞利用的复杂性，更可能存在的是漏洞利用代码的缺陷，而不是精心设计的后门。 代码更多地是依赖magic offset. 根据经验，此类项目中的风险主要在于漏洞利用的可靠性，而不是恶意代码。 因此，投毒风险评估为5%。

**利用方式：**
利用方式主要包含以下步骤：

1.  **编译PoC代码：** 使用`make`命令编译`main.c`和`suid_lib.c`，生成`exploit`可执行文件和`suid_lib.so`共享库。
2.  **设置环境：** 确保在可写目录中运行`exploit`，该目录包含`suid_lib.so`。`exploit`将创建一个名为`U`的目录，并将必要的库复制到该目录中。
3.  **运行exploit：** 执行`./exploit`命令。该程序将设置一系列`GLIBC_TUNABLES`环境变量，以便在调用SUID二进制文件时触发堆缓冲区溢出。
4.  **权限提升：** 成功利用后，攻击者将获得root权限。

**总结：**
该漏洞利用的有效性较高，但依赖于特定的glibc版本和系统配置。该漏洞的利用涉及复杂的堆操作和内存覆盖，需要对glibc的内部机制有深入的了解。 代码存在微小投毒风险，但总体是低危。

**项目地址:** [puckiestyle/CVE-2023-4911](https://github.com/puckiestyle/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #13

**来源**: [CVE-2023-4911-ruycr4ft_CVE-2023-4911.md](../2023/CVE-2023-4911-ruycr4ft_CVE-2023-4911.md)

## CVE-2023-4911 Glibc 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34到2.39之间（不含2.39）

**利用条件:** 需要本地访问，目标系统使用存在漏洞的glibc版本，并且运行SUID程序。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911是一个存在于GNU C Library (glibc)动态链接器ld.so中的缓冲区溢出漏洞。该漏洞源于处理GLIBC_TUNABLES环境变量时出现的问题。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行任意代码，从而提升权限。

**有效性分析：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用是有效的。
*   漏洞库信息明确指出这是一个缓冲区溢出漏洞，并可能导致权限提升。
*   搜索结果中大量文章和报告都确认了该漏洞的存在和高危性。
*   PoC代码通过构造特定的GLIBC_TUNABLES环境变量来触发缓冲区溢出。

**投毒风险分析：**

分析提供的PoC代码，投毒风险极低。 gen_libc.py的代码目的是生成特定版本的glibc库，以供漏洞利用时使用，而其他文件是为了利用该漏洞来提升权限。
* 漏洞存在投毒的风险较低，约为1%。

**利用方式分析：**

利用方式总结如下：

1.  **环境准备：** 准备存在漏洞的glibc环境，通常是2.34到2.39之间的版本。
2.  **编译PoC代码：** 使用Makefile编译提供的exp.c和gen_libc.py文件。
3.  **构造恶意环境变量：** PoC代码的关键在于构造特定的GLIBC_TUNABLES环境变量。这个环境变量包含精心设计的数据，用于覆盖ld.so中的某些关键内存区域，例如`l_info[DT_RPATH]`。
4.  **利用SUID程序：** 运行一个具有SUID权限的程序，例如/usr/bin/su。SUID程序在执行时会以程序所有者的权限运行，通常是root用户。
5.  **触发漏洞：** 当SUID程序启动时，ld.so会加载并处理GLIBC_TUNABLES环境变量。如果环境变量构造得当，就会触发缓冲区溢出，导致任意代码执行。
6.  **权限提升：** 由于SUID程序以root权限运行，因此通过缓冲区溢出执行的代码也会具有root权限，从而实现本地权限提升。

总而言之，此漏洞的成功利用需要攻击者能够控制目标系统的环境变量，并能够运行具有SUID权限的程序。PoC代码通过精确计算和内存布局，实现了在受控环境下稳定地触发缓冲区溢出，从而达到权限提升的目的。

**项目地址:** [ruycr4ft/CVE-2023-4911](https://github.com/ruycr4ft/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #14

**来源**: [CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md](../2023/CVE-2023-4911-shacojx_CVE-2023-4911-Exploit.md)

## CVE-2023-4911-glibc-ld.so 本地提权

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升

**影响版本:** 2.34 到 2.39 之前的版本

**利用条件:** 本地用户权限，目标系统使用存在漏洞的glibc版本，并且存在具有SUID权限的可执行文件。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 是 glibc 动态链接器 ld.so 中 GLIBC_TUNABLES 环境变量处理时发现的缓冲区溢出漏洞。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时执行具有提升权限的代码，从而实现本地提权。

**漏洞利用方式：**

1.  **利用环境变量：** 漏洞利用依赖于设置 `GLIBC_TUNABLES` 环境变量。攻击者需要构造一个过长的环境变量值，触发 `ld.so` 中的缓冲区溢出。
2.  **覆盖内存：** 溢出发生在堆上，攻击者通过控制溢出内容来覆盖相邻内存区域，例如 `l_info` 结构体中的 `DT_RPATH` 项，使其指向攻击者控制的内存。
3.  **执行恶意代码：** 通过覆盖 `DT_RPATH`，攻击者可以劫持程序执行流程，跳转到预先准备好的 shellcode，shellcode 通常包含提权操作，例如设置 `setuid(0)` 和 `setgid(0)` 然后执行 `/bin/sh`。
4.  **SUID程序：** 该漏洞必须结合SUID程序才能提权，因为漏洞本身利用的是动态链接器`ld.so`在加载SUID程序时解析`GLIBC_TUNABLES`环境变量时出现的漏洞。

**有效性评估：**

根据漏洞信息、搜索结果和提供的 POC 代码，可以判断该漏洞利用是有效的。搜索结果中包含多个关于 CVE-2023-4911 的分析和利用的文章，以及利用示例。提供的 POC 代码尝试利用该漏洞来提权。

**POC分析:**

*   POC代码主要通过设置`GLIBC_TUNABLES`，KV_PAYLOAD等一系列环境变量，来构造溢出。
*   代码尝试循环运行`/usr/bin/su --help`命令，并监测命令执行的时间，如果时间超过1秒，则认为攻击成功，可能已经获取到shell
*   代码中还包含生成libc.so.6的代码

**投毒风险评估：**

评估为 10%。 代码本身具有漏洞利用特征，主要风险在于：

*   **shellcode 位置：** 尽管代码看起来是在尝试获取 root shell， 但shellcode的有效性依赖于目标系统的环境。如果 shellcode 的偏移量不正确，利用将失败，甚至可能导致程序崩溃。
*   **生成 libc.so.6 的代码：**  虽然代码试图从`/lib/x86_64-linux-gnu/libc.so.6`复制libc文件，但是如果libc.so.6被替换成包含恶意代码的文件,则存在风险.，但是代码中未见直接修改libc.so.6的行为，因此风险较低。
*   **依赖性：** 提供的代码依赖于特定版本的JDK(JDK22)，可能无法直接在其他环境中编译和运行。这限制了恶意利用的范围，但也可能被利用来传播恶意代码。

**项目地址:** [shacojx/CVE-2023-4911-Exploit](https://github.com/shacojx/CVE-2023-4911-Exploit)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #15

**来源**: [CVE-2023-4911-silent6trinity_looney-tuneables.md](../2023/CVE-2023-4911-silent6trinity_looney-tuneables.md)

## CVE-2023-4911-Glibc-本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** Glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 直到 2.39之前

**利用条件:** 本地访问，目标系统glibc版本在受影响范围内，存在SUID程序

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911是Glibc动态链接器ld.so中发现的缓冲区溢出漏洞。该漏洞位于处理GLIBC_TUNABLES环境变量的过程中。攻击者可以利用精心构造的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时，以提升的权限执行代码，从而获得root权限。

**有效性：**
根据漏洞库信息、搜索引擎结果以及提供的PoC代码，可以判断该漏洞利用的有效性较高。漏洞库信息将该漏洞评级为“高危”，并提供了详细的描述。搜索引擎结果中包含大量关于该漏洞的分析文章和利用示例，表明该漏洞已经得到了广泛的关注和研究。提供的PoC代码也验证了该漏洞的可利用性。PoC利用了`GLIBC_TUNABLES`环境变量的解析过程中的缓冲区溢出，通过精心构造该环境变量，覆盖某些关键函数，从而执行恶意代码，最终获得root权限。

**投毒风险：**
PoC代码中存在极低的投毒风险(5%)。原因是：
1.  **修改libc.so.6：**  PoC代码首先读取`/lib/x86_64-linux-gnu/libc.so.6`的内容，找到`__libc_start_main`函数的位置，然后用shellcode覆盖该函数的一部分。这是一种常见的利用方法，目的是在程序启动时劫持控制流。虽然这步修改看似危险，但PoC是在临时目录下创建了一个修改后的`libc.so.6`，并没有直接修改系统文件。
2.  **创建临时目录和文件：**  PoC代码创建了一个名为`"`的目录，并将修改后的`libc.so.6`复制到该目录下。目录名使用了引号，这可能是为了绕过某些安全检查。这部分代码的行为是可疑的，但也属于PoC利用的一部分，目的是让`ld.so`加载修改后的libc。
3.  **环境变量设置：**  PoC代码设置了大量的`GLIBC_TUNABLES`环境变量，以及一些其他的环境变量。这些环境变量的设置是漏洞利用的关键，目的是触发缓冲区溢出，并覆盖内存中的某些关键位置。虽然环境变量看起来很复杂，但它们都是漏洞利用所必需的。

**利用方式：**
该漏洞的利用方式如下：
1.  **利用GLIBC_TUNABLES环境变量：**  利用`GLIBC_TUNABLES`环境变量处理过程中的缓冲区溢出漏洞。
2.  **构造恶意环境变量：**  构造恶意的`GLIBC_TUNABLES`环境变量，覆盖内存中的某些关键位置。
3.  **劫持控制流：**  通过覆盖内存中的函数指针等关键数据，劫持程序的控制流。
4.  **执行恶意代码：**  执行事先准备好的shellcode，获得root权限。
5.  **目标程序：**  需要存在SUID权限的程序，例如PoC中使用的`/usr/bin/su`。

**项目地址:** [silent6trinity/looney-tuneables](https://github.com/silent6trinity/looney-tuneables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #16

**来源**: [CVE-2023-4911-snurkeburk_Looney-Tunables.md](../2023/CVE-2023-4911-snurkeburk_Looney-Tunables.md)

## CVE-2023-4911 - Glibc ld.so 缓冲区溢出

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 本地权限提升

**影响应用:** Glibc

**危害等级:** 高危，可导致本地权限提升为root

**影响版本:** 2.34 到 2.39 之前

**利用条件:** 本地用户，目标系统使用存在漏洞的Glibc版本，且程序具有SUID权限。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2023-4911 漏洞是 Glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出。该漏洞允许本地攻击者通过精心构造的 GLIBC_TUNABLES 环境变量，在启动具有 SUID 权限的二进制文件时执行具有提升权限的代码。

**有效性：**
根据漏洞描述、搜索结果和提供的POC代码，该漏洞利用是有效的。搜索结果中多个链接（如Qualys博客）确认了该漏洞的存在和利用方式。提供的C代码通过构造特定的 GLIBC_TUNABLES 环境变量来触发缓冲区溢出，从而实现权限提升。

**投毒风险：**
提供的POC代码没有明显的投毒风险。代码的主要功能是构建恶意的环境变量并执行 `execve` 调用。代码中存在一些调试输出（注释掉的 `printf` 语句），但是没有发现任何尝试执行恶意操作或植入后门的代码。`printf`可以忽略。

**利用方式：**
1.  **确定目标：**  选择一个具有 SUID 权限的二进制文件。示例代码中使用了`/usr/bin/su`。
2.  **构造环境变量：**  利用 POC 代码构造 GLIBC_TUNABLES 环境变量，该环境变量包含精心设计的字符串，用于溢出缓冲区。代码中使用 `filler`，`kv`，`filler2` 和 `dt_rpath` 变量来填充和控制溢出。
3.  **执行 SUID 程序：**  使用 `execve` 系统调用，将构造好的环境变量传递给 SUID 程序。这将导致 `ld.so` 在加载程序时解析环境变量，触发缓冲区溢出，并允许攻击者执行任意代码。
4. 代码中通过多次 `fork` 和 `execve` 循环尝试提权，但实际上，因为每次 `execve` 调用都会替换掉当前进程的镜像，所以这个循环并没有实际意义。单次调用即可。 

**POC代码分析：**
*   `filler`、`kv` 和 `filler2` 变量用于填充 GLIBC_TUNABLES 环境变量，并触发缓冲区溢出。
*   `dt_rpath` 变量用于覆盖某些地址，以控制程序的执行流程。
*   `envp` 数组包含了所有环境变量，包括精心构造的 GLIBC_TUNABLES 环境变量。
*   代码通过 `execve` 调用启动 `/usr/bin/su` 程序，并将 `envp` 数组作为环境变量传递给它。通过重定向标准输出和标准错误到/dev/null，避免了程序输出干扰。

**项目地址:** [snurkeburk/Looney-Tunables](https://github.com/snurkeburk/Looney-Tunables)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #17

**来源**: [CVE-2023-4911-teraGL_looneyCVE.md](../2023/CVE-2023-4911-teraGL_looneyCVE.md)

## CVE-2023-4911 - Glibc ld.so 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，本地权限提升至root

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 需要本地用户权限，目标系统glibc版本符合漏洞影响范围，并且存在SUID程序。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2023-4911 漏洞是glibc动态链接器ld.so在处理GLIBC_TUNABLES环境变量时发生的缓冲区溢出。攻击者可以利用特制的GLIBC_TUNABLES环境变量，在启动具有SUID权限的二进制文件时执行代码，从而提升权限。 

**有效性评估：**
根据漏洞信息和搜索结果，这是一个已知的、严重性高的本地权限提升漏洞。多个来源（包括Qualys、Red Hat、NVD）都确认了该漏洞的存在和影响。漏洞利用代码的描述与漏洞原理一致，通过构造特定的环境变量`GLIBC_TUNABLES`来触发缓冲区溢出。

**利用方式分析：**
1.  **漏洞触发：**  通过设置`GLIBC_TUNABLES`环境变量为一个超长字符串，导致在`ld.so`加载器处理该环境变量时发生缓冲区溢出。
2.  **权限提升：**  利用SUID程序，当SUID程序启动时，`ld.so`会加载并处理环境变量。如果`GLIBC_TUNABLES`环境变量被恶意构造，溢出发生时可以覆盖内存中的某些关键区域，例如函数指针或返回地址，从而劫持程序的执行流程，最终执行攻击者控制的代码，获取root权限。
3.  **POC代码分析：**
    *   **步骤1：** 验证目标机器是否存在漏洞，如果出现`Segmentation fault (core dumped)`，则存在漏洞。
    *   **步骤2：** `libc.py`的作用是从目标机器的glibc中提取`__libc_start_main`函数的地址，并将shellcode注入到该位置生成攻击用的`libc.so.6`，这个生成的`libc.so.6`会被exp.c调用。
    *   **步骤3：** `exp.c`程序设置环境变量`GLIBC_TUNABLES`，构造payload，替换`l_info[DT_RPATH]`，通过`execve`函数执行`/usr/bin/su --help`来触发漏洞。 程序尝试通过 fork 循环执行 `execve`，提高了利用成功的概率。

**投毒风险评估：**
代码主要目的是利用该漏洞进行权限提升。分析发现存在轻微的投毒风险，代码中替换`libc.so.6`的行为可能被利用植入恶意代码，但是概率较低。`libc.py`从目标系统提取`__libc_start_main`地址，生成攻击用的`libc.so.6`，也降低了恶意替换的可能性。`exp.c`的修改主要集中在利用漏洞的层面，没有发现明显的恶意代码注入。

**结论：**
该漏洞利用的有效性较高，风险等级为高危。通过利用精心构造的`GLIBC_TUNABLES`环境变量，攻击者可以实现本地权限提升。该漏洞利用代码存在较低的投毒风险。

**项目地址:** [teraGL/looneyCVE](https://github.com/teraGL/looneyCVE)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #18

**来源**: [CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md](../2023/CVE-2023-4911-xiaoQ1z_CVE-2023-4911.md)

## CVE-2023-4911: Glibc ld.so 本地提权漏洞

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可导致本地权限提升

**影响版本:** 2.34 <= glibc < 2.39

**利用条件:** 本地用户，目标系统使用存在漏洞的glibc版本，程序具有SUID权限

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2023-4911 漏洞是 glibc 动态链接器 ld.so 在处理 GLIBC_TUNABLES 环境变量时发生的缓冲区溢出漏洞。该漏洞允许本地攻击者在启动具有 SUID 权限的二进制文件时，利用恶意构造的 GLIBC_TUNABLES 环境变量来执行具有提升权限的代码。

**有效性：**

根据漏洞库信息、搜索引擎结果和提供的漏洞利用代码，可以判断该POC代码是有效的。 搜索引擎结果中多个链接（如Qualys的博客、Uptycs的博客）都确认了漏洞的存在和利用的可能性。POC代码也实现了利用 GLIBC_TUNABLES 环境变量进行缓冲区溢出的功能。

**投毒风险：**

分析POC代码，发现主要由Dockerfile，README.md，exp.c，gen_libc.py 四个文件组成。
*   Dockerfile：用于构建包含漏洞利用代码的Docker镜像。
*   README.md：提供漏洞利用的说明和参考链接。
*   exp.c：漏洞利用的C代码，核心部分。该代码通过设置大量的环境变量，特别是 GLIBC_TUNABLES，来触发缓冲区溢出。
*   gen_libc.py：一个python脚本，用于生成包含漏洞的glibc文件。

代码中没有发现明显的恶意代码或后门。`gen_libc.py` 用于生成特定的 libc.so.6 文件，这是漏洞利用的一部分，并非恶意投毒。`exp.c` 尝试利用 `GLIBC_TUNABLES` 环境变量来溢出，从而提权。虽然利用本身具有破坏性，但这属于漏洞利用的正常行为，而不是投毒。

因此，判断此仓库中不存在作者隐藏的投毒代码的可能性为99%。

**利用方式：**

1.  **漏洞原理：** `ld.so` 在加载程序时会解析 `GLIBC_TUNABLES` 环境变量，由于对该环境变量的长度验证不足，导致缓冲区溢出。
2.  **利用过程：**
    *   设置 `GLIBC_TUNABLES` 环境变量为超长字符串，覆盖 `ld.so` 的内存。
    *   `exp.c` 代码通过设置大量的环境变量，特别构造 `GLIBC_TUNABLES`，利用环境变量来覆盖 `l_info[DT_RPATH]`，使其指向攻击者控制的内存区域。
    *   通过 `execve` 执行具有 SUID 权限的程序（如 `/usr/bin/su`），触发动态链接过程。
    *   `ld.so` 在解析被污染的 `l_info[DT_RPATH]` 时，执行攻击者控制的内存区域的代码，从而实现提权。
3.  **先决条件：**
    *   目标系统使用存在漏洞的 glibc 版本。
    *   存在具有 SUID 权限的程序。
    *   攻击者需要具有本地用户权限。

总而言之，CVE-2023-4911 是一个严重的安全漏洞，攻击者可以利用它来提升权限并完全控制受影响的系统。应尽快应用相应的补丁程序。

**项目地址:** [xiaoQ1z/CVE-2023-4911](https://github.com/xiaoQ1z/CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

## POC #19

**来源**: [CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md](../2023/CVE-2023-4911-yanfernandess_Looney-Tunables-CVE-2023-4911.md)

## CVE-2023-4911 Looney Tunables 本地权限提升

**漏洞编号:** CVE-2023-4911

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc (ld.so)

**危害等级:** 高危，本地权限提升至root

**影响版本:** glibc 2.34 至 glibc 2.39（不含）

**利用条件:** 需要本地用户权限，目标系统glibc版本在受影响范围内，程序需要SUID权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2023-4911 漏洞（Looney Tunables）是 GNU C 库 (glibc) 动态链接器 ld.so 中发现的缓冲区溢出漏洞。该漏洞出现在处理 GLIBC_TUNABLES 环境变量时。攻击者可以利用此漏洞，通过构造恶意的 GLIBC_TUNABLES 环境变量，在使用 SUID 权限启动二进制文件时，执行具有提升权限的代码。

**有效性：**
提供的 PoC 代码利用了该漏洞。`exp.c` 文件包含利用此漏洞的exp代码。`gen_libc.py` 生成一个恶意的 `libc.so.6` 文件，该文件被利用来劫持程序执行流程。

**投毒风险：**
代码仓库中存在轻微的投毒风险。虽然核心的漏洞利用代码看起来是合法的，但`gen_libc.py` 的功能是生成自定义的libc.so.6，如果该脚本中包含恶意代码，则可能导致生成的libc.so.6包含后门或恶意功能。尽管如此，主要的利用流程依赖于缓冲区溢出，所以投毒风险相对较低，约为 10%。

**利用方式：**
1.  **生成恶意 libc.so.6：** 使用 `gen_libc.py` 脚本生成一个特制的 `libc.so.6` 文件。这个文件应该包含一些用于利用漏洞的payload。
2.  **编译漏洞利用程序：** 使用 `gcc` 编译 `exp.c` 文件。这个程序将设置必要的环境变量并执行 SUID 程序。
3.  **设置环境变量：** 漏洞利用程序设置 `GLIBC_TUNABLES` 环境变量，并设置大量的环境变量填充内存，以及使用特制的 `dt_rpath` 变量。
4.  **执行 SUID 程序：** 漏洞利用程序使用 `execve` 函数执行一个具有 SUID 权限的程序，如 `/usr/bin/su`。由于设置了恶意的 `GLIBC_TUNABLES` 环境变量，`ld.so` 加载器在处理这个环境变量时会触发缓冲区溢出。
5.  **权限提升：** 缓冲区溢出允许攻击者覆盖内存中的重要区域，进而劫持程序的控制流。通过覆盖返回地址或其他关键数据，攻击者可以执行任意代码，通常是提权的代码，最终获得 root 权限。

**项目地址:** [yanfernandess/Looney-Tunables-CVE-2023-4911](https://github.com/yanfernandess/Looney-Tunables-CVE-2023-4911)

**漏洞详情:** [CVE-2023-4911](https://nvd.nist.gov/vuln/detail/CVE-2023-4911)

---

