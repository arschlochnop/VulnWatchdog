## CVE-2023-4863 - Google Chrome / libwebp 堆缓冲区溢出

**漏洞编号:** CVE-2023-4863

**漏洞类型:** 堆缓冲区溢出

**影响应用:** Google Chrome / libwebp

**危害等级:** 高危

**CVSS评分:** 8.8

**影响版本:** libwebp < 1.3.2, Google Chrome < 116.0.5845.187 (Mac/Linux), < 116.0.5845.188 (Windows)

**利用条件:** 诱导用户访问恶意构造的WebP图像文件，属于客户端利用

**POC 可用性:** 7/10

**POC 类型:** 概念验证

**攻击复杂度:** 中

**投毒风险:** 15%

## 详情

【POC有效性分析】该POC代码是一个基于libFuzzer的C++ Harness程序。它通过调用libwebp库中的关键函数VP8LBuildHuffmanTable来模拟处理WebP图像时的霍夫曼表构建过程。从提供的ASAN（AddressSanitizer）日志来看，该代码能够成功触发heap-buffer-overflow（堆缓冲区溢出）。错误发生在huffman_utils.c文件的ReplicateValue函数中，由于Huffman码表的分配大小不足以容纳恶意构造的编码长度序列，导致在执行memcpy或直接赋值时越界写入。POC清晰地展示了漏洞触发的根本原因，即在处理特定root_bits和code_lengths组合时，程序未能正确校验缓冲区边界。虽然该POC不是一个完整的RCE（远程代码执行）Exploit，但它作为一个Crash触发器是非常有效的，能够帮助研究人员验证受影响库文件的脆弱性，并协助开发相应的补丁。代码逻辑使用了标准的libFuzzer接口，包含必要的头文件引用，且崩溃点与公开的安全公告高度吻合。 【利用步骤】1. 环境准备：需要安装支持ASAN的clang/LLVM环境以及被测试的旧版本libwebp源码。2. 编译POC：使用clang++将libweb-crash.cc与libwebp库链接，并开启-fsanitize=fuzzer,address标志。3. 运行测试：执行编译生成的二进制文件，无需输入语料库，libFuzzer会自动生成随机数据。4. 漏洞触发：当Fuzzer生成的测试向量满足特定溢出条件（如POC中data数组构造的root_bits为1-8且code_lengths非法），ASAN将捕获异常并输出详细的调用堆栈，证明溢出发生。 【投毒风险分析】该POC目前的投毒风险评级为低（约15%）。通过对提供的代码片段进行静态审计，未发现混淆代码、非法外部请求或对系统敏感路径的读写操作。代码主要使用了stdint.h、stdlib.h等标准库以及libwebp的内部函数，符合安全研究工具的典型特征。唯一的潜在风险点在于此类安全研究相关的开源项目往往会吸引大量关注，攻击者可能通过Fork项目并在README中指引用户下载伪装成'漏洞修复包'或'依赖库'的恶意二进制文件。由于本POC是源码形式，且结构简单透明，不具备主动投毒能力。但防御者在从GitHub等平台获取此类POC时，仍应警惕其Makefile或编译脚本中是否包含隐藏的curl/wget指令，防止在编译过程中引入恶意组件。该代码本身专注于漏洞复现，没有发现试图绕过安全策略或建立持久化的行为。

**项目地址:** [https://github.com/webmproject/libwebp](https://github.com/webmproject/libwebp)

**漏洞详情:** [https://nvd.nist.gov/vuln/detail/CVE-2023-4863](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
