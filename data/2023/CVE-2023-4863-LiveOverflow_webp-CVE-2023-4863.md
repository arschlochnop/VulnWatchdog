## CVE-2023-4863 - libwebp (广泛应用于 Google Chrome, Android, 以及各种图像处理库) 堆缓冲区溢出 (Heap Buffer Overflow)

**漏洞编号:** CVE-2023-4863

**漏洞类型:** 堆缓冲区溢出 (Heap Buffer Overflow)

**影响应用:** libwebp (广泛应用于 Google Chrome, Android, 以及各种图像处理库)

**危害等级:** 高危

**CVSS评分:** 8.8

**影响版本:** libwebp < 1.3.2, Google Chrome < 116.0.5845.187 (Mac/Linux), < 116.0.5845.187/.188 (Windows)

**利用条件:** 用户打开恶意构造的 WebP 图像文件，无需特殊权限。

**POC 可用性:** 8/10

**POC 类型:** 概念验证

**攻击复杂度:** 低

**投毒风险:** 15%

## 详情

POC有效性分析：该漏洞源于 libwebp 库中 Huffman 解码逻辑的错误。在处理 lossless WebP 图像时，`ReadHuffmanCodes` 函数在分配内存时未正确计算所需大小，导致在构建霍夫曼表时发生越界写入。提供的 POC 代码 `count_to_size.c` 展示了如何根据霍夫曼编码的长度分布计算表大小，并演示了 `ReplicateValue` 函数在填充表项时的逻辑。通过构造特定的编码长度序列（如 0,0,...,33,3），可以触发非预期的内存布局计算。结合 Docker 容器化的 `webp_asan.sh` 环境，研究员可以利用 AddressSanitizer (ASAN) 捕获越界写入行为。该 POC 并非一键式 RCE 工具，而是侧重于漏洞原理的复现与触发机制的验证，对于理解堆溢出点非常有效。利用步骤：1. 准备 Ubuntu 基础镜像环境；2. 编译 `count_to_size.c` 工具以模拟内存分配计算；3. 运行包含恶意 WebP 数据的 libwebp 示例程序（如 dwebp）；4. 使用 ASAN 观察程序崩溃位置。投毒风险分析：该项目主要包含 C 源代码、Shell 脚本和 README 文档。代码逻辑清晰，主要使用了标准 C 库（stdint, stdio, assert 等），未发现混淆代码或可疑的远程下载指令。Docker 命令中使用了 `--cap-add=SYS_PTRACE` 和 `--security-opt seccomp=unconfined`，这是为了让 ASAN 和调试工具（如 GDB）能正常工作，属于安全研究的常规配置，而非恶意提权尝试。项目中引用的 YouTube 链接指向知名的安全教学频道，增强了可信度。整体来看，该项目投毒风险较低，代码行为符合防御性安全研究的规范。但由于其涉及内存敏感操作，建议在隔离的沙箱或虚拟机环境中运行，以防止潜在的本地系统不稳定。

**项目地址:** [https://github.com/mistymntncop/CVE-2023-4863](https://github.com/mistymntncop/CVE-2023-4863) (推测自文件路径结构)

**漏洞详情:** [https://nvd.nist.gov/vuln/detail/CVE-2023-4863](https://nvd.nist.gov/vuln/detail/CVE-2023-4863)
