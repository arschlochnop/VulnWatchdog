## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)