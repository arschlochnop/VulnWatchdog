## CVE-2022-0847 Dirty Pipe 本地提权漏洞

**漏洞编号:** CVE-2022-0847

**漏洞类型:** 本地提权

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致本地用户提升权限至 root

**影响版本:** Linux Kernel 5.17 rc6 (以及其他受影响版本，参考漏洞库信息)

**利用条件:** 需要本地用户权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2022-0847 "Dirty Pipe" 漏洞是一个 Linux 内核中的本地权限提升漏洞。该漏洞允许非特权用户覆盖只读文件中的内容，从而可能提升权限。 

**有效性:**
提供的 POC 代码是有效的，因为它利用了 Dirty Pipe 漏洞的核心机制。

**投毒风险分析:**
虽然 POC 代码主要演示了如何利用该漏洞，但存在一定的投毒风险。
1.  **Shellcode 的灵活性:** exploit.c 接收 base64 编码的 shellcode 作为参数，这意味着攻击者可以注入任意 shellcode。虽然示例中可能提供的是简单的提权 shellcode，但攻击者可以替换为恶意代码，例如安装后门、窃取数据或进行其他恶意活动。 这个恶意shellcode的检测需要进一步分析，当前认定为存在一定的投毒风险。
2.  **runC 容器逃逸:** 该代码专门设计用于利用 Dirty Pipe 漏洞来实现容器逃逸。如果攻击者能够修改容器内的 runC 二进制文件，他们就可以在容器启动时执行恶意代码，从而突破容器的隔离。

**因此，虽然该 POC 的主要目的是演示漏洞利用，但它也为恶意攻击者提供了一个方便的工具，可以用来注入恶意 shellcode 并执行各种恶意操作。**

根据代码分析，`exploit.c`  主要通过以下步骤利用漏洞:

1.  **查找 ELF 入口点:** `readELfEntry` 函数读取目标文件的 ELF 头，找到入口点地址。
2.  **准备 Pipe:**  `prepare_pipe` 函数创建一个管道，并将其填充和清空，以便后续的 `splice` 操作能够利用 Dirty Pipe 的特性。
3.  **利用 Splice 写入:** `hax` 函数打开目标文件（以只读方式），然后使用 `splice` 系统调用将目标文件的一个字节写入管道。关键在于，这个操作会修改内核的 page cache，而不会真正修改磁盘上的文件。
4.  **通过 Pipe 覆写:** 紧接着，`hax` 函数使用 `write` 系统调用向管道写入用户提供的 shellcode。由于 Dirty Pipe 漏洞，这个 `write` 操作实际上会覆盖 page cache 中的内容，从而修改了目标文件在内存中的映像。
5.  **base64 解码:** base64_decode对输入的shellcode进行解码,增加代码可读性.
6.  **容器逃逸:** 如果目标文件是 runC 的二进制文件，那么当 runC 启动容器时，它会执行被篡改的二进制文件，从而导致容器逃逸。

**利用方式:**
利用 Dirty Pipe 漏洞进行攻击的典型步骤如下:

1.  **获取本地权限:** 攻击者首先需要获得对目标系统的本地访问权限。
2.  **上传/编译 Exploit:** 将编译后的 exploit 上传到目标系统，或者直接在目标系统上编译。
3.  **准备 Shellcode:** 准备好要注入的 shellcode，并对其进行 base64 编码。
4.  **执行 Exploit:** 运行 exploit，指定要覆盖的目标文件和 base64 编码的 shellcode。
5.  **触发恶意代码:** 触发被修改的文件（例如，通过重启服务或重新启动容器）以执行注入的 shellcode。

总的来说，此漏洞允许本地攻击者修改只读文件，从而实现提权或执行恶意代码，在容器环境中可能导致容器逃逸。

**项目地址:** [JlSakuya/CVE-2022-0847-container-escape](https://github.com/JlSakuya/CVE-2022-0847-container-escape)

**漏洞详情:** [CVE-2022-0847](https://nvd.nist.gov/vuln/detail/CVE-2022-0847)