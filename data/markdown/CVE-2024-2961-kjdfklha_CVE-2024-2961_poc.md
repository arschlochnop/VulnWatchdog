## CVE-2024-2961-glibc-iconv缓冲区溢出

**漏洞编号:** CVE-2024-2961

**漏洞类型:** 缓冲区溢出

**影响应用:** glibc

**危害等级:** 高危，可能导致程序崩溃、任意代码执行或信息泄露

**影响版本:** < 2.40

**利用条件:** 需要目标系统使用存在漏洞的glibc版本，并调用iconv()函数进行ISO-2022-CN-EXT字符集转换。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2024-2961 存在于 glibc 的 iconv() 函数中。当将字符串转换为 ISO-2022-CN-EXT 字符集时，该函数可能导致输出缓冲区溢出，最多溢出 4 个字节。攻击者可以利用此漏洞通过特制的字符序列触发越界写入，从而导致应用程序崩溃，覆盖相邻变量或执行任意代码。

**有效性评估：**
根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞利用 **有效**。漏洞库信息明确指出 iconv() 函数存在缓冲区溢出，搜索引擎结果也佐证了漏洞的存在，并提及了远程代码执行的可能性。提供的 Python 脚本 (exp.py) 尝试利用该漏洞，通过构造特定的输入，触发堆溢出，并最终尝试执行任意代码。Ambionics 的博客文章 (由搜索结果中的网页 4 指出) 提供了更详细的漏洞分析和利用方法，进一步确认了漏洞的可利用性。

**投毒风险评估：**
对提供的 exp.py 脚本进行分析：

*   **依赖库：** 脚本依赖 `pwn`, `requests` (通过`ten` 模块，该模块可能封装了`requests`) 和 `zlib` 等库。这些库本身可能存在安全风险，但属于常用库，风险较低。
*   **功能：** 脚本的主要功能是从远程服务器下载文件，读取内存映射，计算堆地址，然后构造特定的输入数据，触发漏洞。脚本包含很多与堆操作相关的代码,例如计算地址和chunk size。整体代码复杂，难以完全确定是否存在后门。
*   **可疑点：** 脚本使用了 `ten` 这个模块，这有可能是一个定制的模块，其中可能存在未知的恶意代码。脚本中包含了多个压缩和分块的操作，用于构造特定的攻击载荷，这些操作增加了代码的复杂性，也增加了隐藏恶意代码的可能性。
    `ADDR_EFREE = LIBC.symbols["__libc_system"]`这行代码使用了 system 函数，如果能控制传递给 system 函数的参数，就可以执行任意命令。在exp.py的剩余部分代码中，代码是不完整的，难以确认最终传递给system函数的参数。 

综合评估，该 POC 存在一定的投毒风险，大约为 **10%**。风险主要来自于 `ten` 模块的未知风险和利用 `system` 函数执行命令的可能性。

**利用方式分析：**

1.  **漏洞触发：** 漏洞利用首先需要触发 `iconv()` 函数，并将易受攻击的字符集作为目标。
2.  **内存布局：** 攻击者需要确定目标系统上的内存布局，特别是堆地址和 libc 地址。利用代码通过读取 `/proc/self/maps` 来获取内存区域信息，然后计算堆和 libc 的基地址。
3.  **堆溢出：** 攻击者通过构造特定的输入，利用缓冲区溢出覆盖堆上的元数据。提供的代码使用了 `chunked_chunk` 和 `compressed_bucket` 函数来创建包含特定大小和内容的 chunked data，这些chunked data会触发堆溢出。
4.  **任意代码执行：** 成功触发堆溢出后，攻击者可以覆盖关键内存区域，例如函数指针或 GOT 表项，以便在程序执行过程中劫持控制流。利用代码试图覆盖 `__libc_system` 函数，以便执行任意命令。具体而言，攻击者会覆盖free list bin指针指向伪造的chunk，然后通过malloc操作来操纵内存，从而达到任意写的效果，最终劫持控制流，执行任意代码（调用 `system` 函数）。

**项目地址:** [kjdfklha/CVE-2024-2961_poc](https://github.com/kjdfklha/CVE-2024-2961_poc)

**漏洞详情:** [CVE-2024-2961](https://nvd.nist.gov/vuln/detail/CVE-2024-2961)