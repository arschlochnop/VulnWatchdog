## CVE-2024-2887-Chrome-WebAssembly类型混淆

**漏洞编号:** CVE-2024-2887

**漏洞类型:** 类型混淆

**影响应用:** Google Chrome

**危害等级:** 高危，可导致远程代码执行

**影响版本:** < 123.0.6312.86

**利用条件:** 需要用户打开恶意的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2024-2887是Google Chrome浏览器WebAssembly模块中的一个类型混淆漏洞。攻击者可以通过构造恶意的HTML页面触发该漏洞，从而实现远程代码执行。

**有效性：**
根据漏洞信息和搜索结果，此漏洞已在Pwn2Own比赛中被成功利用，并提供了POC代码，因此POC代码的有效性较高。

**投毒风险：**
查看提供的POC代码，发现其主要功能是利用类型混淆漏洞，创建`addrof` 和 `fakeobj` 原语，用于获取对象的地址和伪造对象，从而实现进一步的攻击。虽然代码中包含了一些用于GC的辅助函数，但总体上，该POC的目的是演示漏洞利用，而不是隐藏恶意代码。

主要风险点在于：
*   `worker.js` 中申请大量内存，可能导致目标系统资源耗尽，属于一种拒绝服务攻击的变种。
*   `worker.js` 中存在一些与JIT优化相关的操作，这部分代码相对复杂，理论上存在被利用进行恶意行为的可能性，但是概率较低。

综上，我个人认为该POC存在一定的投毒风险，主要在于资源耗尽方面，以及存在潜在的利用JIT优化的可能性。我给出的投毒风险评分为10%，这个评判结果是基于我对漏洞利用代码的分析，并且综合考虑了其主要功能是演示漏洞利用。

**利用方式：**
1.  **触发类型混淆：** POC代码使用`WasmModuleBuilder`创建Wasm模块。`overflow`函数被用来添加大量类型，超过`kV8MaxWasmTypes`，导致类型索引溢出，使得两种类型被错误地认为是相同的。
2.  **构建原语：**
    *   **addrof：** 创建一个包含引用对象的数组，然后通过float64数组读取，实现获取对象地址的功能。
    *   **fakeobj：** 创建一个float64数组，然后将其读取为对象，实现伪造对象的功能。
3.  **利用原语：**
    *   根据 `README.md` 描述，沙箱绕过可以参考 V8-Sandbox-Escape-via-Regexp 项目。
    *   最终利用ORW（Overwrite Return Address）链，通过标准错误输出（stderr）写入flag，实现提权或者信息泄露。

总的来说，这个漏洞利用的流程是：先利用类型混淆漏洞构建内存读写原语，然后利用这些原语进行沙箱逃逸，最后执行任意代码。

**项目地址:** [rycbar77/CVE-2024-2887](https://github.com/rycbar77/CVE-2024-2887)

**漏洞详情:** [CVE-2024-2887](https://nvd.nist.gov/vuln/detail/CVE-2024-2887)