## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)