## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)