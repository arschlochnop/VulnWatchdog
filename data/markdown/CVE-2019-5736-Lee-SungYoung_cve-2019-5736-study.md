## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)