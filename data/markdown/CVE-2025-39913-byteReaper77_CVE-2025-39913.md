## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)