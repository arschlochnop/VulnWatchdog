## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)