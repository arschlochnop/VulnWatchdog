## CVE-2019-2215 Android Binder Use-After-Free

**漏洞编号:** CVE-2019-2215

**漏洞类型:** Use-After-Free

**影响应用:** Android Kernel

**危害等级:** 高危，可导致权限提升至内核级别

**影响版本:** Kernel

**利用条件:** 需要安装恶意本地应用或利用网络应用中的其他漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-2215 是 Android 内核 binder.c 中的一个use-after-free漏洞，允许应用程序将权限提升到 Linux 内核。根据漏洞信息和搜索结果，该漏洞无需用户交互即可利用，但需要安装恶意本地应用程序或利用面向网络应用程序中的单独漏洞。该漏洞的PoC代码利用UAF漏洞触发AAR（Arbitrary Address Read）原语来泄漏内核地址，然后使用AAW（Arbitrary Address Write）原语来覆盖`addr_limit`，从而实现内核读写原语，进而修改`cred_struct`以进行本地权限提升(LPE)。

**利用方式：**

1.  **创建漏洞利用环境：** 需要一个可以执行代码的Android环境，通常是通过安装恶意应用或者利用现有的应用漏洞。
2.  **打开/dev/binder：** 通过`open("/dev/binder", O_RDONLY)`打开binder设备。
3.  **创建epoll实例：** 使用`epoll_create`创建epoll实例。
4.  **mmap地址：** 使用`mmap`映射内存地址。
5.  **创建pipe：** 使用`pipe()`创建管道，用于进程间通信。
6.  **设置pipe大小：** 使用`fcntl`设置管道大小。
7.  **设置iovec：** 设置`iovec`结构体数组，其中包含要读写的内存地址和长度。
8.  **将binder_thread链接到epoll事件等待队列：** 使用`epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &event)`将binder_thread链接到epoll事件的等待队列。
9.  **fork进程：** 创建子进程。
10. **父进程ioctl释放binder_thread：** 通过`ioctl(fd, BINDER_THREAD_EXIT, NULL)`释放binder_thread，在kmalloc-512中创建一个洞。
11. **父进程writev重新分配binder_thread：** 使用`writev`利用iovec结构体数组填充kmalloc-512中的洞，并阻塞等待子进程。
12. **子进程epoll_ctl删除fd：** 子进程使用`epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &event)`触发unlink操作。
13. **子进程read解阻塞父进程writev：** 子进程从管道读取数据解阻塞父进程。
14. **AAR和AAW：** 通过精心构造的iovec利用UAF漏洞实现任意地址读写。
15. **提权：** 通过修改`cred_struct`实现本地提权。

**有效性：**

该PoC代码看起来有效，因为它实现了利用该漏洞所需的步骤。该代码基于已知的利用技术，并参考了Project Zero的分析报告。

**投毒风险：**

检查提供的 PoC 代码 `exploit.c` 和 `README.md`，没有发现明显的恶意代码或隐藏功能。代码结构清晰，注释合理，主要目的是利用 CVE-2019-2215 漏洞进行提权。代码中使用的系统调用和技术都是为了实现漏洞利用，没有发现与恶意行为相关的操作。因此，投毒风险较低，几乎可以忽略不计。

**总结：**

该漏洞是一个高危的Use-After-Free漏洞，攻击者可以利用该漏洞将权限提升到内核级别。PoC代码实现了利用该漏洞所需的步骤，并且看起来有效。在提供的代码中，没有发现投毒风险。

**项目地址:** [mutur4/CVE-2019-2215](https://github.com/mutur4/CVE-2019-2215)

**漏洞详情:** [CVE-2019-2215](https://nvd.nist.gov/vuln/detail/CVE-2019-2215)