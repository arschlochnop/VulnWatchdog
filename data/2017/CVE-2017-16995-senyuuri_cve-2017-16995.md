# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

# CVE-2017-16995

> 📦 该CVE有 **13** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-16995-Al1ex_CVE-2017-16995.md](../2017/CVE-2017-16995-Al1ex_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许低权限用户获得root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户访问，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux内核的BPF验证器模块中。`check_alu_op` 函数在 `kernel/bpf/verifier.c` 中存在不正确的符号扩展，允许本地用户通过构造恶意的BPF程序，使eBPF验证器模块产生计算错误，导致任意内存读写问题，从而实现本地权限提升。

**有效性:**
根据漏洞库信息、搜索引擎结果(如Exploit-DB链接)和提供的POC代码，此漏洞利用是有效的。 POC 代码 `exploit.c` 旨在通过利用 eBPF 验证器中的缺陷来提升权限。 `README.md` 中包含 Ubuntu 16.04 上的漏洞利用演示，以及成功获得 root 权限的输出。

**投毒风险:**
分析提供的 `exploit.c` 代码，没有发现明显的恶意代码或者后门代码，主要功能是利用BPF漏洞进行提权。不过依然存在一定投毒风险，例如：
1.  **依赖特定内核版本/配置：** 该漏洞利用程序可能依赖于特定版本的内核以及编译配置。如果目标环境不满足这些条件，利用程序可能会失败，甚至导致系统崩溃，攻击者可以伪造成功率很高。
2.  **修改关键系统文件：** 提权过程中，可能会修改 `/etc/passwd`、`/etc/shadow` 等关键系统文件，如果操作不当，可能导致系统不稳定甚至无法启动。虽然目的是提权，但潜在风险存在。
3.  **隐蔽性不足：** 简单的提权脚本容易被安全软件检测到，攻击者可能会添加一些混淆或者反检测手段，但这些手段本身也可能被安全研究人员识别为恶意行为。
4.  **信息收集：** 漏洞利用程序可能包含信息收集代码，用于收集目标系统的敏感信息，例如内核版本、硬件配置、用户列表等。这些信息可能会被用于后续的攻击。

基于以上分析，判定投毒风险为5%。

**利用方式:**
1.  编译 `exploit.c`：`gcc exploit.c -o exploit`
2.  运行编译后的可执行文件：`./exploit`
3.  如果漏洞利用成功，将会获得一个 root shell。

**缓解措施:**
1.  禁用非特权 BPF：`echo 1 > /proc/sys/kernel/unprivileged_bpf_disabled`
2.  升级内核版本到修复此漏洞的版本。
3.  应用代码补丁。

**项目地址:** [Al1ex/CVE-2017-16995](https://github.com/Al1ex/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #2

**来源**: [CVE-2017-16995-C0dak_CVE-2017-16995.md](../2017/CVE-2017-16995-C0dak_CVE-2017-16995.md)

## CVE-2017-16995 - Linux Kernel eBPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地非特权用户获得 root 权限

**影响版本:** <= 4.4

**利用条件:** 需要目标系统运行受影响的 Linux kernel 版本，并且启用 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux 内核的 eBPF 验证器模块中。`check_alu_op` 函数在验证 eBPF 程序时，由于符号扩展处理不当，可能导致计算错误，使得攻击者可以构造恶意的 BPF 程序，进而实现任意内存读写。

**利用方式：**

1.  **构造恶意 eBPF 程序：** 攻击者编写一个特殊的 eBPF 程序，利用验证器中的符号扩展漏洞，使其能够执行非法操作。
2.  **加载 eBPF 程序：** 攻击者通过 `bpf(2)` 系统调用将恶意的 eBPF 程序加载到内核中。
3.  **触发漏洞：** 当内核执行该 eBPF 程序时，验证器中的漏洞会被触发，导致内存破坏或任意内存读写。
4.  **权限提升：** 利用任意内存读写，攻击者可以修改当前进程的 `cred` 结构体中的 UID、GID 等信息，将其修改为 root 用户的 UID 和 GID，从而获得 root 权限。

**有效性评估：**

提供的 POC 代码（`exploit.c`）针对 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 进行了测试，并成功实现了权限提升。代码通过构造恶意的 BPF 程序，覆盖当前进程的 `cred` 结构，将用户 ID 修改为 0，从而获得 root 权限。根据漏洞库信息和搜索结果，此漏洞利用方式是有效的，并存在多个公开可用的exploit。

**投毒风险分析：**

POC 代码 `exploit.c` 看起来比较直接，主要逻辑是构造 BPF 程序，并利用漏洞修改 `cred` 结构。`README.md` 文件也提供了漏洞描述、演示、修复建议和相关链接。 但是，由于eBPF程序本身较为复杂，且涉及到直接的内存操作，仍然存在一些潜在的投毒风险。

1.  **隐藏的后门代码：** 攻击者可能在 BPF 程序中嵌入一些不易察觉的指令，例如在提权之外，额外修改其他内核数据结构，造成系统不稳定或者为后续攻击留下后门。
2.  **特定环境依赖：** 攻击者可能使 exploit 只能在特定内核版本或配置下运行，如果用户在不兼容的环境下运行 exploit，可能会导致系统崩溃。

总的来说，虽然 POC 代码表面上看起来安全，但考虑到 BPF 程序的复杂性和内核利用的风险，投毒风险仍然存在，比例大约为 10%。 需要对代码进行深入分析才能完全排除风险。

**项目地址:** [C0dak/CVE-2017-16995](https://github.com/C0dak/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #3

**来源**: [CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md](../2017/CVE-2017-16995-Lumindu_CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-.md)

## CVE-2017-16995-Linux Kernel-BPF 整数溢出

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 整数溢出

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内存破坏和权限提升

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于Linux kernel 4.4版本及以前的`kernel/bpf/verifier.c` 文件中的`check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能产生未指定的其他影响。

**有效性：**
根据漏洞信息和搜索结果，此漏洞是真实存在的，并且有多个可用的利用程序(Exploit-DB)。提供的POC代码尝试利用此漏洞进行本地权限提升。代码通过BPF程序实现，通过socket进行触发，并利用内存读写原语修改当前进程的cred结构，从而获取root权限。总体来说，该POC代码的思路与已知的利用方式一致，因此可以判断该POC代码是有效的。

**投毒风险：**
从提供的POC代码来看，代码主要包含以下几个部分：

1.  **BPF 程序定义 (`__prog`)**: 这段代码定义了实际运行在内核中的 BPF 指令。指令序列设计用于触发漏洞并提供内存读写能力。
2.  **BPF 程序加载和 Map 创建 (`bpf_prog_load`, `bpf_create_map`)**: 这些函数用于将 BPF 程序加载到内核并创建 BPF map，map 用于内核和用户空间之间的数据交换。
3.  **内存读写原语 (`__read`, `__write`)**:  这些函数使用 BPF map 和加载的 BPF 程序来读取和写入任意内核内存。
4.  **权限提升 (`pwn`)**: 该函数利用内存读写原语定位并修改当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获取 root 权限。

分析代码逻辑，没有发现明显的恶意后门或隐藏的非预期行为。不过，由于 BPF 本身的复杂性，以及代码中涉及的内核地址硬编码 (如 `PHYS_OFFSET`, `CRED_OFFSET`, `UID_OFFSET`)，可能存在以下潜在风险：

*   **依赖特定内核版本和配置**:  硬编码的地址和偏移量可能只在特定内核版本和配置下有效。如果目标环境不匹配，利用可能失败，甚至导致内核崩溃。
*   **调试和错误处理不足**: 代码中的错误处理比较简单，如果利用过程中出现错误，可能无法提供足够的信息进行调试。
*   **安全风险**:  即使代码本身没有恶意行为，成功利用漏洞仍然会导致系统权限被提升，存在潜在的安全风险。

综合以上分析，该POC代码本身没有明显的投毒代码，但由于 BPF 利用的特殊性，存在一定的环境依赖性和潜在的安全风险。判定投毒风险为5%。

**利用方式：**
利用方式可以概括为以下步骤：

1.  **创建 BPF Map 和加载 BPF 程序**:  使用 `bpf_create_map` 创建一个 BPF map，用于用户空间和内核空间的数据交换。使用 `bpf_prog_load` 将精心构造的 BPF 程序加载到内核。
2.  **建立 Socket 连接**: 创建一个 socketpair，并将加载的 BPF 程序附加到 socket 上。这样，当 socket 收到数据时，BPF 程序就会被触发执行。
3.  **构造内存读写原语**: BPF 程序被设计成可以读取和写入任意内核内存。利用 BPF map 和 socket 通信，在用户空间构造出内存读写原语。
4.  **查找 Task_struct 和 Cred 结构**: 首先通过获得栈指针（SP）和帧指针（FP），然后通过在栈上读取数据，找到当前进程的 `task_struct` 结构。
5.  **修改 Cred 结构**: 利用内存写原语，找到 `task_struct` 中的 `cred` 字段，然后将 `cred` 结构中的 UID、GID 等权限相关的字段修改为 0，从而获取 root 权限。

总的来说，该漏洞利用的复杂性在于构造能够绕过 BPF 验证器的恶意程序，并利用该程序实现任意内核内存的读写，最终修改进程权限。

**项目地址:** [Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-](https://github.com/Lumindu/CVE-2017-16995-Linux-Kernel---BPF-Sign-Extension-Local-Privilege-Escalation-)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #4

**来源**: [CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md](../2017/CVE-2017-16995-ZhiQiAnSecFork_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** Linux Kernel eBPF权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地权限提升

**影响版本:** through 4.4

**利用条件:** 本地用户，开启了BPF_SYSCALL配置

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 4.4版本及更早版本中，是 kernel/bpf/verifier.c 中 check_alu_op 函数的一个整数溢出漏洞，允许本地用户通过利用不正确的符号扩展导致拒绝服务（内存损坏）或可能产生未指明的其他影响。根据提供的POC代码和搜索结果分析：

**有效性：**

POC代码显示漏洞利用成功，可以在多个内核版本上实现本地权限提升，获取root权限。代码中明确说明，此漏洞在加固的Grsecurity内核上无法利用，表明其利用依赖于特定的内核配置和缓解措施的缺失。

**投毒风险：**

虽然提供的代码本身看起来是漏洞利用程序，但仍存在潜在的投毒风险。虽然代码的目的是利用漏洞，但恶意攻击者可能会在代码中添加后门或恶意功能，这些功能在表面上可能不明显，但可能会损害受感染系统的安全性。经过对POC代码的分析，未发现明显的恶意代码。风险评估为5%, 主要是因为：

1.  **代码复杂性：** eBPF和内核利用代码比较复杂，隐藏恶意代码相对容易。
2.  **依赖外部资源：** 某些利用可能依赖于外部脚本或库，这些资源可能被篡改。

**利用方式：**

漏洞利用的核心在于绕过BPF验证器中的符号扩展检查。具体步骤如下：

1.  **创建BPF Map：**  创建一个BPF map以存储数据。
2.  **绕过BPF验证器：**  构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误。
3.  **创建Socket Pair：**  创建socketpair。
4.  **附加BPF后门：**  将BPF程序附加到socket上，作为后门。
5.  **泄漏Sock结构：**  利用漏洞泄漏socket结构的信息。
6.  **获取Cred结构地址：**  根据泄漏的信息计算cred结构的地址。
7.  **覆盖Cred结构：**  覆盖cred结构中的UID和GID，将其设置为0，从而获得root权限。
8.  **启动Shell：**  启动一个具有root权限的shell。

漏洞利用的成功依赖于目标系统存在漏洞，且没有启用相应的安全缓解措施。攻击者需要能够编译和运行BPF程序。

**项目地址:** [ZhiQiAnSecFork/cve-2017-16995](https://github.com/ZhiQiAnSecFork/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #5

**来源**: [CVE-2017-16995-anldori_CVE-2017-16995.md](../2017/CVE-2017-16995-anldori_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升为root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，开启了BPF syscall

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-16995 存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响。

**有效性：**
根据提供的漏洞信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中多个网页都提到了此漏洞，并且在Exploit-DB上有相应的漏洞利用程序(45010)。提供的POC代码显示了成功利用该漏洞提升权限的过程。

**投毒风险：**
在提供的POC代码中，风险很低。代码主要用于创建BPF map, 将一段恶意的BPF程序加载到内核，然后利用这个程序来修改内核数据结构`cred`，以实现权限提升。从代码逻辑来看，目的是利用漏洞，而不是植入后门。其中值得注意的是，代码中检测了是否是真实的grsecurity内核，如果是，则放弃利用，这部分可以理解为作者的一种安全意识。但是不排除在其他地方存在作者隐藏的后门,所以风险给出评估值。

**利用方式：**
1.  **创建BPF map：**  程序首先创建一个BPF map，用于存储数据。
2.  **加载恶意BPF程序：**  然后，它将一段特制的BPF程序加载到内核中。这个BPF程序包含了利用符号扩展漏洞的代码，目的是在验证器中绕过安全检查。
3.  **创建socketpair()：** 程序使用socketpair创建一个双向的socket。
4.  **绑定BPF到socket：** 将BPF程序附加到socket上，使得BPF程序可以访问socket缓冲区（skbuff）。
5.  **信息泄漏：** BPF程序用于泄漏sock结构的信息，特别是`sk_rcvtimeo`的地址。
6.  **查找cred结构：** 利用泄漏的`sk_rcvtimeo`地址，进一步计算出当前进程的`cred`结构体的地址。cred 结构体保存着进程的用户ID、组ID等安全上下文信息。
7.  **修改cred结构：**  最后，程序利用BPF程序修改`cred`结构体中的UID和GID为0，从而将当前进程的权限提升为root。
8.  **执行shell：**  权限提升后，程序会执行一个shell，此时该shell拥有root权限。

**项目地址:** [anldori/CVE-2017-16995](https://github.com/anldori/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #6

**来源**: [CVE-2017-16995-fei9747_CVE-2017-16995.md](../2017/CVE-2017-16995-fei9747_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可以获得root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，并开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核中BPF验证器模块中的一个漏洞，由于`check_alu_op`函数在进行符号扩展时存在错误，导致任意内存读写。本地用户可以利用此漏洞，构造恶意的BPF程序，绕过BPF验证器的检查，从而实现内核内存的任意读写，最终提升到root权限。

**有效性：**
从提供的漏洞信息和利用代码来看，此漏洞利用是有效的。漏洞库信息和搜索引擎结果均表明该漏洞存在且可以被利用。POC代码本身也提供了在Ubuntu 16.04上提权的演示。

**投毒风险：**
提供的代码主要包括一个README.md文件和一个exploit.c文件。README.md文件用于描述漏洞信息、影响版本、利用演示和修复方法，看起来没有包含恶意代码。exploit.c文件是漏洞利用的C代码，主要利用BPF验证器的缺陷实现任意内存读写。对exploit.c代码进行分析，并没有发现明显的恶意代码或后门。该漏洞本身是利用了内核的一个缺陷，如果部署的环境打了缓解补丁，可能会造成利用失败, 考虑到github上公开的poc投毒风险较低，因此评估为10%。

**利用方式：**
1.  **编译PoC代码：** 使用gcc编译提供的exploit.c文件。
2.  **运行PoC代码：** 运行编译后的可执行文件。
3.  **PoC利用原理：**
    *   该PoC利用了eBPF验证器模块中的计算错误漏洞。
    *   通过构造特定的BPF程序，使得eBPF验证器产生错误的计算结果，绕过安全检查。
    *   PoC通过精心构造BPF指令，实现对内核内存的任意读写。
    *   利用任意内存写的能力，修改当前进程的`cred`结构体中的uid、gid等字段，将当前用户提升为root权限。
4.  **权限提升：** 成功利用漏洞后，将会获得一个root shell。

**优先级：**
利用代码>搜索引擎结果>漏洞库信息. 漏洞利用代码是直接用于验证和利用漏洞的，因此其优先级最高。搜索引擎结果提供漏洞的背景信息、影响范围和可能的利用方法，因此其优先级次之。漏洞库信息提供漏洞的基本描述和参考链接，但缺乏实际的利用细节，因此其优先级最低。

**项目地址:** [fei9747/CVE-2017-16995](https://github.com/fei9747/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #7

**来源**: [CVE-2017-16995-gugronnier_CVE-2017-16995.md](../2017/CVE-2017-16995-gugronnier_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel BPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户获取root权限

**影响版本:** through 4.4

**利用条件:** 需要本地用户权限，且开启了 BPF_SYSCALL 功能

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器(verifier.c)中，具体是`check_alu_op`函数中的符号扩展错误。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展漏洞绕过验证器的检查，从而导致内存损坏甚至权限提升。漏洞利用代码 `exploit-poc-pentest.c` 提供了一个利用该漏洞的PoC，该PoC通过加载恶意的BPF程序，覆写当前进程的 `cred` 结构体，从而将当前用户的UID、GID等权限信息修改为root用户的权限，实现权限提升。PoC代码中定义了`CRED_OFFSET`，需要根据不同的kernel版本进行调整。通过搜索结果 `https://www.exploit-db.com/exploits/45010` 以及 `https://github.com/senyuuri/cve-2017-16995` 确认存在可用的exploit。 

**漏洞利用方式：**

1.  构造恶意的BPF程序，该程序包含利用符号扩展错误的指令序列。
2.  通过`bpf_prog_load`系统调用将恶意的BPF程序加载到内核。
3.  创建socket，并使用`setsockopt`将BPF程序附加到socket上。
4.  向socket发送数据触发BPF程序执行，利用该漏洞覆写当前进程的`cred`结构体，修改用户ID为0（root用户）。
5.  执行`getuid()`等函数，确认权限是否提升。
6.  执行`/bin/sh`等命令，获取root shell。

**投毒风险分析：**

代码主要通过BPF机制进行提权，逻辑较为清晰，没有发现明显的恶意代码或后门。`CRED_OFFSET`需要根据目标kernel版本调整，如果偏移量设置不正确，可能导致程序崩溃或产生未知的副作用，但这不是投毒行为。因此，投毒风险较低，但是由于github的特殊性,依旧存在极低的风险, 所以评定投毒风险为1%。

**项目地址:** [gugronnier/CVE-2017-16995](https://github.com/gugronnier/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #8

**来源**: [CVE-2017-16995-ivilpez_cve-2017-16995.c.md](../2017/CVE-2017-16995-ivilpez_cve-2017-16995.c.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，允许本地用户提升权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限, 目标内核版本在受影响范围内并且启用了 BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于Linux内核的BPF验证器中，具体是 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，最终实现本地权限提升。漏洞影响内核版本至4.4。

**有效性评估：**
漏洞库信息、搜索引擎结果和Exploit-DB均表明存在该漏洞，且有公开可用的EXP。搜索结果中GitHub链接 `https://github.com/senyuuri/cve-2017-16995` 指出了有针对此漏洞的源码分析和利用代码。

**投毒风险评估：**
提供的POC代码只有一个编译脚本 `compile.sh`，脚本中包含了编译 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的命令，没有发现明显的恶意代码或者下载其他文件的行为。投毒风险较低，大概在 10%。当然不排除在其他源文件中存在隐藏的后门代码。需要检查 `hello.c`, `doubleput.c` 和 `suidhelper.c` 的源代码才能最终确定是否存在投毒行为。

**利用方式分析：**
根据搜索结果和漏洞描述，该漏洞是由于 BPF 验证器在处理算术运算时，符号扩展存在缺陷，导致可以绕过验证器的安全检查，从而构造恶意的 BPF 程序。攻击者利用此漏洞，可以通过 bpf(2) 系统调用提交恶意的 BPF 程序，实现任意内存读写，最终覆盖敏感数据结构如用户凭据等，从而提升权限。EXP通常会利用这个漏洞来覆盖进程的 `cred` 结构体，将其uid/gid设置为0，达到root权限。

**项目地址:** [ivilpez/cve-2017-16995.c](https://github.com/ivilpez/cve-2017-16995.c)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #9

**来源**: [CVE-2017-16995-littlebin404_CVE-2017-16995.md](../2017/CVE-2017-16995-littlebin404_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致普通用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户，需要开启BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux kernel 的 `kernel/bpf/verifier.c` 文件中的 `check_alu_op` 函数中，允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或可能造成其他未指定的危害。

**有效性:**
根据漏洞库信息、搜索引擎结果和提供的 PoC 代码，可以判断此漏洞是有效的。漏洞库信息明确指出该漏洞的存在，以及受影响的 Linux kernel 版本范围。搜索引擎结果中也包含了该漏洞的详细信息，以及多个漏洞利用的链接（例如 Exploit-DB）。提供的 PoC 代码 `upstream44.c` 是一个 C 语言程序，声称可以在 Ubuntu 16.04 上利用此漏洞来提升权限。该 PoC 代码通过构造恶意的 BPF 程序，利用 eBPF 验证器模块的计算错误，导致任意内存读写，从而获得 root 权限。

**投毒风险:**
分析提供的 PoC 代码 `upstream44.c`，主要功能是利用 BPF 漏洞进行提权。代码本身逻辑较为清晰，主要利用了BPF特性进行内存操作，虽然代码中存在硬编码的偏移地址 (CRED_OFFSET)，这依赖于特定的内核版本，可能会导致在其他版本上利用失败，但这不属于恶意投毒行为。 代码中 `__exit` 函数会直接退出程序，可能会导致一些清理工作没有完成，这是一种不良编程习惯，但也不能算作投毒。代码中利用了`socketpair`和`setsockopt`来加载BPF程序，这本身是利用漏洞的正常行为。
但是，`README.md`文件过于简单，没有详细的说明漏洞原理和利用方法，这可能会让使用者不了解风险。综合判断，投毒风险较低，大约为 10%。

**利用方式:**
1.  编译 PoC 代码：`gcc -o upstream44 upstream44.c`
2.  运行编译后的程序：`./upstream44`

程序会利用 BPF 漏洞修改当前用户的 credentials 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**项目地址:** [littlebin404/CVE-2017-16995](https://github.com/littlebin404/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #10

**来源**: [CVE-2017-16995-ph4ntonn_CVE-2017-16995.md](../2017/CVE-2017-16995-ph4ntonn_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升 (LPE)

**影响应用:** Linux Kernel

**危害等级:** 高危，可从普通用户提升到root权限

**影响版本:** <= 4.4

**利用条件:** 本地用户权限，需要开启 BPF syscall (CONFIG_BPF_SYSCALL)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 的 BPF 验证器 (verifier.c) 中的 `check_alu_op` 函数中。由于不正确的符号扩展，本地用户可以利用此漏洞导致拒绝服务（内存损坏）或可能造成未指定的其他影响，例如权限提升。

**有效性:**
根据漏洞库信息和搜索结果，该漏洞影响 Linux kernel 4.4 及更早版本，并有多个公开可用的exp。
提供的POC代码 `exp.c` 似乎是漏洞利用程序，它使用了 `bpf_prog_load` 和 `bpf_create_map` 等系统调用来加载恶意 BPF 程序并创建 BPF map。该程序旨在通过利用 BPF 验证器中的符号扩展错误来覆盖内核内存，从而实现权限提升。因此，提供的POC代码大概率有效。

**投毒风险:**
分析POC代码：
*   代码本身比较短小，主要功能是加载和运行 BPF 程序。没有明显的恶意行为，如反向shell、持久化等。
*   代码依赖于`__prog`变量，该变量定义了实际的 BPF 指令。攻击的核心逻辑都在这个BPF程序中。需要进一步分析该 BPF 程序。
*  BPF 程序通过 `bpf_update_elem` 和 `bpf_lookup_elem` 和map进行交互。
从代码层面看，没有发现明显的后门。但由于 BPF 指令是二进制形式，难以直接分析其行为。潜在的投毒可能隐藏在 BPF 指令中，例如修改 BPF 指令以执行预期之外的内核操作，或者尝试利用其他内核漏洞，或者通过侧信道泄露信息，因此存在一定的投毒风险。代码编译后，实际运行的指令与源代码指令可能会有出入,作者有可能在编译的二进制文件中动手脚,但由于缺少可执行的二进制程序,所以无法判断。
综合考虑，POC代码的投毒风险较低，估计为10%。

**利用方式:**
1.  **漏洞触发:** 攻击者构造一个恶意的 BPF 程序，其中包含会导致 `check_alu_op` 函数中符号扩展错误的指令。
2.  **内存损坏:** 当 BPF 验证器检查到错误的指令时，会发生内存损坏。这可以允许攻击者覆盖内核内存的特定部分，例如当前用户的凭据结构体。
3.  **权限提升:** 通过覆盖凭据结构体中的 UID、EUID、GID 和 EGID 等字段，攻击者可以将自己的权限提升到 root。
4.  **代码执行流程:** 程序首先创建了一个 BPF map，然后加载了一个 socket 过滤器类型的 BPF 程序。接着， BPF 程序被执行，利用漏洞进行提权。

**项目地址:** [ph4ntonn/CVE-2017-16995](https://github.com/ph4ntonn/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #11

**来源**: [CVE-2017-16995-senyuuri_cve-2017-16995.md](../2017/CVE-2017-16995-senyuuri_cve-2017-16995.md)

## CVE-2017-16995

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可导致本地用户获取root权限

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，目标系统内核版本在4.4及以下且未修复该漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数存在的一个整数符号扩展错误。该漏洞允许本地用户利用不正确的符号扩展导致拒绝服务（内存损坏）或者可能造成未指定的其他影响，最终实现本地权限提升。

**有效性：**

根据漏洞信息和搜索引擎结果，存在多个公开的漏洞利用代码（Exploit-DB上的44298、45010、45058，以及GitHub上的senyuuri/cve-2017-16995）。提供的漏洞利用代码`exploit.c` 针对Ubuntu 16.04.4 kernel，明确指定了目标内核版本 `4.4.0-116-generic`，并通过调整`CRED_OFFSET`来适应不同的内核。

**利用方式：**

该漏洞的利用方式通常涉及以下步骤：

1.  **创建BPF map：** 利用`bpf_create_map`创建BPF map。
2.  **加载BPF程序：** 利用`bpf_prog_load`加载特制的BPF程序。该程序旨在触发`check_alu_op`函数中的整数符号扩展错误。
3.  **socketpair & setsockopt：** 创建socketpair，并通过`setsockopt`将BPF程序附加到socket上，从而触发BPF程序的执行。
4.  **内存篡改：** 漏洞利用的核心是通过BPF程序修改当前进程的`cred`结构，将UID、GID等权限相关的字段设置为0，从而获得root权限。
5.  **writemsg & bpf_update_elem:** 通过socket发送消息，触发BPF程序执行，更新map的值，最终达到提权目的

**投毒风险：**

虽然漏洞利用代码本身是针对CVE-2017-16995的利用，但仍然存在一定的投毒风险。以下是风险分析：

*   **Cred Offset不正确:** 提供的代码中`CRED_OFFSET`的值针对特定的内核版本。如果目标系统的内核版本不同，则`CRED_OFFSET`的值需要调整，否则可能导致提权失败或系统崩溃。攻击者可能会故意提供错误的`CRED_OFFSET`值，导致利用失败，但同时破坏系统稳定性。
*   **依赖特定环境：** 该漏洞利用代码依赖特定的操作系统和内核版本。攻击者可能会提供只在特定环境下才能成功执行的代码，而其他环境下可能会导致不可预测的错误。
*   **后门代码：** 仔细检查代码未发现明显的后门代码，但是要完全排除需要对汇编代码进行逆向分析。

考虑到以上风险，评估投毒风险为10%。主要风险在于Cred Offset不正确, 依赖特定环境，可能会导致提权失败或者系统崩溃，增加利用的复杂度或制造不稳定因素，但从整体代码分析，未发现明显的恶意后门代码。

**项目地址:** [senyuuri/cve-2017-16995](https://github.com/senyuuri/cve-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---



---

## POC #12

**来源**: [CVE-2017-16995-vnik5287_CVE-2017-16995.md](../2017/CVE-2017-16995-vnik5287_CVE-2017-16995.md)

## CVE-2017-16995 Linux Kernel eBPF 权限提升漏洞

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，本地用户可提升权限至 root

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启 BPF_SYSCALL 配置

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995 漏洞存在于 Linux Kernel 4.4 及更早版本中的 `kernel/bpf/verifier.c` 文件的 `check_alu_op` 函数中。该漏洞是由于不正确的符号扩展导致，允许本地用户通过利用这一点造成拒绝服务（内存损坏）或可能产生未指明的其他影响。

**利用方式：**

1.  **漏洞触发：** 攻击者通过编写恶意的 eBPF 程序，程序中的某些指令会触发 `check_alu_op` 函数中的符号扩展错误。
2.  **内存破坏：** 错误的符号扩展会导致在 eBPF 程序的验证过程中出现错误，从而允许程序执行后破坏内核内存。
3.  **权限提升：** 通过精心构造的 eBPF 程序，攻击者可以覆盖当前进程的 `cred` 结构，将其 UID、GID 等设置为 0，从而获得 root 权限。

**POC 代码分析：**

提供的 POC 代码是一个利用 CVE-2017-16995 在 Ubuntu 16.04.4 (kernel 4.4.0-116-generic) 上进行权限提升的示例。

*   它首先创建了一个 BPF map 和 BPF program。程序通过套接字过滤器运行，该程序利用了符号扩展漏洞来破坏内核内存。
*   该程序定义了一些辅助函数，例如 `get_value`, `__get_fp`, `__read` 和 `__write`，用于从 BPF map 获取值，从内核读取以及写入。
*   `prep` 函数用于创建map和加载程序到内核
*   漏洞利用涉及覆盖当前进程的 `cred` 结构，POC 代码中定义了 `CRED_OFFSET` (0x5f8) 和 `UID_OFFSET` (4)，这些值与目标内核版本有关。
*   `socketpair` 创建一对连接的UNIX域套接字
*   `setsockopt` 将编译后的BPF程序附加到第一个套接字

**投毒风险评估：**

代码中存在一定投毒的风险，概率大约为10%。主要基于以下几点：

1.  **内核版本依赖性：** POC 代码中的 `CRED_OFFSET` 和其他偏移量是针对特定内核版本（4.4.0-116-generic）的。如果攻击者修改这些偏移量，使其在其他内核版本上运行时破坏关键的内核数据结构，可能导致系统崩溃或其他不可预测的行为。
2.  **恶意覆盖：** 攻击者可以通过修改 POC 代码，使其覆盖其他敏感的内核数据结构，从而达到更严重的目的，如植入后门或进行其他恶意活动。
3.  **依赖特定环境：**POC依赖ubuntu 16.04.4, 可能会存在编译后门或者只适用特定环境, 如果直接运行可能会发生意外情况

虽然存在一定的投毒风险，但相对较低，因为该漏洞本身的利用方式已经比较复杂，攻击者需要对内核内存布局有深入的了解才能成功利用。直接植入后门代码的难度较大，并且容易被发现。

**结论：**

提供的 POC 代码是有效的，可以利用 CVE-2017-16995 漏洞在特定内核版本上进行权限提升。但同时也存在一定的投毒风险，需要谨慎使用，并进行代码审计和验证，避免直接在生产环境中使用。

**项目地址:** [vnik5287/CVE-2017-16995](https://github.com/vnik5287/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

## POC #13

**来源**: [CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md](../2017/CVE-2017-16995-xxxTectationxxx_CVE-2017-16995.md)

## CVE-2017-16995-Linux Kernel-BPF 权限提升

**漏洞编号:** CVE-2017-16995

**漏洞类型:** 本地权限提升

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致root权限获取

**影响版本:** <= 4.4

**利用条件:** 需要本地用户权限，开启BPF_SYSCALL

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2017-16995是Linux内核BPF验证器中`check_alu_op`函数的一个整数溢出漏洞。该漏洞允许本地用户通过构造恶意的BPF程序，利用符号扩展错误导致内存损坏，从而实现权限提升。

**有效性:**

根据漏洞库信息、搜索引擎结果以及提供的PoC代码，该漏洞存在并且PoC代码可利用。漏洞库信息明确指出漏洞影响Linux Kernel 4.4及以下版本，并提供了多个Exploit-DB的链接，表明存在公开的利用代码。搜索引擎结果也指向了多个关于该漏洞的讨论和分析，确认了其存在和危害。

提供的PoC代码（44298.c）是一个针对Ubuntu 16.04.4的本地权限提升漏洞利用程序。代码通过构造恶意的BPF程序，利用`check_alu_op`函数中的符号扩展错误，覆盖内核内存中的`cred`结构，从而将当前用户的UID、GID等权限信息修改为root用户的权限信息。

**投毒风险:**

PoC代码本身的功能是权限提升，不是恶意后门。但任何PoC代码都存在被修改为恶意代码的风险。检查发现，代码本身较为精简，主要功能集中在利用BPF漏洞覆盖`cred`结构。潜在的投毒风险可能存在于以下几个方面：

1.  **覆盖地址的修改：** 攻击者可能会修改PoC代码中覆盖`cred`结构的地址，指向其他敏感的内核数据结构，导致系统崩溃或其他不可预测的行为。
2.  **恶意代码注入：** 攻击者可能会在PoC代码中注入额外的恶意代码，例如，创建一个后门账户，或者执行任意命令。
3.  **依赖项修改：** 攻击者可能会修改PoC代码的依赖项，例如，修改`#include`的文件，引入包含恶意代码的头文件。

考虑到PoC代码的功能相对明确，代码量较小，因此投毒风险较低，估计为10%。

**利用方式:**

1.  **漏洞触发：**  攻击者首先需要编译并运行提供的PoC代码。PoC代码会创建一个恶意的BPF程序，并通过`setsockopt`系统调用将其附加到socket上。
2.  **内存覆盖：**  当socket接收或发送数据时，恶意的BPF程序会被执行，触发`check_alu_op`函数中的漏洞，导致内核内存中的`cred`结构被覆盖。
3.  **权限提升：**  `cred`结构被覆盖后，当前用户的权限信息被修改为root用户的权限信息，从而实现权限提升。

**总结:**

CVE-2017-16995是一个高危的Linux内核漏洞，PoC代码的有效性较高，可以实现本地权限提升。虽然PoC代码本身不是恶意后门，但存在被修改为恶意代码的风险。利用方式主要是通过构造恶意的BPF程序，覆盖内核内存中的`cred`结构，从而实现权限提升。

**项目地址:** [xxxTectationxxx/CVE-2017-16995](https://github.com/xxxTectationxxx/CVE-2017-16995)

**漏洞详情:** [CVE-2017-16995](https://nvd.nist.gov/vuln/detail/CVE-2017-16995)

---

