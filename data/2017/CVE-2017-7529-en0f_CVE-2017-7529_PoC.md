## CVE-2017-7529 - Nginx 整数溢出 (Integer Overflow)

**漏洞编号:** CVE-2017-7529

**漏洞类型:** 整数溢出 (Integer Overflow)

**影响应用:** Nginx

**危害等级:** 中危 (Medium)

**CVSS评分:** 5.3 (CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N)

**影响版本:** 0.5.6 - 1.13.2

**利用条件:** 远程网络访问，目标服务器需开启缓存功能并存在足够长度的文件。

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 5%

## 详情

【POC有效性分析】该POC针对Nginx标准Range过滤模块中的整数溢出漏洞。代码通过精心构造的'Range'头部字段，利用负偏移量绕过边界检查。核心逻辑在于计算一个超大的偏移量（利用Python的f-string构造-9223372036854776000级别的负数），触发Nginx内部处理逻辑错误，从而使得Nginx返回本应作为缓存元数据存储在内存中的信息，而非文件内容。代码结构清晰，使用了requests.Session来保持会话，并实现了一个hexdump函数用于可视化展示泄露的二进制数据。经分析，该POC逻辑严密，能够自动计算目标Content-Length并调整溢出位点，具备极高的实战有效性。它不只是简单的概念验证，而是可以直接dump出目标服务器缓存文件头部的工具，可能包含敏感的后端响应头或服务器内部路径信息。\n\n【利用步骤】1. 环境准备：确保目标Nginx版本处于0.5.6至1.13.2之间。2. 获取目标文件：通过常规GET请求获取目标文件的Content-Length。3. 构造溢出载荷：根据获取的长度加上特定偏移（如623字节），计算出Range头部的起始位置。4. 发送伪造请求：向目标URL发送带有恶意Range头的HTTP请求。5. 检查响应：若服务器返回206 Partial Content状态码且响应体包含非预期的二进制数据，则证明利用成功。6. 数据解析：通过循环请求不断累积缓冲区数据，并使用hexdump展示泄露的内存内容。\n\n【投毒风险分析】该代码库的投毒风险极低。首先，代码逻辑完全透明，仅使用了标准的Python库如urllib、requests和argparse。虽然尝试导入了colorama和termcolor用于终端着色，但设置了优雅的try-except回退机制，不存在强制执行外部恶意脚本的行为。代码中不包含硬编码的远程回连IP、混淆后的Base64载荷或恶意下载指令。唯一的网络活动是针对用户指定的target URL进行的HTTP GET请求，这是典型的扫描器行为。所有的异常处理（如KeyboardInterrupt）都是为了提升用户体验。由于脚本中涉及的大数值运算是基于CVE原理的必要构造，而非混淆手段，因此可以判定该代码为纯粹的安全研究工具，没有发现后门插入或恶意投毒迹象。建议在使用前在隔离环境测试，以防针对特定环境的副作用。

**项目地址:** [https://github.com/en0f/CVE-2017-7529](https://www.google.com/search?q=https://github.com/en0f/CVE-2017-7529)

**漏洞详情:** [https://nvd.nist.gov/vuln/detail/CVE-2017-7529](https://nvd.nist.gov/vuln/detail/CVE-2017-7529)
