# CVE-2017-5941

> 📦 该CVE有 **4** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md](../2017/CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md)

## CVE-2017-5941-node-serialize远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 需要目标应用使用存在漏洞的node-serialize版本，并且允许控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以构造包含立即调用函数表达式（IIFE）的恶意 JavaScript 对象，通过 `unserialize()` 函数进行反序列化，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息、搜索引擎结果和提供的POC代码，该漏洞利用是有效的。搜索引擎结果中多个链接指向了漏洞的细节分析和利用方法，并包含EXP。

**投毒风险分析：**

分析提供的POC代码，代码主要功能是扫描IP列表（从ip.txt读取），然后针对每个IP构造恶意的cookie（profile）发送HTTP请求。恶意cookie的内容是经过base64编码的，其中包含一个JavaScript IIFE。这个IIFE的作用是执行 `ping` 命令，将当前用户名通过 DNS 查询发送到攻击者的 DNSLog 服务器。

代码本身的功能就是漏洞利用，用于测试目标是否存在漏洞，没有发现隐藏的恶意或非预期的行为。

README.md只是一个链接，指向漏洞分析文章，可以忽略。

**利用方式：**

1.  目标应用使用易受攻击的 `node-serialize` 0.0.4 版本。
2.  应用从请求中读取数据，并使用 `unserialize()` 函数对其进行反序列化。例如，许多案例是从cookie中读取profile变量进行反序列化。
3.  攻击者将包含恶意 JavaScript 对象的序列化字符串（包含 IIFE）作为输入（例如，通过HTTP请求的Cookie）发送给目标应用。
4.  `unserialize()` 函数执行 IIFE，从而在目标服务器上执行任意代码。POC代码中，执行的是ping命令，更严重的情况可以执行任意代码。


**项目地址:** [Frivolous-scholar/CVE-2017-5941-NodeJS-RCE](https://github.com/Frivolous-scholar/CVE-2017-5941-NodeJS-RCE)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #2

**来源**: [CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md](../2017/CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md)

## CVE-2017-5941 - node-serialize 反序列化RCE

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** <= 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize版本，且允许用户可控数据传递到unserialize()函数

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-5941 漏洞存在于 node-serialize 包的 0.0.4 版本及更早版本中。当 `unserialize()` 函数接收到不可信数据时，可以通过构造包含立即执行函数表达式（IIFE）的 JavaScript 对象来执行任意代码。

**有效性评估：**

提供的 PoC 代码利用了 `node-serialize` 包的这个反序列化漏洞，通过构造包含恶意 JavaScript 代码的 JSON 数据，发送到目标服务器的 `/api/deserialize` 接口或通过 `profile` cookie，从而在服务器上执行任意命令。PoC代码包含了生成payload、发送POST请求和设置cookie的完整流程，并提供了 filedrop 和 revshell 两种利用模式，验证了漏洞的有效性。

**投毒风险评估：**

分析 PoC 代码，并未发现明显的投毒代码。PoC 的主要功能是演示漏洞利用，而非进行恶意行为。代码中使用的 `child_process.exec` 函数是为了在目标系统上执行命令，这是漏洞利用的常见手段。不过任何 PoC 都可能被滥用，因此存在潜在的风险。投毒风险评估为5%，主要考虑代码被修改后用于恶意目的。

**利用方式：**

1.  **确定目标：** 找到使用了 `node-serialize <= 0.0.4` 的 Node.js 应用，并且允许用户可控的数据传递到 `unserialize()` 函数。
2.  **构造 Payload：** 使用 PoC 代码或手动构造包含恶意 JavaScript 代码的 JSON payload。恶意代码使用 IIFE (Immediately Invoked Function Expression) 执行 shell 命令。
3.  **选择攻击入口：**  
    *   通过 POST 请求发送 JSON payload 到 `/api/deserialize` 接口 (如果应用将 POST body 的 `data` 字段直接传递给 `unserialize()` 函数)。
    *   将 JSON payload 进行 Base64 编码，然后设置到名为 `profile` 的 cookie 中，访问 `/profile` 页面 (如果应用先对 cookie 进行 Base64 解码，然后传递给 `unserialize()` 函数)。
4.  **执行代码：**  服务器接收到 payload 并调用 `unserialize()` 函数后，恶意的 JavaScript 代码将被执行，导致远程代码执行。
5.  **验证与利用：** 通过写入文件或反弹 shell 等方式验证代码是否成功执行，然后进行更深入的攻击。

**项目地址:** [kylew1004/cve-2017-5941-poc-docker-lab](https://github.com/kylew1004/cve-2017-5941-poc-docker-lab)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #3

**来源**: [CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md](../2017/CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md)

# CVE-2017-5941

> 📦 该CVE有 **4** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md](../2017/CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md)

## CVE-2017-5941-node-serialize远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 需要目标应用使用存在漏洞的node-serialize版本，并且允许控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以构造包含立即调用函数表达式（IIFE）的恶意 JavaScript 对象，通过 `unserialize()` 函数进行反序列化，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息、搜索引擎结果和提供的POC代码，该漏洞利用是有效的。搜索引擎结果中多个链接指向了漏洞的细节分析和利用方法，并包含EXP。

**投毒风险分析：**

分析提供的POC代码，代码主要功能是扫描IP列表（从ip.txt读取），然后针对每个IP构造恶意的cookie（profile）发送HTTP请求。恶意cookie的内容是经过base64编码的，其中包含一个JavaScript IIFE。这个IIFE的作用是执行 `ping` 命令，将当前用户名通过 DNS 查询发送到攻击者的 DNSLog 服务器。

代码本身的功能就是漏洞利用，用于测试目标是否存在漏洞，没有发现隐藏的恶意或非预期的行为。

README.md只是一个链接，指向漏洞分析文章，可以忽略。

**利用方式：**

1.  目标应用使用易受攻击的 `node-serialize` 0.0.4 版本。
2.  应用从请求中读取数据，并使用 `unserialize()` 函数对其进行反序列化。例如，许多案例是从cookie中读取profile变量进行反序列化。
3.  攻击者将包含恶意 JavaScript 对象的序列化字符串（包含 IIFE）作为输入（例如，通过HTTP请求的Cookie）发送给目标应用。
4.  `unserialize()` 函数执行 IIFE，从而在目标服务器上执行任意代码。POC代码中，执行的是ping命令，更严重的情况可以执行任意代码。


**项目地址:** [Frivolous-scholar/CVE-2017-5941-NodeJS-RCE](https://github.com/Frivolous-scholar/CVE-2017-5941-NodeJS-RCE)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #2

**来源**: [CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md](../2017/CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md)

## CVE-2017-5941 - node-serialize 反序列化RCE

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** <= 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize版本，且允许用户可控数据传递到unserialize()函数

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-5941 漏洞存在于 node-serialize 包的 0.0.4 版本及更早版本中。当 `unserialize()` 函数接收到不可信数据时，可以通过构造包含立即执行函数表达式（IIFE）的 JavaScript 对象来执行任意代码。

**有效性评估：**

提供的 PoC 代码利用了 `node-serialize` 包的这个反序列化漏洞，通过构造包含恶意 JavaScript 代码的 JSON 数据，发送到目标服务器的 `/api/deserialize` 接口或通过 `profile` cookie，从而在服务器上执行任意命令。PoC代码包含了生成payload、发送POST请求和设置cookie的完整流程，并提供了 filedrop 和 revshell 两种利用模式，验证了漏洞的有效性。

**投毒风险评估：**

分析 PoC 代码，并未发现明显的投毒代码。PoC 的主要功能是演示漏洞利用，而非进行恶意行为。代码中使用的 `child_process.exec` 函数是为了在目标系统上执行命令，这是漏洞利用的常见手段。不过任何 PoC 都可能被滥用，因此存在潜在的风险。投毒风险评估为5%，主要考虑代码被修改后用于恶意目的。

**利用方式：**

1.  **确定目标：** 找到使用了 `node-serialize <= 0.0.4` 的 Node.js 应用，并且允许用户可控的数据传递到 `unserialize()` 函数。
2.  **构造 Payload：** 使用 PoC 代码或手动构造包含恶意 JavaScript 代码的 JSON payload。恶意代码使用 IIFE (Immediately Invoked Function Expression) 执行 shell 命令。
3.  **选择攻击入口：**  
    *   通过 POST 请求发送 JSON payload 到 `/api/deserialize` 接口 (如果应用将 POST body 的 `data` 字段直接传递给 `unserialize()` 函数)。
    *   将 JSON payload 进行 Base64 编码，然后设置到名为 `profile` 的 cookie 中，访问 `/profile` 页面 (如果应用先对 cookie 进行 Base64 解码，然后传递给 `unserialize()` 函数)。
4.  **执行代码：**  服务器接收到 payload 并调用 `unserialize()` 函数后，恶意的 JavaScript 代码将被执行，导致远程代码执行。
5.  **验证与利用：** 通过写入文件或反弹 shell 等方式验证代码是否成功执行，然后进行更深入的攻击。

**项目地址:** [kylew1004/cve-2017-5941-poc-docker-lab](https://github.com/kylew1004/cve-2017-5941-poc-docker-lab)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #3

**来源**: [CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md](../2017/CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md)

# CVE-2017-5941

> 📦 该CVE有 **4** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md](../2017/CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md)

## CVE-2017-5941-node-serialize远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 需要目标应用使用存在漏洞的node-serialize版本，并且允许控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以构造包含立即调用函数表达式（IIFE）的恶意 JavaScript 对象，通过 `unserialize()` 函数进行反序列化，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息、搜索引擎结果和提供的POC代码，该漏洞利用是有效的。搜索引擎结果中多个链接指向了漏洞的细节分析和利用方法，并包含EXP。

**投毒风险分析：**

分析提供的POC代码，代码主要功能是扫描IP列表（从ip.txt读取），然后针对每个IP构造恶意的cookie（profile）发送HTTP请求。恶意cookie的内容是经过base64编码的，其中包含一个JavaScript IIFE。这个IIFE的作用是执行 `ping` 命令，将当前用户名通过 DNS 查询发送到攻击者的 DNSLog 服务器。

代码本身的功能就是漏洞利用，用于测试目标是否存在漏洞，没有发现隐藏的恶意或非预期的行为。

README.md只是一个链接，指向漏洞分析文章，可以忽略。

**利用方式：**

1.  目标应用使用易受攻击的 `node-serialize` 0.0.4 版本。
2.  应用从请求中读取数据，并使用 `unserialize()` 函数对其进行反序列化。例如，许多案例是从cookie中读取profile变量进行反序列化。
3.  攻击者将包含恶意 JavaScript 对象的序列化字符串（包含 IIFE）作为输入（例如，通过HTTP请求的Cookie）发送给目标应用。
4.  `unserialize()` 函数执行 IIFE，从而在目标服务器上执行任意代码。POC代码中，执行的是ping命令，更严重的情况可以执行任意代码。


**项目地址:** [Frivolous-scholar/CVE-2017-5941-NodeJS-RCE](https://github.com/Frivolous-scholar/CVE-2017-5941-NodeJS-RCE)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #2

**来源**: [CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md](../2017/CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md)

## CVE-2017-5941 - node-serialize 反序列化RCE

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** <= 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize版本，且允许用户可控数据传递到unserialize()函数

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-5941 漏洞存在于 node-serialize 包的 0.0.4 版本及更早版本中。当 `unserialize()` 函数接收到不可信数据时，可以通过构造包含立即执行函数表达式（IIFE）的 JavaScript 对象来执行任意代码。

**有效性评估：**

提供的 PoC 代码利用了 `node-serialize` 包的这个反序列化漏洞，通过构造包含恶意 JavaScript 代码的 JSON 数据，发送到目标服务器的 `/api/deserialize` 接口或通过 `profile` cookie，从而在服务器上执行任意命令。PoC代码包含了生成payload、发送POST请求和设置cookie的完整流程，并提供了 filedrop 和 revshell 两种利用模式，验证了漏洞的有效性。

**投毒风险评估：**

分析 PoC 代码，并未发现明显的投毒代码。PoC 的主要功能是演示漏洞利用，而非进行恶意行为。代码中使用的 `child_process.exec` 函数是为了在目标系统上执行命令，这是漏洞利用的常见手段。不过任何 PoC 都可能被滥用，因此存在潜在的风险。投毒风险评估为5%，主要考虑代码被修改后用于恶意目的。

**利用方式：**

1.  **确定目标：** 找到使用了 `node-serialize <= 0.0.4` 的 Node.js 应用，并且允许用户可控的数据传递到 `unserialize()` 函数。
2.  **构造 Payload：** 使用 PoC 代码或手动构造包含恶意 JavaScript 代码的 JSON payload。恶意代码使用 IIFE (Immediately Invoked Function Expression) 执行 shell 命令。
3.  **选择攻击入口：**  
    *   通过 POST 请求发送 JSON payload 到 `/api/deserialize` 接口 (如果应用将 POST body 的 `data` 字段直接传递给 `unserialize()` 函数)。
    *   将 JSON payload 进行 Base64 编码，然后设置到名为 `profile` 的 cookie 中，访问 `/profile` 页面 (如果应用先对 cookie 进行 Base64 解码，然后传递给 `unserialize()` 函数)。
4.  **执行代码：**  服务器接收到 payload 并调用 `unserialize()` 函数后，恶意的 JavaScript 代码将被执行，导致远程代码执行。
5.  **验证与利用：** 通过写入文件或反弹 shell 等方式验证代码是否成功执行，然后进行更深入的攻击。

**项目地址:** [kylew1004/cve-2017-5941-poc-docker-lab](https://github.com/kylew1004/cve-2017-5941-poc-docker-lab)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #3

**来源**: [CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md](../2017/CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md)

# CVE-2017-5941

> 📦 该CVE有 **4** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md](../2017/CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md)

## CVE-2017-5941-node-serialize远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 需要目标应用使用存在漏洞的node-serialize版本，并且允许控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以构造包含立即调用函数表达式（IIFE）的恶意 JavaScript 对象，通过 `unserialize()` 函数进行反序列化，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息、搜索引擎结果和提供的POC代码，该漏洞利用是有效的。搜索引擎结果中多个链接指向了漏洞的细节分析和利用方法，并包含EXP。

**投毒风险分析：**

分析提供的POC代码，代码主要功能是扫描IP列表（从ip.txt读取），然后针对每个IP构造恶意的cookie（profile）发送HTTP请求。恶意cookie的内容是经过base64编码的，其中包含一个JavaScript IIFE。这个IIFE的作用是执行 `ping` 命令，将当前用户名通过 DNS 查询发送到攻击者的 DNSLog 服务器。

代码本身的功能就是漏洞利用，用于测试目标是否存在漏洞，没有发现隐藏的恶意或非预期的行为。

README.md只是一个链接，指向漏洞分析文章，可以忽略。

**利用方式：**

1.  目标应用使用易受攻击的 `node-serialize` 0.0.4 版本。
2.  应用从请求中读取数据，并使用 `unserialize()` 函数对其进行反序列化。例如，许多案例是从cookie中读取profile变量进行反序列化。
3.  攻击者将包含恶意 JavaScript 对象的序列化字符串（包含 IIFE）作为输入（例如，通过HTTP请求的Cookie）发送给目标应用。
4.  `unserialize()` 函数执行 IIFE，从而在目标服务器上执行任意代码。POC代码中，执行的是ping命令，更严重的情况可以执行任意代码。


**项目地址:** [Frivolous-scholar/CVE-2017-5941-NodeJS-RCE](https://github.com/Frivolous-scholar/CVE-2017-5941-NodeJS-RCE)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #2

**来源**: [CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md](../2017/CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md)

## CVE-2017-5941 - node-serialize 反序列化RCE

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** <= 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize版本，且允许用户可控数据传递到unserialize()函数

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-5941 漏洞存在于 node-serialize 包的 0.0.4 版本及更早版本中。当 `unserialize()` 函数接收到不可信数据时，可以通过构造包含立即执行函数表达式（IIFE）的 JavaScript 对象来执行任意代码。

**有效性评估：**

提供的 PoC 代码利用了 `node-serialize` 包的这个反序列化漏洞，通过构造包含恶意 JavaScript 代码的 JSON 数据，发送到目标服务器的 `/api/deserialize` 接口或通过 `profile` cookie，从而在服务器上执行任意命令。PoC代码包含了生成payload、发送POST请求和设置cookie的完整流程，并提供了 filedrop 和 revshell 两种利用模式，验证了漏洞的有效性。

**投毒风险评估：**

分析 PoC 代码，并未发现明显的投毒代码。PoC 的主要功能是演示漏洞利用，而非进行恶意行为。代码中使用的 `child_process.exec` 函数是为了在目标系统上执行命令，这是漏洞利用的常见手段。不过任何 PoC 都可能被滥用，因此存在潜在的风险。投毒风险评估为5%，主要考虑代码被修改后用于恶意目的。

**利用方式：**

1.  **确定目标：** 找到使用了 `node-serialize <= 0.0.4` 的 Node.js 应用，并且允许用户可控的数据传递到 `unserialize()` 函数。
2.  **构造 Payload：** 使用 PoC 代码或手动构造包含恶意 JavaScript 代码的 JSON payload。恶意代码使用 IIFE (Immediately Invoked Function Expression) 执行 shell 命令。
3.  **选择攻击入口：**  
    *   通过 POST 请求发送 JSON payload 到 `/api/deserialize` 接口 (如果应用将 POST body 的 `data` 字段直接传递给 `unserialize()` 函数)。
    *   将 JSON payload 进行 Base64 编码，然后设置到名为 `profile` 的 cookie 中，访问 `/profile` 页面 (如果应用先对 cookie 进行 Base64 解码，然后传递给 `unserialize()` 函数)。
4.  **执行代码：**  服务器接收到 payload 并调用 `unserialize()` 函数后，恶意的 JavaScript 代码将被执行，导致远程代码执行。
5.  **验证与利用：** 通过写入文件或反弹 shell 等方式验证代码是否成功执行，然后进行更深入的攻击。

**项目地址:** [kylew1004/cve-2017-5941-poc-docker-lab](https://github.com/kylew1004/cve-2017-5941-poc-docker-lab)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #3

**来源**: [CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md](../2017/CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md)

# CVE-2017-5941

> 📦 该CVE有 **4** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md](../2017/CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md)

## CVE-2017-5941-node-serialize远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 需要目标应用使用存在漏洞的node-serialize版本，并且允许控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以构造包含立即调用函数表达式（IIFE）的恶意 JavaScript 对象，通过 `unserialize()` 函数进行反序列化，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息、搜索引擎结果和提供的POC代码，该漏洞利用是有效的。搜索引擎结果中多个链接指向了漏洞的细节分析和利用方法，并包含EXP。

**投毒风险分析：**

分析提供的POC代码，代码主要功能是扫描IP列表（从ip.txt读取），然后针对每个IP构造恶意的cookie（profile）发送HTTP请求。恶意cookie的内容是经过base64编码的，其中包含一个JavaScript IIFE。这个IIFE的作用是执行 `ping` 命令，将当前用户名通过 DNS 查询发送到攻击者的 DNSLog 服务器。

代码本身的功能就是漏洞利用，用于测试目标是否存在漏洞，没有发现隐藏的恶意或非预期的行为。

README.md只是一个链接，指向漏洞分析文章，可以忽略。

**利用方式：**

1.  目标应用使用易受攻击的 `node-serialize` 0.0.4 版本。
2.  应用从请求中读取数据，并使用 `unserialize()` 函数对其进行反序列化。例如，许多案例是从cookie中读取profile变量进行反序列化。
3.  攻击者将包含恶意 JavaScript 对象的序列化字符串（包含 IIFE）作为输入（例如，通过HTTP请求的Cookie）发送给目标应用。
4.  `unserialize()` 函数执行 IIFE，从而在目标服务器上执行任意代码。POC代码中，执行的是ping命令，更严重的情况可以执行任意代码。


**项目地址:** [Frivolous-scholar/CVE-2017-5941-NodeJS-RCE](https://github.com/Frivolous-scholar/CVE-2017-5941-NodeJS-RCE)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #2

**来源**: [CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md](../2017/CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md)

## CVE-2017-5941 - node-serialize 反序列化RCE

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** <= 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize版本，且允许用户可控数据传递到unserialize()函数

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-5941 漏洞存在于 node-serialize 包的 0.0.4 版本及更早版本中。当 `unserialize()` 函数接收到不可信数据时，可以通过构造包含立即执行函数表达式（IIFE）的 JavaScript 对象来执行任意代码。

**有效性评估：**

提供的 PoC 代码利用了 `node-serialize` 包的这个反序列化漏洞，通过构造包含恶意 JavaScript 代码的 JSON 数据，发送到目标服务器的 `/api/deserialize` 接口或通过 `profile` cookie，从而在服务器上执行任意命令。PoC代码包含了生成payload、发送POST请求和设置cookie的完整流程，并提供了 filedrop 和 revshell 两种利用模式，验证了漏洞的有效性。

**投毒风险评估：**

分析 PoC 代码，并未发现明显的投毒代码。PoC 的主要功能是演示漏洞利用，而非进行恶意行为。代码中使用的 `child_process.exec` 函数是为了在目标系统上执行命令，这是漏洞利用的常见手段。不过任何 PoC 都可能被滥用，因此存在潜在的风险。投毒风险评估为5%，主要考虑代码被修改后用于恶意目的。

**利用方式：**

1.  **确定目标：** 找到使用了 `node-serialize <= 0.0.4` 的 Node.js 应用，并且允许用户可控的数据传递到 `unserialize()` 函数。
2.  **构造 Payload：** 使用 PoC 代码或手动构造包含恶意 JavaScript 代码的 JSON payload。恶意代码使用 IIFE (Immediately Invoked Function Expression) 执行 shell 命令。
3.  **选择攻击入口：**  
    *   通过 POST 请求发送 JSON payload 到 `/api/deserialize` 接口 (如果应用将 POST body 的 `data` 字段直接传递给 `unserialize()` 函数)。
    *   将 JSON payload 进行 Base64 编码，然后设置到名为 `profile` 的 cookie 中，访问 `/profile` 页面 (如果应用先对 cookie 进行 Base64 解码，然后传递给 `unserialize()` 函数)。
4.  **执行代码：**  服务器接收到 payload 并调用 `unserialize()` 函数后，恶意的 JavaScript 代码将被执行，导致远程代码执行。
5.  **验证与利用：** 通过写入文件或反弹 shell 等方式验证代码是否成功执行，然后进行更深入的攻击。

**项目地址:** [kylew1004/cve-2017-5941-poc-docker-lab](https://github.com/kylew1004/cve-2017-5941-poc-docker-lab)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #3

**来源**: [CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md](../2017/CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md)

# CVE-2017-5941

> 📦 该CVE有 **4** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md](../2017/CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md)

## CVE-2017-5941-node-serialize远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 需要目标应用使用存在漏洞的node-serialize版本，并且允许控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以构造包含立即调用函数表达式（IIFE）的恶意 JavaScript 对象，通过 `unserialize()` 函数进行反序列化，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息、搜索引擎结果和提供的POC代码，该漏洞利用是有效的。搜索引擎结果中多个链接指向了漏洞的细节分析和利用方法，并包含EXP。

**投毒风险分析：**

分析提供的POC代码，代码主要功能是扫描IP列表（从ip.txt读取），然后针对每个IP构造恶意的cookie（profile）发送HTTP请求。恶意cookie的内容是经过base64编码的，其中包含一个JavaScript IIFE。这个IIFE的作用是执行 `ping` 命令，将当前用户名通过 DNS 查询发送到攻击者的 DNSLog 服务器。

代码本身的功能就是漏洞利用，用于测试目标是否存在漏洞，没有发现隐藏的恶意或非预期的行为。

README.md只是一个链接，指向漏洞分析文章，可以忽略。

**利用方式：**

1.  目标应用使用易受攻击的 `node-serialize` 0.0.4 版本。
2.  应用从请求中读取数据，并使用 `unserialize()` 函数对其进行反序列化。例如，许多案例是从cookie中读取profile变量进行反序列化。
3.  攻击者将包含恶意 JavaScript 对象的序列化字符串（包含 IIFE）作为输入（例如，通过HTTP请求的Cookie）发送给目标应用。
4.  `unserialize()` 函数执行 IIFE，从而在目标服务器上执行任意代码。POC代码中，执行的是ping命令，更严重的情况可以执行任意代码。


**项目地址:** [Frivolous-scholar/CVE-2017-5941-NodeJS-RCE](https://github.com/Frivolous-scholar/CVE-2017-5941-NodeJS-RCE)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #2

**来源**: [CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md](../2017/CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md)

## CVE-2017-5941 - node-serialize 反序列化RCE

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** <= 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize版本，且允许用户可控数据传递到unserialize()函数

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-5941 漏洞存在于 node-serialize 包的 0.0.4 版本及更早版本中。当 `unserialize()` 函数接收到不可信数据时，可以通过构造包含立即执行函数表达式（IIFE）的 JavaScript 对象来执行任意代码。

**有效性评估：**

提供的 PoC 代码利用了 `node-serialize` 包的这个反序列化漏洞，通过构造包含恶意 JavaScript 代码的 JSON 数据，发送到目标服务器的 `/api/deserialize` 接口或通过 `profile` cookie，从而在服务器上执行任意命令。PoC代码包含了生成payload、发送POST请求和设置cookie的完整流程，并提供了 filedrop 和 revshell 两种利用模式，验证了漏洞的有效性。

**投毒风险评估：**

分析 PoC 代码，并未发现明显的投毒代码。PoC 的主要功能是演示漏洞利用，而非进行恶意行为。代码中使用的 `child_process.exec` 函数是为了在目标系统上执行命令，这是漏洞利用的常见手段。不过任何 PoC 都可能被滥用，因此存在潜在的风险。投毒风险评估为5%，主要考虑代码被修改后用于恶意目的。

**利用方式：**

1.  **确定目标：** 找到使用了 `node-serialize <= 0.0.4` 的 Node.js 应用，并且允许用户可控的数据传递到 `unserialize()` 函数。
2.  **构造 Payload：** 使用 PoC 代码或手动构造包含恶意 JavaScript 代码的 JSON payload。恶意代码使用 IIFE (Immediately Invoked Function Expression) 执行 shell 命令。
3.  **选择攻击入口：**  
    *   通过 POST 请求发送 JSON payload 到 `/api/deserialize` 接口 (如果应用将 POST body 的 `data` 字段直接传递给 `unserialize()` 函数)。
    *   将 JSON payload 进行 Base64 编码，然后设置到名为 `profile` 的 cookie 中，访问 `/profile` 页面 (如果应用先对 cookie 进行 Base64 解码，然后传递给 `unserialize()` 函数)。
4.  **执行代码：**  服务器接收到 payload 并调用 `unserialize()` 函数后，恶意的 JavaScript 代码将被执行，导致远程代码执行。
5.  **验证与利用：** 通过写入文件或反弹 shell 等方式验证代码是否成功执行，然后进行更深入的攻击。

**项目地址:** [kylew1004/cve-2017-5941-poc-docker-lab](https://github.com/kylew1004/cve-2017-5941-poc-docker-lab)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #3

**来源**: [CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md](../2017/CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md)

# CVE-2017-5941

> 📦 该CVE有 **4** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md](../2017/CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md)

## CVE-2017-5941-node-serialize远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 需要目标应用使用存在漏洞的node-serialize版本，并且允许控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以构造包含立即调用函数表达式（IIFE）的恶意 JavaScript 对象，通过 `unserialize()` 函数进行反序列化，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息、搜索引擎结果和提供的POC代码，该漏洞利用是有效的。搜索引擎结果中多个链接指向了漏洞的细节分析和利用方法，并包含EXP。

**投毒风险分析：**

分析提供的POC代码，代码主要功能是扫描IP列表（从ip.txt读取），然后针对每个IP构造恶意的cookie（profile）发送HTTP请求。恶意cookie的内容是经过base64编码的，其中包含一个JavaScript IIFE。这个IIFE的作用是执行 `ping` 命令，将当前用户名通过 DNS 查询发送到攻击者的 DNSLog 服务器。

代码本身的功能就是漏洞利用，用于测试目标是否存在漏洞，没有发现隐藏的恶意或非预期的行为。

README.md只是一个链接，指向漏洞分析文章，可以忽略。

**利用方式：**

1.  目标应用使用易受攻击的 `node-serialize` 0.0.4 版本。
2.  应用从请求中读取数据，并使用 `unserialize()` 函数对其进行反序列化。例如，许多案例是从cookie中读取profile变量进行反序列化。
3.  攻击者将包含恶意 JavaScript 对象的序列化字符串（包含 IIFE）作为输入（例如，通过HTTP请求的Cookie）发送给目标应用。
4.  `unserialize()` 函数执行 IIFE，从而在目标服务器上执行任意代码。POC代码中，执行的是ping命令，更严重的情况可以执行任意代码。


**项目地址:** [Frivolous-scholar/CVE-2017-5941-NodeJS-RCE](https://github.com/Frivolous-scholar/CVE-2017-5941-NodeJS-RCE)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #2

**来源**: [CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md](../2017/CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md)

## CVE-2017-5941 - node-serialize 反序列化RCE

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** <= 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize版本，且允许用户可控数据传递到unserialize()函数

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-5941 漏洞存在于 node-serialize 包的 0.0.4 版本及更早版本中。当 `unserialize()` 函数接收到不可信数据时，可以通过构造包含立即执行函数表达式（IIFE）的 JavaScript 对象来执行任意代码。

**有效性评估：**

提供的 PoC 代码利用了 `node-serialize` 包的这个反序列化漏洞，通过构造包含恶意 JavaScript 代码的 JSON 数据，发送到目标服务器的 `/api/deserialize` 接口或通过 `profile` cookie，从而在服务器上执行任意命令。PoC代码包含了生成payload、发送POST请求和设置cookie的完整流程，并提供了 filedrop 和 revshell 两种利用模式，验证了漏洞的有效性。

**投毒风险评估：**

分析 PoC 代码，并未发现明显的投毒代码。PoC 的主要功能是演示漏洞利用，而非进行恶意行为。代码中使用的 `child_process.exec` 函数是为了在目标系统上执行命令，这是漏洞利用的常见手段。不过任何 PoC 都可能被滥用，因此存在潜在的风险。投毒风险评估为5%，主要考虑代码被修改后用于恶意目的。

**利用方式：**

1.  **确定目标：** 找到使用了 `node-serialize <= 0.0.4` 的 Node.js 应用，并且允许用户可控的数据传递到 `unserialize()` 函数。
2.  **构造 Payload：** 使用 PoC 代码或手动构造包含恶意 JavaScript 代码的 JSON payload。恶意代码使用 IIFE (Immediately Invoked Function Expression) 执行 shell 命令。
3.  **选择攻击入口：**  
    *   通过 POST 请求发送 JSON payload 到 `/api/deserialize` 接口 (如果应用将 POST body 的 `data` 字段直接传递给 `unserialize()` 函数)。
    *   将 JSON payload 进行 Base64 编码，然后设置到名为 `profile` 的 cookie 中，访问 `/profile` 页面 (如果应用先对 cookie 进行 Base64 解码，然后传递给 `unserialize()` 函数)。
4.  **执行代码：**  服务器接收到 payload 并调用 `unserialize()` 函数后，恶意的 JavaScript 代码将被执行，导致远程代码执行。
5.  **验证与利用：** 通过写入文件或反弹 shell 等方式验证代码是否成功执行，然后进行更深入的攻击。

**项目地址:** [kylew1004/cve-2017-5941-poc-docker-lab](https://github.com/kylew1004/cve-2017-5941-poc-docker-lab)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #3

**来源**: [CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md](../2017/CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md)

# CVE-2017-5941

> 📦 该CVE有 **4** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md](../2017/CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md)

## CVE-2017-5941-node-serialize远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 需要目标应用使用存在漏洞的node-serialize版本，并且允许控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以构造包含立即调用函数表达式（IIFE）的恶意 JavaScript 对象，通过 `unserialize()` 函数进行反序列化，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息、搜索引擎结果和提供的POC代码，该漏洞利用是有效的。搜索引擎结果中多个链接指向了漏洞的细节分析和利用方法，并包含EXP。

**投毒风险分析：**

分析提供的POC代码，代码主要功能是扫描IP列表（从ip.txt读取），然后针对每个IP构造恶意的cookie（profile）发送HTTP请求。恶意cookie的内容是经过base64编码的，其中包含一个JavaScript IIFE。这个IIFE的作用是执行 `ping` 命令，将当前用户名通过 DNS 查询发送到攻击者的 DNSLog 服务器。

代码本身的功能就是漏洞利用，用于测试目标是否存在漏洞，没有发现隐藏的恶意或非预期的行为。

README.md只是一个链接，指向漏洞分析文章，可以忽略。

**利用方式：**

1.  目标应用使用易受攻击的 `node-serialize` 0.0.4 版本。
2.  应用从请求中读取数据，并使用 `unserialize()` 函数对其进行反序列化。例如，许多案例是从cookie中读取profile变量进行反序列化。
3.  攻击者将包含恶意 JavaScript 对象的序列化字符串（包含 IIFE）作为输入（例如，通过HTTP请求的Cookie）发送给目标应用。
4.  `unserialize()` 函数执行 IIFE，从而在目标服务器上执行任意代码。POC代码中，执行的是ping命令，更严重的情况可以执行任意代码。


**项目地址:** [Frivolous-scholar/CVE-2017-5941-NodeJS-RCE](https://github.com/Frivolous-scholar/CVE-2017-5941-NodeJS-RCE)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #2

**来源**: [CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md](../2017/CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md)

## CVE-2017-5941 - node-serialize 反序列化RCE

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** <= 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize版本，且允许用户可控数据传递到unserialize()函数

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-5941 漏洞存在于 node-serialize 包的 0.0.4 版本及更早版本中。当 `unserialize()` 函数接收到不可信数据时，可以通过构造包含立即执行函数表达式（IIFE）的 JavaScript 对象来执行任意代码。

**有效性评估：**

提供的 PoC 代码利用了 `node-serialize` 包的这个反序列化漏洞，通过构造包含恶意 JavaScript 代码的 JSON 数据，发送到目标服务器的 `/api/deserialize` 接口或通过 `profile` cookie，从而在服务器上执行任意命令。PoC代码包含了生成payload、发送POST请求和设置cookie的完整流程，并提供了 filedrop 和 revshell 两种利用模式，验证了漏洞的有效性。

**投毒风险评估：**

分析 PoC 代码，并未发现明显的投毒代码。PoC 的主要功能是演示漏洞利用，而非进行恶意行为。代码中使用的 `child_process.exec` 函数是为了在目标系统上执行命令，这是漏洞利用的常见手段。不过任何 PoC 都可能被滥用，因此存在潜在的风险。投毒风险评估为5%，主要考虑代码被修改后用于恶意目的。

**利用方式：**

1.  **确定目标：** 找到使用了 `node-serialize <= 0.0.4` 的 Node.js 应用，并且允许用户可控的数据传递到 `unserialize()` 函数。
2.  **构造 Payload：** 使用 PoC 代码或手动构造包含恶意 JavaScript 代码的 JSON payload。恶意代码使用 IIFE (Immediately Invoked Function Expression) 执行 shell 命令。
3.  **选择攻击入口：**  
    *   通过 POST 请求发送 JSON payload 到 `/api/deserialize` 接口 (如果应用将 POST body 的 `data` 字段直接传递给 `unserialize()` 函数)。
    *   将 JSON payload 进行 Base64 编码，然后设置到名为 `profile` 的 cookie 中，访问 `/profile` 页面 (如果应用先对 cookie 进行 Base64 解码，然后传递给 `unserialize()` 函数)。
4.  **执行代码：**  服务器接收到 payload 并调用 `unserialize()` 函数后，恶意的 JavaScript 代码将被执行，导致远程代码执行。
5.  **验证与利用：** 通过写入文件或反弹 shell 等方式验证代码是否成功执行，然后进行更深入的攻击。

**项目地址:** [kylew1004/cve-2017-5941-poc-docker-lab](https://github.com/kylew1004/cve-2017-5941-poc-docker-lab)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #3

**来源**: [CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md](../2017/CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md)

# CVE-2017-5941

> 📦 该CVE有 **4** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md](../2017/CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md)

## CVE-2017-5941-node-serialize远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 需要目标应用使用存在漏洞的node-serialize版本，并且允许控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以构造包含立即调用函数表达式（IIFE）的恶意 JavaScript 对象，通过 `unserialize()` 函数进行反序列化，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息、搜索引擎结果和提供的POC代码，该漏洞利用是有效的。搜索引擎结果中多个链接指向了漏洞的细节分析和利用方法，并包含EXP。

**投毒风险分析：**

分析提供的POC代码，代码主要功能是扫描IP列表（从ip.txt读取），然后针对每个IP构造恶意的cookie（profile）发送HTTP请求。恶意cookie的内容是经过base64编码的，其中包含一个JavaScript IIFE。这个IIFE的作用是执行 `ping` 命令，将当前用户名通过 DNS 查询发送到攻击者的 DNSLog 服务器。

代码本身的功能就是漏洞利用，用于测试目标是否存在漏洞，没有发现隐藏的恶意或非预期的行为。

README.md只是一个链接，指向漏洞分析文章，可以忽略。

**利用方式：**

1.  目标应用使用易受攻击的 `node-serialize` 0.0.4 版本。
2.  应用从请求中读取数据，并使用 `unserialize()` 函数对其进行反序列化。例如，许多案例是从cookie中读取profile变量进行反序列化。
3.  攻击者将包含恶意 JavaScript 对象的序列化字符串（包含 IIFE）作为输入（例如，通过HTTP请求的Cookie）发送给目标应用。
4.  `unserialize()` 函数执行 IIFE，从而在目标服务器上执行任意代码。POC代码中，执行的是ping命令，更严重的情况可以执行任意代码。


**项目地址:** [Frivolous-scholar/CVE-2017-5941-NodeJS-RCE](https://github.com/Frivolous-scholar/CVE-2017-5941-NodeJS-RCE)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #2

**来源**: [CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md](../2017/CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md)

## CVE-2017-5941 - node-serialize 反序列化RCE

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** <= 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize版本，且允许用户可控数据传递到unserialize()函数

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-5941 漏洞存在于 node-serialize 包的 0.0.4 版本及更早版本中。当 `unserialize()` 函数接收到不可信数据时，可以通过构造包含立即执行函数表达式（IIFE）的 JavaScript 对象来执行任意代码。

**有效性评估：**

提供的 PoC 代码利用了 `node-serialize` 包的这个反序列化漏洞，通过构造包含恶意 JavaScript 代码的 JSON 数据，发送到目标服务器的 `/api/deserialize` 接口或通过 `profile` cookie，从而在服务器上执行任意命令。PoC代码包含了生成payload、发送POST请求和设置cookie的完整流程，并提供了 filedrop 和 revshell 两种利用模式，验证了漏洞的有效性。

**投毒风险评估：**

分析 PoC 代码，并未发现明显的投毒代码。PoC 的主要功能是演示漏洞利用，而非进行恶意行为。代码中使用的 `child_process.exec` 函数是为了在目标系统上执行命令，这是漏洞利用的常见手段。不过任何 PoC 都可能被滥用，因此存在潜在的风险。投毒风险评估为5%，主要考虑代码被修改后用于恶意目的。

**利用方式：**

1.  **确定目标：** 找到使用了 `node-serialize <= 0.0.4` 的 Node.js 应用，并且允许用户可控的数据传递到 `unserialize()` 函数。
2.  **构造 Payload：** 使用 PoC 代码或手动构造包含恶意 JavaScript 代码的 JSON payload。恶意代码使用 IIFE (Immediately Invoked Function Expression) 执行 shell 命令。
3.  **选择攻击入口：**  
    *   通过 POST 请求发送 JSON payload 到 `/api/deserialize` 接口 (如果应用将 POST body 的 `data` 字段直接传递给 `unserialize()` 函数)。
    *   将 JSON payload 进行 Base64 编码，然后设置到名为 `profile` 的 cookie 中，访问 `/profile` 页面 (如果应用先对 cookie 进行 Base64 解码，然后传递给 `unserialize()` 函数)。
4.  **执行代码：**  服务器接收到 payload 并调用 `unserialize()` 函数后，恶意的 JavaScript 代码将被执行，导致远程代码执行。
5.  **验证与利用：** 通过写入文件或反弹 shell 等方式验证代码是否成功执行，然后进行更深入的攻击。

**项目地址:** [kylew1004/cve-2017-5941-poc-docker-lab](https://github.com/kylew1004/cve-2017-5941-poc-docker-lab)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #3

**来源**: [CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md](../2017/CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md)

# CVE-2017-5941

> 📦 该CVE有 **4** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md](../2017/CVE-2017-5941-Frivolous-scholar_CVE-2017-5941-NodeJS-RCE.md)

## CVE-2017-5941-node-serialize远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 需要目标应用使用存在漏洞的node-serialize版本，并且允许控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以构造包含立即调用函数表达式（IIFE）的恶意 JavaScript 对象，通过 `unserialize()` 函数进行反序列化，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息、搜索引擎结果和提供的POC代码，该漏洞利用是有效的。搜索引擎结果中多个链接指向了漏洞的细节分析和利用方法，并包含EXP。

**投毒风险分析：**

分析提供的POC代码，代码主要功能是扫描IP列表（从ip.txt读取），然后针对每个IP构造恶意的cookie（profile）发送HTTP请求。恶意cookie的内容是经过base64编码的，其中包含一个JavaScript IIFE。这个IIFE的作用是执行 `ping` 命令，将当前用户名通过 DNS 查询发送到攻击者的 DNSLog 服务器。

代码本身的功能就是漏洞利用，用于测试目标是否存在漏洞，没有发现隐藏的恶意或非预期的行为。

README.md只是一个链接，指向漏洞分析文章，可以忽略。

**利用方式：**

1.  目标应用使用易受攻击的 `node-serialize` 0.0.4 版本。
2.  应用从请求中读取数据，并使用 `unserialize()` 函数对其进行反序列化。例如，许多案例是从cookie中读取profile变量进行反序列化。
3.  攻击者将包含恶意 JavaScript 对象的序列化字符串（包含 IIFE）作为输入（例如，通过HTTP请求的Cookie）发送给目标应用。
4.  `unserialize()` 函数执行 IIFE，从而在目标服务器上执行任意代码。POC代码中，执行的是ping命令，更严重的情况可以执行任意代码。


**项目地址:** [Frivolous-scholar/CVE-2017-5941-NodeJS-RCE](https://github.com/Frivolous-scholar/CVE-2017-5941-NodeJS-RCE)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #2

**来源**: [CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md](../2017/CVE-2017-5941-kylew1004_cve-2017-5941-poc-docker-lab.md)

## CVE-2017-5941 - node-serialize 反序列化RCE

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可导致远程代码执行

**影响版本:** <= 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize版本，且允许用户可控数据传递到unserialize()函数

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2017-5941 漏洞存在于 node-serialize 包的 0.0.4 版本及更早版本中。当 `unserialize()` 函数接收到不可信数据时，可以通过构造包含立即执行函数表达式（IIFE）的 JavaScript 对象来执行任意代码。

**有效性评估：**

提供的 PoC 代码利用了 `node-serialize` 包的这个反序列化漏洞，通过构造包含恶意 JavaScript 代码的 JSON 数据，发送到目标服务器的 `/api/deserialize` 接口或通过 `profile` cookie，从而在服务器上执行任意命令。PoC代码包含了生成payload、发送POST请求和设置cookie的完整流程，并提供了 filedrop 和 revshell 两种利用模式，验证了漏洞的有效性。

**投毒风险评估：**

分析 PoC 代码，并未发现明显的投毒代码。PoC 的主要功能是演示漏洞利用，而非进行恶意行为。代码中使用的 `child_process.exec` 函数是为了在目标系统上执行命令，这是漏洞利用的常见手段。不过任何 PoC 都可能被滥用，因此存在潜在的风险。投毒风险评估为5%，主要考虑代码被修改后用于恶意目的。

**利用方式：**

1.  **确定目标：** 找到使用了 `node-serialize <= 0.0.4` 的 Node.js 应用，并且允许用户可控的数据传递到 `unserialize()` 函数。
2.  **构造 Payload：** 使用 PoC 代码或手动构造包含恶意 JavaScript 代码的 JSON payload。恶意代码使用 IIFE (Immediately Invoked Function Expression) 执行 shell 命令。
3.  **选择攻击入口：**  
    *   通过 POST 请求发送 JSON payload 到 `/api/deserialize` 接口 (如果应用将 POST body 的 `data` 字段直接传递给 `unserialize()` 函数)。
    *   将 JSON payload 进行 Base64 编码，然后设置到名为 `profile` 的 cookie 中，访问 `/profile` 页面 (如果应用先对 cookie 进行 Base64 解码，然后传递给 `unserialize()` 函数)。
4.  **执行代码：**  服务器接收到 payload 并调用 `unserialize()` 函数后，恶意的 JavaScript 代码将被执行，导致远程代码执行。
5.  **验证与利用：** 通过写入文件或反弹 shell 等方式验证代码是否成功执行，然后进行更深入的攻击。

**项目地址:** [kylew1004/cve-2017-5941-poc-docker-lab](https://github.com/kylew1004/cve-2017-5941-poc-docker-lab)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #3

**来源**: [CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md](../2017/CVE-2017-5941-turnernator1_Node.js-CVE-2017-5941.md)

## CVE-2017-5941-node-serialize-反序列化漏洞

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 应用程序使用 node-serialize 并且允许用户控制反序列化的数据

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941 是 node-serialize 包 0.0.4 版本中的一个反序列化漏洞。攻击者可以通过将包含恶意 JavaScript 对象（特别是立即调用函数表达式 IIFE）的不可信数据传递给 `unserialize()` 函数来利用此漏洞，从而实现远程代码执行。

**有效性：**
提供的 POC 代码是有效的，它演示了如何利用此漏洞。
`index.js` 文件中的代码展示了如何使用 `node-serialize` 包反序列化 cookie 中的数据。如果 cookie 内容包含恶意 IIFE，则会导致代码执行。

**投毒风险：**
代码仓库中投毒的可能性较低，约为1%。主要原因是:
1.  `README.md`文件描述了漏洞利用和缓解方法，没有发现恶意代码。
2.  `index.js` 文件是漏洞利用的示例，目的是展示如何触发漏洞。
3. `package-lock.json` 文件锁定了依赖版本，防止安装恶意依赖，但也不能完全排除通过依赖包进行投毒的可能性，不过这个概率非常低。

虽然代码本身没有明显的投毒行为，但使用者需要注意依赖包的安全性，以避免受到供应链攻击。

**利用方式：**
1.  目标应用程序必须使用易受攻击的 `node-serialize` 包的版本 0.0.4。
2.  攻击者需要找到应用程序使用 `unserialize()` 函数反序列化用户可控数据的地方，例如 cookie、POST 参数等。
3.  攻击者构造包含恶意 IIFE 的序列化 JavaScript 对象。例如: `{"rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('指令', function(error, stdout, stderr) { console.log(stdout) });}()"}`
4.  将此恶意对象进行 base64 编码，并将其作为 cookie 或其他可控数据发送到目标应用程序。
5.  当应用程序使用 `unserialize()` 反序列化此数据时，IIFE 将被执行，从而导致远程代码执行。

**项目地址:** [turnernator1/Node.js-CVE-2017-5941](https://github.com/turnernator1/Node.js-CVE-2017-5941)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

## POC #4

**来源**: [CVE-2017-5941-uartu0_nodejshell.md](../2017/CVE-2017-5941-uartu0_nodejshell.md)

## CVE-2017-5941-node-serialize-远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize模块，并且允许用户可控的数据传递给unserialize函数。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941是node-serialize 0.0.4版本中的一个反序列化漏洞。攻击者可以将包含恶意JavaScript代码（例如，利用立即执行函数表达式（IIFE））的不可信数据传递给`unserialize()`函数，从而实现远程代码执行(RCE)。

**有效性分析：**
提供的Python脚本`nodejshell.py`旨在利用此漏洞。它通过构造包含反向shell payload的序列化数据，并将其作为cookie或POST参数发送到目标服务器。如果目标服务器使用`node-serialize`的`unserialize()`函数处理这些数据，恶意代码将被执行，从而在攻击者控制的机器上建立反向shell。

**投毒风险分析：**
代码检查显示，提供的Python脚本的主要功能是生成和发送恶意payload，目的是利用目标系统上的反序列化漏洞。该脚本本身并没有明显的植入后门、窃取信息或进行恶意传播的行为。脚本中唯一的网络行为是向目标URL发送HTTP请求，这是利用漏洞所必需的。`poison`的概率很低，因为代码的功能比较直接，主要就是利用漏洞进行反向shell连接。`node_shell`变量中的反向shell代码段是漏洞利用的核心，虽然是恶意目的，但属于payload范畴，不应被视为投毒代码。

**漏洞利用方式：**
1.  **构造Payload：** 脚本生成包含反向shell命令的JavaScript代码。该代码被转换为decimal表示，然后嵌入到IIFE中，并使用`node-serialize`进行序列化，然后进行base64编码。
2.  **发送Payload：** 脚本通过HTTP POST请求将payload作为参数发送到目标URL，或者将其设置到cookie中。
3.  **触发反序列化：** 目标服务器接收到请求后，使用`node-serialize`的`unserialize()`函数反序列化数据。
4.  **执行代码：** 由于payload中包含恶意JavaScript代码，反序列化过程会导致代码执行，从而建立从目标服务器到攻击者机器的反向shell连接。
5.  **建立连接:** 攻击者需要监听设定的端口以接受反向shell的连接。

**项目地址:** [uartu0/nodejshell](https://github.com/uartu0/nodejshell)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---



---

## POC #4

**来源**: [CVE-2017-5941-uartu0_nodejshell.md](../2017/CVE-2017-5941-uartu0_nodejshell.md)

## CVE-2017-5941-node-serialize-远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize模块，并且允许用户可控的数据传递给unserialize函数。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941是node-serialize 0.0.4版本中的一个反序列化漏洞。攻击者可以将包含恶意JavaScript代码（例如，利用立即执行函数表达式（IIFE））的不可信数据传递给`unserialize()`函数，从而实现远程代码执行(RCE)。

**有效性分析：**
提供的Python脚本`nodejshell.py`旨在利用此漏洞。它通过构造包含反向shell payload的序列化数据，并将其作为cookie或POST参数发送到目标服务器。如果目标服务器使用`node-serialize`的`unserialize()`函数处理这些数据，恶意代码将被执行，从而在攻击者控制的机器上建立反向shell。

**投毒风险分析：**
代码检查显示，提供的Python脚本的主要功能是生成和发送恶意payload，目的是利用目标系统上的反序列化漏洞。该脚本本身并没有明显的植入后门、窃取信息或进行恶意传播的行为。脚本中唯一的网络行为是向目标URL发送HTTP请求，这是利用漏洞所必需的。`poison`的概率很低，因为代码的功能比较直接，主要就是利用漏洞进行反向shell连接。`node_shell`变量中的反向shell代码段是漏洞利用的核心，虽然是恶意目的，但属于payload范畴，不应被视为投毒代码。

**漏洞利用方式：**
1.  **构造Payload：** 脚本生成包含反向shell命令的JavaScript代码。该代码被转换为decimal表示，然后嵌入到IIFE中，并使用`node-serialize`进行序列化，然后进行base64编码。
2.  **发送Payload：** 脚本通过HTTP POST请求将payload作为参数发送到目标URL，或者将其设置到cookie中。
3.  **触发反序列化：** 目标服务器接收到请求后，使用`node-serialize`的`unserialize()`函数反序列化数据。
4.  **执行代码：** 由于payload中包含恶意JavaScript代码，反序列化过程会导致代码执行，从而建立从目标服务器到攻击者机器的反向shell连接。
5.  **建立连接:** 攻击者需要监听设定的端口以接受反向shell的连接。

**项目地址:** [uartu0/nodejshell](https://github.com/uartu0/nodejshell)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---



---

## POC #4

**来源**: [CVE-2017-5941-uartu0_nodejshell.md](../2017/CVE-2017-5941-uartu0_nodejshell.md)

## CVE-2017-5941-node-serialize-远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize模块，并且允许用户可控的数据传递给unserialize函数。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941是node-serialize 0.0.4版本中的一个反序列化漏洞。攻击者可以将包含恶意JavaScript代码（例如，利用立即执行函数表达式（IIFE））的不可信数据传递给`unserialize()`函数，从而实现远程代码执行(RCE)。

**有效性分析：**
提供的Python脚本`nodejshell.py`旨在利用此漏洞。它通过构造包含反向shell payload的序列化数据，并将其作为cookie或POST参数发送到目标服务器。如果目标服务器使用`node-serialize`的`unserialize()`函数处理这些数据，恶意代码将被执行，从而在攻击者控制的机器上建立反向shell。

**投毒风险分析：**
代码检查显示，提供的Python脚本的主要功能是生成和发送恶意payload，目的是利用目标系统上的反序列化漏洞。该脚本本身并没有明显的植入后门、窃取信息或进行恶意传播的行为。脚本中唯一的网络行为是向目标URL发送HTTP请求，这是利用漏洞所必需的。`poison`的概率很低，因为代码的功能比较直接，主要就是利用漏洞进行反向shell连接。`node_shell`变量中的反向shell代码段是漏洞利用的核心，虽然是恶意目的，但属于payload范畴，不应被视为投毒代码。

**漏洞利用方式：**
1.  **构造Payload：** 脚本生成包含反向shell命令的JavaScript代码。该代码被转换为decimal表示，然后嵌入到IIFE中，并使用`node-serialize`进行序列化，然后进行base64编码。
2.  **发送Payload：** 脚本通过HTTP POST请求将payload作为参数发送到目标URL，或者将其设置到cookie中。
3.  **触发反序列化：** 目标服务器接收到请求后，使用`node-serialize`的`unserialize()`函数反序列化数据。
4.  **执行代码：** 由于payload中包含恶意JavaScript代码，反序列化过程会导致代码执行，从而建立从目标服务器到攻击者机器的反向shell连接。
5.  **建立连接:** 攻击者需要监听设定的端口以接受反向shell的连接。

**项目地址:** [uartu0/nodejshell](https://github.com/uartu0/nodejshell)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---



---

## POC #4

**来源**: [CVE-2017-5941-uartu0_nodejshell.md](../2017/CVE-2017-5941-uartu0_nodejshell.md)

## CVE-2017-5941-node-serialize-远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize模块，并且允许用户可控的数据传递给unserialize函数。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941是node-serialize 0.0.4版本中的一个反序列化漏洞。攻击者可以将包含恶意JavaScript代码（例如，利用立即执行函数表达式（IIFE））的不可信数据传递给`unserialize()`函数，从而实现远程代码执行(RCE)。

**有效性分析：**
提供的Python脚本`nodejshell.py`旨在利用此漏洞。它通过构造包含反向shell payload的序列化数据，并将其作为cookie或POST参数发送到目标服务器。如果目标服务器使用`node-serialize`的`unserialize()`函数处理这些数据，恶意代码将被执行，从而在攻击者控制的机器上建立反向shell。

**投毒风险分析：**
代码检查显示，提供的Python脚本的主要功能是生成和发送恶意payload，目的是利用目标系统上的反序列化漏洞。该脚本本身并没有明显的植入后门、窃取信息或进行恶意传播的行为。脚本中唯一的网络行为是向目标URL发送HTTP请求，这是利用漏洞所必需的。`poison`的概率很低，因为代码的功能比较直接，主要就是利用漏洞进行反向shell连接。`node_shell`变量中的反向shell代码段是漏洞利用的核心，虽然是恶意目的，但属于payload范畴，不应被视为投毒代码。

**漏洞利用方式：**
1.  **构造Payload：** 脚本生成包含反向shell命令的JavaScript代码。该代码被转换为decimal表示，然后嵌入到IIFE中，并使用`node-serialize`进行序列化，然后进行base64编码。
2.  **发送Payload：** 脚本通过HTTP POST请求将payload作为参数发送到目标URL，或者将其设置到cookie中。
3.  **触发反序列化：** 目标服务器接收到请求后，使用`node-serialize`的`unserialize()`函数反序列化数据。
4.  **执行代码：** 由于payload中包含恶意JavaScript代码，反序列化过程会导致代码执行，从而建立从目标服务器到攻击者机器的反向shell连接。
5.  **建立连接:** 攻击者需要监听设定的端口以接受反向shell的连接。

**项目地址:** [uartu0/nodejshell](https://github.com/uartu0/nodejshell)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---



---

## POC #4

**来源**: [CVE-2017-5941-uartu0_nodejshell.md](../2017/CVE-2017-5941-uartu0_nodejshell.md)

## CVE-2017-5941-node-serialize-远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize模块，并且允许用户可控的数据传递给unserialize函数。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941是node-serialize 0.0.4版本中的一个反序列化漏洞。攻击者可以将包含恶意JavaScript代码（例如，利用立即执行函数表达式（IIFE））的不可信数据传递给`unserialize()`函数，从而实现远程代码执行(RCE)。

**有效性分析：**
提供的Python脚本`nodejshell.py`旨在利用此漏洞。它通过构造包含反向shell payload的序列化数据，并将其作为cookie或POST参数发送到目标服务器。如果目标服务器使用`node-serialize`的`unserialize()`函数处理这些数据，恶意代码将被执行，从而在攻击者控制的机器上建立反向shell。

**投毒风险分析：**
代码检查显示，提供的Python脚本的主要功能是生成和发送恶意payload，目的是利用目标系统上的反序列化漏洞。该脚本本身并没有明显的植入后门、窃取信息或进行恶意传播的行为。脚本中唯一的网络行为是向目标URL发送HTTP请求，这是利用漏洞所必需的。`poison`的概率很低，因为代码的功能比较直接，主要就是利用漏洞进行反向shell连接。`node_shell`变量中的反向shell代码段是漏洞利用的核心，虽然是恶意目的，但属于payload范畴，不应被视为投毒代码。

**漏洞利用方式：**
1.  **构造Payload：** 脚本生成包含反向shell命令的JavaScript代码。该代码被转换为decimal表示，然后嵌入到IIFE中，并使用`node-serialize`进行序列化，然后进行base64编码。
2.  **发送Payload：** 脚本通过HTTP POST请求将payload作为参数发送到目标URL，或者将其设置到cookie中。
3.  **触发反序列化：** 目标服务器接收到请求后，使用`node-serialize`的`unserialize()`函数反序列化数据。
4.  **执行代码：** 由于payload中包含恶意JavaScript代码，反序列化过程会导致代码执行，从而建立从目标服务器到攻击者机器的反向shell连接。
5.  **建立连接:** 攻击者需要监听设定的端口以接受反向shell的连接。

**项目地址:** [uartu0/nodejshell](https://github.com/uartu0/nodejshell)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---



---

## POC #4

**来源**: [CVE-2017-5941-uartu0_nodejshell.md](../2017/CVE-2017-5941-uartu0_nodejshell.md)

## CVE-2017-5941-node-serialize-远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize模块，并且允许用户可控的数据传递给unserialize函数。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941是node-serialize 0.0.4版本中的一个反序列化漏洞。攻击者可以将包含恶意JavaScript代码（例如，利用立即执行函数表达式（IIFE））的不可信数据传递给`unserialize()`函数，从而实现远程代码执行(RCE)。

**有效性分析：**
提供的Python脚本`nodejshell.py`旨在利用此漏洞。它通过构造包含反向shell payload的序列化数据，并将其作为cookie或POST参数发送到目标服务器。如果目标服务器使用`node-serialize`的`unserialize()`函数处理这些数据，恶意代码将被执行，从而在攻击者控制的机器上建立反向shell。

**投毒风险分析：**
代码检查显示，提供的Python脚本的主要功能是生成和发送恶意payload，目的是利用目标系统上的反序列化漏洞。该脚本本身并没有明显的植入后门、窃取信息或进行恶意传播的行为。脚本中唯一的网络行为是向目标URL发送HTTP请求，这是利用漏洞所必需的。`poison`的概率很低，因为代码的功能比较直接，主要就是利用漏洞进行反向shell连接。`node_shell`变量中的反向shell代码段是漏洞利用的核心，虽然是恶意目的，但属于payload范畴，不应被视为投毒代码。

**漏洞利用方式：**
1.  **构造Payload：** 脚本生成包含反向shell命令的JavaScript代码。该代码被转换为decimal表示，然后嵌入到IIFE中，并使用`node-serialize`进行序列化，然后进行base64编码。
2.  **发送Payload：** 脚本通过HTTP POST请求将payload作为参数发送到目标URL，或者将其设置到cookie中。
3.  **触发反序列化：** 目标服务器接收到请求后，使用`node-serialize`的`unserialize()`函数反序列化数据。
4.  **执行代码：** 由于payload中包含恶意JavaScript代码，反序列化过程会导致代码执行，从而建立从目标服务器到攻击者机器的反向shell连接。
5.  **建立连接:** 攻击者需要监听设定的端口以接受反向shell的连接。

**项目地址:** [uartu0/nodejshell](https://github.com/uartu0/nodejshell)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---



---

## POC #4

**来源**: [CVE-2017-5941-uartu0_nodejshell.md](../2017/CVE-2017-5941-uartu0_nodejshell.md)

## CVE-2017-5941-node-serialize-远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize模块，并且允许用户可控的数据传递给unserialize函数。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941是node-serialize 0.0.4版本中的一个反序列化漏洞。攻击者可以将包含恶意JavaScript代码（例如，利用立即执行函数表达式（IIFE））的不可信数据传递给`unserialize()`函数，从而实现远程代码执行(RCE)。

**有效性分析：**
提供的Python脚本`nodejshell.py`旨在利用此漏洞。它通过构造包含反向shell payload的序列化数据，并将其作为cookie或POST参数发送到目标服务器。如果目标服务器使用`node-serialize`的`unserialize()`函数处理这些数据，恶意代码将被执行，从而在攻击者控制的机器上建立反向shell。

**投毒风险分析：**
代码检查显示，提供的Python脚本的主要功能是生成和发送恶意payload，目的是利用目标系统上的反序列化漏洞。该脚本本身并没有明显的植入后门、窃取信息或进行恶意传播的行为。脚本中唯一的网络行为是向目标URL发送HTTP请求，这是利用漏洞所必需的。`poison`的概率很低，因为代码的功能比较直接，主要就是利用漏洞进行反向shell连接。`node_shell`变量中的反向shell代码段是漏洞利用的核心，虽然是恶意目的，但属于payload范畴，不应被视为投毒代码。

**漏洞利用方式：**
1.  **构造Payload：** 脚本生成包含反向shell命令的JavaScript代码。该代码被转换为decimal表示，然后嵌入到IIFE中，并使用`node-serialize`进行序列化，然后进行base64编码。
2.  **发送Payload：** 脚本通过HTTP POST请求将payload作为参数发送到目标URL，或者将其设置到cookie中。
3.  **触发反序列化：** 目标服务器接收到请求后，使用`node-serialize`的`unserialize()`函数反序列化数据。
4.  **执行代码：** 由于payload中包含恶意JavaScript代码，反序列化过程会导致代码执行，从而建立从目标服务器到攻击者机器的反向shell连接。
5.  **建立连接:** 攻击者需要监听设定的端口以接受反向shell的连接。

**项目地址:** [uartu0/nodejshell](https://github.com/uartu0/nodejshell)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---



---

## POC #4

**来源**: [CVE-2017-5941-uartu0_nodejshell.md](../2017/CVE-2017-5941-uartu0_nodejshell.md)

## CVE-2017-5941-node-serialize-远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize模块，并且允许用户可控的数据传递给unserialize函数。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941是node-serialize 0.0.4版本中的一个反序列化漏洞。攻击者可以将包含恶意JavaScript代码（例如，利用立即执行函数表达式（IIFE））的不可信数据传递给`unserialize()`函数，从而实现远程代码执行(RCE)。

**有效性分析：**
提供的Python脚本`nodejshell.py`旨在利用此漏洞。它通过构造包含反向shell payload的序列化数据，并将其作为cookie或POST参数发送到目标服务器。如果目标服务器使用`node-serialize`的`unserialize()`函数处理这些数据，恶意代码将被执行，从而在攻击者控制的机器上建立反向shell。

**投毒风险分析：**
代码检查显示，提供的Python脚本的主要功能是生成和发送恶意payload，目的是利用目标系统上的反序列化漏洞。该脚本本身并没有明显的植入后门、窃取信息或进行恶意传播的行为。脚本中唯一的网络行为是向目标URL发送HTTP请求，这是利用漏洞所必需的。`poison`的概率很低，因为代码的功能比较直接，主要就是利用漏洞进行反向shell连接。`node_shell`变量中的反向shell代码段是漏洞利用的核心，虽然是恶意目的，但属于payload范畴，不应被视为投毒代码。

**漏洞利用方式：**
1.  **构造Payload：** 脚本生成包含反向shell命令的JavaScript代码。该代码被转换为decimal表示，然后嵌入到IIFE中，并使用`node-serialize`进行序列化，然后进行base64编码。
2.  **发送Payload：** 脚本通过HTTP POST请求将payload作为参数发送到目标URL，或者将其设置到cookie中。
3.  **触发反序列化：** 目标服务器接收到请求后，使用`node-serialize`的`unserialize()`函数反序列化数据。
4.  **执行代码：** 由于payload中包含恶意JavaScript代码，反序列化过程会导致代码执行，从而建立从目标服务器到攻击者机器的反向shell连接。
5.  **建立连接:** 攻击者需要监听设定的端口以接受反向shell的连接。

**项目地址:** [uartu0/nodejshell](https://github.com/uartu0/nodejshell)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---



---

## POC #4

**来源**: [CVE-2017-5941-uartu0_nodejshell.md](../2017/CVE-2017-5941-uartu0_nodejshell.md)

## CVE-2017-5941-node-serialize-远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize模块，并且允许用户可控的数据传递给unserialize函数。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941是node-serialize 0.0.4版本中的一个反序列化漏洞。攻击者可以将包含恶意JavaScript代码（例如，利用立即执行函数表达式（IIFE））的不可信数据传递给`unserialize()`函数，从而实现远程代码执行(RCE)。

**有效性分析：**
提供的Python脚本`nodejshell.py`旨在利用此漏洞。它通过构造包含反向shell payload的序列化数据，并将其作为cookie或POST参数发送到目标服务器。如果目标服务器使用`node-serialize`的`unserialize()`函数处理这些数据，恶意代码将被执行，从而在攻击者控制的机器上建立反向shell。

**投毒风险分析：**
代码检查显示，提供的Python脚本的主要功能是生成和发送恶意payload，目的是利用目标系统上的反序列化漏洞。该脚本本身并没有明显的植入后门、窃取信息或进行恶意传播的行为。脚本中唯一的网络行为是向目标URL发送HTTP请求，这是利用漏洞所必需的。`poison`的概率很低，因为代码的功能比较直接，主要就是利用漏洞进行反向shell连接。`node_shell`变量中的反向shell代码段是漏洞利用的核心，虽然是恶意目的，但属于payload范畴，不应被视为投毒代码。

**漏洞利用方式：**
1.  **构造Payload：** 脚本生成包含反向shell命令的JavaScript代码。该代码被转换为decimal表示，然后嵌入到IIFE中，并使用`node-serialize`进行序列化，然后进行base64编码。
2.  **发送Payload：** 脚本通过HTTP POST请求将payload作为参数发送到目标URL，或者将其设置到cookie中。
3.  **触发反序列化：** 目标服务器接收到请求后，使用`node-serialize`的`unserialize()`函数反序列化数据。
4.  **执行代码：** 由于payload中包含恶意JavaScript代码，反序列化过程会导致代码执行，从而建立从目标服务器到攻击者机器的反向shell连接。
5.  **建立连接:** 攻击者需要监听设定的端口以接受反向shell的连接。

**项目地址:** [uartu0/nodejshell](https://github.com/uartu0/nodejshell)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---



---

## POC #4

**来源**: [CVE-2017-5941-uartu0_nodejshell.md](../2017/CVE-2017-5941-uartu0_nodejshell.md)

## CVE-2017-5941-node-serialize-远程代码执行

**漏洞编号:** CVE-2017-5941

**漏洞类型:** 反序列化漏洞

**影响应用:** node-serialize

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 0.0.4

**利用条件:** 目标应用使用了存在漏洞的node-serialize模块，并且允许用户可控的数据传递给unserialize函数。

**POC 可用性:** 是

**投毒风险:** 1%

## 详情

CVE-2017-5941是node-serialize 0.0.4版本中的一个反序列化漏洞。攻击者可以将包含恶意JavaScript代码（例如，利用立即执行函数表达式（IIFE））的不可信数据传递给`unserialize()`函数，从而实现远程代码执行(RCE)。

**有效性分析：**
提供的Python脚本`nodejshell.py`旨在利用此漏洞。它通过构造包含反向shell payload的序列化数据，并将其作为cookie或POST参数发送到目标服务器。如果目标服务器使用`node-serialize`的`unserialize()`函数处理这些数据，恶意代码将被执行，从而在攻击者控制的机器上建立反向shell。

**投毒风险分析：**
代码检查显示，提供的Python脚本的主要功能是生成和发送恶意payload，目的是利用目标系统上的反序列化漏洞。该脚本本身并没有明显的植入后门、窃取信息或进行恶意传播的行为。脚本中唯一的网络行为是向目标URL发送HTTP请求，这是利用漏洞所必需的。`poison`的概率很低，因为代码的功能比较直接，主要就是利用漏洞进行反向shell连接。`node_shell`变量中的反向shell代码段是漏洞利用的核心，虽然是恶意目的，但属于payload范畴，不应被视为投毒代码。

**漏洞利用方式：**
1.  **构造Payload：** 脚本生成包含反向shell命令的JavaScript代码。该代码被转换为decimal表示，然后嵌入到IIFE中，并使用`node-serialize`进行序列化，然后进行base64编码。
2.  **发送Payload：** 脚本通过HTTP POST请求将payload作为参数发送到目标URL，或者将其设置到cookie中。
3.  **触发反序列化：** 目标服务器接收到请求后，使用`node-serialize`的`unserialize()`函数反序列化数据。
4.  **执行代码：** 由于payload中包含恶意JavaScript代码，反序列化过程会导致代码执行，从而建立从目标服务器到攻击者机器的反向shell连接。
5.  **建立连接:** 攻击者需要监听设定的端口以接受反向shell的连接。

**项目地址:** [uartu0/nodejshell](https://github.com/uartu0/nodejshell)

**漏洞详情:** [CVE-2017-5941](https://nvd.nist.gov/vuln/detail/CVE-2017-5941)

---

