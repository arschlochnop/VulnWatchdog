# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **27** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md](../2019/CVE-2019-5736-sonyavalo_CVE-2019-5736-Dockerattack-and-security-mechanism.md)

# CVE-2019-5736

> 📦 该CVE有 **26** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md](../2019/CVE-2019-5736-BBRathnayaka_POC-CVE-2019-5736.md)

## CVE-2019-5736-Runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** Runc

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以Root权限在受影响的容器中执行命令，或控制容器镜像

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过以下方式覆写主机上的 `runc` 二进制文件，从而获得主机 Root 权限：

1.  **利用方式：**
    *   **新的容器，攻击者控制的镜像：** 攻击者创建一个包含恶意代码的容器镜像。当容器启动时，恶意代码会尝试覆写主机上的 `runc` 二进制文件。
    *   **已存在的容器，攻击者有写入权限：** 攻击者获得对现有容器的写入权限后，可以将恶意代码写入容器的文件系统。然后，当容器执行新进程（例如使用 `docker exec`）时，恶意代码会被执行，并尝试覆写主机上的 `runc` 二进制文件。

    该漏洞的根本原因是文件描述符处理不当，与 `/proc/self/exe` 有关。通过覆写 `runc` 二进制文件，攻击者可以在下次容器启动或执行命令时执行任意代码，从而获得主机 Root 权限。

2.  **POC有效性：**
    提供的POC代码包含两种利用方式：
    *   `exec_POC`:  创建一个简单的程序，覆写runc，并打印字符串。
    *   `malicious_image_POC`: 创建一个反向shell，连接到localhost:2345，同样通过覆写runc实现。
    根据漏洞描述和搜索结果，这些POC代码可以有效利用该漏洞。

3.  **投毒风险：**
    `malicious_image_POC/new_runc` 脚本包含反向Shell连接，此为漏洞利用目的，非投毒代码。其他的Dockerfile指令，诸如apt-get等，均为构建镜像准备，非投毒行为。
 overwrite_runc.c 的作用是覆盖runC，其覆盖内容来自 /root/new_runc。因此投毒点可能存在于：
     *   `new_runc`：如果该脚本包含恶意命令，则可能构成投毒。当前脚本是反向shell,不算投毒。
     *   `overwrite_runc.c`：虽然代码功能简单是覆盖runC文件，但如果作者在编译过程中，使用不安全的编译选项，或修改代码，植入后门，则构成投毒，鉴于代码量较少，审查难度不大，且有一定必要性，该处的投毒风险较低。
     综合来看，此仓库的投毒风险较低，约为10%。主要基于假设作者在`overwrite_runc.c`的编译过程或替换的`new_runc`中植入后门。

**项目地址:** [BBRathnayaka/POC-CVE-2019-5736](https://github.com/BBRathnayaka/POC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #2

**来源**: [CVE-2019-5736-Billith_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Billith_CVE-2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致宿主机root权限被获取

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要在容器内有执行权限，且宿主机运行着存在漏洞的runc版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动或执行 `docker exec` 等命令时，`runc` 会被调用。攻击者通过在容器内构造恶意程序，修改 `/proc/self/exe` 指向的 `runc` 二进制文件。
2.  **利用步骤：**
    *   首先，攻击者需要在一个具有写权限的容器内。
    *   攻击者需要将容器内的 `/bin/sh` 或其他会被 `docker exec` 调用的程序替换为 `#!/proc/self/exe`。这样，当管理员执行 `docker exec` 命令时，实际上会执行 `runc` 二进制文件。
    *   攻击者运行提供的 PoC 代码。该 PoC 代码会不断地尝试打开 `/proc/<pid>/exe` (宿主机的runc程序) 并写入恶意代码。其中`<pid>` 是目标runc进程的进程ID
    *   当管理员在宿主机上使用 `docker exec` 命令进入容器时，实际上会调用被篡改的 `runc`，此时PoC会向runc程序写入bash脚本。
    *   下一次 `runc` 被调用时，执行的就是被篡改后的代码，攻击者即可在宿主机上执行任意命令，从而获取 root 权限。

3.  **有效性评估：** 提供的 PoC 代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的 `runc` 二进制文件。
4.  **投毒风险分析：** 提供的 PoC 代码没有明显的投毒代码。PoC 的目的是覆盖 `runc` 文件为一段 bash 脚本。

**总结：** 该漏洞危害巨大，利用条件相对简单，容易被攻击者利用进行容器逃逸，需要及时升级 `runc` 版本或者采用缓解措施。

**项目地址:** [Billith/CVE-2019-5736-PoC](https://github.com/Billith/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #3

**来源**: [CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md](../2019/CVE-2019-5736-Frichetten_CVE-2019-5736-PoC.md)

## CVE-2019-5736-Docker容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要在受影响的Docker容器中具有Root权限，或者能够通过`docker exec`进入容器

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机上的 Root 权限。该漏洞存在于 runc 1.0-rc6 及其之前版本中，影响 Docker 18.09.2 之前的版本。 

**利用方式：**

1.  **预置条件：** 攻击者需要在容器内部具有 Root 权限，或者能够通过 docker exec 等方式进入容器。同时目标主机运行着存在漏洞的runc版本。
2.  **漏洞触发：** 当容器内进程调用某个命令（如 /bin/sh）时，利用 /proc/self/exe 特性，将该命令指向宿主机的 runc 二进制文件。
3.  **覆盖 runc：** 攻击者通过文件描述符操作，在 runc 二进制文件退出时，尝试写入恶意代码，覆盖原有的 runc 二进制文件。
4.  **权限提升：** 当新的容器启动时，由于 runc 二进制文件已被篡改，恶意代码将以 Root 权限在宿主机上执行，导致容器逃逸。

**关于投毒风险：**

提供的PoC代码主要展示了漏洞利用的逻辑，即通过文件描述符覆盖宿主机上的runc二进制文件。PoC本身的功能集中于利用漏洞，没有明显的迹象表明作者有意添加恶意或后门代码。

但是，PoC的使用者需要注意以下几点：
* 恶意的使用PoC代码本身会对目标系统造成破坏。
* 攻击者可能修改PoC，添加额外的恶意代码，例如反向Shell，密钥窃取等。在使用PoC前，务必仔细审查代码，避免引入安全风险。

基于以上分析，判定代码中存在恶意投毒代码的概率较低，约为5%， 主要来自使用者恶意篡改。

**有效性：**

根据漏洞描述和PoC代码，该漏洞利用的有效性较高，漏洞库信息和搜索结果中也有相关验证信息。在满足利用条件（存在漏洞的runc版本，容器内root权限或docker exec访问）的情况下，可以成功实现容器逃逸。

**项目地址:** [Frichetten/CVE-2019-5736-PoC](https://github.com/Frichetten/CVE-2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #4

**来源**: [CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md](../2019/CVE-2019-5736-GiverOfGifts_CVE-2019-5736-Custom-Runtime.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可能导致宿主机被完全控制

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在受影响的Docker或runc版本中，拥有在容器内执行命令的权限（可以是新建容器并控制镜像，或者已存在容器的写入权限）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 当容器启动或执行 `docker exec` 时，会调用宿主机上的 `runc` 二进制文件。漏洞在于容器内的进程可以访问 `/proc/self/exe`，该文件指向宿主机上的 `runc` 二进制文件。利用此漏洞，攻击者可以通过在容器内运行恶意程序，覆盖宿主机上的 `runc` 二进制文件。

2.  **利用步骤：**
    *   **准备：** 需要一个存在漏洞的 Docker 或 runc 环境，以及在容器内执行命令的权限。
    *   **恶意镜像或文件：** 准备一个包含恶意代码的 Docker 镜像，或者利用已存在容器的写入权限上传恶意文件。该恶意代码的目的是覆盖宿主机上的 `runc` 二进制文件。从提供的代码来看，利用过程需要编译一些C代码，这些C代码首先会找到`/proc/self/exe`, 然后打开它，再利用`execve`执行编译好的`overwrite_sndbx_runtime`， 该程序会不断尝试打开先前找到的runc文件，并在容器重启或者重新`exec`的时候，通过写入恶意的`payload`到runc文件实现劫持。
    *   **触发：** 触发容器的重新启动（例如，通过 `docker restart`）或者执行 `docker exec`。当 Docker 重新调用被篡改的 `runc` 二进制文件时，恶意代码将以 root 权限在宿主机上执行。

3.  **投毒风险分析：**
    *   代码中包含一些文件下载和编译步骤，存在被替换为恶意文件的风险。特别是 `libcap` 的修改和编译，如果被替换为包含恶意代码的版本，可能会引入后门。
    *   `overwrite_sndbx_runtime.c` 中的 `DEFAULT_NEW_RUNC_PATH` 设置为 `/root/payload`，表明payload是写死的，虽然方便了POC的演示，但也降低了灵活性，如果需要更加隐蔽的攻击，这个路径需要动态配置。由于需要rootfs, 需要编译libcap, 准备payload等步骤, 完整重现该POC需要较高的技术门槛，因此投毒者可能通过提供修改过的`libcap`代码或者其他编译好的二进制文件来植入后门。
    *   `exploit_code_for_shared_lib.c`  中使用`__attribute__ ((constructor))`，该属性使得函数在链接时自动执行，为利用提供了便利，但也增加了隐藏恶意代码的可能性。

综上所述，虽然提供的代码主要集中在漏洞利用本身，但仍然存在一定的投毒风险，主要集中在编译和依赖的库文件上。务必仔细检查所有下载和编译的组件，确保其来源可靠。

**项目地址:** [GiverOfGifts/CVE-2019-5736-Custom-Runtime](https://github.com/GiverOfGifts/CVE-2019-5736-Custom-Runtime)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #5

**来源**: [CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md](../2019/CVE-2019-5736-Lee-SungYoung_cve-2019-5736-study.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 攻击者需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符来覆盖宿主机的`runc`二进制文件，从而获得宿主机的 root 访问权限。此漏洞利用涉及以下步骤：

1.  **构建恶意容器镜像:** `Dockerfile` 定义了构建镜像的步骤，包括安装构建工具、下载并编译 `libseccomp` 库，并将 `stage1.c`、`stage2.c` 和 `run.sh` 添加到镜像中。
2.  **修改`libseccomp`:**  `run.sh` 脚本将 `stage1.c` 的内容追加到 `libseccomp` 的 `src/api.c` 文件中。`stage1.c` 包含一个构造函数 `foo()`，它会在 `libseccomp` 加载时自动执行。
3.  **编译并安装修改后的`libseccomp`:**  `run.sh` 使用 `dpkg-buildpackage` 编译修改后的 `libseccomp` 库，并使用 `dpkg -i` 安装编译好的deb包. 
4.  **替换`/bin/bash`:** `run.sh` 将 `/bin/bash` 替换为一个指向 `/proc/self/exe` 的符号链接，这意味着每次执行 `/bin/bash` 实际上是执行当前的 runc 进程. 并且将原来的 `/bin/bash` 修改为 `/bin/good_bash`
5.  **编写攻击payload到`/bin/bash`:**`stage2.c` 中的代码尝试打开在参数中传递的文件（即`/bin/bash`）, 并将反向shell的bash脚本写入到其中，实现runc 二进制文件的覆盖。
6.  **触发容器操作:** 当容器启动或使用`docker exec`进入容器时，runc 进程会被调用。由于`/bin/bash`已经被篡改为指向`/proc/self/exe`，并且该文件已经被`stage2.c`修改，runc 二进制文件会被恶意代码覆盖。
7.  **容器逃逸:** 下一次宿主机调用 runc （例如，启动一个新的容器），被覆盖的 runc 二进制文件会被执行，从而允许攻击者在宿主机上执行任意代码，获得 root 权限。

**有效性:**  提供的POC代码利用了 CVE-2019-5736 漏洞，理论上是有效的，可以在未经修补的系统上实现容器逃逸。

**投毒风险:**  代码中没有明显的恶意投毒代码。虽然该漏洞本身允许攻击者在宿主机上执行任意代码，但提供的 POC 代码主要目的是为了演示漏洞，没有发现其他隐藏的恶意行为。`stage2.c`最终写入`/bin/bash`的代码为反弹shell，这个是漏洞验证的必要步骤，不能算作投毒代码。因此投毒风险可以评估为0%。

**利用方式总结:**  该漏洞利用的核心在于利用文件描述符的特性，在容器启动时覆盖宿主机的 `runc` 二进制文件。通过覆盖 `runc` 二进制文件，攻击者可以在宿主机上获得 root 权限，从而控制整个系统。

**项目地址:** [Lee-SungYoung/cve-2019-5736-study](https://github.com/Lee-SungYoung/cve-2019-5736-study)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #6

**来源**: [CVE-2019-5736-Perimora_cve_2019-5736-PoC.md](../2019/CVE-2019-5736-Perimora_cve_2019-5736-PoC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，允许容器逃逸并获取宿主机Root权限

**影响版本:** runc <= 1.0-rc6，Docker < 18.09.2

**利用条件:** 攻击者需要在容器内执行代码的能力（例如，通过docker exec连接到现有容器，或通过构建恶意镜像启动新容器），并且容器需要具有root权限。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞是runc在处理文件描述符时的一个错误，导致攻击者可以覆盖宿主机的runc二进制文件，从而获得宿主机的root权限。攻击者可以通过以下步骤利用此漏洞：

1.  **准备阶段：**
    *   攻击者需要能够在一个容器内执行代码，并且该容器需要拥有root权限。
    *   攻击者可以将恶意代码（如提供的POC）放置在容器内。

2.  **漏洞触发：**
    *   当在容器内执行`docker exec`或者创建一个新的容器时，会调用宿主机上的runc。
    *   恶意代码会尝试打开`/proc/self/exe`，并获取runc二进制文件的文件描述符。
    *   由于文件描述符处理不当，恶意代码可以覆盖宿主机上的runc二进制文件。

3.  **权限提升：**
    *   一旦runc二进制文件被覆盖，下次任何容器操作（例如`docker exec`或`docker run`）都会执行被替换的恶意代码，从而允许攻击者在宿主机上以root权限执行任意命令。

**有效性评估：**

根据漏洞描述和搜索结果，提供的POC代码是有效的，可以用于利用CVE-2019-5736漏洞。

**投毒风险评估：**

提供的POC代码主要功能是替换宿主机上的`runc`二进制文件，并执行预先设定的命令。检查`Makefile`，`src/exploit.c`和`src/main.c`，发现其功能是编译和执行漏洞利用，并没有发现明显的恶意代码。但是存在一定的投毒风险，因为：

*   **自定义命令执行：** 漏洞利用允许攻击者在宿主机上执行任意命令。虽然默认的POC可能只是复制`/etc/shadow`，但攻击者可以修改`-c`参数来执行更具破坏性的操作，例如安装后门或删除关键文件。
*   **依赖外部脚本：**  `scripts` 目录下的脚本负责环境搭建和漏洞触发，攻击者可能会在这些脚本中添加恶意逻辑，例如下载并执行恶意程序。

因此，虽然直接的POC代码没有明显的投毒特征，但其灵活性和对外部脚本的依赖使得投毒风险依然存在。建议用户在使用前仔细审查所有代码和脚本，确保其安全性。

**项目地址:** [Perimora/cve_2019-5736-PoC](https://github.com/Perimora/cve_2019-5736-PoC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #7

**来源**: [CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md](../2019/CVE-2019-5736-RyanNgWH_CVE-2019-5736-POC.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能在受影响的容器中执行命令，且拥有root权限（新建容器使用攻击者控制的镜像，或者已存在的容器之前拥有写权限，并使用docker exec连接)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。漏洞利用方式如下：

1.  **攻击条件：**
    *   攻击者需要能够以 root 身份在容器内执行命令。
    *   受影响的 runc 版本 (<= 1.0-rc6) 和 Docker 版本 (低于 18.09.2)。
    *   攻击者需要有权限创建一个新的容器并控制镜像，或者对已存在的容器有写权限并能使用 `docker exec` 连接到该容器。

2.  **漏洞利用过程：**
    *   攻击者构建一个包含恶意代码的容器镜像（如提供的 Dockerfile）。
    *   恶意镜像中的代码会尝试打开 `/proc/self/exe`（即 runc 二进制文件）的文件描述符，并保持打开状态。
    *   当 Docker 或其他容器管理工具执行 `docker exec` 或启动新的容器时，会复用该文件描述符。
    *   恶意代码随后会覆盖该文件描述符指向的 runc 二进制文件，替换为攻击者控制的恶意代码。
    *   下次宿主机调用被篡改的 runc 二进制文件时（例如启动新的容器），就会执行攻击者的恶意代码，从而获得宿主机的 root 权限。

3.  **POC 分析：**
    提供的 POC 代码实现以下步骤：
    *   Dockerfile: 构建包含恶意代码的镜像。
        *   安装构建依赖并获取 `libseccomp` 源码。
        *   向 `libseccomp` 的源代码中添加自定义的 `run_at_link` 函数（未提供具体代码，但推测该函数用于在链接时执行某些操作）。
        *   编译 `libseccomp` 并安装。
        *   添加 `overwrite_runc.c`，用于覆盖宿主机的 `runc` 二进制文件。
        *   添加 `new_runc` 脚本，该脚本包含将在宿主机上执行的恶意操作，例如安装 VNC 服务器。
        *   创建一个指向 `/proc/self/exe` 的符号链接 `/entrypoint`，并将其设置为容器的入口点。
    *   `new_runc`:  Bash 脚本，用于在宿主机上安装 VNC 服务器，以便攻击者可以远程访问宿主机桌面环境。
    *   `overwrite_runc.c`: C 语言程序，用于覆盖宿主机的 runc 二进制文件。它读取 `new_runc` 脚本的内容，然后将其写入 runc 文件描述符。

4. **有效性评估:**
    此POC代码有效，利用了文件描述符劫持的漏洞, 能够成功覆盖宿主机上的runC二进制文件，从而控制宿主机。

5.  **投毒风险分析：**
    虽然主要目的是利用漏洞，但代码中存在潜在的投毒风险。
    *   `new_runc` 脚本安装 VNC 服务器，这本身可能被视为一种后门行为。攻击者可以通过 VNC 连接到宿主机，并执行任意操作。
    *   `run_at_link.c` 代码未提供，可能包含更隐蔽的恶意代码。
    
    综合评估，存在一定的投毒风险，约10%。主要风险来自于`new_runc`脚本和未提供的`run_at_link.c`，前者直接在宿主机上安装VNC服务。

6.  **缓解措施：**
    *   升级 runc 到 1.0-rc7 或更高版本。
    *   升级 Docker 到 18.09.2 或更高版本。
    *   使用 AppArmor 或 SELinux 等安全工具限制容器的权限。
    *   监控容器的行为，检测异常的文件访问和进程创建。


**项目地址:** [RyanNgWH/CVE-2019-5736-POC](https://github.com/RyanNgWH/CVE-2019-5736-POC)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #8

**来源**: [CVE-2019-5736-agppp_cve-2019-5736-poc.md](../2019/CVE-2019-5736-agppp_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到一个具有写权限的已存在容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736漏洞允许攻击者通过覆盖宿主机的runc二进制文件来获取宿主机的root访问权限。攻击者需要在容器内部以root身份运行代码，通过文件描述符的处理不当，利用`/proc/self/exe`来修改宿主机上的runc二进制文件。之后，当宿主机需要通过runc创建或者管理容器时，将会执行被篡改过的runc二进制文件，从而导致攻击者在宿主机上执行任意代码。

**漏洞利用方式：**

1.  **Dockerfile准备：**  Dockerfile用于构建包含漏洞利用代码的镜像。它安装必要的编译工具，并添加利用程序 `stage1.c`, `stage2.c`和执行脚本`run.sh`。
2.  **stage1.c：**  这个C程序在容器启动时执行，主要目的是打开`/proc/self/exe`文件，获取runc二进制文件的文件描述符，然后执行`stage2`程序，并将文件描述符传递给它。
3.  **stage2.c：**  这个C程序接收`stage1.c`传递过来的文件描述符，然后尝试打开该文件描述符对应的文件（即宿主机的runc二进制文件），并写入恶意代码。恶意代码通常是一个反向shell，用于连接攻击者的服务器。
4.  **run.sh：**  这个脚本编译`stage1.c` 和`stage2.c`，然后修改`/bin/bash`的内容，使得每次运行bash实际上是执行`/proc/self/exe`，也就是宿主机的runc二进制文件。
5.  **容器运行和利用：**  首先，备份宿主机上的runc二进制文件。然后，在Docker容器中运行利用脚本。当Docker需要再次调用runc时，就会执行被篡改的runc，从而在宿主机上执行恶意代码。

**有效性：**
根据提供的漏洞信息和利用代码，此POC代码是有效的。它可以利用文件描述符的漏洞来覆盖宿主机上的runc二进制文件，从而实现容器逃逸。

**投毒风险：**
分析提供的POC代码，没有发现明显的投毒代码。提供的代码主要是用于利用CVE-2019-5736漏洞来获得宿主机的root权限。当然，利用成功后，恶意用户可以进一步植入后门或者执行其他恶意操作。因此，投毒风险评估为0%。代码目的明确，就是为了验证和利用该漏洞，没有其他隐藏的恶意行为。

**项目地址:** [agppp/cve-2019-5736-poc](https://github.com/agppp/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #9

**来源**: [CVE-2019-5736-b3d3c_poc-cve-2019-5736.md](../2019/CVE-2019-5736-b3d3c_poc-cve-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器中执行命令（无论是新创建的容器使用攻击者控制的镜像，还是已存在的容器攻击者具有写入权限并可使用docker exec附加）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。

**利用方式：**

1.  攻击者需要在具有漏洞的Docker版本中使用runc。
2.  攻击者需要在容器中拥有root权限，可以通过两种方式实现：
    *   创建一个新的容器，使用攻击者控制的镜像。
    *   攻击者已经对现有容器拥有写入权限，并且可以使用`docker exec`命令附加到该容器。
3.  利用代码首先更新apt源并安装必要的编译工具和依赖库libseccomp。
4.  然后，它会创建一个名为`stage1.c`的C程序，该程序会在容器启动时运行（通过`__attribute__ ((constructor))`）。`stage1.c`尝试打开`/proc/self/exe`（即runc二进制文件），获取其文件描述符，然后执行`/stage2`，并将runc的文件描述符作为参数传递。
5.  利用代码创建另一个名为`stage2.c`的C程序。`stage2.c`接收`/proc/self/exe`的文件描述符，打开该文件，并写入恶意bash脚本。恶意bash脚本的功能是：读取宿主机的`/etc/shadow`文件，将其复制到容器的`/root/shadow.txt`，然后使用`docker cp`命令将`/root/shadow.txt`复制到名为`test`的容器中。这个步骤需要Docker CLI可用和正确配置。
6.  利用代码将`/bin/bash`重命名为`/bin/good_bash`，然后创建一个符号链接，将`/bin/bash`指向`/proc/self/exe`，从而使得后续执行的bash命令实际上是执行runc二进制文件（已经被stage2.c修改）。
7.  关键在于`/proc/self/exe`允许容器内的进程访问宿主机上的runc二进制文件，攻击者通过覆盖这个文件来实现容器逃逸。

**有效性：**

提供的PoC代码是有效的，它演示了如何覆盖宿主机上的runc二进制文件。成功利用该漏洞可以使攻击者在宿主机上执行任意命令，从而完全控制宿主机。

**投毒风险：**

该PoC代码本身的目的在于演示漏洞，但存在一定的投毒风险。例如，`stage2.c`中写入的文件`/root/shadow.txt`，虽然目的是为了复制`/etc/shadow`，但恶意攻击者可能会修改写入的内容，植入更隐蔽的后门代码。代码里使用了sed修改源列表，apt安装软件包,这些都是常见的持久化后门植入点.此外，`/bin/bash`被替换成指向runc二进制文件的符号链接，这可能导致宿主机上的其他容器出现异常行为.总体评估投毒风险为10%。

**项目地址:** [b3d3c/poc-cve-2019-5736](https://github.com/b3d3c/poc-cve-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #10

**来源**: [CVE-2019-5736-chosam2_cve-2019-5736-poc.md](../2019/CVE-2019-5736-chosam2_cve-2019-5736-poc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（无论是通过创建新容器并控制镜像，还是通过 docker exec 进入具有写入权限的现有容器）。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。

**有效性：**
提供的POC代码有效。它包含以下几个步骤：
1.  **构建恶意镜像：**Dockerfile 构建了一个包含漏洞利用程序的 Ubuntu 镜像。它安装了必要的编译工具和 libseccomp 的构建依赖项。
2.  **注入恶意代码：** stage1.c 和 stage2.c 是漏洞利用的核心。stage1.c 是一个在程序启动时自动执行的构造函数，它尝试打开 `/proc/self/exe`（即 runc 二进制文件），然后执行 stage2.c。stage2.c 尝试打开通过参数传递的文件描述符，用恶意的 bash 脚本（反弹 shell）覆盖该文件。
3.  **替换 /bin/bash:**  run.sh脚本将 /bin/bash 替换为指向 /proc/self/exe 的符号链接，这样当容器内部执行 /bin/bash 时，实际上执行的是被覆盖的 runc 二进制文件中的恶意代码。
4.  **利用：** 容器启动时，libseccomp的修改触发 stage1, stage2运行，覆盖 host 上的 /usr/bin/docker-runc。

**投毒风险：**
代码仓库中存在一定程度的投毒风险。主要体现在以下几个方面：
*   **反弹shell地址：** stage2.c 中包含一个硬编码的反弹 shell 地址。如果攻击者修改了这个地址，他们可以控制受害者机器。  虽然它展示了漏洞利用，但也可能被恶意利用，但主要目的是演示漏洞，不是隐藏的恶意行为。
*   **依赖项：** Dockerfile 中安装了多个软件包。如果其中任何一个软件包被恶意篡改，可能会导致额外的安全问题。虽然可能性较小，但无法完全排除。
*   **构建脚本：** run.sh 脚本的复杂性增加了一定的投毒可能性。恶意攻击者可能会在构建过程中插入额外的恶意代码。但分析发现脚本本身是为了成功完成漏洞利用而设计的，主要目的是编译和准备利用程序所需的组件。其目的是为了成功利用漏洞，而非隐藏的恶意行为。

综合分析，投毒风险约为10%，主要集中在反弹shell被利用、依赖被污染、构建脚本被篡改等可能性。代码的主要目标是演示漏洞利用本身。

**利用方式：**
1.  攻击者需要构建一个包含恶意代码的 Docker 镜像，或者通过 docker exec 进入具有写入权限的现有容器。
2.  当容器启动或执行命令时，恶意代码会尝试覆盖宿主机上的 runc 二进制文件。
3.  成功覆盖 runc 后，下次容器运行时，宿主机上的 runc 会执行恶意代码，从而允许攻击者获得宿主机的 root 权限。
4.  POC中反弹shell，允许攻击者远程控制宿主机。

**项目地址:** [chosam2/cve-2019-5736-poc](https://github.com/chosam2/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #11

**来源**: [CVE-2019-5736-epsteina16_Docker-Escape-Miner.md](../2019/CVE-2019-5736-epsteina16_Docker-Escape-Miner.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6

**利用条件:** 需要能够以root身份在受影响的容器内执行命令，或者能够写入现有容器的文件系统

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 访问权限。漏洞利用过程如下：

1.  攻击者需要在一个存在漏洞的 Docker 环境中运行一个恶意的容器，或者已经具有对现有容器的写权限。
2.  Dockerfile 首先更新并安装构建 libseccomp 所需的依赖项，然后下载 libseccomp 的源代码。
3.  Dockerfile 修改了 libseccomp-2.3.1/src/api.c 文件，附加了 run_at_link.c 中的代码，然后重新构建 libseccomp。
4.  Dockerfile 添加了 overwrite_runc.c 文件，并将其编译为 /overwrite_runc 二进制文件。
5.  Dockerfile 添加了 new_runc 文件，该文件用于替换宿主机上的 runc 二进制文件，其中包含运行挖矿程序的恶意代码。
6.  Dockerfile 创建了一个指向 /proc/self/exe 的符号链接 /entrypoint，并将其设置为容器的入口点。
7.  当容器启动时，/entrypoint（即 /proc/self/exe，也就是 runc 进程）会被调用。
8.  在容器内部执行的 overwrite_runc 程序利用 /proc/self/exe 访问 runc 二进制文件，并用恶意脚本 new_runc 的内容覆盖它。
9.  当 Docker 容器关闭时，被覆盖的 runc 二进制文件会被执行，从而启动一个后台的 bitcoin 挖矿进程。

**有效性评估：** 根据漏洞描述和公开的PoC代码，该漏洞利用的有效性较高，因为已经有公开可用的exp，并且被多个安全厂商证实。

**投毒风险分析：** 代码主要目的是利用漏洞在宿主机上运行挖矿程序。虽然核心是利用该漏洞进行提权，但随后执行了挖矿脚本，使得被攻击主机的资源被消耗。`new_runc`脚本中，包含python挖矿程序，有投毒嫌疑，占比10%，因为攻击利用该漏洞进行加密货币挖掘。

**利用方式总结：**

*   攻击者首先获得在受影响的 Docker 环境中创建容器的能力。
*   然后，攻击者构建一个包含恶意代码的 Docker 镜像。
*   当创建的容器启动时，它会覆盖主机上的 runc 二进制文件。
*   当下一次运行任何容器时，将以 root 权限执行攻击者的恶意代码。

**项目地址:** [epsteina16/Docker-Escape-Miner](https://github.com/epsteina16/Docker-Escape-Miner)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #12

**来源**: [CVE-2019-5736-fahmifj_Docker-breakout-runc.md](../2019/CVE-2019-5736-fahmifj_Docker-breakout-runc.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker before 18.09.2

**利用条件:** 需要能够以root身份在受影响的容器内执行命令（通过创建新容器或docker exec现有容器）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过操控文件描述符，覆盖宿主机上的runc二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **漏洞原理：** 容器启动时，runc 会打开 `/proc/self/exe` 文件，该文件指向 runc 自身的二进制文件。由于文件描述符处理不当，攻击者可以在容器启动后保持对 runc 二进制文件的文件描述符的引用。
2.  **利用条件：** 攻击者需要在容器内部以 root 权限运行代码，这可以通过两种方式实现：
    *   创建一个包含恶意镜像的新容器。
    *   使用 `docker exec` 连接到攻击者具有写入权限的现有容器。
3.  **攻击步骤：**
    *   **替换 `/bin/sh`：** 将容器内的 `/bin/sh` 替换为一个解释器脚本，该脚本会在 runc 被执行时被调用。该解释器脚本会将 `/proc/self/exe` 的内容（即 runc 二进制文件）覆盖为恶意代码。
    *   **寻找 runc 进程：** 通过扫描 `/proc` 目录，找到正在运行的 runc 进程的 PID。
    *   **打开 `/proc/<runc_pid>/exe`：**  尝试打开 runc 进程对应的 `/proc/<runc_pid>/exe` 文件，并获取文件描述符。
    *   **覆盖 runc 二进制文件：**  使用获取到的文件描述符，通过 `/proc/self/fd/<fd>` 覆盖宿主机上的 runc 二进制文件。
    *   **触发漏洞：** 当 Docker 或其他容器管理工具再次调用 runc 时，被覆盖的恶意代码将以 root 权限在宿主机上执行。

**有效性：** 提供的PoC代码基本有效，能够利用该漏洞实现容器逃逸。但是，该PoC代码可能需要根据实际环境进行调整，例如，文件描述符的值可能因环境而异。

**投毒风险：** 仓库存在一定的投毒风险，概率约为10%。
    *   该仓库中提供的`README.md`和`main.go`文件本身实现了CVE-2019-5736漏洞的利用，即容器逃逸，在未打补丁的环境下具有真实危害。
    *   但由于代码功能比较集中，且逻辑相对简单，可以判定作者未在PoC中隐藏额外的后门，或具备其他危害的恶意代码。
    *   存在的风险在于，攻击者可能在下载的 PoC 代码中添加自己的恶意代码，然后再传播，从而达到攻击其他用户的目的。该风险并非源于作者本身，而是代码传播的潜在风险。


**项目地址:** [fahmifj/Docker-breakout-runc](https://github.com/fahmifj/Docker-breakout-runc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #13

**来源**: [CVE-2019-5736-geropl_CVE-2019-5736.md](../2019/CVE-2019-5736-geropl_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致主机Root权限泄露

**影响版本:** 1.0-rc6之前版本

**利用条件:** 需要攻击者控制的容器镜像或对现有容器的写权限，并通过docker exec等方式附加到容器

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用 runc 中的文件描述符处理不当问题，覆盖主机上的 runc 二进制文件，从而获得主机 root 权限。攻击者需要在受影响的 Docker 或其他容器环境中拥有一定权限：

1.  **有效性：** 根据漏洞描述、搜索引擎结果和提供的PoC代码，该漏洞利用是有效的。 搜索引擎结果中很多文章都提到了该漏洞可以导致容器逃逸并获取主机root权限。PoC代码中也包含了expolit.c文件，用于修改run二进制文件。
2.  **投毒风险：** PoC 代码中存在一定投毒风险。主要体现在以下几个方面：
    *   **README.md的警告：**  明确指出该漏洞利用具有破坏性，会覆盖主机上的 `/usr/bin/docker-runc` 二进制文件，还会覆盖容器内的 `/bin/sh`。虽然这是漏洞利用的正常结果，但如果攻击者恶意修改 `payload.c`，可能会对主机造成更大的损害。
    *   **payload.c 的可修改性：**  `payload.c` 包含反向 shell 代码，允许攻击者连接到容器并执行命令。攻击者可能会修改此文件，植入恶意代码，从而在受害者主机上执行任意操作。虽然提供的代码是简单的反向shell，但是如果利用人员修改payload，可能会造成更大的损失
    *   **pwn.sh的潜在恶意行为：** `pwn.sh` 脚本循环扫描 `/proc/*/exe`，寻找 `runc` 进程并尝试利用。攻击者可能修改此脚本，使其在找到目标进程后执行其他恶意操作，例如安装后门或窃取敏感数据。

    因此，虽然漏洞利用本身是公开的，但攻击者可以通过修改 PoC 代码中的 `payload.c` 或 `pwn.sh` 来植入恶意代码，增加投毒风险。概率估计为10%。

3.  **利用方式：** 漏洞利用方式如下：
    1.  **准备阶段：** 攻击者需要构建包含漏洞利用代码的恶意镜像，或者获得对现有容器的写入权限。
    2.  **部署 Payload：** 攻击者将编译好的 `exploit` 和 `payload` 放入容器中。
    3.  **执行漏洞利用：** 运行 `pwn.sh` 脚本，该脚本会循环扫描 `/proc/*/exe`，找到 `runc` 进程对应的 `/proc/<pid>/exe` 文件。
    4.  **覆盖 runc 二进制文件：** `exploit.c` 代码会打开 `/proc/<pid>/exe` 文件，并使用 `payload.c` 编译后的二进制内容覆盖它。  `payload.c` 包含反向 shell 代码，用于连接到攻击者的服务器。
    5.  **触发漏洞：** 当主机执行 `docker exec` 等命令时，会重新调用被覆盖的 runc 二进制文件，此时实际上执行的是 `payload.c` 中的恶意代码，从而建立反向 shell 连接，攻击者获得主机 root 权限。

简单来说，攻击者通过文件描述符覆盖了宿主机的runc程序，当宿主机调用runc时，相当于执行攻击者的代码。


**项目地址:** [geropl/CVE-2019-5736](https://github.com/geropl/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #14

**来源**: [CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md](../2019/CVE-2019-5736-h3x0v3rl0rd_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够在受影响的容器中以root身份执行命令，或者拥有对现有容器的写入权限并通过docker exec附加到该容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过利用文件描述符处理不当的问题，覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 权限。攻击者可以在以下两种情况下利用此漏洞：

1.  **新的容器，攻击者控制镜像：** 攻击者可以创建一个包含恶意代码的容器镜像。
2.  **已存在的容器，攻击者拥有写入权限：** 攻击者可以修改容器内的文件，并在之后使用 `docker exec` 命令附加到该容器。

**利用方式：**

1.  **利用 /proc/self/exe:**  容器内的进程可以通过 `/proc/self/exe` 访问到 runc 的二进制文件。
2.  **文件描述符泄露：** runc 在创建容器时，会将自身的文件描述符传递给容器内的进程。
3.  **覆盖 runc 二进制文件：** 攻击者可以利用泄露的文件描述符，以写模式打开宿主机的 runc 二进制文件，并使用恶意代码覆盖它。
4.  **触发漏洞：** 当宿主机再次使用被篡改的 runc 二进制文件启动容器时，恶意代码将在宿主机上以 root 权限执行。

**POC代码分析：**

提供的POC代码首先会将`/bin/sh`替换为指向`/proc/self/exe`的解释器路径，这意味着每次调用 `/bin/sh` 都会执行当前的 `runc` 二进制文件。 然后，它会循环遍历 `/proc` 目录查找包含 `runc` 字符串的进程，确定目标 `runc` 进程的PID，并尝试获取该 `runc` 进程对应的宿主机上的 `runc` 二进制文件描述符。成功获取文件描述符后，它会用恶意payload覆盖该二进制文件。恶意payload是一个反弹shell脚本，它会将宿主机的shell反弹到攻击者的指定IP和端口。

**有效性评估：**

根据漏洞信息、搜索结果和提供的POC代码，该POC代码是有效的，能够利用 CVE-2019-5736 漏洞实现容器逃逸。

**投毒风险评估：**

提供的代码的核心功能是利用漏洞进行容器逃逸，没有发现恶意或隐藏的、与漏洞利用无关的代码。虽然该payload本身用于建立反向shell可用于恶意目的，但这是漏洞利用的预期行为，不属于投毒。因此，投毒风险为 0%。

**项目地址:** [h3x0v3rl0rd/CVE-2019-5736](https://github.com/h3x0v3rl0rd/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #15

**来源**: [CVE-2019-5736-jas502n_CVE-2019-5736.md](../2019/CVE-2019-5736-jas502n_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可导致容器逃逸，获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在容器内执行命令（可以是新容器，或者已有的具有写权限的容器），并在宿主机上执行docker exec等操作

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操控容器内的文件描述符，覆写宿主机上的runc二进制文件，当宿主机执行`docker exec`等操作时，会执行被覆写的恶意runc二进制文件，从而获得宿主机root权限。

**漏洞利用有效性分析：**

根据漏洞库信息、搜索引擎结果以及提供的漏洞利用代码，可以判断此漏洞的POC代码是有效的。漏洞描述明确指出攻击者可以通过特定的方法覆盖宿主机的runc二进制文件，从而获得宿主机的root访问权限。提供的代码包括了`exploit.c`、`payload.c`和`pwn.sh`，分别用于利用漏洞和执行恶意操作。漏洞利用脚本 `pwn.sh` 会不断扫描 `/proc/*/exe` 寻找 runc 进程，并利用 `exploit` 程序尝试覆盖 `/usr/bin/docker-runc`。

**投毒风险分析：**

分析提供的代码，发现以下潜在的风险点：

*   `payload.c`: 这是一个反向shell的payload，默认连接 `127.0.0.1:4455`。**如果攻击者修改了此IP地址，可能会连接到攻击者控制的服务器，构成潜在的后门。** 尽管当前代码连接的是本地地址，但在实际利用中，攻击者完全可以修改。
*   `exploit.c`:  该程序负责打开目标文件 `/proc/${pid}/exe` 并且进行覆盖，本身功能较为直接，投毒可能性较低。
*   `pwn.sh`:  该脚本主要负责查找目标进程并执行漏洞利用，投毒可能性较低。
*   `README.md`: 提到该exploit具有破坏性，会覆盖 `/usr/bin/docker-runc`。这是漏洞利用的正常行为，但可能被误解为投毒，实际这是漏洞利用方式。

**综合分析，投毒的风险主要集中在 `payload.c` 中潜在的后门连接，以及利用本身的破坏性。** 尽管大部分代码功能明确，但是依然存在被修改后植入恶意代码的可能性。因此，投毒风险评估为10%。

**漏洞利用方式总结：**

1.  **准备阶段：** 在容器内部，需要准备好编译环境（例如gcc）和相关依赖。修改`payload.c`中的`HOST`，指向攻击者控制的服务器，并编译`exploit.c`和`payload.c`。
2.  **寻找目标：** 运行`pwn.sh`脚本，该脚本会循环扫描`/proc/*/exe`，寻找包含`runc`的进程。
3.  **文件覆盖：**  找到目标进程后，`exploit`程序会尝试以`O_WRONLY | O_TRUNC`模式打开`/proc/${pid}/exe`（即宿主机的runc二进制文件），并将编译好的`payload`写入该文件。
4.  **触发漏洞：**  当宿主机执行`docker exec`等命令时，会调用被覆盖的runc二进制文件，从而执行`payload`，建立反向shell连接，攻击者获得宿主机root权限。

**项目地址:** [jas502n/CVE-2019-5736](https://github.com/jas502n/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #16

**来源**: [CVE-2019-5736-likekabin_CVE-2019-5736.md](../2019/CVE-2019-5736-likekabin_CVE-2019-5736.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes)

**危害等级:** 高危，允许容器内的攻击者获取主机 root 权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器中拥有执行代码的能力（例如，通过控制镜像或 docker exec）

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者通过覆盖主机上的 `runc` 二进制文件来逃逸容器。该漏洞的利用方式如下：

1.  **漏洞原理：** 当使用 `docker exec` 或创建新的容器时，`runc` 会被调用。漏洞利用的关键在于 `/proc/self/exe` 文件描述符的处理，攻击者可以利用此文件描述符来写入主机上的 `runc` 二进制文件。
2.  **利用条件：** 攻击者需要具备在目标容器内执行代码的能力，并且目标主机运行着存在漏洞版本的 Docker 或其他使用 runc 的容器平台。
3.  **利用步骤：**
    *   **准备 Payload：** 攻击者需要创建一个 Payload，该 Payload 将替换主机上的 `runc` 二进制文件。Payload 可以是任何可执行代码，例如反向 shell。
    *   **利用 exploit.c:** `exploit.c`首先打开`/proc/[pid]/exe`,然后使用恶意payload覆盖runc二进制文件。
    *   **触发漏洞：** 攻击者通过`docker exec`命令或创建新容器来触发漏洞。当主机尝试调用被篡改的 `runc` 二进制文件时，Payload 将以 root 权限执行。

4.  **代码分析：**
    *   `payload.c`：这是一个简单的反向 shell Payload，连接到攻击者指定的 IP 地址和端口。
    *   `exploit.c`：该程序尝试打开 `/proc/*/exe`，查找运行的 `runc` 进程，并使用 Payload 覆盖它。
    *   `pwn.sh`：该脚本在容器内部循环查找runC的进程，并且执行`exploit.c`进行覆盖。
    *   `README.md`：说明了漏洞利用方法，以及漏洞利用具有破坏性，会覆盖宿主机上的`/usr/bin/docker-runc`二进制文件,还覆盖了容器内的`/bin/sh`。

5.  **投毒风险分析：**
    *   该代码仓库的主要目的是提供 CVE-2019-5736 漏洞的 PoC。虽然总体目的是为了展示漏洞，但存在潜在的投毒风险，例如：
    *   `payload.c` 中的恶意 IP 地址或端口：攻击者可能会修改 `payload.c`，将反向 shell 连接到恶意 IP 地址或端口，从而控制受害者主机。
    *   `exploit.c` 中的后门：攻击者可能会在 `exploit.c` 中添加额外的代码，例如安装后门或收集敏感信息。
    *   根据经验和代码检查，该仓库中作者隐藏的投毒代码可能性较低，约为 10%。这个PoC主要用来验证漏洞，但使用者仍然需要仔细检查代码，确保没有恶意修改。

6.  **有效性评估：**
    *   根据漏洞描述、搜索结果和 PoC 代码，该漏洞利用是有效的。成功利用该漏洞可以使攻击者获得主机的 root 权限。

7.  **缓解措施：**
    *   升级 Docker 到 >= 18.09.2 或更新的 runc 版本。
    *   实施容器安全策略，限制容器的权限。
    *   使用安全扫描工具检测容器镜像中的漏洞。

总之，CVE-2019-5736 是一个严重的安全漏洞，需要及时修复。在使用 PoC 代码时，务必谨慎，并仔细检查代码是否存在恶意修改。

**项目地址:** [likekabin/CVE-2019-5736](https://github.com/likekabin/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #17

**来源**: [CVE-2019-5736-likekabin_cve-2019-5736-poc.md](../2019/CVE-2019-5736-likekabin_cve-2019-5736-poc.md)

## CVE-2019-5736 - runc 容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，允许恶意容器用户获得宿主机的 root 权限。

**影响版本:** runc <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要在受影响的容器内以 root 身份执行命令。可能需要攻击者控制的镜像或已经具有写入权限的现有容器。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞是 runc 中的一个文件描述符处理错误，允许攻击者覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 访问权限。

**利用方式：**

1.  攻击者需要能够以 root 身份在容器内执行代码。这可以通过两种方式实现：
    *   **新容器，攻击者控制镜像：** 攻击者创建一个包含恶意代码的 Docker 镜像。
    *   **现有容器，攻击者具有写入权限：** 攻击者首先获得对现有容器的写入权限（例如，通过另一个漏洞），然后注入恶意代码。
2.  容器内的恶意代码利用 `/proc/self/exe` 打开 runc 二进制文件，并将其文件描述符传递给容器内的另一个进程。
3.  当 Docker 容器启动新进程时，会调用宿主机上的 runc 二进制文件。由于存在文件描述符处理错误，容器内的恶意进程可以利用该文件描述符覆盖宿主机上的 runc 二进制文件。
4.  下次 runc 被调用时（例如，启动另一个容器），恶意代码就会以 root 权限在宿主机上执行。

**POC代码分析：**

*   `Dockerfile`: 用于构建包含攻击代码的镜像。它首先安装编译工具和依赖项，然后将 `stage1.c` 和 `stage2.c` 添加到镜像中，并编译 `stage2.c`。
*   `stage1.c`: 这是一个在容器启动时执行的 C 代码。它打开 `/proc/self/exe` (即 runc 二进制文件)，并使用 `execve` 调用 `/stage2`，将 runc 的文件描述符传递给 `stage2`。
*   `stage2.c`: 这是一个 C 代码，它接收 runc 的文件描述符，并向其中写入字符串 "cve-2019-5736"，从而修改宿主机上的 runc 二进制文件。
*   `README`: 提供运行 POC 的说明。

**有效性：**
提供的 POC 代码是有效的，它可以用于演示 CVE-2019-5736 漏洞。该 POC 通过修改宿主机上的 runc 二进制文件来证明漏洞的存在。

**投毒风险：**
该 POC 代码本身没有明显的投毒代码。该代码的目的是修改宿主机上的 runc 二进制文件以证明漏洞的存在。没有发现作者隐藏的其他恶意功能或后门。因此投毒风险为0%。

**项目地址:** [likekabin/cve-2019-5736-poc](https://github.com/likekabin/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #18

**来源**: [CVE-2019-5736-milloni_cve-2019-5736-exp.md](../2019/CVE-2019-5736-milloni_cve-2019-5736-exp.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker等)

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要控制容器内的root权限，或者能够通过docker exec进入容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许恶意容器覆盖宿主机上的runc二进制文件，从而获得宿主机的root权限。该漏洞的利用方式是：

1.  **攻击准备：** 攻击者需要有一个可以执行命令的容器环境，这个容器可以是新创建的（攻击者控制镜像），也可以是已存在的（攻击者之前拥有写权限，可以通过`docker exec`进入）。
2.  **漏洞触发：** 在容器内，攻击者运行恶意程序（如`evil.c`编译后的`/evil`）。
3.  **文件描述符劫持：** 恶意程序利用`/proc/self/fd/3`文件描述符，该描述符指向runc的二进制文件。
4.  **覆盖runc二进制文件：** 恶意程序将预先准备好的payload（如`/payload`）写入`/proc/self/fd/3`，从而覆盖宿主机上的runc二进制文件。
5.  **权限提升：** 下次运行runc时（例如启动新的容器），宿主机将会执行被覆盖的payload，从而获得宿主机的root权限。

**有效性：** 提供的POC代码是有效的，它演示了如何利用该漏洞覆盖宿主机上的runc二进制文件。

**投毒风险：** 提供的代码中，`evil.c`负责覆盖runc二进制文件，`payload`负责在runc被覆盖后执行恶意命令。`/payload` 文件非常简单，只包含一行`echo "YOU HAVE BEEN PWNED"`。投毒风险主要在于：

*   **`evil.c`**: 潜在的风险在于，攻击者可能在`evil.c`中添加额外的恶意代码，例如反弹shell、安装后门等。虽然提供的代码只是简单地将`/payload`写入runc，但攻击者可以修改该程序以执行更复杂的操作。如果对编译后的`evil`二进制文件进行反编译，可能会发现隐藏的恶意行为。
*   **`/payload`**: 攻击者可以修改 `/payload` 的内容，从而在宿主机上执行任意命令。`/payload` 的内容决定了容器逃逸后在宿主机上执行的操作。
*  **Dockerfile**: Dockerfile存在通过替换glibc来引入其他恶意代码的风险。虽然提供的Dockerfile似乎是为了编译和安装`evil.c`，存在加入其他恶意代码的可能。

由于以上风险分析，投毒风险比例判断为 10%。主要是作者可能修改了提供的代码，以添加更隐蔽的恶意行为。

**利用方式总结：** 该漏洞利用了runc处理文件描述符的缺陷，允许容器内的进程修改宿主机上的runc二进制文件。通过覆盖runc，攻击者可以在下次runc被调用时执行任意代码，从而实现容器逃逸并获得宿主机的root权限。

**项目地址:** [milloni/cve-2019-5736-exp](https://github.com/milloni/cve-2019-5736-exp)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #19

**来源**: [CVE-2019-5736-panzouh_Docker-Runc-Exploit.md](../2019/CVE-2019-5736-panzouh_Docker-Runc-Exploit.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可获取主机Root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够在容器内以root权限执行命令，可以是新建的恶意镜像容器，或者已有写入权限的容器。

**POC 可用性:** 是

**投毒风险:** 5%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意构造的容器镜像或已获得写入权限的容器，覆盖宿主机的 runc 二进制文件，从而在后续容器启动或执行 docker exec 时获得宿主机的 root 权限。

**利用方式：**

1.  **准备阶段：** 攻击者需要能够控制一个容器的环境。这可以通过创建一个包含恶意代码的新容器镜像或者攻击一个已存在的容器，并获得该容器的写入权限来实现。
2.  **覆盖runc:** 在容器内，攻击者利用文件描述符处理不当的漏洞，将恶意代码写入到宿主机上的 `/proc/self/exe` 所指向的 runc 二进制文件。
3.  **触发执行：** 下一次启动容器或执行 `docker exec` 命令时，宿主机将执行被覆盖的恶意 runc 二进制文件，从而允许攻击者在宿主机上以 root 权限执行任意命令。

**关于投毒风险的分析：**

提供的Dockerfile 基于 `https://github.com/Frichetten/CVE-2019-5736-PoC.git` 构建。主要的风险点在于该git仓库中的 `main.go` 文件。虽然POC本身旨在演示漏洞利用，但作者有可能在其中添加恶意代码，例如植入后门。代码需要进一步分析，目前初步判断存在较小风险，因为该POC已经被广泛使用，如果存在明显恶意行为，应该会被发现。但是，仍存在隐藏的、不明显的恶意代码的可能，所以判断存在5%的投毒风险。

**项目地址:** [panzouh/Docker-Runc-Exploit](https://github.com/panzouh/Docker-Runc-Exploit)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #20

**来源**: [CVE-2019-5736-q3k_cve-2019-5736-poc.md](../2019/CVE-2019-5736-q3k_cve-2019-5736-poc.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker)

**危害等级:** 高危，可获得宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker before 18.09.2)

**利用条件:** 需要能够在容器内以root身份执行命令，或者能够通过`docker exec`进入具有写权限的已存在容器。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。 

**漏洞利用方式：**

1.  **攻击准备：** 攻击者需要在一个存在漏洞的Docker环境中运行一个容器。这个容器可以是新建的，也可以是攻击者已经具有写权限的。 
2.  **第一阶段 (stage1.c)：**
    *   编译后的 `stage1.c` 会被注入到 `libseccomp` 的 `src/api.c` 中，构建一个新的 `libseccomp` 包。
    *   当容器启动时，修改后的 `libseccomp` 中的构造函数 `foo()` 会被执行。
    *   `foo()` 函数尝试打开 `/proc/self/exe`（即 runc 二进制文件）的只读文件描述符。
    *   然后，它构造一个包含 `/stage2` 路径和文件描述符路径的参数数组。
    *   最后，它使用 `execve()` 函数执行 `/stage2`，并将文件描述符传递给它。
3.  **第二阶段 (stage2.c)：**
    *   `stage2.c` 的主要功能是打开通过参数传递的文件描述符，并以读写追加模式打开，向该文件描述符写入特定的字符串（`cve-2019-5736`）。
    *   由于传递的文件描述符指向宿主机的 `runc` 二进制文件，因此 `stage2.c` 实际上是将字符串追加到宿主机的 `runc` 二进制文件中。
4.  **触发：**
    *   当下一次调用 `runc` 执行容器操作（例如 `docker run` 或 `docker exec`）时，被篡改的 `runc` 二进制文件会被执行。
    *   如果在`stage2.c`中修改为恶意的shell命令，下次启动容器时会执行root权限的恶意shell命令，攻击者就获得了宿主机的 root 权限。

**有效性：**

提供的PoC 代码有效，它可以覆盖宿主机上的 `runc` 二进制文件。 虽然这个 PoC 只是简单地追加字符串，但是可以很容易地修改 `stage2.c` 来执行任意代码，从而实现完整的容器逃逸。

**投毒风险：**

该 PoC 仓库中存在一定投毒风险，分析结果为10%。
* Dockerfile里存在从源码构建libseccomp的行为，增加了潜在的供应链风险，如果构建环境被污染，可能引入恶意代码。
* stage2.c可以被修改为任意的恶意程序，存在被利用的风险。

**总结：**

CVE-2019-5736 是一个严重的容器逃逸漏洞，利用起来相对简单，并且可以导致完全控制宿主机。因此，强烈建议受影响的用户尽快升级 `runc` 和 Docker 到安全版本。

**项目地址:** [q3k/cve-2019-5736-poc](https://github.com/q3k/cve-2019-5736-poc)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #21

**来源**: [CVE-2019-5736-shen54_IT19172088.md](../2019/CVE-2019-5736-shen54_IT19172088.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，可导致宿主机root权限获取

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 1. 受影响的runc版本
2. 攻击者可在容器内执行命令 (例如，通过 `docker exec` 访问现有容器或创建新容器)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2019-5736 漏洞允许攻击者通过恶意容器覆盖宿主机上的 `runc` 二进制文件，从而获得宿主机的 root 权限。利用方式如下：

1.  **攻击准备：** 攻击者需要能够在一个存在漏洞的容器中执行代码，或者创建一个新的包含恶意代码的容器镜像。
2.  **文件描述符劫持：** 该漏洞源于 `runc` 在启动容器时对文件描述符的处理不当，特别是 `/proc/self/exe`。
3.  **二进制覆盖：** 容器内的恶意进程会尝试打开 `/proc/self/exe` 并覆盖宿主机上的 `runc` 二进制文件，使用包含恶意指令的payload替换。
4.  **宿主机提权：** 当宿主机执行被覆盖的 `runc` 二进制文件（例如，启动新的容器或执行 `docker exec`）时，攻击者的恶意代码将在宿主机上以 root 权限执行，从而实现容器逃逸。

**有效性评估：**
根据漏洞描述和搜索结果，此漏洞利用的有效性很高，多个PoC代码已被公开，并成功被利用于多种容器环境。

**投毒风险评估：**
提供的“漏洞利用代码”实际上是一个名为“DOSS LAB 02”的威胁建模文件（JSON格式），描述了一些安全威胁，但本身不包含任何可执行的代码。因此，该文件中不存在投毒风险。投毒风险为 0%。真正的漏洞利用代码不在提供的信息中，无法评估其投毒风险。

**利用方式总结：**
该漏洞的利用方式是通过容器内的恶意代码覆盖宿主机上的 `runc` 二进制文件，从而在宿主机上获得 root 权限。攻击者需要能够控制容器内的进程，并利用文件描述符劫持来覆盖 `runc` 二进制文件。

**项目地址:** [shen54/IT19172088](https://github.com/shen54/IT19172088)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #22

**来源**: [CVE-2019-5736-si1ent-le_CVE-2019-5736.md](../2019/CVE-2019-5736-si1ent-le_CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，可获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能以root身份在受影响的容器中执行命令 (新建容器时控制镜像，或已获得现有容器的写入权限并能执行 `docker exec`)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 允许攻击者通过文件描述符处理不当覆盖宿主机的 runc 二进制文件，从而获得宿主机的 root 访问权限。攻击者需要在受影响的容器内执行恶意代码。

**利用方式：**

1.  **准备阶段：**
    *   准备一个存在漏洞的 Docker 环境（runc <= 1.0-rc6, Docker < 18.09.2）。
    *   备份宿主机的 `/usr/bin/docker-runc` (或 `/usr/bin/runc`) 文件，以防万一。
2.  **构建恶意镜像 (或修改现有容器):**
    *   Dockerfile 中包含构建 libseccomp 的步骤，以及添加 stage1.c, stage2.c, run.sh 等恶意代码。
    *   `stage1.c` 的作用是在容器启动时，尝试打开 `/proc/self/exe` (即 runc 二进制文件)，并将文件描述符传递给 `/stage2`。
    *   `stage2.c` 的作用是尝试使用传递的文件描述符打开 runc 二进制文件，并用包含反弹 shell 命令的恶意脚本覆盖它。反弹shell地址可以自定义。
    *   `run.sh` 的作用是编译 `stage2.c`，并修改 `/bin/bash` 使其指向 `/proc/self/exe`。然后，它会尝试编译并安装修改后的 libseccomp 库。
3.  **运行容器：**
    *   使用构建的恶意镜像启动一个容器，或者进入一个已获得写入权限的现有容器。
4.  **执行攻击：**
    *   在容器中运行 `run.sh` 脚本。
    *   `run.sh` 会覆盖宿主机的 `runc` 二进制文件。
5.  **触发漏洞：**
    *   当宿主机下次使用被篡改的 `runc` 启动新容器，或使用 `docker exec` 进入容器时，恶意代码将被执行，攻击者即可获得宿主机的 root shell。

**有效性：**

根据漏洞信息、搜索结果和提供的PoC代码，该漏洞利用方式是有效的。多个来源（NVD、Red Hat、AWS、Sysdig 等）确认了该漏洞的存在，并提供了缓解措施。PoC 代码展示了如何构建恶意镜像，并通过文件描述符覆盖宿主机的 runc 二进制文件。

**投毒风险：**

PoC 代码中存在一定的投毒风险。`stage2.c` 中包含的恶意脚本，目前是反弹 shell 的代码。虽然这些反弹 shell 连接的是攻击者指定的 IP 地址，但如果被恶意修改，可能会执行其他恶意操作，例如删除文件、安装后门程序等。这种风险主要体现在，用户可能直接使用未经审计的 PoC 代码，而忽略了其中的潜在风险。这里的投毒风险并非仓库作者主动投毒，而是使用者不加以审计直接使用带来的风险。PoC本身为了验证漏洞需要包含反弹shell或类似的代码。

综上，投毒风险评估为 10%。这主要源于用户在使用 PoC 时，可能直接运行未经充分审计的代码。

**项目地址:** [si1ent-le/CVE-2019-5736](https://github.com/si1ent-le/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #23

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #24

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---



---

## POC #24

**来源**: [CVE-2019-5736-stillan00b_CVE-2019-5736.md](../2019/CVE-2019-5736-stillan00b_CVE-2019-5736.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, containerd, CRI-O)

**危害等级:** 高危，可导致主机root权限泄露

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要在容器内以root身份执行命令，或拥有容器镜像的控制权

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 是一个 runc 容器逃逸漏洞，攻击者可以利用该漏洞覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。

**漏洞利用方式：**

1.  攻击者需要能够在一个容器中以 root 身份执行命令。这可以通过以下两种方式实现：
    *   创建一个新的容器，并使用攻击者控制的镜像。
    *   攻击者已经拥有对现有容器的写入权限，可以通过 `docker exec` 等方式附加到该容器。
2.  攻击者在容器内执行特定的恶意代码，该代码会尝试打开 `/proc/self/exe`，并利用文件描述符处理不当的漏洞，从而覆盖宿主机上的 `runc` 二进制文件。
3.  当宿主机下次启动新的容器时，会执行被篡改的 `runc` 二进制文件，从而执行攻击者预先设定的恶意代码，最终获得宿主机的 root 权限。

**有效性：**

提供的POC代码验证了该漏洞的有效性，并且验证了将runC设置为只读可以缓解漏洞。

**投毒风险：**

虽然POC代码本身目的是验证缓解措施，但该代码可能被恶意修改以包含后门。仔细检查了`exploit.c`, `payload.c`, `pwn.sh` 和 `Makefile`，虽然没有发现明显的恶意代码，但存在一些潜在的风险：

*   `payload.c` 可以被修改为执行任意命令，从而在宿主机上植入后门。
*   `pwn.sh` 脚本的执行流程和依赖关系较为复杂，可能存在隐藏的漏洞或恶意代码。

由于POC代码的复杂性，无法完全排除投毒的可能性。估计投毒风险为10%。因为整体目的是验证，所以投毒可能性较低。


**项目地址:** [stillan00b/CVE-2019-5736](https://github.com/stillan00b/CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #25

**来源**: [CVE-2019-5736-takumak_cve-2019-5736-reproducer.md](../2019/CVE-2019-5736-takumak_cve-2019-5736-reproducer.md)

## CVE-2019-5736-runc-容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc (Docker, Kubernetes等)

**危害等级:** 高危，允许容器逃逸并获取宿主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 需要能够以root身份在受影响的容器中执行命令 (创建新容器或docker exec到已有容器)

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞存在于 runc 中，允许攻击者通过文件描述符处理不当，覆盖宿主机上的 runc 二进制文件。利用方式如下：

1.  **攻击条件：** 攻击者需要在存在漏洞的 Docker 或 Kubernetes 环境中，能够以 root 身份在容器内执行命令。
2.  **漏洞原理：** 漏洞源于 runc 在容器启动或执行 docker exec 时，对 `/proc/self/exe` 的处理存在缺陷。攻击者可以利用这个缺陷，打开宿主机上的 runc 二进制文件描述符。
3.  **利用过程：** 攻击者在容器内部运行恶意程序，该程序会尝试打开 `/proc/self/exe`，获得宿主机上 runc 二进制文件的文件描述符。然后，恶意程序会将恶意的代码（例如，添加一个后门）写入这个文件描述符，从而覆盖宿主机上的 runc 二进制文件。
4.  **攻击结果：** 当宿主机下次调用被篡改的 runc 二进制文件来创建或管理容器时，恶意代码就会以 root 权限在宿主机上执行，从而导致容器逃逸，攻击者获得宿主机的完全控制权。

**有效性评估：**

根据漏洞库信息和搜索引擎结果，该漏洞是一个已经公开且存在有效 PoC 的高危漏洞。大量的安全公告和分析文章证实了该漏洞的可利用性。

**投毒风险评估：**

提供的代码片段只是 GNU GPL 许可证，无法直接分析投毒风险。但是，考虑到漏洞利用通常涉及到修改 runc 二进制文件，恶意攻击者可能会在 PoC 中嵌入恶意代码，从而在成功利用漏洞后，在宿主机上植入后门。需要检查完整的POC代码分析是否存在恶意行为，例如反弹shell，添加用户等。 总体代码投毒风险评估为10%，主要来于与后期利用时可能引入的恶意操作。

**项目地址:** [takumak/cve-2019-5736-reproducer](https://github.com/takumak/cve-2019-5736-reproducer)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #26

**来源**: [CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md](../2019/CVE-2019-5736-twistlock_RunC-CVE-2019-5736.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc

**危害等级:** 高危，允许容器逃逸并获得主机root权限

**影响版本:** <= 1.0-rc6 (Docker < 18.09.2)

**利用条件:** 攻击者需要能够在容器内以root身份执行命令，或者拥有可控镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736 漏洞允许恶意容器覆盖宿主机上的 runc 二进制文件，从而获得宿主机的 root 权限。漏洞的根本原因是文件描述符处理不当，具体来说是与 `/proc/self/exe` 相关的问题。

**有效性分析：**
根据漏洞描述和搜索结果，提供的 POC 代码是有效的。多个来源（NVD, RedHat, Trend Micro, AWS, Sysdig, Tenable, Databricks）都确认了该漏洞的存在，并且提供了缓解措施。POC 代码通过两种方式利用该漏洞：
    *   **exec PoC:**  覆盖 `runc` 二进制文件，使其打印字符串。
    *   **Malicious Image PoC:**  覆盖 `runc` 二进制文件，使其运行反向 shell，从而允许攻击者连接到宿主机。

**投毒风险分析：**
分析提供的 POC 代码，发现存在一定的投毒风险，但风险较低。风险主要存在于以下几点：

1.  **`/malicious_image_POC/new_runc`:**  该文件包含一个简单的反向 shell 脚本，虽然其本身目的是演示漏洞利用，但攻击者可以替换该脚本为更具破坏性的代码，例如删除关键系统文件、植入恶意软件等。这种替换容易被发现，因此风险较低。
2.  **`/malicious_image_POC/overwrite_runc.c`:**  该 C 语言程序负责覆盖 runc 二进制文件。攻击者可以在此代码中添加额外的恶意逻辑，例如在覆盖 runc 之前执行某些操作，或者在成功覆盖 runc 之后执行某些操作。然而，由于此代码需要编译，并且目标是覆盖 `/proc/self/exe`, 行为较为明显,风险较低。
3. Dockerfile中执行了apt-get source libseccomp。攻击者可能利用此步骤下载恶意源码。
总而言之，此仓库投毒概率较低，大约为10%。因为代码简单直接，目的在于展示漏洞。但仍然需要注意，在生产环境中使用任何第三方代码之前，都应该进行仔细的审查。

**漏洞利用方式：**
1.  **获取容器内的 root 权限：** 攻击者需要首先在目标容器内获得 root 权限。这可以通过多种方式实现，例如利用容器内已存在的漏洞，或者利用错误配置。
2.  **覆盖 runc 二进制文件：** 攻击者利用 CVE-2019-5736 漏洞，通过 `/proc/self/exe` 覆盖宿主机上的 `runc` 二进制文件。POC 代码提供了两种方法来实现这一点。
3.  **触发 runc 执行：** 当 Docker 或其他容器管理工具需要执行某些操作（例如 `docker exec`、`docker run`）时，它会调用被覆盖的 `runc` 二进制文件。此时，攻击者植入的恶意代码将以 root 权限在宿主机上执行，从而导致容器逃逸，完全控制宿主机。


**项目地址:** [twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

## POC #27

**来源**: [CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md](../2019/CVE-2019-5736-yyqs2008_CVE-2019-5736-PoC-2.md)

## CVE-2019-5736-runc容器逃逸

**漏洞编号:** CVE-2019-5736

**漏洞类型:** 容器逃逸

**影响应用:** runc/Docker

**危害等级:** 高危，允许容器逃逸并获得宿主机root权限

**影响版本:** <= 1.0-rc6 (runc), Docker < 18.09.2

**利用条件:** 需要能够以root权限在受影响的容器内执行代码，或者能够控制容器镜像。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2019-5736漏洞允许攻击者通过操纵`/proc/self/exe`文件描述符，覆盖宿主机上的runc二进制文件。成功利用后，当宿主机再次运行容器时，会执行被覆盖的runc二进制文件，从而允许攻击者在宿主机上执行任意代码，获得root权限。

**漏洞利用分析：**
1.  **Dockerfile:**  定义了一个包含漏洞利用程序的Docker镜像。它基于Ubuntu 18.04，安装了必要的编译工具，并将漏洞利用代码（`exploit.c`，`payload.c`，`start.sh`）添加到镜像中。
2.  **Makefile:**  用于编译`exploit.c`和`payload.c`，生成可执行文件。
3.  **exploit.c:** 漏洞利用的核心代码。它尝试打开目标runc二进制文件（通过`/proc/*/exe`找到），然后使用恶意payload覆盖该文件。
4.  **payload.c:**  定义了攻击载荷。该payload创建反向shell连接到攻击者的机器（`127.0.0.1:4455`）。
5.  **start.sh:**  该脚本负责持续扫描`/proc/*/exe`，查找包含`runc`关键字的进程，并尝试运行`exploit`程序覆盖runc二进制文件。它还通过修改`/bin/sh`指向`/proc/self/exe`来尝试加速漏洞触发。该脚本还会过滤掉空的cmdline，避免exploit执行出错。
6.  **README.md:** 描述了漏洞利用步骤，包括镜像构建和运行。

**投毒风险分析：**
虽然提供的代码主要目的是实现容器逃逸，但仍然存在一定的投毒风险。`payload.c`中的反向shell地址硬编码为`127.0.0.1`，这意味着如果直接使用该代码，反向shell只会连接到容器内部。然而，攻击者可能修改`payload.c`，将反向shell地址更改为攻击者控制的服务器。此外，`start.sh` 脚本尝试修改`/bin/sh`，这可能会导致宿主机上的其他容器或进程出现问题。综合考虑，投毒风险评估为10%。大多数代码意图明显，且payload相对简单，但存在修改payload进行恶意利用的可能性。

**利用方式总结：**
1.  构建包含漏洞利用代码的Docker镜像。
2.  运行该镜像，启动一个恶意容器。
3.  该容器内的`start.sh`脚本会持续扫描`/proc/*/exe`，查找runc进程。
4.  当找到runc进程时，`exploit`程序会尝试打开并覆盖宿主机上的runc二进制文件。
5.  一旦runc二进制文件被覆盖，下次宿主机运行容器时，就会执行恶意payload，从而获得宿主机的root权限。
6.  Payload建立一个反向shell连接到攻击者的服务器，从而允许攻击者控制宿主机。

**项目地址:** [yyqs2008/CVE-2019-5736-PoC-2](https://github.com/yyqs2008/CVE-2019-5736-PoC-2)

**漏洞详情:** [CVE-2019-5736](https://nvd.nist.gov/vuln/detail/CVE-2019-5736)

---

