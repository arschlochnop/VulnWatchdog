# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

# CVE-2020-16012

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-16012-aleksejspopovs_cve-2020-16012.md](../2020/CVE-2020-16012-aleksejspopovs_cve-2020-16012.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012 是 Google Chrome 浏览器中存在的一个侧信道信息泄露漏洞。该漏洞存在于图形处理过程中，允许远程攻击者通过精心设计的 HTML 页面泄露跨域数据。

**有效性评估：**

根据提供的漏洞库信息、搜索结果和漏洞利用代码，该漏洞的POC代码是有效的。搜索结果中包含了指向GitHub存储库的链接，该存储库专门用于演示此漏洞，并提供了可用于测量操作定时的基准测试代码，以及一个利用此漏洞来恢复跨域图像轮廓的利用示例。Mozilla Attack & Defense 博客上有一篇关于此漏洞的详细文章，进一步证实了其有效性。

**投毒风险分析：**

提供的代码主要由基准测试代码 (`benchmark/benchmark.html`, `benchmark/chromium.tsv`) 和利用示例组成 (`exploit` 目录，未提供完整代码)。基准测试代码用于测量 `drawImage()` 函数的执行时间，利用示例则利用该时间差异来推断图像信息。目前看来，主要的风险在于利用代码的复杂性和潜在的恶意修改。例如，攻击者可能会修改 `exploit` 目录下的代码（如果提供的话）以收集其他敏感信息，或者创建更具破坏性的攻击。在 `benchmark/benchmark.html` 中，虽然没有发现明显的恶意代码，但如果攻击者修改了该文件，将其部署在用户浏览器中，并收集用户的基准测试数据，也可能存在隐私风险。总的来说，虽然直接的投毒代码并不明显，但修改和重新利用代码的风险仍然存在，大约评估投毒风险为10%。

**利用方式分析：**

1.  **漏洞原理：** 该漏洞利用了 `CanvasRenderingContext2D.drawImage()` 函数在处理不同内容时的时间差异。通过测量绘制不同内容的图像所需的时间，攻击者可以推断出有关图像内容的信息。
2.  **利用步骤：**
    *   攻击者创建一个包含恶意 JavaScript 代码的 HTML 页面。
    *   该 JavaScript 代码使用 `drawImage()` 函数绘制跨域图像。
    *   通过 `performance.now()` 等 API 测量 `drawImage()` 函数的执行时间。
    *   根据执行时间的差异，推断出图像的内容，例如图像的轮廓或颜色分布。
    *   将推断出的信息发送到攻击者的服务器。
3.  **攻击场景：** 攻击者可以将恶意 HTML 页面托管在自己的服务器上，并通过社交工程等手段诱骗用户访问该页面。当用户使用受影响的 Chrome 浏览器访问该页面时，攻击者就可以利用该漏洞泄露用户的跨域数据。

**项目地址:** [aleksejspopovs/cve-2020-16012](https://github.com/aleksejspopovs/cve-2020-16012)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---



---

## POC #2

**来源**: [CVE-2020-16012-helidem_CVE-2020-16012-PoC.md](../2020/CVE-2020-16012-helidem_CVE-2020-16012-PoC.md)

## CVE-2020-16012-Chrome-侧信道信息泄露

**漏洞编号:** CVE-2020-16012

**漏洞类型:** 侧信道信息泄露

**影响应用:** Chrome

**危害等级:** 中危，可能导致跨域数据泄露

**影响版本:** < 87.0.4280.66

**利用条件:** 需要用户访问恶意构造的HTML页面

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-16012是Google Chrome浏览器中存在的一个侧信道信息泄露漏洞，影响版本低于87.0.4280.66。该漏洞源于图形处理中drawImage()函数的实现缺陷，允许远程攻击者通过精心设计的HTML页面泄露跨域数据。

**有效性：**

根据搜索结果和提供的漏洞利用代码，此漏洞的POC是有效的。aleksejspopovs/cve-2020-16012 GitHub仓库（搜索结果[9]）包含针对此漏洞的POC，该POC通过侧信道攻击CanvasRenderingContext2D.drawImage()函数的实现来提取信息。

提供的代码片段也印证了这一点，它通过测量drawImage()操作的时间来推断信息。它通过反复绘制图像的一小部分，然后测量绘制操作所花费的时间。由于不同像素绘制时间差异，攻击者可以通过分析这些时间差异来重建原始图像，从而实现跨域数据窃取。

**投毒风险：**

评估POC代码中是否存在投毒风险，需要关注以下几个方面：

*   **服务器端脚本（server.py）：** 该脚本接收来自客户端的像素数据，并将其保存到图像中。潜在的投毒点可能包括恶意修改接收到的数据、向服务器写入恶意文件，或执行其他未授权的操作。
*   **客户端脚本（exploit.html）：** 该脚本负责测量drawImage()操作的时间并将数据发送到服务器。潜在的投毒点可能包括窃取用户的其他信息、执行恶意脚本或将用户重定向到恶意网站。

仔细分析代码后，发现以下几点：

*   客户端（`exploit.html`）通过POST请求将像素数据发送到服务器，服务器端（`server.py`）将这些数据拼接到一起形成图片。
*   客户端和服务端都相对简单，主要功能是复现漏洞，没有明显恶意代码，但仍存在被利用的可能。
*   服务端缺乏对上传数据的严格校验，可能存在被恶意利用的空间。

综合来看，**投毒风险较低，约为10%**。主要风险集中在服务器端对接收到的数据缺乏严格验证，可能被用于执行拒绝服务攻击，或者写入恶意构造的图像文件，但这些风险可以通过安全编码实践来降低。

**利用方式：**

1.  攻击者搭建一个恶意网站，其中包含利用CVE-2020-16012漏洞的HTML页面（exploit.html）。
2.  用户使用受影响的Chrome版本（低于87.0.4280.66）访问该恶意网站。
3.  恶意网站上的JavaScript代码利用drawImage()函数的侧信道信息泄露漏洞，通过测量绘制操作的时间来提取目标网站上的像素信息。
4.  提取到的像素信息被发送到攻击者控制的服务器（server.py）。
5.  攻击者通过分析接收到的像素信息来重建原始图像，从而窃取跨域数据。

**项目地址:** [helidem/CVE-2020-16012-PoC](https://github.com/helidem/CVE-2020-16012-PoC)

**漏洞详情:** [CVE-2020-16012](https://nvd.nist.gov/vuln/detail/CVE-2020-16012)

---

