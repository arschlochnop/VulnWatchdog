# CVE-2020-13151

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-13151-ByteMe1001_CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-.md](../2020/CVE-2020-13151-ByteMe1001_CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-.md)

## CVE-2020-13151-Aerospike-RCE

**漏洞编号:** CVE-2020-13151

**漏洞类型:** 远程代码执行

**影响应用:** Aerospike Community Edition

**危害等级:** 高危，可导致服务器被完全控制

**影响版本:** 4.9.0.5

**利用条件:** 需要网络访问Aerospike服务，默认端口3000

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-13151允许未经身份验证的用户提交和执行用户自定义函数（UDF）。虽然Aerospike试图通过禁用`os.execute()`来限制代码执行，但这并不充分。攻击者可以通过构造恶意的Lua UDF，利用其他Lua库或函数绕过限制，执行任意操作系统命令。漏洞利用代码`exploit.py`首先连接到Aerospike数据库，然后注册一个包含恶意代码的UDF。最后，它通过调用该UDF来执行系统命令。POC中包含python反弹shell和netcat反弹shell的payload，可以用于获取目标系统的shell。

**有效性：**

根据漏洞信息、搜索结果以及POC代码，可以判断此漏洞的POC代码是有效的。多个搜索结果表明该漏洞存在且可以被利用，并且提供了POC代码的链接。

**投毒风险：**

`exploit.py` 本身包含了反弹 shell 的 payload，这属于漏洞验证的范畴，并非投毒。投毒风险主要来源于作者是否在UDF注册或命令执行过程中植入其他后门代码。

*   代码总体结构较为清晰，主要功能是连接 Aerospike 服务器、注册 UDF 并执行命令。仔细检查代码逻辑，未发现明显的恶意行为，代码中包含的payload功能是反弹shell。`_send` 函数用于发送命令，`_register_udf` 函数用于注册 UDF，这两个函数的实现都比较直接，未发现篡改行为。
*  `_version_check` 函数用于检查 Aerospike 版本，如果版本已经被修复，则退出程序。如果无法确定版本，则继续执行。这个函数本身没有问题，但是如果攻击者故意篡改这个函数，使其始终返回漏洞存在，则可能误导用户。
*   在代码中，没有发现从外部源加载或执行代码的行为。这意味着攻击者无法通过远程方式注入恶意代码。
*   代码使用 `aerospike` python 包，需要确保该包的来源安全，避免供应链攻击。

综合分析，认为此仓库中存在作者隐藏的投毒代码的可能性较低，估计为10%。

**利用方式：**

1.  **目标确定：** 确定存在漏洞的Aerospike Community Edition 4.9.0.5服务器，并且网络可达。
2.  **连接数据库：** 使用`exploit.py`脚本连接到Aerospike数据库服务器。
3.  **版本检测：** 脚本会检测Aerospike的版本，如果版本高于4.9.0.5或者已经修复了该漏洞，脚本会退出。
4.  **UDF注册：** 脚本会注册一个包含恶意代码的Lua UDF。这个UDF中的代码可以执行任意系统命令。
5.  **命令执行：** 脚本通过调用UDF执行系统命令，例如反弹shell等。
6.  **获取Shell：** 如果成功执行了反弹shell命令，攻击者可以在指定的IP地址和端口上监听，从而获得目标服务器的shell访问权限。

**项目地址:** [ByteMe1001/CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-](https://github.com/ByteMe1001/CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-)

**漏洞详情:** [CVE-2020-13151](https://nvd.nist.gov/vuln/detail/CVE-2020-13151)

---

## POC #2

**来源**: [CVE-2020-13151-b4ny4n_CVE-2020-13151.md](../2020/CVE-2020-13151-b4ny4n_CVE-2020-13151.md)

# CVE-2020-13151

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-13151-ByteMe1001_CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-.md](../2020/CVE-2020-13151-ByteMe1001_CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-.md)

## CVE-2020-13151-Aerospike-RCE

**漏洞编号:** CVE-2020-13151

**漏洞类型:** 远程代码执行

**影响应用:** Aerospike Community Edition

**危害等级:** 高危，可导致服务器被完全控制

**影响版本:** 4.9.0.5

**利用条件:** 需要网络访问Aerospike服务，默认端口3000

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-13151允许未经身份验证的用户提交和执行用户自定义函数（UDF）。虽然Aerospike试图通过禁用`os.execute()`来限制代码执行，但这并不充分。攻击者可以通过构造恶意的Lua UDF，利用其他Lua库或函数绕过限制，执行任意操作系统命令。漏洞利用代码`exploit.py`首先连接到Aerospike数据库，然后注册一个包含恶意代码的UDF。最后，它通过调用该UDF来执行系统命令。POC中包含python反弹shell和netcat反弹shell的payload，可以用于获取目标系统的shell。

**有效性：**

根据漏洞信息、搜索结果以及POC代码，可以判断此漏洞的POC代码是有效的。多个搜索结果表明该漏洞存在且可以被利用，并且提供了POC代码的链接。

**投毒风险：**

`exploit.py` 本身包含了反弹 shell 的 payload，这属于漏洞验证的范畴，并非投毒。投毒风险主要来源于作者是否在UDF注册或命令执行过程中植入其他后门代码。

*   代码总体结构较为清晰，主要功能是连接 Aerospike 服务器、注册 UDF 并执行命令。仔细检查代码逻辑，未发现明显的恶意行为，代码中包含的payload功能是反弹shell。`_send` 函数用于发送命令，`_register_udf` 函数用于注册 UDF，这两个函数的实现都比较直接，未发现篡改行为。
*  `_version_check` 函数用于检查 Aerospike 版本，如果版本已经被修复，则退出程序。如果无法确定版本，则继续执行。这个函数本身没有问题，但是如果攻击者故意篡改这个函数，使其始终返回漏洞存在，则可能误导用户。
*   在代码中，没有发现从外部源加载或执行代码的行为。这意味着攻击者无法通过远程方式注入恶意代码。
*   代码使用 `aerospike` python 包，需要确保该包的来源安全，避免供应链攻击。

综合分析，认为此仓库中存在作者隐藏的投毒代码的可能性较低，估计为10%。

**利用方式：**

1.  **目标确定：** 确定存在漏洞的Aerospike Community Edition 4.9.0.5服务器，并且网络可达。
2.  **连接数据库：** 使用`exploit.py`脚本连接到Aerospike数据库服务器。
3.  **版本检测：** 脚本会检测Aerospike的版本，如果版本高于4.9.0.5或者已经修复了该漏洞，脚本会退出。
4.  **UDF注册：** 脚本会注册一个包含恶意代码的Lua UDF。这个UDF中的代码可以执行任意系统命令。
5.  **命令执行：** 脚本通过调用UDF执行系统命令，例如反弹shell等。
6.  **获取Shell：** 如果成功执行了反弹shell命令，攻击者可以在指定的IP地址和端口上监听，从而获得目标服务器的shell访问权限。

**项目地址:** [ByteMe1001/CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-](https://github.com/ByteMe1001/CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-)

**漏洞详情:** [CVE-2020-13151](https://nvd.nist.gov/vuln/detail/CVE-2020-13151)

---

## POC #2

**来源**: [CVE-2020-13151-b4ny4n_CVE-2020-13151.md](../2020/CVE-2020-13151-b4ny4n_CVE-2020-13151.md)

# CVE-2020-13151

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-13151-ByteMe1001_CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-.md](../2020/CVE-2020-13151-ByteMe1001_CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-.md)

## CVE-2020-13151-Aerospike-RCE

**漏洞编号:** CVE-2020-13151

**漏洞类型:** 远程代码执行

**影响应用:** Aerospike Community Edition

**危害等级:** 高危，可导致服务器被完全控制

**影响版本:** 4.9.0.5

**利用条件:** 需要网络访问Aerospike服务，默认端口3000

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-13151允许未经身份验证的用户提交和执行用户自定义函数（UDF）。虽然Aerospike试图通过禁用`os.execute()`来限制代码执行，但这并不充分。攻击者可以通过构造恶意的Lua UDF，利用其他Lua库或函数绕过限制，执行任意操作系统命令。漏洞利用代码`exploit.py`首先连接到Aerospike数据库，然后注册一个包含恶意代码的UDF。最后，它通过调用该UDF来执行系统命令。POC中包含python反弹shell和netcat反弹shell的payload，可以用于获取目标系统的shell。

**有效性：**

根据漏洞信息、搜索结果以及POC代码，可以判断此漏洞的POC代码是有效的。多个搜索结果表明该漏洞存在且可以被利用，并且提供了POC代码的链接。

**投毒风险：**

`exploit.py` 本身包含了反弹 shell 的 payload，这属于漏洞验证的范畴，并非投毒。投毒风险主要来源于作者是否在UDF注册或命令执行过程中植入其他后门代码。

*   代码总体结构较为清晰，主要功能是连接 Aerospike 服务器、注册 UDF 并执行命令。仔细检查代码逻辑，未发现明显的恶意行为，代码中包含的payload功能是反弹shell。`_send` 函数用于发送命令，`_register_udf` 函数用于注册 UDF，这两个函数的实现都比较直接，未发现篡改行为。
*  `_version_check` 函数用于检查 Aerospike 版本，如果版本已经被修复，则退出程序。如果无法确定版本，则继续执行。这个函数本身没有问题，但是如果攻击者故意篡改这个函数，使其始终返回漏洞存在，则可能误导用户。
*   在代码中，没有发现从外部源加载或执行代码的行为。这意味着攻击者无法通过远程方式注入恶意代码。
*   代码使用 `aerospike` python 包，需要确保该包的来源安全，避免供应链攻击。

综合分析，认为此仓库中存在作者隐藏的投毒代码的可能性较低，估计为10%。

**利用方式：**

1.  **目标确定：** 确定存在漏洞的Aerospike Community Edition 4.9.0.5服务器，并且网络可达。
2.  **连接数据库：** 使用`exploit.py`脚本连接到Aerospike数据库服务器。
3.  **版本检测：** 脚本会检测Aerospike的版本，如果版本高于4.9.0.5或者已经修复了该漏洞，脚本会退出。
4.  **UDF注册：** 脚本会注册一个包含恶意代码的Lua UDF。这个UDF中的代码可以执行任意系统命令。
5.  **命令执行：** 脚本通过调用UDF执行系统命令，例如反弹shell等。
6.  **获取Shell：** 如果成功执行了反弹shell命令，攻击者可以在指定的IP地址和端口上监听，从而获得目标服务器的shell访问权限。

**项目地址:** [ByteMe1001/CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-](https://github.com/ByteMe1001/CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-)

**漏洞详情:** [CVE-2020-13151](https://nvd.nist.gov/vuln/detail/CVE-2020-13151)

---

## POC #2

**来源**: [CVE-2020-13151-b4ny4n_CVE-2020-13151.md](../2020/CVE-2020-13151-b4ny4n_CVE-2020-13151.md)

# CVE-2020-13151

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2020-13151-ByteMe1001_CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-.md](../2020/CVE-2020-13151-ByteMe1001_CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-.md)

## CVE-2020-13151-Aerospike-RCE

**漏洞编号:** CVE-2020-13151

**漏洞类型:** 远程代码执行

**影响应用:** Aerospike Community Edition

**危害等级:** 高危，可导致服务器被完全控制

**影响版本:** 4.9.0.5

**利用条件:** 需要网络访问Aerospike服务，默认端口3000

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-13151允许未经身份验证的用户提交和执行用户自定义函数（UDF）。虽然Aerospike试图通过禁用`os.execute()`来限制代码执行，但这并不充分。攻击者可以通过构造恶意的Lua UDF，利用其他Lua库或函数绕过限制，执行任意操作系统命令。漏洞利用代码`exploit.py`首先连接到Aerospike数据库，然后注册一个包含恶意代码的UDF。最后，它通过调用该UDF来执行系统命令。POC中包含python反弹shell和netcat反弹shell的payload，可以用于获取目标系统的shell。

**有效性：**

根据漏洞信息、搜索结果以及POC代码，可以判断此漏洞的POC代码是有效的。多个搜索结果表明该漏洞存在且可以被利用，并且提供了POC代码的链接。

**投毒风险：**

`exploit.py` 本身包含了反弹 shell 的 payload，这属于漏洞验证的范畴，并非投毒。投毒风险主要来源于作者是否在UDF注册或命令执行过程中植入其他后门代码。

*   代码总体结构较为清晰，主要功能是连接 Aerospike 服务器、注册 UDF 并执行命令。仔细检查代码逻辑，未发现明显的恶意行为，代码中包含的payload功能是反弹shell。`_send` 函数用于发送命令，`_register_udf` 函数用于注册 UDF，这两个函数的实现都比较直接，未发现篡改行为。
*  `_version_check` 函数用于检查 Aerospike 版本，如果版本已经被修复，则退出程序。如果无法确定版本，则继续执行。这个函数本身没有问题，但是如果攻击者故意篡改这个函数，使其始终返回漏洞存在，则可能误导用户。
*   在代码中，没有发现从外部源加载或执行代码的行为。这意味着攻击者无法通过远程方式注入恶意代码。
*   代码使用 `aerospike` python 包，需要确保该包的来源安全，避免供应链攻击。

综合分析，认为此仓库中存在作者隐藏的投毒代码的可能性较低，估计为10%。

**利用方式：**

1.  **目标确定：** 确定存在漏洞的Aerospike Community Edition 4.9.0.5服务器，并且网络可达。
2.  **连接数据库：** 使用`exploit.py`脚本连接到Aerospike数据库服务器。
3.  **版本检测：** 脚本会检测Aerospike的版本，如果版本高于4.9.0.5或者已经修复了该漏洞，脚本会退出。
4.  **UDF注册：** 脚本会注册一个包含恶意代码的Lua UDF。这个UDF中的代码可以执行任意系统命令。
5.  **命令执行：** 脚本通过调用UDF执行系统命令，例如反弹shell等。
6.  **获取Shell：** 如果成功执行了反弹shell命令，攻击者可以在指定的IP地址和端口上监听，从而获得目标服务器的shell访问权限。

**项目地址:** [ByteMe1001/CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-](https://github.com/ByteMe1001/CVE-2020-13151-POC-Aerospike-Server-Host-Command-Execution-RCE-)

**漏洞详情:** [CVE-2020-13151](https://nvd.nist.gov/vuln/detail/CVE-2020-13151)

---

## POC #2

**来源**: [CVE-2020-13151-b4ny4n_CVE-2020-13151.md](../2020/CVE-2020-13151-b4ny4n_CVE-2020-13151.md)

## CVE-2020-13151 - Aerospike UDF远程命令执行

**漏洞编号:** CVE-2020-13151

**漏洞类型:** 远程命令执行

**影响应用:** Aerospike Community Edition

**危害等级:** 高危，允许未经身份验证的远程命令执行

**影响版本:** 4.9.0.5 (小于 5.1.0.3)

**利用条件:** 目标Aerospike服务器运行着受影响的版本，并且攻击者可以进行网络访问。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2020-13151 允许未经身份验证的用户通过上传和执行恶意的 Lua UDF（用户自定义函数）在 Aerospike 数据库服务器上执行任意操作系统命令。漏洞存在于Aerospike Community Edition 4.9.0.5 版本中，且小于5.1.0.3 版本。漏洞利用的关键在于绕过 Aerospike 禁用 `os.execute()` 调用的限制。攻击者可以通过其他 Lua 函数或模块来执行系统命令。 

**利用方式：**

1.  **UDF 注册：** 攻击者首先需要通过 Aerospike 客户端将包含恶意代码的 Lua UDF 注册到服务器。
2.  **命令执行：** 注册完成后，攻击者可以调用该 UDF，UDF 内部的恶意代码会以运行 Aerospike 服务的用户权限在服务器上执行任意操作系统命令。

**POC代码分析：**

提供的POC代码包含一个Python脚本 `cve2020-13151.py` 和一个 Lua 脚本 `poc.lua`。

*   `cve2020-13151.py`：这是一个 Python 脚本，用于自动化漏洞利用过程。它首先连接到目标 Aerospike 服务器，检查服务器版本是否易受攻击，然后上传并执行 `poc.lua` 中定义的 UDF。
*   `poc.lua`：该文件包含 Lua 代码，用于执行操作系统命令。虽然漏洞描述中提到了 `os.execute()` 被禁用，但实际的利用可能使用了其他 Lua 函数或模块来绕过此限制，执行命令。

**有效性：**

根据漏洞描述和POC代码，可以判断该漏洞利用方法是有效的，前提是目标服务器运行的是受影响的版本。

**投毒风险：**

检查提供的Python脚本和示例Lua代码, 并未发现明显的恶意代码. 投毒风险较低,约10%, 主要风险在于脚本可能包含不明显的后门或收集信息的代码。


**项目地址:** [b4ny4n/CVE-2020-13151](https://github.com/b4ny4n/CVE-2020-13151)

**漏洞详情:** [CVE-2020-13151](https://nvd.nist.gov/vuln/detail/CVE-2020-13151)

---



---



---



---

