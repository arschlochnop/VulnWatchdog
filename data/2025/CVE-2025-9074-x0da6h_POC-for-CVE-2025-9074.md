## CVE-2025-9074 - Docker Engine (unauthenticated API) Host File System Access / Container Escape

**漏洞编号:** CVE-2025-9074

**漏洞类型:** Host File System Access / Container Escape

**影响应用:** Docker Engine (unauthenticated API)

**危害等级:** 严重 (Critical)

**CVSS评分:** CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H (10.0 Critical)

**影响版本:** 取决于Docker守护进程配置，特别是开放未认证API的版本

**利用条件:** 需要攻击者能够通过网络直接访问Docker守护进程的HTTP API端口（默认为2375），且该API未启用认证。

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

该POC（`POC-for-CVE-2025-9074.sh`）是一个功能完备的Bash shell脚本，旨在演示通过未认证的Docker HTTP API进行主机文件系统读写的能力。脚本设计精良，结构清晰，易于理解和执行。它首先通过对Docker API的`/_ping`和`/version`端点进行健康检查和信息收集，确认目标Docker守护进程的可达性和版本信息。其核心功能在于利用Docker容器创建API (`/containers/create`)，通过特殊的`HostConfig`配置实现对宿主文件系统的访问。具体来说，脚本构建了一个JSON payload，其中包含：
1. `Image`: 使用一个轻量级的Docker镜像（默认为`alpine`）。
2. `Cmd`: 在容器内执行的命令，可以是读取文件（`cat '$MOUNT_PATH/$FILE_BASENAME'`）或写入文件（`printf '%s' '$CONTENT' > '$MOUNT_PATH/$FILE_BASENAME'`）。
3. `HostConfig.Binds`: 这是漏洞利用的关键。脚本将宿主机的某个目录（通过`dirname "$HOST_LINUX_PATH"`从用户提供的Windows路径转换而来）挂载到容器内的`/host_root`目录。通过这种方式，容器内的操作可以直接影响到宿主机的相应路径。脚本还包含路径转换逻辑，能够将Windows风格的路径（例如`C:/path/to/file.txt`）正确转换为Linux风格的宿主路径（例如`/mnt/host/c/path/to/file.txt`），以适应Docker在Linux环境下挂载Windows路径的机制。在执行完文件操作后，脚本会清理现场，移除创建的临时容器。整体而言，该POC是一个高度可靠和有效的漏洞验证工具，能够清楚地展示未认证Docker API所带来的严重安全风险。

**利用步骤**
利用此漏洞的步骤相对直接：
1. **确定目标**: 攻击者需要识别暴露在网络上且未启用认证的Docker HTTP API端点（通常是TCP端口2375）。
2. **执行POC（读取操作）**: 攻击者可以使用以下命令尝试读取宿主机上的敏感文件，例如Windows的`hosts`文件：
`bash POC-for-CVE-2025-9074.sh -read "C:/Windows/System32/drivers/etc/hosts"`
脚本将创建一个容器，将`C:\Windows\System32\drivers\etc`目录挂载到容器内，并在容器中执行`cat`命令读取`hosts`文件内容并输出。
3. **执行POC（写入操作）**: 攻击者也可以向宿主机上的任意文件写入内容，例如修改或创建文件：
`bash POC-for-CVE-2025-9074.sh -write "malicious content here" "C:/ProgramData/malicious.txt"`
脚本将执行类似的操作，但会在容器中执行`printf`命令将指定内容写入到宿主机上的目标文件。通过写入可执行文件、配置文件或注入启动脚本，攻击者可以轻易实现宿主机上的任意代码执行（RCE）。

**投毒风险分析**
对`POC-for-CVE-2025-9074.sh`的投毒风险评估为**低风险（10%）**。分析基于以下几个关键因素：
1. **代码清晰度与可读性**: 脚本代码结构清晰，使用了标准的Bash语法和常用的命令行工具（如`curl`, `sed`, `cut`, `printf`, `cat`, `basename`, `dirname`, `tr`）。没有发现任何代码混淆或难以理解的复杂逻辑。每个步骤都有明确的意图，且易于安全研究人员进行审计。
2. **无外部依赖或可疑链接**: 脚本不从任何外部URL下载额外的代码或可执行文件。所有操作都基于本地脚本代码和目标Docker API进行。没有发现硬编码的恶意IP地址、域名或用于C2（命令与控制）通信的逻辑。`curl`命令的目标始终是用户定义的Docker API端点`$BASE_URL`。
3. **无隐藏恶意行为**: 脚本的核心功能是利用Docker的挂载机制和`sh -c`命令来执行用户定义的`CMD`，以实现文件读写。这种读写文件本身是漏洞利用的行为，而非POC代码中隐藏的额外恶意功能。例如，`printf '%s' '$CONTENT' > '$MOUNT_PATH/$FILE_BASENAME'`是直接将用户指定的`$CONTENT`写入目标文件，是预期的漏洞利用payload，而非POC作者植入的后门。在安全研究中，区分漏洞本身利用代码和POC作者额外植入的恶意代码至关重要。此POC没有展示后者。
4. **标准库使用**: 脚本仅依赖于标准Unix/Linux环境下的shell工具，不包含任何自定义的或预编译的二进制文件，这进一步降低了隐藏恶意代码的风险。
5. **目标明确性**: POC的唯一目标是与Docker API交互以验证和利用未认证访问漏洞，其行为与所声称的漏洞利用目的完全一致，没有额外的、与目的不符的副作用。
综合来看，该POC是一个“纯净”的漏洞利用脚本，其设计和实现都专注于验证特定的Docker未认证API漏洞。尽管脚本本身能够执行危险的文件操作（这是漏洞的性质所致），但它没有在代码层面上被“投毒”，即没有在验证漏洞之外，悄悄地执行其他恶意活动。因此，对于防御性安全研究，使用此POC来复现和理解漏洞的风险是可控且较低的。

**项目地址:** N/A

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-9074
