## CVE-2025-9074 - Docker Desktop 容器逃逸/越权访问 (Container Escape/Privilege Escalation)

**漏洞编号:** CVE-2025-9074

**漏洞类型:** 容器逃逸/越权访问 (Container Escape/Privilege Escalation)

**影响应用:** Docker Desktop

**危害等级:** 高危

**CVSS评分:** 9.3

**影响版本:** < 4.44.3

**利用条件:** 需要本地运行恶意容器，通过默认子网访问Docker Engine API，无需认证

**POC 可用性:** 9

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 5%

## 详情

CVE-2025-9074是一个影响Docker Desktop在Windows和macOS系统上的高危容器越权访问/逃逸漏洞，CVSS评分为9.3。该漏洞允许本地运行的恶意Linux容器绕过隔离机制，通过默认子网（192.168.65.7:2375）直接访问Docker Engine API，从而实现对宿主机文件系统的任意读写，最终可能导致宿主机完全控制。该漏洞已在Docker Desktop 4.44.3版本中修复，因此影响所有低于此版本的Docker Desktop。利用该漏洞的主要条件是攻击者需已在目标系统上的一个Docker容器内拥有本地执行权限。

**POC有效性分析**：
提供的POC是一个名为`POC-for-CVE-2025-9074.sh`的Shell脚本，它高度功能化且有效，能够清晰地演示对宿主机文件系统的读写操作。脚本通过`curl`工具直接与Docker Engine API进行交互，无需挂载`docker.sock`。
核心利用机制如下：
1.  **目标定位与路径转换**：脚本首先解析命令行参数以确定是进行读操作（`-read`）还是写操作（`-write`），以及目标Windows文件路径。它会将Windows路径（例如`C:/path/to/file.txt`）转换为Docker容器内部可识别的Linux路径格式（例如`/mnt/host/c/path/to/file.txt`）。
2.  **API连通性检查**：在发起攻击前，脚本会通过访问`/_ping`和`/version`API端点，验证Docker Engine API的连通性和获取版本信息。
3.  **容器创建与绑定挂载**：POC利用`/containers/create` API端点创建一个新的临时容器（默认使用`alpine`镜像）。关键在于其`HostConfig.Binds`参数，该参数允许将宿主机上的任意目录（例如，根据目标文件路径推断出的`C:/path/to/`）以读写权限绑定挂载到新容器的指定路径（例如`/host_root`）。
4.  **宿主机文件操作**：在新创建的容器启动后，脚本通过容器的`Cmd`参数在容器内执行`sh -c`命令。对于读操作，执行`cat '$MOUNT_PATH/$FILE_BASENAME'`以读取宿主机文件内容；对于写操作，执行`printf '%s' '$CONTENT' > '$MOUNT_PATH/$FILE_BASENAME'`以向宿主机文件写入指定内容。容器的日志随后会被收集，以显示读操作的结果。
5.  **清理**：漏洞演示完成后，脚本会负责地通过`/containers/$CID?force=1` API端点删除其创建的临时容器，确保不留下多余的痕迹。
总体而言，该POC通过直接操作Docker API，巧妙地利用绑定挂载和容器内命令执行，实现了对宿主机文件系统的任意读写，完整且有效地验证了容器逃逸漏洞。

**利用步骤**：
1.  攻击者首先需要获得在目标Docker Desktop环境中的某个Linux容器内的代码执行权限。
2.  确保目标Docker Desktop版本低于4.44.3。
3.  在已受控的容器内，执行POC脚本，并指定要读写的目标宿主机文件路径（例如，`bash POC-for-CVE-2025-9074.sh -read "C:/Windows/System32/drivers/etc/hosts"`）。
4.  POC脚本将通过默认子网访问宿主机的Docker Engine API。
5.  POC会创建一个新的容器，并将宿主机上包含目标文件的目录绑定挂载到新容器内。
6.  在新容器内执行文件读写命令，从而读取或修改宿主机上的任意文件，实现容器逃逸和对宿主机的控制。

**投毒风险分析**：
该POC脚本的投毒风险评估为**低**。
首先，脚本是纯粹的Shell脚本，其代码逻辑完全公开透明，没有经过任何形式的混淆或加密处理，使得任何具有基本Shell脚本阅读能力的安全研究员都可以轻松审计其内部实现。
其次，脚本仅依赖于标准Linux命令行工具，如`curl`、`printf`、`cat`、`sed`、`cut`、`basename`、`dirname`、`tr`。这些都是操作系统自带的合法且常用的工具，脚本没有引入任何第三方库、二进制文件或从外部URL下载可执行代码的行为。这种对系统原生工具的依赖显著降低了潜在的恶意负载或后门植入风险。
再者，脚本中涉及的`printf`和`cat`等命令，其作用是明确地为了演示漏洞利用成功后，如何在宿主机文件系统上进行读写操作。这些命令是漏洞功能验证的核心组成部分，而非额外隐藏的恶意代码。它们直接反映了漏洞的危害能力，而不是POC作者利用POC本身对运行者进行攻击。
最后，脚本在完成利用演示后会执行清理操作，删除其创建的临时容器。这一行为进一步佐证了其作为漏洞验证工具而非恶意软件的性质。
综上所述，该POC代码清晰、功能聚焦于漏洞验证，且没有引入任何可疑或非标准的组件，因此其携带恶意负载的投毒风险非常低。

**项目地址:** 

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-9074
