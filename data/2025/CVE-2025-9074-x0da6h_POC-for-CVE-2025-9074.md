## CVE-2025-9074 - Docker Desktop 容器逃逸 (Container Escape), 越权访问 (Privilege Escalation)

**漏洞编号:** CVE-2025-9074

**漏洞类型:** 容器逃逸 (Container Escape), 越权访问 (Privilege Escalation)

**影响应用:** Docker Desktop

**危害等级:** 高危 (Critical)

**CVSS评分:** 9.3

**影响版本:** Docker Desktop < 4.44.3 (Windows and macOS版本)

**利用条件:** 需要本地运行的Linux容器中存在代码执行能力；利用Docker内部子网（默认为192.168.65.7:2375）直接访问Docker Engine API；无需Docker Socket挂载或TLS认证。

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 5%

## 详情

POC有效性分析：
提供的POC脚本`POC-for-CVE-2025-9074.sh`充分且有效地验证了Docker Desktop存在的容器逃逸漏洞（CVE-2025-9074）。该漏洞允许在Docker Desktop环境下运行的恶意Linux容器，通过非预期的途径访问宿主机上的Docker Engine API。通常情况下，容器与宿主机之间应存在严格的隔离，Docker Engine API的访问应受到严格控制，例如通过挂载Docker Socket或进行TLS认证。然而，此漏洞利用了Docker Desktop在Windows和macOS上运行Linux容器时，默认会在内部网络接口（如192.168.65.7:2375）上暴露一个非认证的Docker Engine API监听。恶意容器可以绕过标准隔离机制，直接通过此内部IP地址和端口与Docker Engine通信。

该POC脚本的核心机制在于利用API调用（`POST /containers/create`）来创建一个新的特权容器。此特权容器被精心构造，其`HostConfig`参数中的`Binds`字段用于将宿主机上任意指定目录（通过Windows路径转换后得到）挂载到容器内部的一个目录（例如`/host_root`）。一旦宿主机的指定路径被成功挂载到容器中，容器就可以执行任意命令，例如通过`cat`命令读取宿主机上的敏感文件内容，或者通过`printf`命令向宿主机文件写入任意内容。这实际上赋予了容器对宿主机文件系统的读写权限，从而实现完全的宿主机接管。脚本还包含了一系列健壮性检查，如对`/_ping`和`/version` API的探测，以确保与Docker Engine API的连通性。

此漏洞的严重性在于，一旦攻击者成功在任何一个Docker Desktop容器中实现代码执行，即可利用此漏洞突破容器沙箱，进而获得对宿主机的控制权，包括读取敏感配置、修改系统文件、部署恶意软件等。考虑到Docker Desktop的广泛使用，以及其通常运行在开发人员或企业的核心工作站上，该漏洞的潜在影响是巨大的。

利用步骤：
1.  **初始访问**：攻击者首先需要通过其他漏洞（例如Web应用漏洞、供应链攻击等）获得在Docker Desktop上运行的某个Linux容器中的代码执行能力。这是此漏洞利用的先决条件。
2.  **获取POC脚本**：攻击者将POC脚本`POC-for-CVE-2025-9074.sh`传输到已受控的容器内部。
3.  **读取宿主机文件**：在容器内部，攻击者执行POC脚本并指定要读取的宿主机文件路径。例如，要读取Windows系统的`C:\Windows\system.ini`文件内容，攻击者会运行：`bash POC-for-CVE-2025-9074.sh -read "C:/Windows/system.ini"`。脚本会自动处理路径转换、容器创建、挂载和文件读取，并将文件内容输出到标准输出。
4.  **写入宿主机文件**：攻击者也可以利用该POC向宿主机文件写入内容。例如，要向`C:\temp\malicious.txt`写入特定字符串，可以执行：`bash POC-for-CVE-2025-9074.sh -write "恶意内容" "C:/temp/malicious.txt"`。脚本将执行相同的流程，并在成功写入后给出提示。
5.  **后续操作**：通过对宿主机文件的读写能力，攻击者可以进一步进行持久化、提权或横向移动，最终完全控制宿主机系统。

投毒风险分析：
对提供的POC代码`POC-for-CVE-2025-9074.sh`进行了详细的代码审查，以评估其潜在的投毒风险。分析结果表明，该POC脚本的投毒风险极低，评估为约5%。以下是详细的理由：

1.  **代码清晰度**：脚本采用标准的Bash语法编写，逻辑清晰，结构分明。所有操作，包括变量定义、函数调用、HTTP请求的构建和执行，都易于理解。没有发现任何代码混淆（如Base64编码、Hex编码、Zlib压缩等）的迹象，使得代码的意图一目了然。
2.  **标准库和工具的使用**：脚本主要依赖于常用的、标准的Linux命令行工具，如`curl`（用于HTTP通信）、`sed`（用于文本处理和路径转换）、`cut`（用于字符串截取）、`basename`、`dirname`（用于路径操作）、`printf`和`cat`（用于文件I/O）。这些都是成熟且经过广泛验证的工具，其行为是可预测的，不包含隐蔽的恶意功能。
3.  **无外部恶意连接**：除了对Docker Engine API（位于本地内部IP地址192.168.65.7:2375）的合法API调用外，脚本没有尝试建立任何到外部恶意C2服务器或其他不明地址的网络连接。所有HTTP请求都明确指向本地Docker API服务。
4.  **无恶意负载**：脚本本身不包含任何嵌入式的恶意负载（如shellcode、病毒、后门程序等）。它利用的是Docker Engine API的合法功能来演示漏洞，所有对宿主机的文件读写操作都直接由用户通过命令行参数控制内容和路径，并未硬编码任何恶意内容。
5.  **容器镜像安全**：POC在创建临时容器时，默认使用`alpine`镜像。`alpine`是一个非常流行且精简的Linux发行版，广泛用于容器环境，通常被认为是安全的基石镜像。脚本未尝试从不可信的注册表拉取镜像，也未在容器内部执行任何可疑的`apt-get install`或`yum install`等包管理命令。
6.  **可控的命令执行**：脚本通过构建JSON payload将命令传递给Docker Engine执行。这些命令（`printf`或`cat`）以及其参数都是直接从用户输入中构造，并通过单引号严格包裹，避免了命令注入的风险（至少在POC脚本本身层面）。

鉴于上述分析，该POC脚本是一个纯粹用于安全研究和验证的工具，不包含任何恶意投毒行为。在受控环境中进行防御性研究时，可以相对安全地使用此POC，但作为最佳实践，任何POC代码在执行前都应进行独立的审查。

**项目地址:** N/A

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-9074
