## CVE-2025-49844 - Redis Use-After-Free (UAF), 远程代码执行 (RCE)

**漏洞编号:** CVE-2025-49844

**漏洞类型:** Use-After-Free (UAF), 远程代码执行 (RCE)

**影响应用:** Redis

**危害等级:** 严重/Critical

**CVSS评分:** 10.0

**影响版本:** 所有支持Lua脚本的版本，包括Redis 6.x-8.x全分支，具体受影响版本如低于Redis 6.2.20，以及所有低于特定补丁版本 (例如Redis 7.2.22, 7.8.6, 7.4.6, 7.2.4, 6.4.2的最新安全补丁) 的Redis实例。

**利用条件:** 需要认证，攻击者需具备Redis的低权限或以上用户权限。

**POC 可用性:** 4/10

**POC 类型:** 概念验证

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

该POC（Proof of Concept）代码旨在验证Redis中存在的CVE-2025-49844 Lua脚本Use-After-Free (UAF) 漏洞。此漏洞被命名为“RediShell”，且CVSS评分高达10.0，表明其具有极高的严重性，可以导致未经授权的远程代码执行。该漏洞是由于Redis的Lua脚本执行模块中，经过认证的攻击者可以通过构造特殊的Lua脚本，操控垃圾回收机制，触发释放后重用（Use-After-Free）漏洞，进而可能导致任意代码执行并使得服务器失陷。

**POC有效性分析：**
该POC采用Python编写，利用`redis-py`库与目标Redis实例进行交互。POC的初始阶段包含了对Redis连接和Lua脚本启用状态的检查。首先，通过`test_connection`函数尝试建立与Redis服务器的连接，并获取其`INFO`信息，例如Redis版本。这一步是确保攻击者能够访问目标服务器并收集基本信息。随后，`check_lua_enabled`函数通过执行一个简单的Lua脚本（`return 'test'`）来确认Redis实例是否支持并启用了Lua脚本功能，因为此漏洞正是利用了Lua解释器中的缺陷。这两个前置检查对于后续的漏洞利用至关重要。
核心的漏洞触发逻辑位于`exploit_uaf_basic`函数中。该函数包含一个精心构造的Lua脚本，其目的是模拟CVE-2025-49844所利用的UAF模式。脚本的核心思想是创建一个带有`__gc`（垃圾回收）元表的Lua表。当这个表在垃圾回收过程中被销毁时，`__gc`元表中的函数会被调用。POC中的`__gc`函数仅执行了`redis.log(redis.LOG_WARNING, "UAF触发点")`，这是一个无害的日志操作，用于在Redis服务器日志中留下痕迹，表明UAF的触发点已被触及。为了增加UAF条件被触发的可能性，脚本随后在一个循环中多次调用`collectgarbage("collect")`，强制Lua解释器进行垃圾回收。
需要注意的是，POC代码明确指出这是一个“简化的演示”，并且实际的CVE-2025-49844利用涉及“Lua解释器中的复杂内存操作”。这意味着该POC本身并未实现完整的远程代码执行（RCE）功能，也未提供一个可交互的shell。它的主要目的在于验证底层UAF漏洞的存在，即通过特定的Lua脚本能够导致Redis的Lua解释器进入一个UAF状态。成功执行该脚本并观察到日志中的“UAF触发点”信息，即可证明目标系统存在该漏洞。因此，该POC的有效性在于它是一个成功的概念验证工具，能够确认漏洞的可触发性，但并非一个完全武器化的利用代码。对于防御者而言，这是一个有价值的工具，可以用来扫描和验证自家Redis实例是否受到此高危漏洞的影响。

**利用步骤：**
1. 确保目标Redis服务器运行受影响版本，并且Lua脚本功能已启用。
2. 确保拥有目标Redis服务器的认证凭证（如果Redis配置了密码），具备低权限或以上用户权限。
3. 使用提供的Python POC脚本，指定目标Redis服务器的IP地址、端口和密码（如果需要）。
4. 脚本会首先尝试连接Redis并检查Lua脚本是否启用。
5. 成功连接并确认Lua启用后，脚本会执行内置的Lua脚本，该脚本旨在通过多次强制垃圾回收来触发Use-After-Free条件。
6. 如果UAF模式被成功触发（即使是简化演示），脚本会报告"UAF模式已执行"，并在Redis服务器日志中留下"UAF触发点"的警告信息。
7. 为了达到完整的远程代码执行，攻击者需要进一步构造更复杂的Lua脚本，利用UAF漏洞进行内存损坏，从而绕过Lua沙箱并执行任意系统命令。此POC代码未实现RCE，仅为UAF概念验证。

**投毒风险分析：**
对该POC代码的投毒风险评估为低，具体百分比约为10%。此评估基于对代码的结构、依赖、行为以及其核心功能的全面分析：
首先，从代码的依赖库来看，该POC使用了Python的`redis`库（用于与Redis通信）、`sys`（系统接口）、`argparse`（命令行参数解析）和`colorama`（命令行颜色输出）。这些都是Python生态系统中广泛使用且经过充分审查的标准或准标准库。没有发现引入任何不常见、已被报告存在安全问题或具有潜在恶意功能的第三方库。这大大降低了通过依赖库引入恶意代码的风险。
其次，对POC的核心逻辑进行深入分析。代码的主体是连接、检查和执行一个嵌入式的Lua脚本。该Lua脚本的唯一已知目的是触发Redis Lua解释器中的Use-After-Free漏洞模式。脚本中唯一的“副作用”是调用`redis.log`函数向Redis服务器的日志文件写入一条警告信息，表明UAF模式已被触及。这个操作是合法且无害的，旨在提供漏洞触发的可见性。脚本内部没有包含任何直接的远程代码执行负载（例如，没有`os.execute()`、`io.popen()`或其他系统级调用），也没有尝试进行文件读写、网络连接到外部地址或数据窃取等恶意行为。
再者，代码的透明度和可读性非常高。整个脚本没有进行任何形式的代码混淆或加密，变量和函数命名清晰，注释也提供了对逻辑的解释。这种高度的透明性使得任何潜在的恶意行为都难以隐藏，便于安全研究人员进行代码审计和分析。
最后，从网络行为角度看，POC仅与用户指定的Redis服务器进行通信。它不会连接到其他未知的IP地址，也不会从外部下载任何代码或数据。所有的交互都局限于标准的Redis协议和命令。
综上所述，该POC代码被设计为一个纯粹的概念验证工具，用于演示和验证CVE-2025-49844漏洞的存在。其内部没有任何明显的恶意负载、可疑行为或试图隐藏自身意图的迹象。因此，将其用于漏洞验证时，投毒风险极低，用户可以相对安全地运行和分析该代码。

**项目地址:** N/A

**漏洞详情:** https://redis.io/blog/security-advisory-cve-2025-49844/
