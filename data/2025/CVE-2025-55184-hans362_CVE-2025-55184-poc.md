## CVE-2025-55184 - React Server Components (RSC), Next.js, Waku 拒绝服务 (Denial of Service)

**漏洞编号:** CVE-2025-55184

**漏洞类型:** 拒绝服务 (Denial of Service)

**影响应用:** React Server Components (RSC), Next.js, Waku

**危害等级:** 高危

**CVSS评分:** 7.5

**影响版本:** 未明确指定受影响版本，但建议立即升级到已打补丁的版本，注意CVE-2025-67779是对CVE-2025-55184的不完整修复

**利用条件:** 无需认证，远程通过恶意构造的HTTP请求即可触发

**POC 可用性:** 8/10

**POC 类型:** 概念验证 (Proof of Concept)

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

POC有效性分析:
该漏洞CVE-2025-55184涉及React Server Components (RSC) 中的拒绝服务（DoS）问题，根据多个安全通告（如腾讯云、Nessus、深信服）描述，其根本原因在于服务器函数端点（Server Function Endpoint）在接收到HTTP请求的payload时，执行了不安全的payload反序列化，导致触发无限循环，从而耗尽CPU资源，使服务器进程挂起，并阻碍后续HTTP请求的响应。

提供的POC代码包含两个Python脚本：`poc-nextjs.py`和`poc-waku.py`。这两个脚本都使用Python的`requests`库来模拟恶意HTTP请求。
`poc-nextjs.py`针对默认运行在`http://localhost:3000`的Next.js应用。它发送一个`POST`请求，包含一个`Next-Action`头（值为"x"）和一个`files`参数。`files`参数中的内容是`{"0": ("", '"$@0"')}`，这是一个精心构造的字符串`"$@0"`，目的在于利用反序列化逻辑中的循环引用或递归处理缺陷。当服务器尝试反序列化此 payload 时，预期会进入无限循环状态。
`poc-waku.py`则针对默认运行在`http://localhost:8080/RSC/x.txt`的Waku应用。它也发送一个`POST`请求，包含相同的`files`参数`{"0": ("", '"$@0"')}`，但不包含`Next-Action`头。这表明不同受影响的RSC实现或框架可能在请求的URL或头部要求上存在细微差异，但核心恶意payload是相似的。

这两个POC的有效性在于它们直接模拟了漏洞描述中提到的“恶意构造的HTTP请求”和“不安全反序列化”过程。通过在本地搭建受影响版本的Next.js或Waku环境进行测试，可以验证这些POC是否能成功导致目标服务挂起。如果目标服务在收到请求后不再响应，且CPU利用率飙升，则POC被认为是有效的。由于POC代码简洁明了，没有引入复杂的逻辑或外部依赖，其可靠性较高。

利用步骤:
攻击者利用此漏洞的步骤相对简单，主要分为以下几步：
1.  **识别目标：** 确定目标网站或应用是否使用了React Server Components (RSC)，并且其服务器函数端点是否可公开访问。这可能涉及识别Next.js、Waku等基于RSC的框架。
2.  **定位端点：** 识别RSC服务器函数端点的URL。对于Next.js，这通常是根路径或带有特定头部信息；对于Waku，可能是`/RSC/...`之类的路径。
3.  **构造恶意请求：** 使用HTTP POST方法，根据目标RSC框架的特点，构造包含恶意反序列化payload的HTTP请求。核心payload是`"$@0"`，它被设计用于触发反序列化过程中的无限循环。可能需要添加特定的HTTP头，如Next.js的`Next-Action`头。
4.  **发送请求：** 将构造好的恶意HTTP请求发送到目标RSC服务器函数端点。
5.  **观察效果：** 观察目标服务的响应。如果攻击成功，目标服务将因CPU资源耗尽而挂起，不再响应新的HTTP请求，从而导致拒绝服务。

此漏洞的利用无需认证，这意味着任何能够访问目标RSC端点的攻击者都可能发起攻击。攻击复杂度较低，因为攻击者只需发送一个精心构造的HTTP请求即可。自动化攻击的可能性很高。

投毒风险分析:
提供的POC代码的投毒风险极低，评估为10%。详细分析如下：
1.  **代码透明度与可读性：** POC代码由两个独立的Python脚本组成，`poc-nextjs.py`和`poc-waku.py`。它们的结构和逻辑非常清晰，不含任何形式的代码混淆、加密或压缩，使得任何具备Python基础的分析人员都可以轻松地阅读、理解并审查其功能。这种高度的透明性是评估低投毒风险的关键因素。
2.  **外部依赖审查：** 脚本仅引入了Python标准库和`requests`库。`requests`库是Python生态系统中一个高度成熟、广泛使用且经过严格审计的HTTP客户端库，由知名社区维护，其本身被恶意篡改的可能性极低。POC没有导入或执行任何来自未知来源或信誉不佳的第三方模块，也未包含通过网络动态加载或执行任意代码的机制。
3.  **行为分析与目的单一性：** 两个POC脚本的核心功能都是构造并发送一个特定的HTTP POST请求到预设的目标地址。该请求的payload（`{"0": ("", '"$@0"')}`）是硬编码在脚本中的，并且是专门针对React Server Components中反序列化漏洞的设计模式。此payload的目标是触发服务器端的无限循环，从而达到拒绝服务的效果，而非执行任意命令、窃取敏感信息、创建后门账户、修改文件系统或建立持久性连接等典型的恶意行为。脚本执行完成后，仅通过标准输出（`print`语句）报告攻击尝试的状态，没有尝试进行任何形式的日志擦除、数据回传或与外部C2服务器通信。
4.  **无持久化与隐蔽性机制：** POC代码中没有发现任何试图在目标系统上留下持久化机制（如修改启动项、创建服务、植入后门程序等）或隐藏自身行为（如进程伪装、文件隐藏）的迹象。它的生命周期仅限于执行请求并等待响应。
5.  **资源消耗模式：** 尽管POC旨在造成拒绝服务，消耗目标系统的CPU资源，但这是一种直接的、可观察到的攻击行为，与静默植入恶意软件或进行隐蔽数据窃取截然不同。这种资源消耗是漏洞利用的直接结果，而非POC代码本身的隐藏恶意功能。
综上所述，根据对代码的全面审查，可以确认该POC旨在作为一个纯粹的功能性验证工具，其目标明确且局限于漏洞复现，不包含任何与攻击者“投毒”目的相关的额外恶意代码或行为。尽管如此，在执行任何来自外部来源的POC时，始终建议在隔离的、受控的沙箱环境中进行，并对代码进行人工审查和动态行为监控，以应对潜在的、尽管在此处风险极低的，未来变种或伪装攻击。

**项目地址:** 未公开披露的本地文件路径

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-55184
