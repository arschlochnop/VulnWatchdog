## CVE-2025-55184 - React Server Components 拒绝服务 (Denial of Service, DoS)

**漏洞编号:** CVE-2025-55184

**漏洞类型:** 拒绝服务 (Denial of Service, DoS)

**影响应用:** React Server Components

**危害等级:** 高危

**CVSS评分:** N/A

**影响版本:** 未更新至最新版本的React Server Components

**利用条件:** 无需认证，远程可利用，通过构造恶意HTTP请求触发

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 0%

## 详情

React Server Components (RSC) 存在一个高危的预认证阶段拒绝服务（DoS）漏洞，编号为 CVE-2025-55184。该漏洞源于RSC在处理特定构造的“Flight Payload”数据时，反序列化机制未能正确处理循环引用（Cyclical Promise References），导致服务器陷入无限循环，最终耗尽资源并中断服务。攻击者无需任何认证即可利用此漏洞，通过发送恶意HTTP请求触发该无限循环。奇安信CERT、阿里云、深信服等安全厂商均已关注并发布预警。相关的另一个漏洞 CVE-2025-67779 也涉及类似的循环Promise引用，而 CVE-2025-55183 则是中危的源代码暴露漏洞，虽然与本DoS漏洞不同，但一同揭示了RSC可能存在的安全隐患。此漏洞的核心在于攻击者可以构造一个恶意的RSC Flight Payload，其中包含相互引用的Promise对象或数据结构，当服务器尝试解析这些数据时，将进入一个无法退出的循环状态，从而导致拒绝服务。该漏洞利用通常涉及对 `rsc-action` 或 `Next-Action` HTTP头的操作，以及通过 `multipart/form-data` 传输特制的payload。

**POC有效性分析**
提供的两个Python POC脚本（`1.py` 和 `2.py`）旨在验证 CVE-2025-55184 拒绝服务漏洞。两个脚本都使用 `requests` 库向目标React Server Components应用发送特制的POST请求，并利用请求超时来判断DoS是否成功。
*   `1.py` 是一个简洁的验证脚本，它发送一个包含 `"$@0"` 作为文件内容的数据，并设置了 `rsc-action` 和 `Next-Action` HTTP头。`"$@0"` 是一种典型的自引用构造，旨在触发反序列化过程中的循环引用问题。如果服务器因处理此恶意Payload而陷入无限循环，`requests` 请求将因设定的短超时而中断。脚本会打印“DoS attempt sent”，表明服务器可能已受影响。这是一个基础但有效的概念验证。
*   `2.py` 则更为复杂和精巧，它构造了一个“PRE-INITIALIZED cyclic payload”，旨在通过在元数据块中使用 `setup` 数组来强制初始化一个更复杂的循环引用（B -> C -> B），然后主块 (A) 再引用这个预先建立的循环。这种设计旨在绕过或规避RSC中可能存在的简单循环检测机制，因为它确保了在实际访问根对象之前，内部循环就已经被强制初始化。具体来说，它构建了一个包含五个部分（chunk 0, 1, 2, 3, 4）的 `files` 字典。其中，Chunk 1 (A) 弱引用 Chunk 2 (B)，Chunk 2 (B) 弱引用 Chunk 3 (C)，而 Chunk 3 (C) 则强制引用回 Chunk 2 (B)，从而形成 B-C-B 的循环。Chunk 4 (Meta) 中的 `setup` 字段强制初始化 B 和 C，预先建立循环，其 `bound` 字段则弱引用到 Chunk 1 (A)。当服务器处理这个精心构造的 Payload 时，`setup` 阶段强制解析循环引用，随后对 A 的访问将导致无限循环，最终耗尽服务器资源。脚本同样使用 `timeout` 参数来检测服务器是否进入挂起状态，如果请求超时，则认为 DoS 攻击成功。
综合来看，这两个POC脚本都提供了有效的机制来触发和检测此DoS漏洞，特别是 `2.py` 展示了更深层次的利用技巧，表明它们具有很高的有效性。

**利用步骤**
1.  **目标识别**: 识别使用了React Server Components技术栈的Web应用程序，通常可以通过分析其前端代码或网络请求特征来判断。
2.  **构造恶意Payload**: 参照POC脚本的原理，构造一个恶意的RSC Flight Payload。该Payload应包含在反序列化过程中会导致无限循环的循环引用结构。例如，使用 `$@` 形式的弱引用或 `$h` 形式的强引用来构建一个自引用或相互引用的链条。关键在于设计能让RSC反序列化器陷入死循环的数据结构，如 `{"setup":["$2","$3"],"id":"test","bound":"$@1"}` 这样的元数据块，结合多个引用块形成预初始化的循环。
3.  **发送HTTP请求**: 将构造好的Payload作为HTTP POST请求体的一部分（通常以 `multipart/form-data` 形式），发送到目标应用程序。请求头中需包含 `rsc-action` 和 `Next-Action` 等必要的RSC相关头信息，其值可根据目标应用程序实际情况调整或推测。
4.  **观察效果**: 监控目标服务器的响应情况。成功的利用将导致服务器资源（如CPU、内存）被耗尽，服务响应变慢或完全停止，最终达到拒绝服务的效果。POC脚本中通过设置短超时来判断服务器是否挂起是一种有效的检测方式，实际攻击中则可能通过对目标服务可用性的持续监控来确认。

**投毒风险分析**
针对所提供的POC代码，投毒风险评估为**低**（0%）。分析依据如下：
1.  **代码透明度高**: 两个Python脚本都非常简洁明了，没有进行任何混淆处理。代码逻辑清晰，易于阅读和理解其意图。研究人员可以轻松审查代码，确认其功能仅限于漏洞验证。
2.  **标准库使用**: 脚本仅依赖Python标准库 `requests` 进行HTTP通信。`requests` 是一个广泛使用且经过充分审查的库，本身不包含恶意功能。没有引入其他可疑的第三方库或模块。
3.  **无外部恶意行为**: 代码中没有发现任何尝试连接非预期外部地址、下载和执行未知代码、修改系统配置、写入文件、或进行其他恶意系统级操作的行为。所有网络流量都清晰地指向用户在脚本中定义的目标URL (`http://localhost:3000` 或 `http://localhost:3001`)。没有证据表明存在命令注入、文件写入或远程 shell 等恶意功能。
4.  **功能单一**: 脚本的唯一目的是通过发送特定构造的HTTP请求来触发拒绝服务漏洞并检测其效果。它不包含任何后门、信息窃取、远程代码执行或其他形式的攻击代码。其设计目的纯粹是为了防御性安全研究和漏洞验证。
5.  **无动态代码执行**: 代码中没有使用 `eval()`、`exec()` 或其他可能导致动态执行恶意代码的函数。Payload内容是硬编码的JSON字符串，并通过 `requests` 库以数据形式发送，而不是作为代码执行。
综上所述，这些POC代码是专为防御性安全研究和漏洞验证而编写的，其内容和行为均符合预期，不携带任何恶意投毒成分。在复制和使用这些POC时，用户只需关注其目标URL和请求头等配置，无需担忧代码本身带来额外的安全风险。

**项目地址:** N/A

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-55184
