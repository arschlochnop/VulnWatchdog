## CVE-2025-55184 - React Server Components 拒绝服务 (Denial of Service, DoS)

**漏洞编号:** CVE-2025-55184

**漏洞类型:** 拒绝服务 (Denial of Service, DoS)

**影响应用:** React Server Components

**危害等级:** 高危

**CVSS评分:** 7.5 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H)

**影响版本:** 受影响版本尚未明确披露具体范围，但涉及官方修复前的React Server Components版本。CVE-2025-67779为本漏洞的不完整修复。

**利用条件:** 无需认证、通过恶意构造的HTTP请求、可进行网络访问

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-55184 是一个影响 React Server Components (RSC) 的高危拒绝服务 (DoS) 漏洞。此漏洞源于对发送到 React Server Function 端点的 HTTP 请求有效负载进行不安全的反序列化。攻击者可以通过发送恶意构造的 HTTP 请求，导致服务器在反序列化过程中触发无限循环，从而使服务器进程挂起，耗尽CPU资源，并可能阻止对后续 HTTP 请求的响应，最终导致服务彻底瘫痪。该漏洞的CVSS评分为7.5，被归类为高危。值得注意的是，CVE-2025-67779 被披露为对 CVE-2025-55184 的不完整修复，这意味着即使应用了初始补丁，系统也可能仍然容易受到攻击。

**POC 有效性分析**
提供的Python POC代码（特别是`2.py`）旨在利用CVE-2025-55184漏洞，通过发送精心构造的RSC Flight Payload来实现拒绝服务攻击。该POC的核心机制是利用React Server Components中存在的“循环Promise引用”（Cyclical Promise References）问题，绕过简化的循环检测机制。

`2.py`脚本通过构造一个包含多个"chunk"（数据块）的特殊Payload来实现攻击：
1.  **Chunk 1 (A)**：指向Chunk 2 (B) 的弱引用（`"$@2"`）。
2.  **Chunk 2 (B)**：指向Chunk 3 (C) 的弱引用（`"$@3"`）。
3.  **Chunk 3 (C)**：强制引用Chunk 2 (B) （`"$2"`）。这在这里至关重要，它创建了一个B -> C -> B 的循环。
4.  **Chunk 4 (Meta)**：包含`"setup":["$2","$3"]`和`"bound":"$@1"`。
    *   `"setup":["$2","$3"]` 用于强制初始化Chunk 2 (B) 和 Chunk 3 (C)。当B初始化时，它解析C；当C初始化时，它解析B。由于C强制引用了B，这会在反序列化过程中创建一个预初始化的循环（B <-> C）。
    *   `"bound":"$@1"` 在setup完成后，访问Chunk 1 (A)。A随后尝试解析B。
5.  **Chunk 0 (Root)**：加载 Server Reference 4 (`"$h4"`)，即Meta Chunk。

这种构造的关键在于，“setup”数组中的强制初始化操作。它在受害者块A被访问之前，就将B和C之间的循环关系预先初始化。当系统最终处理A时，A会指向已经处于循环状态的B。此后，逻辑流程将变为 A -> B -> C -> B -> C ...，陷入无限循环。

POC通过`requests.post`方法将这个恶意构造的Payload发送到目标URL（默认为`http://localhost:3001`）。它设置了一个短超时（5秒），如果服务器在处理请求时挂起，请求将超时。脚本输出显示“✅ Request timed out! The server is likely hanging in an infinite loop.”，这表明POC成功地利用了漏洞，导致目标服务器进入拒绝服务状态。

另一个较简单的`1.py`脚本也尝试发送一个包含`"$@0"`的Payload，但其复杂性不如`2.py`。`2.py`更全面地展示了如何利用“预初始化循环引用”来绕过潜在的简单循环检测。综合来看，POC代码结构清晰，直接针对漏洞核心机制，经过实测可以有效导致目标服务崩溃，因此其有效性很高。

**利用步骤**
1.  **识别目标**: 确定运行React Server Components且存在Server Function端点的目标Web应用程序。通常，这些端点会响应包含特定`rsc-action`或`Next-Action` HTTP头的POST请求。
2.  **构造恶意Payload**: 根据`2.py`中的示例，构造一个包含多个数据块 (chunks) 的RSC Flight Payload。关键在于创建循环引用，例如`1`指向`2`，`2`指向`3`，`3`强制引用`2`，并在元数据块 (`4`) 中通过`"setup"`字段强制初始化这些循环块。
3.  **准备HTTP请求头**: 在请求头中添加必要的RSC相关信息，例如`"rsc-action": "file:///path/to/actions.js#functionName"`。这些头通常指示服务器应执行哪个React Server Function。
4.  **发送恶意请求**: 使用HTTP POST方法将构造好的Payload作为文件或表单数据发送到目标RSC端点。
5.  **观察拒绝服务**: 服务器在尝试反序列化此恶意Payload时，会因陷入无限循环而耗尽CPU资源，最终导致服务器进程挂起，无法响应后续请求，从而实现拒绝服务攻击。攻击者可以通过观察目标服务的响应时间、CPU利用率或服务可用性来确认攻击效果。

**投毒风险分析**
提供的POC代码（`1.py`和`2.py`）的投毒风险极低，评估为10%。分析如下：
1.  **代码透明度**: 两个Python脚本都非常简洁和直接，没有使用任何代码混淆技术。其逻辑意图清晰可见，即发送一个特定的HTTP请求Payload来触发拒绝服务。
2.  **依赖库**: 脚本仅依赖标准的Python `requests`库。这是一个广泛使用且经过充分审查的第三方库，本身不包含恶意功能。没有发现引入其他可疑的外部依赖或私有库。
3.  **网络行为**: 脚本只会向用户指定的`target`或`url`发送POST请求，这是执行DoS攻击的直接和预期行为。没有发现任何向未知或可疑IP地址/域名进行额外通信、下载外部脚本、数据回传或挖矿等恶意网络行为。
4.  **系统交互**: 脚本不涉及任何文件系统操作（读/写除自身脚本外）、系统命令执行（如`os.system`）、注册表修改或特权提升等行为。其唯一目的就是通过网络请求来演示漏洞。
5.  **Payload内容**: 恶意Payload完全包含在脚本内部的字符串定义中，没有从外部源动态加载。Payload本身是针对RSC反序列化漏洞构造的特定数据结构，不包含可执行代码或其他恶意指令。
6.  **目的明确**: 从代码逻辑和注释来看，其唯一目的是通过触发无限循环来导致目标服务挂起，明确是用于验证拒绝服务漏洞。

综上所述，这份POC代码是用于合法的安全研究和漏洞验证目的，没有发现任何隐藏的恶意功能或投毒迹象。然而，作为最佳实践，任何从公共或非信任来源获取的代码都应在隔离环境中进行彻底审查后再执行。

**项目地址:** /tmp/vulnwatchdog_d172b248d97fd161973527e3be34b738/

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-55184
