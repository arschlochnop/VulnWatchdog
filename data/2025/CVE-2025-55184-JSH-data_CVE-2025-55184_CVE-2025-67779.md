## CVE-2025-55184 - React Server Components 拒绝服务 (Denial of Service)

**漏洞编号:** CVE-2025-55184

**漏洞类型:** 拒绝服务 (Denial of Service)

**影响应用:** React Server Components

**危害等级:** 高危

**CVSS评分:** 7.5

**影响版本:** 受影响版本为已发布补丁前的React Server Components，以及针对CVE-2025-55184修复不完整的版本（CVE-2025-67779）。具体版本号未明确披露，但建议立即升级到最新修复版本。

**利用条件:** 无需认证、通过恶意构造的HTTP POST请求远程利用、需要网络访问

**POC 可用性:** 9/10

**POC 类型:** 概念验证

**攻击复杂度:** 低

**投毒风险:** 5%

## 详情

POC有效性分析:
此POC代码，特别是`2.py`脚本，精确而有效地展示了CVE-2025-55184漏洞所描述的React Server Components拒绝服务（DoS）漏洞。该漏洞的核心在于React Flight Server反序列化机制中的一个缺陷，攻击者可以通过构造恶意的HTTP POST请求，诱导服务器在处理数据时陷入无限循环，从而耗尽CPU资源并导致服务不可用。

`2.py`脚本通过一个精巧设计的multipart/form-data载荷实现了这一攻击。载荷中的每个部分代表React Flight协议中的一个“数据块”（chunk）。脚本首先定义了三个互相引用的数据块：`chunk 1`（A）弱引用`chunk 2`（B），`chunk 2`（B）弱引用`chunk 3`（C），以及`chunk 3`（C）强制引用`chunk 2`（B）。这种设计创建了一个 `B -> C -> B` 的循环引用链。更为关键的是，脚本引入了一个元数据块`chunk 4`，其中包含一个`"setup"`数组，专门用于在主数据处理之前，强制初始化`chunk 2`（B）和`chunk 3`（C）。这种预初始化机制是绕过“简单周期检测”（例如，那些仅检查当前正在检查的值是否构成循环的机制）的关键。一旦`B`和`C`被预先初始化并解析了它们之间的循环引用，元数据块`chunk 4`的`"bound"`字段随后指向`chunk 1`（A）。当服务器开始处理`chunk 1`时，它会尝试解析`chunk 1`对`chunk 2`的引用，进而卷入到已经被预初始化并存在循环的`B -> C -> B`链中。此时，由于循环已经形成且被强制初始化，服务器将不断尝试解析这个永无止境的循环，最终陷入无限循环状态。

脚本使用Python的`requests`库发送此恶意请求，并设置了5秒的超时。如果目标服务器易受攻击，它将在处理载荷时挂起，导致请求超时。当发生超时时，脚本会输出“✅ Request timed out! The server is likely hanging in an infinite loop.”，这清晰地验证了拒绝服务攻击的成功。服务器的进程将停止响应，从而实现了DoS效果。相比之下，`1.py`脚本似乎是一个更简单或不同变体的尝试，其载荷`"$@0"`并不包含复杂的循环逻辑，可能无法有效触发相同的无限循环机制，或者需要特定的环境配置才能生效。因此，`2.py`是针对CVE-2025-55184描述的核心反序列化无限循环漏洞的更准确和有效的概念验证。

利用步骤:
要复现和验证此漏洞，请遵循以下步骤：
1.  **环境设置**: 确保您的目标系统上运行着基于React Server Components的应用程序，或者使用React Flight协议的框架（如某些版本的Next.js）。POC代码默认将目标地址设置为`http://localhost:3001`，请根据实际测试环境修改`url`变量以指向您的目标服务。
2.  **安装Python依赖**: 在执行POC脚本的机器上，您需要安装`requests` Python库。如果尚未安装，请通过命令行运行`pip install requests`进行安装。
3.  **获取POC代码**: 将`2.py`脚本保存到您的本地文件系统。
4.  **执行攻击**: 打开终端或命令提示符，导航到保存`2.py`脚本的目录，然后执行命令：`python 2.py`。
5.  **观察结果**: 脚本将发送恶意构造的HTTP POST请求到指定的目标URL。
    *   如果目标服务器存在该漏洞，它将在处理恶意载荷时进入无限循环，导致服务器进程挂起并无法响应。此时，您会观察到`2.py`脚本在5秒后因超时而终止，并打印出确认消息：“✅ Request timed out! The server is likely hanging in an infinite loop.” 这表明拒绝服务攻击已经成功，目标服务已不可用。
    *   如果目标服务器未受影响（例如，已打补丁或不运行受影响版本），请求可能会正常完成并返回响应，脚本将打印服务器返回的状态码和响应体，且不会报告超时。
攻击者可以通过循环执行此脚本，持续发送恶意请求，从而长时间地维持对目标服务的拒绝服务状态。

投毒风险分析:
对提供的POC代码进行详细分析后，可以评估其投毒风险极低，约为5%。该评估基于以下几个关键因素：
1.  **代码透明度与可读性**: POC代码（尤其是`2.py`）结构清晰，逻辑直接，没有经过任何形式的代码混淆。所有关键部分，包括恶意载荷的构造，都以明文形式呈现，并且附有详细的注释，解释了攻击的原理和意图。这使得任何熟悉Python和HTTP协议的分析人员都能轻松理解其功能，从而排除了隐藏恶意代码的可能性。
2.  **标准库和可信依赖**: 脚本仅依赖于Python标准库以及广受欢迎且经过严格审查的第三方库`requests`。`requests`库是Python生态系统中用于HTTP请求的标准工具，其代码库开放透明且拥有庞大的用户群和维护者社区，极少存在隐藏恶意功能的风险。POC中没有引入其他任何非标准或可疑的外部依赖。
3.  **行为范围限制**: POC的行为范围严格限定在构造并发送HTTP POST请求，以及接收和处理服务器响应。它不执行任何文件系统操作（如读写文件、创建目录）、不访问敏感系统资源、不修改注册表、不创建新的进程、不监听网络端口、不安装服务或驱动。其所有操作都仅限于网络通信层面，且目标明确，即触发服务器端的反序列化循环。
4.  **无数据收集或回传**: 代码中没有任何收集目标系统信息（如系统配置、用户凭证）、将数据外传到第三方服务器、或建立持久化控制的机制。它是一个纯粹的“打完就跑”式的验证脚本，只关注是否能触发DoS。
5.  **无混淆或加密**: 代码中不包含任何旨在隐藏其真实意图的加密或混淆技术。这意味着恶意行为无法在不被发现的情况下嵌入其中。

综上所述，该POC代码是典型的安全研究工具，其设计和实现均围绕验证特定漏洞的目的。它没有表现出任何恶意软件、后门或投毒的特征。对于组织而言，使用此类POC进行防御性测试是安全的，但仍建议在隔离环境中进行，以避免对生产环境造成意外影响（例如，真实触发DoS）。

**项目地址:** https://github.com/vulnwatchdog/CVE-2025-55184_CVE-2025-67779

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-55184
