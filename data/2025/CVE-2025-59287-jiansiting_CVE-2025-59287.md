## CVE-2025-59287 - Microsoft Windows Server Update Services (WSUS) 非安全反序列化导致远程代码执行

**漏洞编号:** CVE-2025-59287

**漏洞类型:** 非安全反序列化导致远程代码执行

**影响应用:** Microsoft Windows Server Update Services (WSUS)

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 未知

**利用条件:** 需要获取WSUS加密密钥；通过网络访问GetCookie()端点

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 0%

## 详情

该公开披露的POC材料详细描述了CVE-2025-59287这一关键漏洞，它影响着Microsoft Windows Server Update Services (WSUS)。此漏洞源于WSUS在处理发送至其`GetCookie()`端点的`AuthorizationCookie`对象时存在的非安全反序列化缺陷。具体来说，系统首先使用AES-128-CBC算法对传入的Cookie数据进行解密，然后在使用`BinaryFormatter`进行反序列化时，缺乏足够的类型验证。这一设计上的弱点为攻击者提供了在WSUS服务器上以`SYSTEM`权限实现远程代码执行（RCE）的途径。`README.md`文件明确指出，此漏洞利用需要事先获取WSUS的加密密钥，而该密钥必须通过其他攻击方法获得，这强调了其作为攻击链中一环的性质。

POC的核心是一个Python脚本`cve-2025-59287-encrypt.py`。该脚本的主要功能是使用一个预设的AES密钥对一个预先构造的、Base64编码的.NET反序列化Payload（在脚本中称为`zfc`）进行加密。加密过程采用AES-128-CBC模式，并且使用一个固定的全零初始化向量（IV，`iv=b'\x00' * 16`）。加密步骤包括：首先生成一个16字节的非零salt，然后对其进行加密；接着，将主要的Payload数据分块加密；最后，如果Payload的最后一个块不足AES块大小（16字节），则会用零进行填充。脚本的输出是加密后的二进制数据，这些数据预期作为`AuthorizationCookie`的值发送到易受攻击的`GetCookie()`端点，从而触发RCE。脚本本身结构清晰，使用了`PyCryptodome`库（`Crypto.Cipher.AES`）进行密码学操作，这是一个声誉良好且广泛使用的Python包。假设提供的AES密钥是正确的，并且`zfc`代表一个有效的.NET反序列化Gadget Chain，则该脚本在功能上能够生成恶意的加密Cookie。然而，其端到端的可利用性完全取决于硬编码密钥和`zfc` Payload的准确性，以及能否成功从目标系统获取到**真实的**WSUS加密密钥，而这超出了当前POC脚本的范围。因此，尽管该脚本是漏洞利用的关键组件，但它并非一个独立的、完整的攻击链。

**利用步骤：**
1.  **前提条件：获取WSUS加密密钥。** 攻击者必须首先获取目标WSUS服务器使用的AES加密密钥。此密钥通常存储在WSUS服务器的配置文件（例如`web.config`）或系统注册表中，可能需要通过其他漏洞（如本地文件读取、信息泄露、DLL劫持）或特权升级来获取。POC脚本中包含了一个硬编码的示例密钥（`877C14E433638145AD21BD0C17393071`），但在实际攻击中，必须使用目标WSUS实例的真实密钥。
2.  **准备恶意反序列化Payload。** 攻击者需要构造一个Base64编码的.NET反序列化Gadget Chain。该Payload设计用于在WSUS服务器上执行任意代码。POC脚本中已提供一个示例`zfc`字符串，这是一个经过序列化的`System.Collections.Generic.SortedSet`对象，其内部通过`System.Collections.Generic.ComparisonComparer`调用反射机制来执行任意方法。在实际场景中，此Payload应根据攻击者的具体命令执行目标进行定制。
3.  **使用POC脚本加密Payload。** 运行提供的Python脚本`cve-2025-59287-encrypt.py`。该脚本将利用获取到的WSUS密钥，通过AES-128-CBC算法对准备好的恶意Base64 Payload进行加密。脚本的输出是一个二进制数据流，代表了加密后的`AuthorizationCookie`内容，该内容已经包含了恶意的反序列化数据。
4.  **发送恶意Cookie。** 攻击者将上一步中生成的加密数据作为`AuthorizationCookie`的值，通过构造一个恶意的HTTP POST请求，发送到目标WSUS服务器的`/GetCookie.aspx`或其他相关`GetCookie()`端点。这个请求通常会模拟正常的客户端行为，但携带着精心制作的恶意Cookie。
5.  **触发反序列化并执行代码。** WSUS服务器在接收到该请求后，会首先尝试使用其内部密钥解密`AuthorizationCookie`。解密成功后，服务器会使用`BinaryFormatter`尝试反序列化其内容。由于反序列化过程中缺乏对对象类型的严格验证（即未实施“白名单”机制），服务器会将恶意Payload视为合法对象进行实例化，从而导致预设的恶意代码（如启动一个反向Shell或执行系统命令）以`SYSTEM`权限在WSUS服务器上被成功执行。

**投毒风险分析：**
该POC代码的投毒风险被评估为**低（0%）**。
1.  **代码清晰度与可读性：** 提供的Python脚本`cve-2025-59287-encrypt.py`的代码结构极其清晰，逻辑简单直接，易于理解和审计。它专注于实现特定的AES-CBC加密功能，没有包含复杂的控制流、模糊的代码片段或任何旨在隐藏恶意意图的设计。变量命名遵循规范，函数职责明确（例如，`get_non_zero_bytes`用于生成安全的非零salt，`encrypt_payload`用于封装整个加密过程）。
2.  **依赖项分析：** 脚本主要依赖`PyCryptodome`库（`from Crypto.Cipher import AES`）执行加密操作，以及Python标准库`os`模块用于生成加密所需的随机字节。`PyCryptodome`是Python社区中广泛使用、经过严格审计且高度安全的密码学库，而`os`模块是Python内置的标准模块。这两个依赖项均无已知恶意行为或安全隐患，确保了脚本基础功能的安全性。
3.  **外部连接与下载行为：** 脚本代码中未发现任何尝试建立外部网络连接、下载外部资源、访问远程API或执行任何网络通信的指令。它是一个纯粹的本地数据处理工具，所有操作均在本地内存中完成，不与外部世界进行交互。
4.  **混淆或恶意行为检测：** 代码中没有出现任何形式的代码混淆、嵌入式后门、数据窃取逻辑、加密货币挖矿程序或其他任何可疑或恶意行为。其唯一明确的目的是根据提供的密钥和数据生成加密的Payload。值得强调的是，脚本中硬编码的Base64字符串`zfc`是**待加密的攻击Payload本身**，其内容虽然可能包含恶意代码，但这属于**攻击Payload**的范畴，而不是POC**生成工具**试图执行的恶意逻辑。POC代码的安全性在于其自身不包含恶意行为，而是生成一个用于攻击目标系统的恶意数据包。恶意代码或混淆通常会以隐蔽方式嵌入到核心功能之外，或通过难以察觉的手段集成，而该脚本不具备这些特征。
5.  **敏感系统操作：** 脚本在执行过程中不涉及任何文件系统修改、进程创建、注册表操作或任何其他可能对执行环境造成影响的特权操作。它仅在内存中对输入数据进行处理，并输出结果。
综上所述，作为防御性安全研究人员，可以安全地在隔离环境中运行和分析此POC脚本，它本身不会对研究环境造成任何损害。主要的风险点在于将**此脚本生成的恶意Payload**部署并发送到**真实的生产WSUS系统**中，这才是触发漏洞和造成危害的关键环节。

**项目地址:** 未知

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-59287
