## CVE-2025-59287 - Microsoft Windows Server Update Services (WSUS) 反序列化远程代码执行 (RCE)

**漏洞编号:** CVE-2025-59287

**漏洞类型:** 反序列化远程代码执行 (RCE)

**影响应用:** Microsoft Windows Server Update Services (WSUS)

**危害等级:** 高危

**CVSS评分:** N/A (但预计为高危，因可导致SYSTEM权限RCE)

**影响版本:** 未知

**利用条件:** 需要预先获取WSUS AES加密密钥，需要网络访问。

**POC 可用性:** 5/10

**POC 类型:** 概念验证

**攻击复杂度:** 高

**投毒风险:** 5%

## 详情

POC有效性分析：
此POC代码，特别是`cve-2025-59287-encrypt.py`脚本，旨在演示利用CVE-2025-59287这一在Microsoft Windows Server Update Services (WSUS) 中发现的严重不安全反序列化漏洞的关键步骤。该漏洞源于WSUS的`GetCookie()`端点对`AuthorizationCookie`对象的处理不当。当加密的Cookie数据使用AES-128-CBC解密后，会通过`BinaryFormatter`进行反序列化，且未进行充分的类型验证，这使得攻击者能够注入任意.NET对象，从而以SYSTEM权限实现远程代码执行（RCE）。

`encrypt.py`脚本的核心功能是使用一个已知的AES密钥和固定的全零初始化向量（IV）对预先制作的.NET反序列化Payload进行加密。它包含两个主要函数：`get_non_zero_bytes`用于生成一个16字节的非零随机盐值，以及`encrypt_payload`函数执行AES-CBC模式加密。加密过程包括首先加密生成的盐值，然后加密主要的Payload数据（如果需要，会进行填充）。

脚本的`main`函数展示了其使用方式，其中包含了一个硬编码的十六进制密钥（`877C14E433638145AD21BD0C17393071`）和一个截断的Base64编码反序列化Payload（变量`zfc`）。这个`zfc`字符串是通常由`ysoserial.net`等工具生成的、旨在实现RCE的.NET gadget链的典型表示。

需要强调的是，尽管此脚本有效地演示了漏洞利用所需的加密机制，但它并非一个完整的端到端利用程序。它不包含获取WSUS AES密钥的功能，也不负责构造和发送最终的HTTP请求到`GetCookie()`端点。因此，它是一个功能性组件，但需要进一步的集成和先决条件步骤才能实现完整的漏洞利用。

利用步骤：
1. **获取WSUS AES密钥 (高复杂度前提):** 这是利用此漏洞最关键且最具挑战性的前提。攻击者需要通过其他攻击方法（例如，通过信息泄露、文件读取漏洞、或者已获得低权限访问后提取注册表或内存中的密钥）来获取目标WSUS服务器的AES加密密钥。没有此密钥，后续的加密和反序列化将无法成功。
2. **生成恶意.NET反序列化Payload:** 攻击者需要使用工具，如`ysoserial.net`，根据目标WSUS服务器的环境和可用的.NET反序列化链，生成一个恶意的.NET对象序列化数据。这个Payload将包含攻击者希望执行的任意代码，例如执行系统命令。
3. **使用提供的加密脚本加密Payload:** 将上一步生成的Base64编码的.NET Payload（即`zfc`变量所代表的内容）替换到`cve-2025-59287-encrypt.py`脚本中。同时，将第1步获取到的WSUS AES密钥替换到脚本中的`hex_key`变量。运行`encrypt.py`脚本，它将使用AES-128-CBC模式和固定的全零IV对Payload进行加密，并输出加密后的字节流。
4. **Base64编码加密后的数据:** 将`encrypt.py`脚本输出的加密字节流进行Base64编码。这将是最终嵌入到`AuthorizationCookie`中的内容。
5. **构造并发送HTTP请求:** 攻击者需要手动或使用脚本构造一个HTTP POST请求，目标是WSUS服务器的`GetCookie()`端点。在请求头中，包含一个名为`AuthorizationCookie`的cookie，其值设置为第4步Base64编码后的加密Payload。
6. **远程代码执行:** 当WSUS服务器接收到此请求时，它会尝试解密`AuthorizationCookie`中的数据。如果解密成功（即使用了正确的AES密钥），服务器将使用`BinaryFormatter`对解密后的数据进行反序列化。由于缺少类型验证，恶意Payload将被执行，从而在WSUS服务器上以SYSTEM权限实现远程代码执行。

投毒风险分析：
对`cve-2025-59287-encrypt.py`脚本进行详细审查后，评估其投毒风险为低（约5%）。

1. **代码清晰度与可读性:** 脚本代码结构清晰，使用了标准的Python语法和库，易于理解和审计。函数命名和逻辑都符合常见的加密操作范式，没有发现混淆代码或复杂难以理解的逻辑。
2. **库依赖:** 脚本主要依赖`base64`和`os`（用于生成随机盐），以及`pycryptodome`库中的`Crypto.Cipher.AES`。这些都是Python生态系统中用于加密和系统交互的标准且广泛使用的库。脚本没有引入未知或不常见的第三方库，从而显著降低了潜在的供应链攻击风险。
3. **外部通信与可疑行为:** 脚本中没有发现任何代码用于建立外部网络连接、下载额外资源、执行除其功能所需（如`os.urandom`生成随机字节）之外的系统命令、修改系统配置、或进行任何与其声明功能（加密Payload）无关的行为。所有操作均在本地进行，不与外部服务器进行通信。
4. **Payload分析与误判避免:** 脚本中的`zfc`变量存储了一个Base64编码的字符串，这代表了攻击者希望在目标WSUS服务器上执行的恶意.NET反序列化Payload。根据防御性安全研究的原则，以及要求“务必不要把POC验证的后门代码判定为投毒代码”，这个Payload是漏洞利用的目标内容，而不是POC代码本身对运行者进行的投毒行为。POC的目的是生成这个Payload的加密形式，而不是执行它。运行此POC并不会在运行者的系统上执行这个恶意Payload。

结论： 鉴于上述分析，该POC脚本具有高度的透明性，仅依赖于标准且受信任的库，并且缺乏任何外部通信或可疑行为。因此，它被认为是一个安全的防御性研究工具，其对运行者的投毒风险非常低。建议使用者在运行前仍应确保其Python环境中的`pycryptodome`库是从官方渠道获取且未被篡改的版本，这是任何依赖第三方库时的基本安全实践，以防止更广泛的供应链攻击。

**项目地址:** N/A

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-59287
