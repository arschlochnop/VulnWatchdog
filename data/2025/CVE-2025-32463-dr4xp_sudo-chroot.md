## CVE-2025-32463 - Sudo 本地提权 (Privilege Escalation)

**漏洞编号:** CVE-2025-32463

**漏洞类型:** 本地提权 (Privilege Escalation)

**影响应用:** Sudo

**危害等级:** 高危

**CVSS评分:** 9.3

**影响版本:** Sudo 1.8.8 至 1.9.17 (在 1.9.17p1 中修复)

**利用条件:** 需要本地访问权限，攻击者需构造恶意chroot环境并调用sudo --chroot

**POC 可用性:** 9

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-32463是一个Linux `sudo`组件中的高危本地提权漏洞，其CVSS评分为9.3。该漏洞主要影响Sudo版本1.8.8至1.9.17，并已在1.9.17p1版本中得到修复。此漏洞的核心在于`sudo`在使用`--chroot`选项时，未能正确处理`nsswitch.conf`文件的加载逻辑。通常情况下，`sudo`旨在安全地执行命令，并严格限制其环境。然而，当一个低权限的本地用户通过`sudo`命令调用`--chroot`选项，并指定一个由用户控制的目录作为chroot环境时，`sudo`会错误地从这个**用户可控的chroot环境**中加载`nsswitch.conf`文件，而非系统默认的`/etc/nsswitch.conf`。`nsswitch.conf`文件是Linux系统用于配置名称服务查询顺序（例如，如何查找用户、组、主机名等信息）的关键配置文件。它定义了诸如`passwd: files systemd`这样的规则，指示系统在何处寻找用户账户信息。通过操纵这个文件，攻击者可以指示系统加载一个恶意的共享库作为名称服务提供者。一旦这个恶意共享库被加载，其内部的构造函数（在库加载时自动执行的代码）便能在`sudo`进程的上下文环境中，以`root`权限执行任意代码，从而实现本地权限提升。这种设计缺陷使得攻击者可以绕过`sudo`旨在提供的安全沙箱，获取目标系统的完全控制权。

提供的Python POC (`exploit.py`) 是一个完整且功能强大的利用脚本，它巧妙地自动化了CVE-2025-32463漏洞的利用过程。脚本首先利用`tempfile.mkdtemp`创建了一个安全的临时目录作为攻击的舞台，并在其中设置了特定的文件结构：`woot/etc`用于存放伪造的`nsswitch.conf`，以及`libnss_`目录用于存放恶意共享库。POC的核心部分在于动态生成并编译一个C语言代码片段。该C代码包含一个特殊的构造函数`__attribute__((constructor)) void woot(void)`，其设计目的是在共享库被加载时立即执行。该函数将调用`setreuid(0,0)`和`setregid(0,0)`来将当前进程的用户ID和组ID提升至root权限，随后通过`execl("/bin/bash", "/bin/bash", NULL)`执行一个新的root shell。这个C代码随后使用`gcc -shared -fPIC -Wl,-init,woot -o libnss_/woot1337.so.2 woot1337.c`命令编译成一个名为`libnss_/woot1337.so.2`的共享库。`--shared`和`-fPIC`标志确保生成的是一个位置无关的共享库，`-Wl,-init,woot`则指定`woot`函数在库加载时执行。接下来，POC在`woot/etc/nsswitch.conf`文件中写入`passwd: /woot1337`这一行。当`sudo`在`--chroot=woot`环境下尝试解析名称服务时，它会根据这个配置去寻找并加载`/woot1337.so.2`共享库。最后，脚本执行`sudo -R woot woot`命令。这里的`-R woot`选项将`sudo`的chroot根目录设置为我们精心构造的`woot`目录，并尝试执行一个不存在的命令`woot`。这种执行方式会促使`sudo`进程在chroot环境中查询名称服务以解析用户（即使目标命令不存在，名称服务解析也会被触发），从而加载恶意的`libnss_/woot1337.so.2`。一旦该共享库被加载，其中的构造函数便会立即执行，赋予攻击者一个root权限的shell。POC的自动化程度高，代码逻辑严谨，完全遵循漏洞的利用机制，因此具有极高的有效性和成功率。

**利用步骤:**
1.  **环境准备**: 确保目标Linux系统安装了受影响版本的Sudo (1.8.8至1.9.17)，并且本地用户具有执行`sudo`命令的权限。
2.  **获取POC**: 将提供的`exploit.py`脚本以及相关的C代码内容上传到目标系统上的某个可写目录。
3.  **执行POC**: 在目标系统上，以低权限用户身份直接运行`python3 exploit.py`命令。
4.  **权限提升**: 脚本将自动完成临时环境搭建、恶意代码编译、配置文件写入以及`sudo -R`命令的调用。成功利用后，当前终端会话将直接转变为一个root权限的shell，表明提权成功。

**投毒风险分析:**
对`exploit.py` POC代码及其关联的C语言有效载荷进行了全面审查，评估其投毒风险为低 (10%)。这一评估是基于以下几个关键因素：
*   **代码透明度与可读性**: `exploit.py`脚本用Python编写，代码结构清晰，易于阅读和理解。没有发现任何形式的代码混淆、加密或难以分析的复杂逻辑。所有文件操作、子进程调用和C代码生成都以明文形式存在，使得安全研究人员能够直接审计其行为。
*   **依赖项分析**: 脚本主要依赖于Python标准库（`os`, `subprocess`, `shutil`, `tempfile`）和系统上预安装的`gcc`编译器。它不引入任何外部的、非标准的第三方库或从远程位置下载任何组件。这意味着POC的执行完全独立于外部网络资源，从而显著降低了通过供应链攻击或恶意外部源引入额外威胁的风险。
*   **核心功能与预期行为**: POC的核心目的是通过CVE-2025-32463漏洞实现本地权限提升。其内置的C语言代码有效载荷（`woot1337.c`）明确地执行了`setreuid(0,0)`、`setregid(0,0)`和`execl("/bin/bash", "/bin/bash", NULL)`，这正是获取root权限shell的典型操作。这些行为与漏洞的提权性质完全吻合，是利用该漏洞所必需的步骤，而非额外的恶意功能。在合法防御性安全研究的背景下，这种“恶意”行为被视为漏洞利用的一部分，而非投毒。
*   **网络通信**: 脚本中未发现任何进行网络连接、数据外传或与远程服务器进行通信的代码逻辑。所有操作均严格限制在本地文件系统和进程执行的范畴内。
*   **持久性与清理**: `exploit.py`在临时目录中创建文件和编译二进制文件，并在利用尝试结束后（无论成功与否）通过`shutil.rmtree(temp_dir)`机制自动清理所有创建的临时资源。这表明POC没有设计任何持久化机制，不会在目标系统上留下后门、恶意服务或配置更改。
*   **总结**: 综上所述，该POC代码是专门为演示和利用CVE-2025-32463漏洞而设计的，其所有行为均围绕实现本地提权这一单一目标。代码的高度透明性、对标准库和工具的依赖、缺乏外部通信以及完善的清理机制，都表明它是一个纯粹的功能性漏洞利用工具，不包含任何额外、非预期的恶意载荷或“投毒”行为。因此，在受控环境中进行安全测试和验证时，可以放心地使用该POC。

**项目地址:** 

**漏洞详情:** https://ubuntu.com/security/CVE-2025-32463
