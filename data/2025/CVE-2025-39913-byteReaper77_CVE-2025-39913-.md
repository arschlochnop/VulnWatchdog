# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

# CVE-2025-39913

> 📦 该CVE有 **2** 个相关POC仓库

---

## POC #1

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913-.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913-.md)

## CVE-2025-39913 - Linux Kernel eBPF SOCKMAP UAF

**漏洞编号:** CVE-2025-39913

**漏洞类型:** Use-After-Free (UAF)

**影响应用:** Linux Kernel

**危害等级:** 高危，可能导致内核崩溃、权限提升甚至任意代码执行

**影响版本:** <= 6.12.38

**利用条件:** 需要目标系统运行受影响的内核版本，且开启了SOCKMAP支持，需要能够加载和运行 eBPF 程序，需要配置好网络环境以便进行socket通信

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于Linux内核的`tcp_bpf_send_verdict()` 函数中。当`bpf_msg_cork_bytes()` 尝试分配 `psock->cork` 失败时，内核可能跳过释放 `sk_msg`，导致内存管理错误。

**利用方式：**

1.  加载一个 eBPF `sk_msg` 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)` 设置大于实际发送数据量的 `cork_bytes`。
2.  将该程序附加到 `SOCKMAP`。
3.  将一个 socket 添加到 `SOCKMAP`。
4.  触发内存分配失败（例如，通过 fault injection）。
5.  发送小于 `cork_bytes` 的数据。

由于内存分配失败，`tcp_bpf_send_verdict()` 无法分配 `psock->cork` 来保存数据，并且在没有释放 `sk_msg` 的情况下返回，导致use-after-free。

**有效性评估：**

根据提供的POC代码，该代码旨在利用此UAF漏洞。它包括一个Makefile用于构建，源代码文件（如`main.c`, `load_bpf.c`, `bpf_injection.c`等）以及一个README.md文件，其中包含有关漏洞利用的信息。POC代码包含加载ebpf程序、创建sockmap、发送数据等步骤，与漏洞描述一致，因此POC代码看起来是有效的。

**投毒风险评估：**

分析了提供的POC代码，发现以下潜在风险因素:

* `exit_asm.c` 和 `asm_exit.h`:  包含汇编相关的退出函数，存在一定的风险，可能被用于隐藏恶意代码。如果汇编代码被替换为执行恶意操作的指令，则可能构成投毒。
* `bpf_injection.c`: 这是BPF程序的代码，攻击逻辑都在这里实现, 存在被篡改风险.
* 代码库从第三方平台引用：存在安全风险。
* 检查结果：根据目前提供的文件来看，投毒风险较低，约为10%，主要集中在以上风险点。 但需要对 `exit_asm.c` 和 `bpf_injection.c` 仔细分析，确认其行为是否符合预期。


**项目地址:** [byteReaper77/CVE-2025-39913-](https://github.com/byteReaper77/CVE-2025-39913-)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---



---

## POC #2

**来源**: [CVE-2025-39913-byteReaper77_CVE-2025-39913.md](../2025/CVE-2025-39913-byteReaper77_CVE-2025-39913.md)

## CVE-2025-39913-Linux Kernel-TCP BPF内存泄漏

**漏洞编号:** CVE-2025-39913

**漏洞类型:** 内存泄漏

**影响应用:** Linux Kernel

**危害等级:** 中危，可能导致拒绝服务

**影响版本:** 4.17 <= version < 5.4.300, 5.10.245, 5.15.194, 6.1.153, 6.6.107, 6.12.48, 6.16.8, 6.17

**利用条件:** 需要能够加载 BPF 程序的权限

**POC 可用性:** 是

**投毒风险:** 10%

## 详情

CVE-2025-39913 漏洞存在于 Linux Kernel 的 TCP BPF 实现中。当 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败时，没有正确释放 `sk->sk_forward_alloc`，导致内存泄漏。

**利用方式：**

1.  加载一个 sk_msg BPF 程序，该程序调用 `bpf_msg_cork_bytes(msg, cork_bytes)`。
2.  将该程序附加到 SOCKMAP。
3.  添加一个 socket 到 SOCKMAP。
4.  激活 fault injection（故障注入），模拟内存分配失败的情况。
5.  发送小于 `cork_bytes` 的数据。

这将导致 `tcp_bpf_send_verdict()` 尝试分配 `psock->cork` 失败，从而触发漏洞。

**有效性评估：**

根据漏洞描述，POC 代码尝试利用 `bpf_msg_cork_bytes` 和 `bpf_msg_pop_data` 以及 `bpf_msg_push_data` 来触发漏洞。如果系统存在漏洞，且fault injection能够成功模拟内存分配失败，这段POC可能成功。

由于POC主要通过bpf函数调用来触发内核中的内存泄露，因此，从代码层面来看，其有效性依赖于内核版本和配置是否满足触发条件。如果内核版本在受影响范围内，且能够触发内存分配失败，则POC大概率有效。

**投毒风险评估：**

分析提供的 Makefile 和 C 代码，虽然代码目的是为了验证 CVE-2025-39913 漏洞，但是 `check_elf.c` , `check_bpfELf.c`, `asm_exit.h`, `exit_asm.c`以及 `com_c.c` 这些文件看起来比较可疑，其具体功能和目的尚不清楚，存在潜在的风险。特别是 `exit_asm.c` 和 `asm_exit.h`如果被利用，有可能执行恶意代码。 这些文件本身功能不明, 因此评估投毒风险为10%。

**项目地址:** [byteReaper77/CVE-2025-39913](https://github.com/byteReaper77/CVE-2025-39913)

**漏洞详情:** [CVE-2025-39913](https://nvd.nist.gov/vuln/detail/CVE-2025-39913)

---

