## CVE-2025-32463 - Sudo 本地提权

**漏洞编号:** CVE-2025-32463

**漏洞类型:** 本地提权

**影响应用:** Sudo

**危害等级:** Critical

**CVSS评分:** 9.3

**影响版本:** 1.9.14 到 1.9.17 (含), 修复于 1.9.17p1 之前

**利用条件:** 本地访问，无需认证（普通用户）

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 5%

## 详情

CVE-2025-32463是一个影响Sudo程序的本地提权漏洞，允许本地的普通用户在没有Sudoers规则配置的情况下，提升权限到root。该漏洞于2023年6月在Sudo v1.9.14版本中引入，并影响至1.9.17版本。其根源在于Sudo在处理`chroot`功能，特别是结合`-R`选项和命令匹配逻辑时存在的缺陷。具体来说，当Sudo在`chroot`环境中执行命令时，它未能正确限制`LD_PRELOAD`环境变量的使用。`LD_PRELOAD`是一个动态链接器环境变量，允许用户指定在程序启动前加载的共享库。攻击者可以利用这一机制，通过控制`LD_PRELOAD`加载一个恶意共享库，该库在加载时执行特权操作，从而绕过Sudo的安全检查并获得root权限。此漏洞被评为严重级别，CVSSv3评分为9.3。

**POC有效性分析**
提供的POC（`exploit.sh`和`exploit.c`）是一个高度有效且功能完整的利用工具，能够成功复现CVE-2025-32463漏洞并获取root权限。
`exploit.sh`脚本自动化了整个攻击流程。它首先会检查系统是否安装了`gcc`编译器，因为编译恶意共享库是攻击的关键一步。随后，脚本会在`/tmp/`目录下创建一个唯一的临时目录（例如`/tmp/sudo_preload_stage.XXXXXX`），以确保利用过程的隔离性和整洁性。
核心利用逻辑在于`exploit.c`。这个C语言文件被编译成一个共享库（`hax.so`）。`exploit.c`中包含一个`__attribute__((constructor))`修饰的`init()`函数。这意味着当`hax.so`被动态链接器加载时，`init()`函数将自动执行。`init()`函数首先调用`setreuid(0, 0);`和`setregid(0, 0);`将当前进程的有效用户ID和组ID设置为root（0）。紧接着，它通过`execl("/bin/bash", "[sudo_preload_shell]", NULL);`启动一个全新的bash shell，该shell将以root权限运行。
在`exploit.sh`中，编译完成后，`hax.so`会被复制到一个名为`lib/`的子目录中。随后，脚本会设置`LD_PRELOAD="./lib/hax.so"`环境变量。虽然提供的`exploit.sh`代码在末尾被截断，但根据其上下文和常见的`LD_PRELOAD`劫持攻击模式，可以推断，脚本的后续步骤将通过某种方式执行一个被`sudo`调用的程序，例如通过`sudo -R /path/to/chroot_env /bin/true`或类似的命令，在满足漏洞触发条件（即Sudo在`chroot`环境下未能正确清理`LD_PRELOAD`）时，强制`sudo`进程加载并执行恶意的`hax.so`。一旦`hax.so`被加载，`init()`函数即刻执行，从而赋予攻击者一个root shell。整个过程无需目标系统上的任何特定`sudoers`配置，仅需一个本地普通用户权限即可。

**利用步骤**
1.  确认目标系统上安装的Sudo版本在1.9.14至1.9.17（含）范围内。
2.  通过Git克隆POC代码库：`git clone https://github.com/wvverez/CVE-2025-32463.git`
3.  进入POC目录：`cd CVE-2025-32463`
4.  赋予`exploit.sh`执行权限：`chmod +x exploit.sh`
5.  运行攻击脚本：`./exploit.sh`
6.  如果漏洞利用成功，脚本将自动弹出一个root权限的bash shell。

**投毒风险分析**
针对`wvverez/CVE-2025-32463`这个POC项目的投毒风险评估为低（约5%）。
**代码清晰度与透明性：** POC中包含的`exploit.sh`脚本和`exploit.c`源代码都非常清晰、结构良好，并且提供了必要的注释（尽管是西班牙语，但易于理解）。代码中没有发现任何形式的代码混淆、加密或难以理解的复杂逻辑。攻击者可以通过简单地阅读代码来完全理解其功能和行为。这种透明度是评估低投毒风险的关键因素之一。
**外部依赖与网络行为：** 该POC在执行过程中主要依赖于本地系统上已安装的标准工具，如`gcc`编译器、`mktemp`（用于创建临时目录）、`mkdir`、`cp`等。脚本本身不涉及从外部URL下载额外的可执行文件、恶意脚本或配置信息。没有检测到任何向远程服务器发送数据、建立C2（命令与控制）连接或进行其他可疑网络通信的行为。这意味着POC的执行范围严格限制在本地系统，降低了通过网络引入外部恶意载荷的风险。
**恶意行为分析（功能与预期）：** `exploit.c`中的C代码是专门为实现本地提权而设计的。其核心功能是利用`LD_PRELOAD`机制，在Sudo进程的特权上下文中执行`setreuid(0, 0);`、`setregid(0, 0);`以获取root权限，并随后启动一个root shell。这是本地提权POC的预期行为。该代码不包含任何额外的、超出提权目的的恶意功能，例如：安装持久性后门、修改关键系统文件（除了临时的exploit组件）、植入勒索软件、进行数据窃取或作为僵尸网络的一部分。POC创建的临时目录及其内容在利用完成后通常会被清理或容易被识别。
**结论：** 综上所述，该POC表现出高度的透明性和单一的、明确的提权目的。它没有表现出代码混淆、外部脚本下载、可疑网络请求或其他常见的“投毒”迹象。因此，可以认为这个POC是一个合法的、用于安全研究和验证漏洞的工具，其对运行它的系统引入额外恶意软件或进行意外破坏的风险极低。然而，任何执行POC的防御性安全研究人员都应始终在受控且隔离的环境中进行，并对代码进行彻底审查。

**项目地址:** https://github.com/wvverez/CVE-2025-32463

**漏洞详情:** https://ubuntu.com/security/CVE-2025-32463
