## CVE-2025-8110 - Gogs 远程代码执行 (RCE)

**漏洞编号:** CVE-2025-8110

**漏洞类型:** 远程代码执行 (RCE)

**影响应用:** Gogs

**危害等级:** 高危

**CVSS评分:** 7.8

**影响版本:** Gogs <= (未明确具体版本号，受影响版本在CVE-2024-55947修复后至此漏洞补丁发布前)

**利用条件:** 需要经过身份验证，需要网络访问

**POC 可用性:** 9

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

该POC代码的投毒风险评估为低，具体百分比约为10%。这一评估基于对代码的全面审查，未发现任何旨在危害运行POC的本地系统或其用户而非目标Gogs服务器的恶意行为。

首先，**代码的透明度非常高**。该脚本完全以Python编写，未采用任何代码混淆技术、加密字符串或复杂的动态加载机制。所有逻辑和功能都清晰可见，易于安全研究人员或具备Python基础的用户进行审计和理解。这意味着任何潜在的恶意行为都将是显而易见的。

其次，**依赖性均合法且无异常行为**。脚本所依赖的库，如`requests`用于HTTP通信、`BeautifulSoup`用于HTML解析、`os`和`shutil`用于文件系统操作、`subprocess`用于执行本地`git`命令，以及`rich`用于美化输出，都是Python生态系统中广泛使用且信誉良好的标准或第三方库。这些库的使用方式均符合其设计目的，没有被滥用以执行非预期功能。特别是`subprocess`调用`git`命令，这是模拟Git客户端行为以利用此类型漏洞的必要组成部分，并非用于执行恶意系统命令以危害本地环境。

再者，**POC的核心功能严格聚焦于目标漏洞的利用**。脚本的所有操作，从用户认证到构造恶意Git仓库，再到最终的远程推送，都直接服务于CVE-2025-8110的利用链。其目的是将攻击者指定的恶意内容（如shell脚本或SSH公钥）写入到目标Gogs服务器的特定文件路径，从而在远程服务器上实现代码执行。POC本身不包含任何在运行POC的本地机器上安装后门、持久化机制、窃取本地数据（如用户凭据、文件）或建立与外部恶意C2服务器通信的逻辑。

此外，**恶意载荷是参数化的**。POC脚本通过命令行参数接收`malicious_content`和`target_file`，这意味着实际的恶意载荷和其目标路径完全由POC的使用者决定。POC本身不包含任何预设的、可能对本地系统造成损害的恶意载荷。这进一步降低了POC作者利用POC代码本身进行投毒的风险。

将此POC与高风险的投毒行为进行比较：高风险的POC通常会包含下载并执行来自未知来源的二进制文件、通过`eval()`执行外部代码、修改用户的`~/.bashrc`或系统启动项、在后台静默安装加密货币挖矿程序，或尝试连接到非Gogs的命令与控制服务器进行数据回传。此Gogs POC中未发现任何上述行为。因此，可以确定该POC的投毒风险处于低水平。

**POC有效性分析:**
This exploit script for CVE-2025-8110 targets Gogs, an open-source self-hosted Git service, leveraging a symbolic link bypass vulnerability to achieve Remote Code Execution (RCE). The script is exceptionally comprehensive and robust, demonstrating a full attack chain from initial access to arbitrary code execution. Written in Python, it prioritizes user-friendliness and reliability, utilizing standard libraries for network interactions (`requests`), HTML parsing (`BeautifulSoup` for CSRF token extraction), and file system operations (`os`, `shutil`, `subprocess` for local Git commands). It also incorporates the `rich` library for enhanced console output, making its execution progress and results clear to the user.

The script's execution begins with an authentication phase. It intelligently handles user management by either registering a new user on the target Gogs instance or logging in with provided existing credentials. During this process, it dynamically extracts crucial security tokens, specifically the Cross-Site Request Forgery (CSRF) token, which is essential for making legitimate POST requests to Gogs' web interface. Following successful authentication, the script proceeds to generate an application API token. This token is vital for programmatically interacting with Gogs' Git functionalities, particularly for pushing repositories, which forms the core mechanism of the exploit.

The central part of the exploit, implemented within functions like `create_symlink_payload` and `main_exploit`, involves meticulously crafting a malicious Git repository locally on the attacker's machine. This involves initializing a temporary Git repository, creating a benign-looking file (e.g., `shell.sh`), and crucially, establishing a symbolic link within this local repository. This symbolic link is ingeniously designed to point from the path of the benign file (within the local repo) to an arbitrary, sensitive file path *outside* the repository directory on the target Gogs server (e.g., `/home/git/.ssh/authorized_keys` for SSH key overwriting, or a Git hook like `/path/to/gogs-repositories/repo.git/hooks/pre-receive` for direct command execution). The content of the "benign" file is the attacker's chosen malicious payload.

Once this manipulated local repository is prepared, the script uses the previously obtained application API token to perform a Git push operation to the target Gogs server. The critical vulnerability resides in Gogs' improper handling and filtering of symbolic links during this repository update process. Instead of rejecting or sanitizing the symbolic link that points outside the repository's boundaries, Gogs follows it, effectively writing the attacker-controlled malicious payload into the arbitrary target file on the server. If this target file is a system configuration file, a script that is regularly executed by the system, or a Git hook (which automatically triggers upon certain Git events like pushes), it directly leads to Remote Code Execution (RCE) on the Gogs server. The script also includes functionalities for verifying the success of the file write and performing cleanup of created resources, underscoring its completeness as an exploitation tool. The careful design ensures that the entire attack chain is automated and robust, making it a highly effective demonstration and exploitation tool for CVE-2025-8110.

**利用步骤:**
该POC脚本通过以下自动化步骤利用CVE-2025-8110漏洞：
1. **用户认证：** 脚本首先尝试使用提供的用户名和密码登录Gogs服务。如果用户不存在，它会尝试注册新用户。在此过程中，动态抓取网页中的CSRF令牌以确保后续请求的有效性。
2. **API令牌生成：** 成功认证后，脚本导航至用户设置的应用页面，生成一个新的应用程序API令牌。此令牌将用于通过Git协议与Gogs服务器进行交互。
3. **本地恶意Git仓库构建：** 在本地文件系统上创建一个临时目录，并将其初始化为一个Git仓库。在该仓库中，脚本会创建一个包含攻击者恶意载荷的文件（例如一个shell脚本），并创建一条关键的符号链接。这条符号链接会将载荷文件映射到目标Gogs服务器文件系统上的任意敏感路径（如`/etc/cron.d/`, `/var/www/html/shell.php`或`.git/hooks/pre-receive`）。
4. **远程仓库推送：** 利用生成的API令牌，脚本通过HTTP/HTTPS协议将本地构造的恶意Git仓库推送到Gogs服务器。
5. **触发RCE：** Gogs服务器在处理此推送请求时，由于对符号链接的过滤不当，会错误地跟随恶意符号链接，将攻击者的载荷写入到服务器文件系统上的指定敏感位置。一旦写入成功，如果目标文件是一个可执行脚本或系统进程会读取的文件，即可实现远程代码执行。
6. **状态检查与清理：** 脚本最后会检查指定的靶机文件是否存在，以验证漏洞利用是否成功，并提供清理本地和远程痕迹的功能。

**项目地址:** N/A

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-8110
