## CVE-2025-6554 - V8 JavaScript 引擎 类型混淆/内存越界读写/RCE

**漏洞编号:** CVE-2025-6554

**漏洞类型:** 类型混淆/内存越界读写/RCE

**影响应用:** V8 JavaScript 引擎

**危害等级:** 高危/Critical

**CVSS评分:** CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H (Base Score: 8.8)

**影响版本:** V8引擎版本，具体受影响范围围绕提交(commit) 609a85c2a1bd77d6f6905369f4bc4fcf34c5db09，通常影响在补丁发布前的最新版本。

**利用条件:** 无需认证, 需用户交互 (例如：用户访问恶意网页或运行恶意JavaScript代码)。

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

该POC代码（CVE-2025-6554.js）旨在利用V8 JavaScript引擎中的一个关键漏洞，成功实现内存越界读写（Out-of-Bounds Read/Write）的原语，进而为任意代码执行（RCE）奠定基础。其核心漏洞触发点位于`hax`函数。函数中`delete x?.[y]?.a;`与`let hole = y; let y;`的组合，在V8引擎进行JIT优化时，可能导致`y`变量被错误地优化成一个内部的特殊值（如`TheHole`或一个被错误处理的`HeapConstant`）。随后的关键操作是`o.maybe_hole = trigger ? hole : "not the hole";`，然后试图通过`o.maybe_hole.length`获取长度。当`trigger`为`true`时，`o.maybe_hole`被赋予了`hole`，如果此时V8引擎对`hole`的类型或内存布局处理不当，可能导致其`length`属性被错误计算，例如产生一个非预期的负值，如POC注释中提到的`-524289`。

这个错误的负长度值随后被用于一系列整数运算：`let i1 = 2 - (sign + 1);`、`let i2 = 5 - (i1 + 4) >> 1;`、`let i3 = 1 * i2 + 1;`、`let i4 = i3 * 100;`。这些计算最终导致`i4`的值为`0`。然而，问题并非`i4`为`0`本身，而是V8在对`hax`函数进行优化（`%OptimizeFunctionOnNextCall(hax)`）后，`arr`数组的内部表示可能被破坏。原始`arr`是一个包含8个元素的数组（`new Array(8)`）。在`hax(false)`的“正常”路径中，`i4`的值会是`0`，`arr[0]`被正常写入。但在`hax(true)`的“漏洞触发”路径中，由于类型混淆或内部优化错误，当执行`arr[i4] = 13.37;`时，即使`i4`计算出来是`0`，但其内部写入机制可能被劫持或错误解释，导致实际上写入了超出数组边界的内存位置，或者更精确地说，是破坏了`arr`数组的元数据（如其长度或元素类型信息）。POC中的`corrupted[14]`访问正是利用了这种内存布局的破坏，因为对于一个8元素的数组，索引`14`显然是越界的。

一旦这种越界访问能力被建立，POC代码通过`addrof`（获取对象地址）和`fakeobj`（伪造对象）函数，将这种原始的内存破坏能力提升为更高级别的攻击原语。`addrof`函数通过将目标对象放置在一个已知的被污染数组（`victim`）的特定索引处，并读取`corrupted[14]`来获取其内存地址。`fakeobj`则相反，通过写入`corrupted[14]`并读取`victim[0]`来在指定内存地址伪造一个JavaScript对象。最后，通过`ArbitraryRead64`和`ArbitraryWrite64`函数，利用`arr1`和`fake_arr`的交互，实现了任意内存地址的64位读写能力。这些原语是V8引擎攻击中最为强大的工具，能够绕过地址空间布局随机化（ASLR）等防御机制，最终实现沙箱逃逸和任意代码执行。因此，该POC代码在技术上是高度有效且完备的。

**利用步骤**:
攻击者会首先准备一个包含上述POC代码的恶意网页或Node.js应用程序。
1. **诱导执行**: 攻击者通过钓鱼邮件、恶意广告、水坑攻击等方式，诱导受害者使用受影响版本的Chrome浏览器或Node.js环境访问该恶意网页，或者运行该恶意JavaScript脚本。
2. **触发漏洞**: 当受害者的浏览器或Node.js环境加载并执行POC中的JavaScript代码时，`hax(true)`函数被调用。在V8引擎优化执行该函数时，其内部的类型混淆或内存越界漏洞被触发。
3. **建立原语**: 漏洞成功触发后，V8引擎的内存状态被破坏，攻击者随即通过代码中实现的`addrof`、`fakeobj`、`ArbitraryRead64`和`ArbitraryWrite64`等函数，获得了对任意内存地址进行64位读写的强大原语。
4. **沙箱逃逸与RCE**: 攻击者利用这些内存读写原语，可以进一步：
    *   读取V8引擎和底层操作系统的内存布局信息，绕过ASLR。
    *   在可执行内存区域中写入自定义的shellcode。
    *   修改程序执行流（如覆盖函数指针、返回地址），将控制权转移到注入的shellcode。
    *   最终在受害者的系统上实现任意代码执行，并可能进行沙箱逃逸，从而完全控制受害者的设备。
这种攻击流程使得攻击者能够执行恶意软件、窃取敏感信息、植入后门或进行其他未经授权的操作。

**投毒风险分析**:
针对`CVE-2025-6554`的POC代码，我们进行了详细的投毒风险评估，结果显示其投毒风险为**低（10%）**。
1. **代码透明度高**: POC代码（`CVE-2025-6554.js`）结构清晰，变量命名规范，且没有经过任何形式的代码混淆。所有的关键操作，从触发漏洞到构建`addrof`、`fakeobj`以及任意读写原语，都以可读的方式呈现，使得安全研究人员能够清晰地理解其功能和意图。这种透明性是判断代码是否包含恶意载荷的重要指标。
2. **功能聚焦**: 该POC代码严格专注于演示V8引擎漏洞的利用过程，即如何从一个类型混淆/内存越界问题发展出强大的内存操作原语。代码中没有发现任何与此核心功能无关的外部通信、文件系统操作（例如创建或修改文件）、进程启动或网络连接尝试（如C2通信、数据外发）。它是一个高度自包含的漏洞验证脚本。
3. **无恶意负载迹象**: 代码中未包含任何常见的恶意软件特征，例如加密货币挖矿代码、后门植入逻辑、数据窃取模块或与已知恶意基础设施的通信。其所有的内存操作都是为了证明漏洞的存在和利用能力，而非为了执行实际的恶意载荷。
4. **安全社区背景**: `README.md`文件明确指出该POC是由安全研究人员构建和验证的，并向发现漏洞和撰写分析报告的其他知名安全研究团队及平台致谢。这表明该POC是合法安全研究的一部分，其目的是帮助社区理解和防御此类漏洞，而非进行恶意攻击。指向`mistymntncop`的GitHub仓库和`qianxin`在知乎上的详细分析链接，都进一步证实了其研究性质和社区认可度。
综上所述，尽管POC代码本身展示了高度危险的利用能力，但其作为安全研究工具的性质决定了其在投毒方面的风险极低。组织在利用此类POC进行防御性测试时，可以相对放心地运行和分析，但仍需确保在隔离环境中进行，以防范未知或未披露的风险。

**项目地址:** https://github.com/mistymntncop/CVE-2025-6554

**漏洞详情:** https://zhuanlan.zhihu.com/p/1933101353829381194
