## CVE-2025-49844 - Redis 远程代码执行 (RCE)

**漏洞编号:** CVE-2025-49844

**漏洞类型:** 远程代码执行 (RCE)

**影响应用:** Redis

**危害等级:** 严重 (Critical)

**CVSS评分:** 未指定，但根据漏洞性质（关键RCE）推测可能为 9.8 - 10.0 (CVSS:3.x/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)

**影响版本:** 受影响版本为 Redis 7.0.0-rc1 及更早版本，以及其他所有未应用补丁 `d5728cb` 的版本。

**利用条件:** 攻击者需要通过网络访问受影响的 Redis 实例，并能够发送恶意的 Lua 脚本指令（如 EVAL, EVALSHA, SCRIPT LOAD）。通常无需身份认证，但取决于 Redis 实例的配置。

**POC 可用性:** 9/10

**POC 类型:** 概念验证（Honeypot/检测工具）

**攻击复杂度:** 低

**投毒风险:** 5%

## 详情

CVE-2025-49844，代号“RediShell”，是 Redis 中一个严重的远程代码执行漏洞。该漏洞源于嵌入式 Lua 引擎中存在一个长达 13 年的 use-after-free (UAF) 错误。具体来说，Redis 在存储 Lua 块名时，未能将其正确固定在 Lua 栈上，导致在垃圾回收周期中，当 C 代码仍然持有指向该字符串的指针时，该字符串的内存可能被回收。这种悬空指针的存在为攻击者提供了执行任意代码的原始能力。

Wiz Research 详细描述了此漏洞，并指出其利用路径依赖于通过 Redis 的 `EVAL`、`EVALSHA` 或 `SCRIPT LOAD` 命令发送恶意 Lua 脚本。Redis 的补丁 `d5728cb5795c966c5b5b1e0f0ac576a7e69af539` 通过在解析和弹出 Lua 块名之前将其推送到 Lua 栈（通过 `setsvalue2s`/`incr_top`），从而解决了这一问题，有效防止了悬空指针并关闭了 RCE 漏洞。

提供的 POC 代码是一个名为 RediTrap 的最小 Redis 蜜罐，专门用于早期发现对 CVE-2025-49844 的利用尝试。它并非用于实际攻击或复现漏洞的利用代码，而是一个防御性工具，通过模拟一个未打补丁的 Redis 节点来吸引攻击者。该蜜罐监听 Redis TCP 端口（默认为 6379），并支持 RESP 协议的一个子集，以响应基本的探测命令（如 PING, INFO, AUTH）。它将所有命令记录到 JSON-lines 格式的日志文件中，并对 Lua 脚本活动提供额外的上下文信息（SHA-1 摘要、长度、令牌启发式、预览）。对于脚本相关的命令，蜜罐会将其标记为可疑，并返回安全错误回复，以确保恶意负载不会在蜜罐本身上执行，从而避免被攻击者利用。

**POC有效性分析:**
该蜜罐代码在作为 CVE-2025-49844 的防御性检测工具方面非常有效。它清晰地模拟了一个易受攻击的 Redis 实例行为，并专注于记录攻击者可能用来触发 RCE 的关键交互——发送恶意 Lua 脚本。通过返回安全错误而非执行脚本，它成功地在不暴露自身风险的情况下捕捉攻击意图。这意味着虽然它不是一个“利用 POC”，但它是一个高度有效的“检测 POC”，可以帮助安全团队了解攻击模式和早期预警。其 Dockerfile 配置也体现了良好的安全实践，例如使用非特权用户 `honeypot` 运行服务，并将日志文件写入独立的数据卷，便于管理和分析。这种设计使其成为威胁情报和事件响应团队的宝贵资产，用于发现针对 Redis 实例的 RediShell 漏洞扫描和利用尝试。

**利用步骤:**
1.  **攻击者利用步骤（针对真实漏洞）:** 攻击者首先需要发现一个未打补丁的 Redis 实例，通常通过网络扫描。然后，攻击者会精心构造恶意 Lua 脚本，并使用 Redis 客户端通过 `EVAL`、`EVALSHA` 或 `SCRIPT LOAD` 命令将其发送到目标 Redis 服务器。由于服务器未能正确处理 Lua 块名，导致 use-after-free 漏洞被触发，最终允许攻击者远程执行任意代码，完全控制受影响的 Redis 实例或底层系统。攻击者可能通过这种方式获取敏感数据、部署恶意软件或进一步横向移动。
2.  **防御者部署蜜罐步骤（使用提供的 POC）:**
    *   **本地运行:** 克隆或下载 RediTrap 蜜罐代码，然后执行 `python3 reditrap.py --host 0.0.0.0 --port 6379 --log-file logs/redis-honeypot-events.ndjson`。这将在本地运行蜜罐，并将事件记录到指定的日志文件中。
    *   **Docker 容器部署:**
        1.  构建 Docker 镜像：`docker build -t reditrap .`。
        2.  创建日志目录：`mkdir -p honeypot-logs`。
        3.  运行容器，暴露 Redis 端口并将日志目录挂载到宿主机：`docker run -d --name reditrap -p 6379:6379 -v "$(pwd)/honeypot-logs:/data" reditrap`。蜜罐将自动启动并监听，所有捕获到的事件日志会写入到 `honeypot-logs/redis-honeypot-events.ndjson` 文件中。
    通过部署此蜜罐，安全团队可以监控并记录针对 CVE-2025-49844 的攻击活动，而无需担心真实系统受损。

**投毒风险分析:**
此 POC 代码（RediTrap 蜜罐）的投毒风险极低，评估为 5%。理由如下：
1.  **目的明确且良性:** 代码的 README.md 文件清楚地说明了其作为 Redis 蜜罐的防御性目的，旨在检测而不是利用漏洞。其核心功能是监听 Redis 流量并记录可疑的 Lua 脚本命令，而不是执行它们。
2.  **代码结构清晰:** Dockerfile 和 README.md 文件内容简洁明了，没有发现任何混淆或隐藏的恶意行为迹象。Dockerfile 使用了轻量级的 Alpine Linux 基础镜像，并通过 `adduser` 和 `addgroup` 命令创建了一个名为 `honeypot` 的非特权用户，所有应用操作均在此用户下执行。这遵循了最小权限原则，显著降低了潜在的系统影响。
3.  **不执行外部代码:** 蜜罐的设计明确指出“返回安全错误回复，以确保恶意负载永远不会执行”。这意味着即使攻击者向蜜罐发送了恶意脚本，蜜罐也不会实际运行这些脚本，从而杜绝了通过蜜罐自身传播恶意代码的可能性。
4.  **无外部依赖加载:** 根据提供的 Dockerfile 和 README，代码没有动态加载外部脚本或二进制文件，也没有进行可疑的网络请求（除了监听 Redis 端口）。这降低了供应链攻击或运行时注入恶意代码的风险。
5.  **日志记录行为透明:** 所有捕获到的交互都以结构化 JSON 格式记录到本地指定文件中，便于审计和审查，不会秘密地将数据发送到外部服务器。
综上所述，该 POC 代码是一个透明且安全的防御工具，旨在增强安全性而非构成威胁，其投毒风险可以忽略不计。

**项目地址:** 未提供

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-49844
