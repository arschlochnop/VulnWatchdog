## CVE-2025-49844 - Redis RCE

**漏洞编号:** CVE-2025-49844

**漏洞类型:** RCE

**影响应用:** Redis

**危害等级:** Critical

**CVSS评分:** 10.0

**影响版本:** Redis 8.2.1 及以下版本

**利用条件:** 需要经过身份验证的远程访问权限，且具备执行 Lua 脚本的权限（低权限用户即可利用）

**POC 可用性:** 8/10

**POC 类型:** 概念验证

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

【POC有效性分析】该POC（CVE-2025-49844.lua）是一个高质量的概念验证脚本，其核心逻辑在于触发Redis嵌入的Lua 5.1解析器中的内存管理缺陷。漏洞根源在于`luaY_parser`函数在调用词法分析器（lexer）之前，未能将'chunk name'字符串锚定在Lua栈上。POC通过`make_chunk_name`函数创建了一个带有`__gc`元方法的代理对象，并在`loadstring`解析过程中强制执行垃圾回收（GC）。当`collectgarbage('collect')`被触发时，原本由解析器引用的块名字符串被提前释放，导致Use-After-Free（UAF）状态。脚本通过2000次循环的压力测试（Hammering）来增加竞争条件的触发概率。代码中包含大量的注释填充以绕过Lua的局部变量限制，并利用大量的字符串内存分配（Heap churn）来诱导GC在特定的解析阶段运行。经过分析，该POC逻辑严谨，能够有效导致Redis进程崩溃或在特定条件下实现控制流劫持。利用步骤如下：1. 获取目标Redis实例的连接权限；2. 使用`redis-cli`或其他客户端调用`EVAL`命令执行该Lua脚本；3. 脚本在循环中不断尝试触发GC竞争；4. 观察Redis服务是否崩溃或响应异常。一旦竞争成功，内存中的悬空指针将被重定向，从而执行任意代码。【投毒风险分析】该POC代码的安全性较高，表现为极低的投毒风险。首先，代码逻辑完全透明，使用了标准的Lua原生语法和Redis Lua环境支持的函数（如`newproxy`、`getmetatable`、`collectgarbage`），未引用任何外部恶意二进制文件或加密的网络请求。其次，脚本中虽然有看似异常的`string.rep('-- whatthefu...', 4096)`，但这明确是为了填充Lua解析器的缓冲区以辅助触发UAF，而非恶意载荷。README文档清晰地说明了漏洞原理、环境要求和预期结果，符合安全研究社区的规范。脚本中的循环尝试和内存堆叠行为仅限于消耗Redis服务端的局部内存资源，旨在证明漏洞存在，并不具备自我复制、敏感信息外发或持久化驻留的功能。唯一需要注意的是，在生产环境中运行此脚本会导致Redis服务进程崩溃（DoS），因此必须在受控的实验室环境中进行防御性验证。该POC不含混淆代码，无可疑的远程连接行为，属于纯粹的技术验证脚本。

**项目地址:** [https://github.com/redis/redis/commit/d5728cb5795c966c5b5b1e0f0ac576a7e69af539](https://github.com/redis/redis/commit/d5728cb5795c966c5b5b1e0f0ac576a7e69af539)

**漏洞详情:** [https://nvd.nist.gov/vuln/detail/CVE-2025-49844](https://nvd.nist.gov/vuln/detail/CVE-2025-49844)
