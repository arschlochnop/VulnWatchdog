## CVE-2025-49844 - Redis RCE (Use-After-Free)

**漏洞编号:** CVE-2025-49844

**漏洞类型:** RCE (Use-After-Free)

**影响应用:** Redis

**危害等级:** CRITICAL

**CVSS评分:** 10.0 (CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H)

**影响版本:** 所有支持Lua脚本的版本，包括 6.x, 7.x, 及 8.x 分支至 8.2.1 (修复于 8.2.2)

**利用条件:** 经过身份验证的用户（拥有执行LUA脚本权限），网络可达

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 15%

## 详情

POC有效性分析：该漏洞被称为'RediShell'，是Redis历史上首个CVSS 10.0满分漏洞。其核心缺陷存在于Redis集成的Lua脚本引擎（Lua 5.1）中。在解析Lua脚本（luaY_parser）的过程中，Redis未能正确地在Lua栈上锚定（anchor）正在处理的chunk name字符串。提供的POC代码巧妙地利用了Lua的垃圾回收（GC）机制：通过定义一个带有__gc元方法的newproxy对象作为chunk name，在解析器运行期间强制触发垃圾回收（collectgarbage），导致原本引用的字符串被释放，从而产生内存释放后重用（Use-After-Free）。POC代码结构完整，包含了payload构建、GC触发逻辑以及一个自动化循环脚本，能够通过高频尝试绕过复杂的内存竞争环境，最终实现Redis进程崩溃或劫持指令流。经分析，该POC逻辑严密，利用了LUA引擎底层的内存管理逻辑缺陷，具有极高的实战复现成功率。利用步骤：1. 准备一个运行Redis 8.2.1及以下版本的测试环境。2. 使用redis-cli或其他客户端连接到目标Redis服务器。3. 运行提供的Lua脚本，脚本会通过loadstring函数传入精心构造的带有GC触发器的chunk name。4. 脚本进入高频循环，同时在内部构造‘堆碎片’（Heap churn）以增加GC在解析期间运行的概率。5. 当竞态条件被触发，Redis服务器将发生内存冲突，攻击者可借此实现远程代码执行。投毒风险分析：该POC代码主要由标准的Lua语法构成，未发现明显的二进制恶意荷载（如反弹Shell shellcode）或混淆逻辑。代码逻辑清晰，其`newproxy`和`collectgarbage`的使用完全符合漏洞复现的理论逻辑。README文件中提供的bash循环脚本也仅是常规的自动化测试手段。虽然代码中使用了大量的字符串填充（如string.rep）来操纵内存布局，但这属于典型的UAF漏洞利用技术，并非针对分析者的投毒行为。脚本不包含任何向外部未授权IP发送敏感数据的网络通信逻辑，也不涉及本地文件的敏感操作。整体评估认为，该POC是出于安全研究目的编写的优质演示代码，投毒风险较低，但在受控环境外运行仍具有极大破坏性。

**项目地址:** [https://github.com/redis/redis/commit/d5728cb5795c966c5b5b1e0f0ac576a7e69af539](https://github.com/redis/redis/commit/d5728cb5795c966c5b5b1e0f0ac576a7e69af539)

**漏洞详情:** [https://nvd.nist.gov/vuln/detail/CVE-2025-49844](https://nvd.nist.gov/vuln/detail/CVE-2025-49844)
