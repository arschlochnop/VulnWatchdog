## CVE-2025-49844 - Redis 远程代码执行 (RCE) / Use-After-Free

**漏洞编号:** CVE-2025-49844

**漏洞类型:** 远程代码执行 (RCE) / Use-After-Free

**影响应用:** Redis

**危害等级:** 严重 (Critical)

**CVSS评分:** 10.0

**影响版本:** 版本低于 8.2.2 的 Redis 服务器

**利用条件:** 需要认证、需要网络访问

**POC 可用性:** 9

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

CVE-2025-49844 是 Redis 服务器中存在的一个严重 Lua use-after-free 漏洞，其CVSS评分为10.0（危急）。该漏洞允许经过身份验证的远程攻击者通过构造恶意的Lua脚本，在特定的时间窗口内触发内存释放后使用（Use-After-Free）条件，最终导致远程代码执行。此漏洞的本质在于Redis在解析Lua脚本时，对内存的管理不当，特别是当垃圾回收机制被精确触发时，已释放的内存块可能被错误地再次引用。

**POC有效性分析:**
提供的POC是一个Lua脚本（`CVE-2025-49844.lua`），它被设计为通过利用Redis的Lua解析器中的竞争条件来触发use-after-free漏洞。该脚本通过以下机制尝试实现这一点：
1.  **构造payload**: 创建一个包含大量本地变量的Lua脚本，以确保其在内存中占用一定的空间，并避免被编译规则限制。脚本中也填充了大量注释，以规避“200个局部变量”的编译限制。
2.  **劫持GC**: POC利用`newproxy`和`__gc`元方法，创建一个在垃圾回收时会主动调用`collectgarbage('collect')`的对象。这个对象的`tostring`表示被用作Lua chunk的名称。其目的是在`luaY_parser`仍持有chunk名称字符串时，强制Lua虚拟机执行垃圾回收，从而让已释放的chunk名称内存有机会被重新分配。
3.  **循环加载**: POC通过一个循环反复尝试加载带有此特殊chunk名称的Lua脚本。每次循环中，它还会周期性地创建大量垃圾字符串（`string.rep('A', 4096)`），以在堆上制造波动，进一步增加垃圾回收在不恰当时机执行的可能性。
`README.MD`中提供的`while redis-cli -h localhost -p 6379 --eval CVE-2025-49844.lua >/dev/null; do printf 'connect to server :) RCE' done`命令明确指示了该POC旨在通过反复尝试触发漏洞。当漏洞成功触发时，Redis进程可能会崩溃，或者攻击者可以进一步利用内存损坏实现远程代码执行，这正是`README.MD`中“connect to server :) RCE”所表达的含义。因此，该POC在概念上和实践上都是一个有效的、用于验证此关键漏洞的完整利用代码。

**利用步骤:**
1.  **环境准备**: 确保目标Redis服务器版本低于8.2.2，并通过网络可访问。由于漏洞利用需要认证，攻击者需要具有低权限的Redis认证凭据。
2.  **获取POC**: 下载`CVE-2025-49844.lua`文件，例如从GitHub仓库获取。
3.  **执行攻击**: 使用Redis命令行客户端`redis-cli`，通过循环方式反复执行POC Lua脚本。典型的执行命令如下：`while redis-cli -h <目标IP> -p <端口> -a <密码> --eval CVE-2025-49844.lua >/dev/null; do printf '连接到服务器成功 :) RCE
' done`。请将`<目标IP>`、`<端口>`和`<密码>`替换为实际值。
4.  **结果观察**: POC将持续尝试触发use-after-free。一旦成功触发，目标Redis服务器进程可能会发生崩溃，或者攻击者可以进一步利用此内存损坏状态，执行任意系统命令，从而获得远程代码执行能力。攻击者可能需要进一步的payload来实际利用RCE。

**投毒风险分析:**
对`CVE-2025-49844.lua`及其配套`README.MD`的分析显示，该POC代码的投毒风险评估为低（约为10%）。主要原因是：
1.  **代码透明度**: Lua脚本的代码结构清晰，没有明显的混淆。它主要使用了标准的Lua函数（如`string.rep`, `string.format`, `table.concat`, `newproxy`, `getmetatable`, `collectgarbage`, `tostring`, `loadstring`）来构建和执行其逻辑。这些都是合法的编程和漏洞利用探测技术。
2.  **意图明确**: 脚本中的注释（尽管是波斯语）翻译后表明其目的是重现CVE-2025-49844，并解释了通过GC“复活”已释放chunk名称的利用机制。`README.MD`也明确指出其目的是进行“RCE”验证，而非植入恶意软件。
3.  **无外部依赖/恶意行为**: POC代码本身不包含任何下载外部可执行文件、尝试建立C2连接、执行非预期系统命令（Lua沙箱内）或进行其他恶意行为的逻辑。它专注于在Redis的Lua环境中触发UAF条件。
4.  **执行方式**: 漏洞的触发依赖于用户通过`redis-cli`手动执行Lua脚本。攻击者不会在用户不知情的情况下自动执行恶意代码。
尽管如此，任何从公共来源获取的POC代码都存在一定的固有风险，即使代码看起来是无害的。恶意行为者可能修改POC以包含后门、加密货币挖矿程序或其他恶意负载。因此，防御性安全团队在运行任何POC之前，仍应始终从可信来源获取代码，并进行彻底的安全审查，以验证其内容的完整性和安全性。

**项目地址:** https://github.com/dwisiswant0/CVE-2025-49844

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-49844
