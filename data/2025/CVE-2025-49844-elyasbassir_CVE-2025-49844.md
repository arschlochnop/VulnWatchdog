## CVE-2025-49844 - Redis Use-After-Free/RCE

**漏洞编号:** CVE-2025-49844

**漏洞类型:** Use-After-Free/RCE

**影响应用:** Redis

**危害等级:** 严重/Critical

**CVSS评分:** 10.0

**影响版本:** Redis < 8.2.2 (包括所有支持Lua脚本的6.x, 7.x, 8.x分支中低于各自最新补丁的版本)

**利用条件:** 需要认证/低权限用户访问

**POC 可用性:** 7

**POC 类型:** 概念验证

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-49844是一个Redis中与Lua脚本引擎相关的Use-After-Free（释放后重用）漏洞。该漏洞的核心在于Redis在处理Lua脚本时，特别是在Lua解析器（luaY_parser）仍在保持对chunk名称字符串的引用时，通过垃圾回收机制（GC）过早地释放了该字符串的内存，导致后续对该内存的访问可能引发未定义行为，最终可被利用进行远程代码执行。此漏洞由Wiz研究团队在Pwn2Own Berlin大赛中发现，并将其命名为RediShell，影响所有支持Lua脚本的Redis版本（包括6.x-8.x全分支）。

**POC有效性分析:**
提供的POC代码是一个名为`CVE-2025-49844.lua`的Lua脚本。其主要目的是通过构造特定的Lua环境来复现这一UAF漏洞。脚本的关键在于定义了一个元表（metatable）的`__gc`方法，当`newproxy(true)`创建的对象被垃圾回收时，该方法会被调用。脚本利用这一机制，在`loadstring`函数内部，当Lua解析器仍在处理chunk名称时，强制执行一次完整的垃圾回收（`collectgarbage('collect')`）。这种时序上的精妙操控旨在触发在chunk名称内存被释放后，解析器仍然尝试访问该内存的场景，从而引发UAF。此外，脚本通过重复创建大量本地变量和填充注释来构建一个足够大的payload，并间歇性地分配和释放大量“垃圾”字符串（`string.rep('A', 4096)`），以此在堆上制造波动，进一步提高垃圾回收器在关键时刻运行的概率。
POC的README文件明确指出，这个Lua脚本需要通过`redis-cli --eval`命令循环执行（`while redis-cli ...`），直到触发漏洞并可能导致RCE（“connect to server :) RCE”）。这表明该POC是一个概念验证性质的触发器，旨在展示漏洞的存在，而非一个一次性即可获得完整shell的稳定利用工具。其成功触发RCE可能依赖于多种因素，包括内存布局、Redis版本、操作系统等，需要多次尝试以增加成功率。因此，POC的质量评定为7分，因为它功能完整，但需要特定的执行方式（循环）和环境，且其最终利用（RCE）是预期结果而非脚本直接提供。

**利用步骤:**
攻击者利用此漏洞需要满足以下条件：
1.  **认证访问:** 攻击者需要获得对目标Redis服务器的认证访问权限，哪怕是低权限用户。这是因为Redis的`EVAL`命令通常需要认证才能执行。
2.  **目标识别:** 攻击者可以通过Shodan等搜索引擎，使用`product:"Redis key-value store"`等关键词来寻找暴露在公网上的Redis服务器。根据POC的说明，目标服务器的版本应低于Redis 8.2。更具体的受影响版本包括所有支持Lua脚本的Redis 6.x、7.x和8.x分支中，低于各自最新补丁的版本，例如低于Redis 6.4.2-131、7.2.4-138、7.4.6-272、7.8.6-207以及8.2.2等。
3.  **上传并执行POC:** 将提供的`CVE-2025-49844.lua`脚本保存到本地。使用Redis客户端工具`redis-cli`连接到目标Redis服务器，并执行该Lua脚本。POC的README提供了具体的执行命令：`while redis-cli -h <target_ip> -p <target_port> --eval CVE-2025-49844.lua >/dev/null; do printf 'connect to server :) RCE\n'; done`。这个命令会持续循环执行Lua脚本。攻击者需要监控目标Redis服务器的响应或其行为，以判断漏洞是否成功触发并导致了远程代码执行。成功触发UAF后，攻击者需要进一步的利用手段（例如ROP链构造或其他内存利用技术）才能实现任意代码执行，但POC旨在提供触发漏洞的机制。
攻击复杂度被评为“中等”，因为虽然需要认证，且脚本执行需要循环多次以增加成功概率，但一旦拥有认证凭据，利用过程可以被自动化，并且不需要非常深入的系统底层知识（只需执行提供的POC）。

**投毒风险分析:**
对提供的POC代码`CVE-2025-49844.lua`及其配套`README.MD`文件进行分析，评估其投毒风险。
首先，从代码结构和内容来看，`CVE-2025-49844.lua`是一个清晰、目的明确的Lua脚本。脚本没有进行混淆处理。所有变量名、函数调用都符合Lua语言的常见习惯。代码的注释（虽然是波斯语，但可以通过翻译理解其意图）也清楚地解释了其设计思想——“使用GC在解析时重新激活已释放的chunk名称”。脚本主要使用了Lua的标准库函数，如`string.rep`、`table.concat`、`newproxy`、`getmetatable`、`__gc`、`collectgarbage`、`loadstring`等。这些函数本身是无害的，脚本的逻辑是为了在特定的时序条件下触发Redis Lua引擎的UAF漏洞。脚本没有任何外部文件加载、网络请求、shell命令执行或其他可疑的外部依赖。它完全在Redis Lua沙箱内部运行，并尝试操纵其内部机制。未发现任何恶意代码，例如用于下载恶意负载、建立反向shell、删除系统文件或进行数据窃取等。脚本的唯一目的似乎是触发并复现CVE-2025-49844描述的UAF漏洞。
其次，`README.MD`文件提供了如何运行POC、如何寻找受害者以及如何修补漏洞的指导。这表明其作者的意图是帮助研究人员或管理员理解和防护漏洞，而非传播恶意软件。该文件明确指出了修复方法（更新Redis版本或禁用Lua脚本）。
**总结:** 鉴于POC代码的透明性、无害的函数调用、无外部依赖以及其配套文档的清晰说明，该POC的投毒风险极低。它是一个专注于漏洞复现的合法安全研究工具。因此，其投毒风险评估为10%。用户在运行此类POC时，仍应在受控环境中进行，并仔细阅读代码，以确保其行为符合预期。

**项目地址:** None

**漏洞详情:** https://redis.io/blog/security-advisory-cve-2025-49844/
