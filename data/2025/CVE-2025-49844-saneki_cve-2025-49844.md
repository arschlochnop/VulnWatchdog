## CVE-2025-49844 - Redis RCE

**漏洞编号:** CVE-2025-49844

**漏洞类型:** RCE

**影响应用:** Redis

**危害等级:** Critical

**CVSS评分:** 10.0

**影响版本:** Redis 8.2.1 及以下版本

**利用条件:** 经过身份验证的远程攻击者（具备执行Lua脚本权限，如EVAL命令权限）

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 15%

## 详情

POC有效性分析：该POC针对CVE-2025-49844漏洞进行了高度还原且功能完备。漏洞核心源于Redis Lua引擎在处理特定脚本加载逻辑时的Use-After-Free（UAF）缺陷。在提供的Python代码中，攻击者通过构造一个特殊的`myloader`加载函数，并在第二次调用时强制触发`collectgarbage("collect")`。根据代码逻辑，当`luaX_setinput`正在使用`chunkname`字符串时，GC回收了该内存，随后利用`get_smallstrs`函数快速分配新的小字符串（small strings）填补被释放的堆内存块（Heap Spraying/Grooming），从而实现对已释放内存的重占位。POC通过这种方式替换了Lua内部的原型名，进而控制指令执行流。该POC不仅包含内存占位的验证逻辑，还提供了基于`uv`环境的一键式Shell指令执行和反弹Shell功能，并支持基于Alpine和Bookworm的Docker镜像环境测试，证明其在主流容器化Redis部署环境下具有极高的实战有效性。利用步骤：1. 环境准备：安装Python 3.13、uv及相关库（redis, iced-x86）。2. 建立连接：POC通过Redis库连接至目标实例（默认127.0.0.1:6379）。3. 脚本预热：执行`script_flush('SYNC')`。这一步非常关键，旨在清理jemalloc的线程缓存（tcache），确保堆分配的地址具备确定性，提高UAF占位的成功率。4. 漏洞触发：向Redis发送精心构造的Lua脚本，脚本内部嵌套`load(myloader)`，在`myloader`迭代中触发同步垃圾回收。5. 代码执行：通过UAF控制底层Proto对象，重定向执行流至系统调用，实现命令执行或反弹Shell。投毒风险分析：该POC项目属于透明度较高的开源防御性研究工具，其代码结构清晰，使用了Python的标准工程化管理方式（pyproject.toml）。经过代码审计，主要风险点在于其依赖库`iced-x86`用于指令处理，这是编写高质量Exploit的常见选择，并非恶意逻辑。核心脚本`demonstration.py`逻辑清晰，明确标注了每一步的意图（如内存清理、占位字符串生成），没有发现任何混淆、隐藏的外部连接或删除宿主机系统文件的恶意代码。项目README明确指出其目的是复现Wiz Research发现的漏洞，并警示了环境要求。唯一的风险在于此类高可用性POC若被直接集成到非官方安全扫描工具中，可能会被非法修改。但就当前源码而言，其投毒风险极低，属于典型的安全研究类代码，未见任何针对安全研究员自身的后门行为或敏感信息窃取逻辑。

**项目地址:** [https://www.wiz.io/blog/wiz-research-redis-rce-cve-2025-49844](https://www.wiz.io/blog/wiz-research-redis-rce-cve-2025-49844)

**漏洞详情:** [https://nvd.nist.gov/vuln/detail/CVE-2025-49844](https://nvd.nist.gov/vuln/detail/CVE-2025-49844)
