## CVE-2025-49844 - Redis RCE (Use-After-Free)

**漏洞编号:** CVE-2025-49844

**漏洞类型:** RCE (Use-After-Free)

**影响应用:** Redis

**危害等级:** CRITICAL

**CVSS评分:** 10.0

**影响版本:** Redis 6.x, 7.x, 8.x 全分支版本，具体修复版本为 6.2.17, 7.2.7, 7.4.2, 8.2.2 等

**利用条件:** 需要经过身份验证（拥有低权限及以上用户权限），且目标实例支持Lua脚本执行

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 15%

## 详情

【POC有效性分析】该漏洞（代号RediShell）源于Redis内置的Lua脚本引擎在处理特定加载逻辑时存在内存管理缺陷。根据提供的POC代码（demonstration.py）分析，利用路径非常清晰且具备极高的可行性。攻击者通过构造特殊的Lua加载器函数（myloader），在首次调用时返回nil触发缓存预读，第二次调用时强制执行collectgarbage("collect")进行垃圾回收。由于Lua引擎在处理chunkname（脚本块名称）时未能正确更新引用计数，导致chunkname字符串所在的内存被释放（Free）。随后，POC通过大量生成小型字符串（loadstring）来填充jemalloc分配器释放出的内存块，从而实现对已释放内存区域（UAF）的占位和数据覆盖。通过控制该内存区域的内容，攻击者可以篡改Lua内部结构或指令流，最终绕过沙箱并获得宿主进程的执行权限。代码中针对redis:8.2.1等主流Docker镜像进行了特定适配，具备高度的实战针对性。【利用步骤】1. 获取Redis访问凭据（即使是低权限账号）；2. 使用脚本清理环境（SCRIPT FLUSH），确保jemalloc的tcache处于一致状态以提高占位成功率；3. 执行精心构造的EVAL脚本，该脚本包含自定义loader以触发垃圾回收并导致UAF；4. 快速分配大量可控字符串以接管被释放的内存；5. 利用内存覆盖修改执行流，执行系统命令（如echo或rshell）。【投毒风险分析】该POC库的投毒风险评定为低（15%）。虽然其功能极其强大（支持反弹Shell和一键命令执行），但从代码结构上看，其行为具有明显的透明性和研究性质。代码采用了标准的Python项目结构（pyproject.toml），依赖项如iced-x86（用于指令处理）和redis库均通过官方渠道获取。核心逻辑位于demonstration.py中，代码逻辑清晰，没有发现任何混淆、base64加密的恶意Payload或隐藏的外部域名请求。攻击者虽然可以利用该工具直接发起攻击，但作为防御性研究员，未发现该POC本身包含针对研究者本人的后门或窃密行为。风险点主要在于其对高版本Redis（如8.x）的精准打击能力，如果被恶意利用，破坏力极大。建议在受控的隔离环境（如Sandboxed Docker）中运行验证，并严格审计pyproject.toml中引入的依赖包版本，防止供应链投毒风险。

**项目地址:** [https://github.com/saneki/cve-2025-49844](https://github.com/saneki/cve-2025-49844)

**漏洞详情:** [https://nvd.nist.gov/vuln/detail/CVE-2025-49844](https://nvd.nist.gov/vuln/detail/CVE-2025-49844)
