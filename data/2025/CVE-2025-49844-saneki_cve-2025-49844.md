## CVE-2025-49844 - Redis Use-After-Free (UAF), 远程代码执行 (RCE)

**漏洞编号:** CVE-2025-49844

**漏洞类型:** Use-After-Free (UAF), 远程代码执行 (RCE)

**影响应用:** Redis

**危害等级:** 严重

**CVSS评分:** 10.0

**影响版本:** 所有支持Lua脚本的Redis版本，包括6.x至8.x分支，受影响的版本低于以下安全补丁版本：Redis 6.4.2-131, 7.2.4-138, 7.4.6-272, 7.8.6-207, 7.22.2-20

**利用条件:** 需要认证的攻击者，拥有低权限及以上用户权限，需要网络访问

**POC 可用性:** 9/10

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 10%

## 详情

CVE-2025-49844，又名 RediShell，是 Redis 数据库中一个极其严重的远程代码执行（RCE）漏洞，CVSS 评分为 10.0（最高级别）。该漏洞利用了 Redis Lua 脚本引擎中的一个 Use-After-Free (UAF) 缺陷。经过身份认证的攻击者可以通过精心构造的 Lua 脚本，操控 Redis 的垃圾回收机制，触发释放后重用错误，最终在服务器上执行任意代码，导致服务器完全失陷。此漏洞影响所有支持 Lua 脚本的 Redis 版本，包括从 6.x 到 8.x 的多个分支，直到官方发布补丁版本。该漏洞在 Redis 源代码中已存在约 13 年之久，由 Wiz 研究团队在 Pwn2Own Berlin 大赛中发现并披露。攻击者一旦成功利用，可完全控制 Redis 服务器及其底层操作系统，对业务连续性和数据安全构成极大威胁。

**POC有效性分析:**
提供的 POC 代码是一个针对 CVE-2025-49844 的完整利用工具，其结构清晰，文档详尽。它由 `README.md` 和 Python 脚本 (`demonstration.py` 以及其他支持文件，如 `pyproject.toml`) 组成。`README.md` 文件清晰地说明了 POC 的用途，指明其支持的具体目标系统，例如 `x86-64 Linux redis:8.2.1-alpine` 和 `redis:8.2.1-bookworm` Docker 镜像，这体现了其高度的针对性和有效性。文档中提供了详细的使用说明，包括如何运行单向 shell 命令（例如 `echo 'hello world' > /data/hello.txt`）以及如何连接反向 shell（例如 `uv run cve-2025-49844 rshell -l 127.0.0.1 -p 4444`），这明确表明该 POC 具备完整的远程代码执行能力，不仅仅是概念验证。`demonstration.py` 文件则深入展示了触发 Use-After-Free 漏洞的核心技术细节。它通过一个特别设计的 Lua 脚本，巧妙地利用 Redis Lua 引擎的 `load` 函数和垃圾回收机制 (`collectgarbage`)。脚本中的 `myloader` 函数在特定执行流下（例如首次调用返回 `nil`，第二次调用触发垃圾回收）诱导 Redis 在 `luaX_setinput` 阶段重新填充缓冲区时，`chunkname` 字符串已处于可收集状态，从而引发 UAF。虽然 `demonstration.py` 主要侧重于 UAF 的底层触发机制，但结合 `README.md` 中提供的完整利用命令，可以确认该 POC 能够实现从漏洞触发到最终 RCE 的完整利用链。该 POC 质量较高，代码逻辑严谨，文档齐全，且针对特定环境给出了明确的运行方式，使得安全研究人员和防御团队能够相对容易地复现、验证此漏洞并评估其影响。它提供了对漏洞深层原理的理解以及实际利用的有效手段。

**利用步骤:**
攻击者利用此漏洞的典型步骤如下：
1.  **认证获取**: 攻击者首先需要获得对目标 Redis 服务器的认证权限。虽然漏洞本身发生在 Redis 内部的 Lua 引擎，但执行 Lua 脚本通常需要客户端通过身份验证（除非 Redis 配置为无认证访问）。这通常意味着攻击者需要窃取凭证或利用其他漏洞获取低权限或以上用户权限。
2.  **构造恶意 Lua 脚本**: 攻击者会基于 POC 提供的原理，精心构造一个恶意的 Lua 脚本。这个脚本的核心是利用 `load` 函数和自定义的 `myloader` 回调函数，在 Redis Lua 引擎内部创造特定的执行条件。通过控制 `myloader` 的返回值，脚本可以在关键时刻触发垃圾回收 (`collectgarbage`)，使得 Lua 状态机中表示 `chunkname` 的字符串被过早释放，为后续的 Use-After-Free 攻击创造条件。
3.  **触发 Use-After-Free**: 攻击者通过 Redis 客户端（如 `redis-cli` 或编程库）使用 `EVAL` 或 `EVALSHA` 命令将构造好的恶意 Lua 脚本发送给目标 Redis 服务器执行。在脚本执行过程中，当满足特定条件时，Redis Lua 引擎会尝试访问已被释放的 `chunkname` 内存区域，导致 Use-After-Free 漏洞被触发。
4.  **内存覆盖与执行流劫持**: 利用 Use-After-Free 漏洞，攻击者可以对已释放并被重新分配的内存区域进行控制，并写入恶意数据或指令。由于 Redis 服务通常以较高权限运行，成功的内存覆盖可以劫持程序执行流，使其跳转到攻击者控制的内存区域，从而执行任意操作系统命令。这通常涉及覆盖关键的数据结构或函数指针。
5.  **获取远程控制**: 一旦代码执行成功，攻击者可以执行各种恶意操作，例如创建文件 (`echo 'hello world' > /data/hello.txt`)、下载恶意软件、修改系统配置、或者建立反向 shell 连接回攻击者控制的服务器，从而获得对整个 Redis 服务器所在系统的完全远程控制。

**投毒风险分析:**
对提供的 POC 代码（包括 `README.md`、`demonstration.py` 和 `pyproject.toml`）进行综合分析，可以评估其投毒风险为较低（10%）。
1.  **代码透明度与可读性**: `demonstration.py` 中的 Python 代码是完全透明且可读的，没有进行任何形式的代码混淆。它主要利用标准的 `redis-py` 库与 Redis 服务器进行交互，并发送预定义的 Lua 脚本。Lua 脚本本身虽然在技术上较为复杂，其目的是精确地触发已知的 UAF 漏洞，而不是隐藏或夹带恶意负载。代码的清晰性使得安全研究人员可以轻松审计其功能和行为，识别任何潜在的恶意组件。
2.  **依赖项分析**: `pyproject.toml` 文件中明确列出了项目所需的 Python 依赖项，包括 `hexdump`、`iced-x86` 和 `redis`。这些库都是在安全研究、逆向工程、以及与 Redis 交互中广泛使用且普遍被认为是标准和受信任的库。没有发现引入任何来源不明、非标准或被报告存在安全问题的第三方库。此外，`uv` 是一个合法的、广泛使用的 Python 包管理和运行工具，其作用是管理项目依赖和执行脚本，本身不携带恶意。
3.  **行为模式**: `demonstration.py` 的核心功能是展示如何触发 Redis Lua 引擎的 UAF 漏洞，并通过随后的利用实现远程代码执行。它不包含任何超出此范围的直接恶意行为，例如主动窃取敏感数据、安装持久化后门程序、连接到未知的命令和控制 (C2) 服务器、或发起分布式拒绝服务 (DDoS) 攻击。其设计的目的是作为漏洞利用的“第一阶段”或技术验证工具。`README.md` 中虽然提到了“运行单向 shell 命令”和“连接反向 shell”，这些是漏洞成功利用后攻击者可以在目标系统上执行的动作，代表了漏洞利用的最终效果，而不是 POC 代码自身被注入了恶意功能。
4.  **无外部可疑请求**: 在提供的代码片段中，未发现任何向外部未知服务器发起网络请求、下载额外 payload 或执行其他可疑网络通信的行为。所有的 Redis 交互都指向本地或指定的目标 Redis 服务器。
5.  **无动态代码执行风险（POC层面）**: 除了预期的、用于触发漏洞的 Lua 脚本执行外（这本身是漏洞利用的一部分，而非 POC 被污染），Python 部分没有使用 `eval` 或 `exec` 等高风险函数来执行来自不可信来源的动态代码。这意味着 POC 自身不会因执行外部输入而产生额外的动态代码执行风险。
综上所述，该 POC 是一个专注于技术验证和漏洞利用演示的工具，其代码本身没有迹象表明存在恶意投毒行为。研究人员在使用此类 POC 时，应重点关注其利用目标（Redis 服务器）可能产生的副作用和被攻击的风险，而非 POC 代码本身带来的风险。

**项目地址:** None

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-49844
