## CVE-2025-32463 - Sudo 本地提权 (Local Privilege Escalation)

**漏洞编号:** CVE-2025-32463

**漏洞类型:** 本地提权 (Local Privilege Escalation)

**影响应用:** Sudo

**危害等级:** 高危 (Critical)

**CVSS评分:** 9.3

**影响版本:** 1.9.14 到 1.9.17 (含)

**利用条件:** 需要本地用户访问权限

**POC 可用性:** 9

**POC 类型:** 完整利用 (Full Exploit)

**攻击复杂度:** 低

**投毒风险:** 10%

## 详情

该POC是一个名为`CVE-2025-32463.sh`的Bash脚本，旨在利用Sudo的本地提权漏洞CVE-2025-32463。该漏洞影响Sudo版本1.9.14至1.9.17，其根源在于Sudo在使用`--chroot` (或`-R`) 选项时，在降低权限之前加载了位于用户控制目录下的配置文件（如`/etc/nsswitch.conf`），从而允许加载恶意的NSS（Name Service Switch）库。

**POC有效性分析:**
该POC脚本的核心逻辑如下：
1.  **创建临时目录**: 使用`mktemp -d`创建一个唯一的临时目录（例如`/tmp/sudo.woot.XXXXXXXXXXX`），所有后续操作都在此目录中进行。
2.  **创建恶意C文件**: 在临时目录中创建一个名为`woot.c`的C源文件。该C代码包含一个构造函数`woot`，其作用是在程序加载时立即执行`setreuid(0,0)`和`setregid(0,0)`来将当前进程的用户和组ID设置为root (0)，然后切换到根目录`/`，最后通过`execl("/bin/bash","/bin/bash",NULL)`启动一个root权限的Bash shell。
3.  **准备chroot环境**: 
    *   创建`woot/etc`和`libnss_`子目录。
    *   在`woot/etc`中创建`nsswitch.conf`文件，内容为`passwd: /woot`。这指示系统在查找passwd信息时，应使用`/woot`目录（在chroot环境中，即`STEEP/woot`）作为NSS模块的路径。
    *   将宿主系统的`/etc/group`文件复制到`woot/etc`，确保chroot环境内有基本的组信息。
4.  **编译恶意NSS库**: 使用`gcc`将`woot.c`编译成一个共享库`libnss_/woot.so.2`。`setreuid(0,0)`和`setregid(0,0)`以及`execl`的逻辑被包含在`__attribute__((constructor))`标记的`woot`函数中，这意味着当该共享库被加载时，`woot`函数会自动执行。`-Wl,-init,woot`选项确保`woot`函数作为初始化函数被调用。
5.  **触发漏洞**: 执行`sudo -R woot woot`命令。`-R woot`选项告诉Sudo在`chroot`到`STEEP/woot`目录后执行命令。当Sudo尝试在chroot环境中解析名称服务（例如通过加载NSS模块），并读取`STEEP/woot/etc/nsswitch.conf`时，它会尝试加载`STEEP/libnss_/woot.so.2`这个我们构造的恶意NSS模块。由于这个加载发生在Sudo完全降低权限之前，恶意模块中的`woot`构造函数会被以root权限执行，从而提升当前用户的权限到root。
经验证，该POC代码逻辑清晰，利用了Sudo在chroot功能中加载NSS模块时的权限管理缺陷，能够有效实现本地权限提升。

**利用步骤:**
1.  **下载POC脚本**: 将POC脚本`CVE-2025-32463.sh`保存到本地文件系统。
2.  **赋予执行权限**: 在终端中执行`chmod +x CVE-2025-32463.sh`。
3.  **运行POC**: 在终端中执行`./CVE-2025-32463.sh`。
4.  **验证**: 如果系统受影响且POC成功，执行后当前用户的shell会变为root权限的shell。可以通过输入`id`命令来验证当前用户是否为root（uid=0, gid=0）。
需要注意的是，此漏洞要求攻击者拥有本地系统的普通用户权限。

**投毒风险分析:**
该POC脚本的投毒风险被评估为低（10%）。主要原因如下：
1.  **代码透明性**: POC代码是纯Bash脚本和一段简单的C代码，未经过任何形式的代码混淆。攻击者可以轻松地审查其内容，理解其功能。
2.  **功能单一性**: 脚本的唯一目的是利用CVE-2025-32463漏洞进行本地提权。它没有包含额外的、与提权无关的恶意功能，例如下载并执行外部恶意负载、建立后门、进行加密货币挖矿或尝试横向移动等。
3.  **资源利用**: 脚本仅在本地文件系统创建临时目录和文件，并使用系统自带的`gcc`编译器。它不进行任何网络通信（例如连接C2服务器、下载资源等），因此不存在通过外部源引入恶意内容或数据泄露的风险。
4.  **标准库使用**: C代码使用的函数（`stdlib.h`，`unistd.h`中的`setreuid`, `setregid`, `chdir`, `execl`）都是标准的系统调用，并且其目的是明确的——提权并启动shell。
5.  **无持久性机制**: POC脚本在成功提权后，只是启动了一个root shell，并没有内置任何机制来建立持久性访问（如修改系统启动项、安装服务、创建新的root用户等）。攻击者需要手动执行额外的步骤来确保持久化。
综上所述，虽然POC本身是为了执行恶意提权操作，但其代码本身的清晰性、局限性以及缺乏额外的恶意载荷或外部通信，使其作为“投毒”的风险非常低。在防御性安全研究中，需要区分漏洞利用代码本身与额外植入的恶意载荷。此POC仅是漏洞利用，而非带有额外“投毒”性质的恶意软件。然而，任何执行未经审查的代码都存在固有风险，因此在受控环境中进行分析始终是最佳实践。

**项目地址:** https://github.com/kh4sh3i/CVE-2025-32463

**漏洞详情:** https://ubuntu.com/security/CVE-2025-32463
